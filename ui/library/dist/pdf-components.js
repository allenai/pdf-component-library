!function(n,g){"object"==typeof exports&&"object"==typeof module?module.exports=g(require("react")):"function"==typeof define&&define.amd?define(["react"],g):"object"==typeof exports?exports.PdfComponents=g(require("react")):n.PdfComponents=g(n.React)}(this,(function(__WEBPACK_EXTERNAL_MODULE__888__){return(()=>{var __webpack_modules__={757:(module,__unused_webpack_exports,__webpack_require__)=>{eval("module.exports = __webpack_require__(666);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9QZGZDb21wb25lbnRzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzP2EzNGEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEseUNBQStDIiwiZmlsZSI6Ijc1Ny5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlZ2VuZXJhdG9yLXJ1bnRpbWVcIik7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///757\n")},184:(module,exports)=>{eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n  Copyright (c) 2018 Jed Watson.\n  Licensed under the MIT License (MIT), see\n  http://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\n\tfunction classNames() {\n\t\tvar classes = [];\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (!arg) continue;\n\n\t\t\tvar argType = typeof arg;\n\n\t\t\tif (argType === 'string' || argType === 'number') {\n\t\t\t\tclasses.push(arg);\n\t\t\t} else if (Array.isArray(arg)) {\n\t\t\t\tif (arg.length) {\n\t\t\t\t\tvar inner = classNames.apply(null, arg);\n\t\t\t\t\tif (inner) {\n\t\t\t\t\t\tclasses.push(inner);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (argType === 'object') {\n\t\t\t\tif (arg.toString === Object.prototype.toString) {\n\t\t\t\t\tfor (var key in arg) {\n\t\t\t\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\t\t\t\tclasses.push(key);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tclasses.push(arg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn classes.join(' ');\n\t}\n\n\tif ( true && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (true) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n\t\t\treturn classNames;\n\t\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n}());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9QZGZDb21wb25lbnRzLy4vbm9kZV9tb2R1bGVzL2NsYXNzbmFtZXMvaW5kZXguanM/NGQyNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7O0FBRUEsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUssS0FBNkI7QUFDbEM7QUFDQTtBQUNBLEVBQUUsVUFBVSxJQUE0RTtBQUN4RjtBQUNBLEVBQUUsaUNBQXFCLEVBQUUsbUNBQUU7QUFDM0I7QUFDQSxHQUFHO0FBQUEsa0dBQUM7QUFDSixFQUFFLE1BQU0sRUFFTjtBQUNGLENBQUMiLCJmaWxlIjoiMTg0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gIENvcHlyaWdodCAoYykgMjAxOCBKZWQgV2F0c29uLlxuICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHNlZVxuICBodHRwOi8vamVkd2F0c29uLmdpdGh1Yi5pby9jbGFzc25hbWVzXG4qL1xuLyogZ2xvYmFsIGRlZmluZSAqL1xuXG4oZnVuY3Rpb24gKCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5cdGZ1bmN0aW9uIGNsYXNzTmFtZXMoKSB7XG5cdFx0dmFyIGNsYXNzZXMgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0aWYgKCFhcmcpIGNvbnRpbnVlO1xuXG5cdFx0XHR2YXIgYXJnVHlwZSA9IHR5cGVvZiBhcmc7XG5cblx0XHRcdGlmIChhcmdUeXBlID09PSAnc3RyaW5nJyB8fCBhcmdUeXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRjbGFzc2VzLnB1c2goYXJnKTtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG5cdFx0XHRcdGlmIChhcmcubGVuZ3RoKSB7XG5cdFx0XHRcdFx0dmFyIGlubmVyID0gY2xhc3NOYW1lcy5hcHBseShudWxsLCBhcmcpO1xuXHRcdFx0XHRcdGlmIChpbm5lcikge1xuXHRcdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGlubmVyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoYXJnVHlwZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0aWYgKGFyZy50b1N0cmluZyA9PT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykge1xuXHRcdFx0XHRcdGZvciAodmFyIGtleSBpbiBhcmcpIHtcblx0XHRcdFx0XHRcdGlmIChoYXNPd24uY2FsbChhcmcsIGtleSkgJiYgYXJnW2tleV0pIHtcblx0XHRcdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGtleSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNsYXNzZXMucHVzaChhcmcudG9TdHJpbmcoKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gY2xhc3Nlcy5qb2luKCcgJyk7XG5cdH1cblxuXHRpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcblx0XHRjbGFzc05hbWVzLmRlZmF1bHQgPSBjbGFzc05hbWVzO1xuXHRcdG1vZHVsZS5leHBvcnRzID0gY2xhc3NOYW1lcztcblx0fSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gcmVnaXN0ZXIgYXMgJ2NsYXNzbmFtZXMnLCBjb25zaXN0ZW50IHdpdGggbnBtIHBhY2thZ2UgbmFtZVxuXHRcdGRlZmluZSgnY2xhc3NuYW1lcycsIFtdLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gY2xhc3NOYW1lcztcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHR3aW5kb3cuY2xhc3NOYW1lcyA9IGNsYXNzTmFtZXM7XG5cdH1cbn0oKSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///184\n")},299:function(module,__unused_webpack_exports,__webpack_require__){eval('/**\n * @licstart The following is the entire license notice for the\n * Javascript code in this page\n *\n * Copyright 2020 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @licend The above is the entire license notice for the\n * Javascript code in this page\n */\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __w_pdfjs_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __w_pdfjs_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__w_pdfjs_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__w_pdfjs_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__w_pdfjs_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__w_pdfjs_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__w_pdfjs_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== \'undefined\' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: \'Module\' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, \'__esModule\', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__w_pdfjs_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __w_pdfjs_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === \'object\' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__w_pdfjs_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, \'default\', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != \'string\') for(var key in value) __w_pdfjs_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__w_pdfjs_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module[\'default\']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__w_pdfjs_require__.d(getter, \'a\', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__w_pdfjs_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__w_pdfjs_require__.p = "";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __w_pdfjs_require__(__w_pdfjs_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n"use strict";\n\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nObject.defineProperty(exports, "addLinkAttributes", {\n  enumerable: true,\n  get: function () {\n    return _display_utils.addLinkAttributes;\n  }\n});\nObject.defineProperty(exports, "getFilenameFromUrl", {\n  enumerable: true,\n  get: function () {\n    return _display_utils.getFilenameFromUrl;\n  }\n});\nObject.defineProperty(exports, "LinkTarget", {\n  enumerable: true,\n  get: function () {\n    return _display_utils.LinkTarget;\n  }\n});\nObject.defineProperty(exports, "loadScript", {\n  enumerable: true,\n  get: function () {\n    return _display_utils.loadScript;\n  }\n});\nObject.defineProperty(exports, "PDFDateString", {\n  enumerable: true,\n  get: function () {\n    return _display_utils.PDFDateString;\n  }\n});\nObject.defineProperty(exports, "RenderingCancelledException", {\n  enumerable: true,\n  get: function () {\n    return _display_utils.RenderingCancelledException;\n  }\n});\nObject.defineProperty(exports, "build", {\n  enumerable: true,\n  get: function () {\n    return _api.build;\n  }\n});\nObject.defineProperty(exports, "getDocument", {\n  enumerable: true,\n  get: function () {\n    return _api.getDocument;\n  }\n});\nObject.defineProperty(exports, "LoopbackPort", {\n  enumerable: true,\n  get: function () {\n    return _api.LoopbackPort;\n  }\n});\nObject.defineProperty(exports, "PDFDataRangeTransport", {\n  enumerable: true,\n  get: function () {\n    return _api.PDFDataRangeTransport;\n  }\n});\nObject.defineProperty(exports, "PDFWorker", {\n  enumerable: true,\n  get: function () {\n    return _api.PDFWorker;\n  }\n});\nObject.defineProperty(exports, "version", {\n  enumerable: true,\n  get: function () {\n    return _api.version;\n  }\n});\nObject.defineProperty(exports, "CMapCompressionType", {\n  enumerable: true,\n  get: function () {\n    return _util.CMapCompressionType;\n  }\n});\nObject.defineProperty(exports, "createObjectURL", {\n  enumerable: true,\n  get: function () {\n    return _util.createObjectURL;\n  }\n});\nObject.defineProperty(exports, "createPromiseCapability", {\n  enumerable: true,\n  get: function () {\n    return _util.createPromiseCapability;\n  }\n});\nObject.defineProperty(exports, "createValidAbsoluteUrl", {\n  enumerable: true,\n  get: function () {\n    return _util.createValidAbsoluteUrl;\n  }\n});\nObject.defineProperty(exports, "InvalidPDFException", {\n  enumerable: true,\n  get: function () {\n    return _util.InvalidPDFException;\n  }\n});\nObject.defineProperty(exports, "MissingPDFException", {\n  enumerable: true,\n  get: function () {\n    return _util.MissingPDFException;\n  }\n});\nObject.defineProperty(exports, "OPS", {\n  enumerable: true,\n  get: function () {\n    return _util.OPS;\n  }\n});\nObject.defineProperty(exports, "PasswordResponses", {\n  enumerable: true,\n  get: function () {\n    return _util.PasswordResponses;\n  }\n});\nObject.defineProperty(exports, "PermissionFlag", {\n  enumerable: true,\n  get: function () {\n    return _util.PermissionFlag;\n  }\n});\nObject.defineProperty(exports, "removeNullCharacters", {\n  enumerable: true,\n  get: function () {\n    return _util.removeNullCharacters;\n  }\n});\nObject.defineProperty(exports, "shadow", {\n  enumerable: true,\n  get: function () {\n    return _util.shadow;\n  }\n});\nObject.defineProperty(exports, "UnexpectedResponseException", {\n  enumerable: true,\n  get: function () {\n    return _util.UnexpectedResponseException;\n  }\n});\nObject.defineProperty(exports, "UNSUPPORTED_FEATURES", {\n  enumerable: true,\n  get: function () {\n    return _util.UNSUPPORTED_FEATURES;\n  }\n});\nObject.defineProperty(exports, "Util", {\n  enumerable: true,\n  get: function () {\n    return _util.Util;\n  }\n});\nObject.defineProperty(exports, "VerbosityLevel", {\n  enumerable: true,\n  get: function () {\n    return _util.VerbosityLevel;\n  }\n});\nObject.defineProperty(exports, "AnnotationLayer", {\n  enumerable: true,\n  get: function () {\n    return _annotation_layer.AnnotationLayer;\n  }\n});\nObject.defineProperty(exports, "apiCompatibilityParams", {\n  enumerable: true,\n  get: function () {\n    return _api_compatibility.apiCompatibilityParams;\n  }\n});\nObject.defineProperty(exports, "GlobalWorkerOptions", {\n  enumerable: true,\n  get: function () {\n    return _worker_options.GlobalWorkerOptions;\n  }\n});\nObject.defineProperty(exports, "renderTextLayer", {\n  enumerable: true,\n  get: function () {\n    return _text_layer.renderTextLayer;\n  }\n});\nObject.defineProperty(exports, "SVGGraphics", {\n  enumerable: true,\n  get: function () {\n    return _svg.SVGGraphics;\n  }\n});\n\nvar _display_utils = __w_pdfjs_require__(1);\n\nvar _api = __w_pdfjs_require__(5);\n\nvar _util = __w_pdfjs_require__(2);\n\nvar _annotation_layer = __w_pdfjs_require__(19);\n\nvar _api_compatibility = __w_pdfjs_require__(9);\n\nvar _worker_options = __w_pdfjs_require__(12);\n\nvar _text_layer = __w_pdfjs_require__(20);\n\nvar _svg = __w_pdfjs_require__(21);\n\nconst pdfjsVersion = \'2.6.347\';\nconst pdfjsBuild = \'3be9c65f\';\n{\n  const {\n    isNodeJS\n  } = __w_pdfjs_require__(4);\n\n  if (isNodeJS) {\n    const PDFNodeStream = __w_pdfjs_require__(22).PDFNodeStream;\n\n    (0, _api.setPDFNetworkStreamFactory)(params => {\n      return new PDFNodeStream(params);\n    });\n  } else {\n    const PDFNetworkStream = __w_pdfjs_require__(25).PDFNetworkStream;\n\n    let PDFFetchStream;\n\n    if ((0, _display_utils.isFetchSupported)()) {\n      PDFFetchStream = __w_pdfjs_require__(26).PDFFetchStream;\n    }\n\n    (0, _api.setPDFNetworkStreamFactory)(params => {\n      if (PDFFetchStream && (0, _display_utils.isValidFetchUrl)(params.url)) {\n        return new PDFFetchStream(params);\n      }\n\n      return new PDFNetworkStream(params);\n    });\n  }\n}\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n"use strict";\n\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.addLinkAttributes = addLinkAttributes;\nexports.getFilenameFromUrl = getFilenameFromUrl;\nexports.isFetchSupported = isFetchSupported;\nexports.isValidFetchUrl = isValidFetchUrl;\nexports.loadScript = loadScript;\nexports.deprecated = deprecated;\nexports.PDFDateString = exports.StatTimer = exports.DOMSVGFactory = exports.DOMCMapReaderFactory = exports.BaseCMapReaderFactory = exports.DOMCanvasFactory = exports.BaseCanvasFactory = exports.DEFAULT_LINK_REL = exports.LinkTarget = exports.RenderingCancelledException = exports.PageViewport = void 0;\n\nvar _util = __w_pdfjs_require__(2);\n\nconst DEFAULT_LINK_REL = "noopener noreferrer nofollow";\nexports.DEFAULT_LINK_REL = DEFAULT_LINK_REL;\nconst SVG_NS = "http://www.w3.org/2000/svg";\n\nclass BaseCanvasFactory {\n  constructor() {\n    if (this.constructor === BaseCanvasFactory) {\n      (0, _util.unreachable)("Cannot initialize BaseCanvasFactory.");\n    }\n  }\n\n  create(width, height) {\n    (0, _util.unreachable)("Abstract method `create` called.");\n  }\n\n  reset(canvasAndContext, width, height) {\n    if (!canvasAndContext.canvas) {\n      throw new Error("Canvas is not specified");\n    }\n\n    if (width <= 0 || height <= 0) {\n      throw new Error("Invalid canvas size");\n    }\n\n    canvasAndContext.canvas.width = width;\n    canvasAndContext.canvas.height = height;\n  }\n\n  destroy(canvasAndContext) {\n    if (!canvasAndContext.canvas) {\n      throw new Error("Canvas is not specified");\n    }\n\n    canvasAndContext.canvas.width = 0;\n    canvasAndContext.canvas.height = 0;\n    canvasAndContext.canvas = null;\n    canvasAndContext.context = null;\n  }\n\n}\n\nexports.BaseCanvasFactory = BaseCanvasFactory;\n\nclass DOMCanvasFactory extends BaseCanvasFactory {\n  constructor({\n    ownerDocument = globalThis.document\n  } = {}) {\n    super();\n    this._document = ownerDocument;\n  }\n\n  create(width, height) {\n    if (width <= 0 || height <= 0) {\n      throw new Error("Invalid canvas size");\n    }\n\n    const canvas = this._document.createElement("canvas");\n\n    const context = canvas.getContext("2d");\n    canvas.width = width;\n    canvas.height = height;\n    return {\n      canvas,\n      context\n    };\n  }\n\n}\n\nexports.DOMCanvasFactory = DOMCanvasFactory;\n\nclass BaseCMapReaderFactory {\n  constructor({\n    baseUrl = null,\n    isCompressed = false\n  }) {\n    if (this.constructor === BaseCMapReaderFactory) {\n      (0, _util.unreachable)("Cannot initialize BaseCMapReaderFactory.");\n    }\n\n    this.baseUrl = baseUrl;\n    this.isCompressed = isCompressed;\n  }\n\n  async fetch({\n    name\n  }) {\n    if (!this.baseUrl) {\n      throw new Error(\'The CMap "baseUrl" parameter must be specified, ensure that \' + \'the "cMapUrl" and "cMapPacked" API parameters are provided.\');\n    }\n\n    if (!name) {\n      throw new Error("CMap name must be specified.");\n    }\n\n    const url = this.baseUrl + name + (this.isCompressed ? ".bcmap" : "");\n    const compressionType = this.isCompressed ? _util.CMapCompressionType.BINARY : _util.CMapCompressionType.NONE;\n    return this._fetchData(url, compressionType).catch(reason => {\n      throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${url}`);\n    });\n  }\n\n  _fetchData(url, compressionType) {\n    (0, _util.unreachable)("Abstract method `_fetchData` called.");\n  }\n\n}\n\nexports.BaseCMapReaderFactory = BaseCMapReaderFactory;\n\nclass DOMCMapReaderFactory extends BaseCMapReaderFactory {\n  _fetchData(url, compressionType) {\n    if (isFetchSupported() && isValidFetchUrl(url, document.baseURI)) {\n      return fetch(url).then(async response => {\n        if (!response.ok) {\n          throw new Error(response.statusText);\n        }\n\n        let cMapData;\n\n        if (this.isCompressed) {\n          cMapData = new Uint8Array(await response.arrayBuffer());\n        } else {\n          cMapData = (0, _util.stringToBytes)(await response.text());\n        }\n\n        return {\n          cMapData,\n          compressionType\n        };\n      });\n    }\n\n    return new Promise((resolve, reject) => {\n      const request = new XMLHttpRequest();\n      request.open("GET", url, true);\n\n      if (this.isCompressed) {\n        request.responseType = "arraybuffer";\n      }\n\n      request.onreadystatechange = () => {\n        if (request.readyState !== XMLHttpRequest.DONE) {\n          return;\n        }\n\n        if (request.status === 200 || request.status === 0) {\n          let cMapData;\n\n          if (this.isCompressed && request.response) {\n            cMapData = new Uint8Array(request.response);\n          } else if (!this.isCompressed && request.responseText) {\n            cMapData = (0, _util.stringToBytes)(request.responseText);\n          }\n\n          if (cMapData) {\n            resolve({\n              cMapData,\n              compressionType\n            });\n            return;\n          }\n        }\n\n        reject(new Error(request.statusText));\n      };\n\n      request.send(null);\n    });\n  }\n\n}\n\nexports.DOMCMapReaderFactory = DOMCMapReaderFactory;\n\nclass DOMSVGFactory {\n  create(width, height) {\n    (0, _util.assert)(width > 0 && height > 0, "Invalid SVG dimensions");\n    const svg = document.createElementNS(SVG_NS, "svg:svg");\n    svg.setAttribute("version", "1.1");\n    svg.setAttribute("width", width + "px");\n    svg.setAttribute("height", height + "px");\n    svg.setAttribute("preserveAspectRatio", "none");\n    svg.setAttribute("viewBox", "0 0 " + width + " " + height);\n    return svg;\n  }\n\n  createElement(type) {\n    (0, _util.assert)(typeof type === "string", "Invalid SVG element type");\n    return document.createElementNS(SVG_NS, type);\n  }\n\n}\n\nexports.DOMSVGFactory = DOMSVGFactory;\n\nclass PageViewport {\n  constructor({\n    viewBox,\n    scale,\n    rotation,\n    offsetX = 0,\n    offsetY = 0,\n    dontFlip = false\n  }) {\n    this.viewBox = viewBox;\n    this.scale = scale;\n    this.rotation = rotation;\n    this.offsetX = offsetX;\n    this.offsetY = offsetY;\n    const centerX = (viewBox[2] + viewBox[0]) / 2;\n    const centerY = (viewBox[3] + viewBox[1]) / 2;\n    let rotateA, rotateB, rotateC, rotateD;\n    rotation = rotation % 360;\n    rotation = rotation < 0 ? rotation + 360 : rotation;\n\n    switch (rotation) {\n      case 180:\n        rotateA = -1;\n        rotateB = 0;\n        rotateC = 0;\n        rotateD = 1;\n        break;\n\n      case 90:\n        rotateA = 0;\n        rotateB = 1;\n        rotateC = 1;\n        rotateD = 0;\n        break;\n\n      case 270:\n        rotateA = 0;\n        rotateB = -1;\n        rotateC = -1;\n        rotateD = 0;\n        break;\n\n      case 0:\n        rotateA = 1;\n        rotateB = 0;\n        rotateC = 0;\n        rotateD = -1;\n        break;\n\n      default:\n        throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");\n    }\n\n    if (dontFlip) {\n      rotateC = -rotateC;\n      rotateD = -rotateD;\n    }\n\n    let offsetCanvasX, offsetCanvasY;\n    let width, height;\n\n    if (rotateA === 0) {\n      offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;\n      offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;\n      width = Math.abs(viewBox[3] - viewBox[1]) * scale;\n      height = Math.abs(viewBox[2] - viewBox[0]) * scale;\n    } else {\n      offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;\n      offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;\n      width = Math.abs(viewBox[2] - viewBox[0]) * scale;\n      height = Math.abs(viewBox[3] - viewBox[1]) * scale;\n    }\n\n    this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];\n    this.width = width;\n    this.height = height;\n  }\n\n  clone({\n    scale = this.scale,\n    rotation = this.rotation,\n    offsetX = this.offsetX,\n    offsetY = this.offsetY,\n    dontFlip = false\n  } = {}) {\n    return new PageViewport({\n      viewBox: this.viewBox.slice(),\n      scale,\n      rotation,\n      offsetX,\n      offsetY,\n      dontFlip\n    });\n  }\n\n  convertToViewportPoint(x, y) {\n    return _util.Util.applyTransform([x, y], this.transform);\n  }\n\n  convertToViewportRectangle(rect) {\n    const topLeft = _util.Util.applyTransform([rect[0], rect[1]], this.transform);\n\n    const bottomRight = _util.Util.applyTransform([rect[2], rect[3]], this.transform);\n\n    return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];\n  }\n\n  convertToPdfPoint(x, y) {\n    return _util.Util.applyInverseTransform([x, y], this.transform);\n  }\n\n}\n\nexports.PageViewport = PageViewport;\n\nclass RenderingCancelledException extends _util.BaseException {\n  constructor(msg, type) {\n    super(msg);\n    this.type = type;\n  }\n\n}\n\nexports.RenderingCancelledException = RenderingCancelledException;\nconst LinkTarget = {\n  NONE: 0,\n  SELF: 1,\n  BLANK: 2,\n  PARENT: 3,\n  TOP: 4\n};\nexports.LinkTarget = LinkTarget;\n\nfunction addLinkAttributes(link, {\n  url,\n  target,\n  rel,\n  enabled = true\n} = {}) {\n  (0, _util.assert)(url && typeof url === "string", \'addLinkAttributes: A valid "url" parameter must provided.\');\n  const urlNullRemoved = (0, _util.removeNullCharacters)(url);\n\n  if (enabled) {\n    link.href = link.title = urlNullRemoved;\n  } else {\n    link.href = "";\n    link.title = `Disabled: ${urlNullRemoved}`;\n\n    link.onclick = () => {\n      return false;\n    };\n  }\n\n  let targetStr = "";\n\n  switch (target) {\n    case LinkTarget.NONE:\n      break;\n\n    case LinkTarget.SELF:\n      targetStr = "_self";\n      break;\n\n    case LinkTarget.BLANK:\n      targetStr = "_blank";\n      break;\n\n    case LinkTarget.PARENT:\n      targetStr = "_parent";\n      break;\n\n    case LinkTarget.TOP:\n      targetStr = "_top";\n      break;\n  }\n\n  link.target = targetStr;\n  link.rel = typeof rel === "string" ? rel : DEFAULT_LINK_REL;\n}\n\nfunction getFilenameFromUrl(url) {\n  const anchor = url.indexOf("#");\n  const query = url.indexOf("?");\n  const end = Math.min(anchor > 0 ? anchor : url.length, query > 0 ? query : url.length);\n  return url.substring(url.lastIndexOf("/", end) + 1, end);\n}\n\nclass StatTimer {\n  constructor() {\n    this.started = Object.create(null);\n    this.times = [];\n  }\n\n  time(name) {\n    if (name in this.started) {\n      (0, _util.warn)(`Timer is already running for ${name}`);\n    }\n\n    this.started[name] = Date.now();\n  }\n\n  timeEnd(name) {\n    if (!(name in this.started)) {\n      (0, _util.warn)(`Timer has not been started for ${name}`);\n    }\n\n    this.times.push({\n      name,\n      start: this.started[name],\n      end: Date.now()\n    });\n    delete this.started[name];\n  }\n\n  toString() {\n    const outBuf = [];\n    let longest = 0;\n\n    for (const time of this.times) {\n      const name = time.name;\n\n      if (name.length > longest) {\n        longest = name.length;\n      }\n    }\n\n    for (const time of this.times) {\n      const duration = time.end - time.start;\n      outBuf.push(`${time.name.padEnd(longest)} ${duration}ms\\n`);\n    }\n\n    return outBuf.join("");\n  }\n\n}\n\nexports.StatTimer = StatTimer;\n\nfunction isFetchSupported() {\n  return typeof fetch !== "undefined" && typeof Response !== "undefined" && "body" in Response.prototype && typeof ReadableStream !== "undefined";\n}\n\nfunction isValidFetchUrl(url, baseUrl) {\n  try {\n    const {\n      protocol\n    } = baseUrl ? new URL(url, baseUrl) : new URL(url);\n    return protocol === "http:" || protocol === "https:";\n  } catch (ex) {\n    return false;\n  }\n}\n\nfunction loadScript(src) {\n  return new Promise((resolve, reject) => {\n    const script = document.createElement("script");\n    script.src = src;\n    script.onload = resolve;\n\n    script.onerror = function () {\n      reject(new Error(`Cannot load script at: ${script.src}`));\n    };\n\n    (document.head || document.documentElement).appendChild(script);\n  });\n}\n\nfunction deprecated(details) {\n  console.log("Deprecated API usage: " + details);\n}\n\nlet pdfDateStringRegex;\n\nclass PDFDateString {\n  static toDateObject(input) {\n    if (!input || !(0, _util.isString)(input)) {\n      return null;\n    }\n\n    if (!pdfDateStringRegex) {\n      pdfDateStringRegex = new RegExp("^D:" + "(\\\\d{4})" + "(\\\\d{2})?" + "(\\\\d{2})?" + "(\\\\d{2})?" + "(\\\\d{2})?" + "(\\\\d{2})?" + "([Z|+|-])?" + "(\\\\d{2})?" + "\'?" + "(\\\\d{2})?" + "\'?");\n    }\n\n    const matches = pdfDateStringRegex.exec(input);\n\n    if (!matches) {\n      return null;\n    }\n\n    const year = parseInt(matches[1], 10);\n    let month = parseInt(matches[2], 10);\n    month = month >= 1 && month <= 12 ? month - 1 : 0;\n    let day = parseInt(matches[3], 10);\n    day = day >= 1 && day <= 31 ? day : 1;\n    let hour = parseInt(matches[4], 10);\n    hour = hour >= 0 && hour <= 23 ? hour : 0;\n    let minute = parseInt(matches[5], 10);\n    minute = minute >= 0 && minute <= 59 ? minute : 0;\n    let second = parseInt(matches[6], 10);\n    second = second >= 0 && second <= 59 ? second : 0;\n    const universalTimeRelation = matches[7] || "Z";\n    let offsetHour = parseInt(matches[8], 10);\n    offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;\n    let offsetMinute = parseInt(matches[9], 10) || 0;\n    offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;\n\n    if (universalTimeRelation === "-") {\n      hour += offsetHour;\n      minute += offsetMinute;\n    } else if (universalTimeRelation === "+") {\n      hour -= offsetHour;\n      minute -= offsetMinute;\n    }\n\n    return new Date(Date.UTC(year, month, day, hour, minute, second));\n  }\n\n}\n\nexports.PDFDateString = PDFDateString;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n"use strict";\n\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.arrayByteLength = arrayByteLength;\nexports.arraysToBytes = arraysToBytes;\nexports.assert = assert;\nexports.bytesToString = bytesToString;\nexports.createPromiseCapability = createPromiseCapability;\nexports.escapeString = escapeString;\nexports.getModificationDate = getModificationDate;\nexports.getVerbosityLevel = getVerbosityLevel;\nexports.info = info;\nexports.isArrayBuffer = isArrayBuffer;\nexports.isArrayEqual = isArrayEqual;\nexports.isBool = isBool;\nexports.isNum = isNum;\nexports.isString = isString;\nexports.isSameOrigin = isSameOrigin;\nexports.createValidAbsoluteUrl = createValidAbsoluteUrl;\nexports.removeNullCharacters = removeNullCharacters;\nexports.setVerbosityLevel = setVerbosityLevel;\nexports.shadow = shadow;\nexports.string32 = string32;\nexports.stringToBytes = stringToBytes;\nexports.stringToPDFString = stringToPDFString;\nexports.stringToUTF8String = stringToUTF8String;\nexports.utf8StringToString = utf8StringToString;\nexports.warn = warn;\nexports.unreachable = unreachable;\nexports.IsEvalSupportedCached = exports.IsLittleEndianCached = exports.createObjectURL = exports.FormatError = exports.Util = exports.UnknownErrorException = exports.UnexpectedResponseException = exports.TextRenderingMode = exports.StreamType = exports.PermissionFlag = exports.PasswordResponses = exports.PasswordException = exports.MissingPDFException = exports.InvalidPDFException = exports.AbortException = exports.CMapCompressionType = exports.ImageKind = exports.FontType = exports.AnnotationType = exports.AnnotationStateModelType = exports.AnnotationReviewState = exports.AnnotationReplyType = exports.AnnotationMarkedState = exports.AnnotationFlag = exports.AnnotationFieldFlag = exports.AnnotationBorderStyleType = exports.UNSUPPORTED_FEATURES = exports.VerbosityLevel = exports.OPS = exports.IDENTITY_MATRIX = exports.FONT_IDENTITY_MATRIX = exports.BaseException = void 0;\n\n__w_pdfjs_require__(3);\n\nconst IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];\nexports.IDENTITY_MATRIX = IDENTITY_MATRIX;\nconst FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];\nexports.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;\nconst PermissionFlag = {\n  PRINT: 0x04,\n  MODIFY_CONTENTS: 0x08,\n  COPY: 0x10,\n  MODIFY_ANNOTATIONS: 0x20,\n  FILL_INTERACTIVE_FORMS: 0x100,\n  COPY_FOR_ACCESSIBILITY: 0x200,\n  ASSEMBLE: 0x400,\n  PRINT_HIGH_QUALITY: 0x800\n};\nexports.PermissionFlag = PermissionFlag;\nconst TextRenderingMode = {\n  FILL: 0,\n  STROKE: 1,\n  FILL_STROKE: 2,\n  INVISIBLE: 3,\n  FILL_ADD_TO_PATH: 4,\n  STROKE_ADD_TO_PATH: 5,\n  FILL_STROKE_ADD_TO_PATH: 6,\n  ADD_TO_PATH: 7,\n  FILL_STROKE_MASK: 3,\n  ADD_TO_PATH_FLAG: 4\n};\nexports.TextRenderingMode = TextRenderingMode;\nconst ImageKind = {\n  GRAYSCALE_1BPP: 1,\n  RGB_24BPP: 2,\n  RGBA_32BPP: 3\n};\nexports.ImageKind = ImageKind;\nconst AnnotationType = {\n  TEXT: 1,\n  LINK: 2,\n  FREETEXT: 3,\n  LINE: 4,\n  SQUARE: 5,\n  CIRCLE: 6,\n  POLYGON: 7,\n  POLYLINE: 8,\n  HIGHLIGHT: 9,\n  UNDERLINE: 10,\n  SQUIGGLY: 11,\n  STRIKEOUT: 12,\n  STAMP: 13,\n  CARET: 14,\n  INK: 15,\n  POPUP: 16,\n  FILEATTACHMENT: 17,\n  SOUND: 18,\n  MOVIE: 19,\n  WIDGET: 20,\n  SCREEN: 21,\n  PRINTERMARK: 22,\n  TRAPNET: 23,\n  WATERMARK: 24,\n  THREED: 25,\n  REDACT: 26\n};\nexports.AnnotationType = AnnotationType;\nconst AnnotationStateModelType = {\n  MARKED: "Marked",\n  REVIEW: "Review"\n};\nexports.AnnotationStateModelType = AnnotationStateModelType;\nconst AnnotationMarkedState = {\n  MARKED: "Marked",\n  UNMARKED: "Unmarked"\n};\nexports.AnnotationMarkedState = AnnotationMarkedState;\nconst AnnotationReviewState = {\n  ACCEPTED: "Accepted",\n  REJECTED: "Rejected",\n  CANCELLED: "Cancelled",\n  COMPLETED: "Completed",\n  NONE: "None"\n};\nexports.AnnotationReviewState = AnnotationReviewState;\nconst AnnotationReplyType = {\n  GROUP: "Group",\n  REPLY: "R"\n};\nexports.AnnotationReplyType = AnnotationReplyType;\nconst AnnotationFlag = {\n  INVISIBLE: 0x01,\n  HIDDEN: 0x02,\n  PRINT: 0x04,\n  NOZOOM: 0x08,\n  NOROTATE: 0x10,\n  NOVIEW: 0x20,\n  READONLY: 0x40,\n  LOCKED: 0x80,\n  TOGGLENOVIEW: 0x100,\n  LOCKEDCONTENTS: 0x200\n};\nexports.AnnotationFlag = AnnotationFlag;\nconst AnnotationFieldFlag = {\n  READONLY: 0x0000001,\n  REQUIRED: 0x0000002,\n  NOEXPORT: 0x0000004,\n  MULTILINE: 0x0001000,\n  PASSWORD: 0x0002000,\n  NOTOGGLETOOFF: 0x0004000,\n  RADIO: 0x0008000,\n  PUSHBUTTON: 0x0010000,\n  COMBO: 0x0020000,\n  EDIT: 0x0040000,\n  SORT: 0x0080000,\n  FILESELECT: 0x0100000,\n  MULTISELECT: 0x0200000,\n  DONOTSPELLCHECK: 0x0400000,\n  DONOTSCROLL: 0x0800000,\n  COMB: 0x1000000,\n  RICHTEXT: 0x2000000,\n  RADIOSINUNISON: 0x2000000,\n  COMMITONSELCHANGE: 0x4000000\n};\nexports.AnnotationFieldFlag = AnnotationFieldFlag;\nconst AnnotationBorderStyleType = {\n  SOLID: 1,\n  DASHED: 2,\n  BEVELED: 3,\n  INSET: 4,\n  UNDERLINE: 5\n};\nexports.AnnotationBorderStyleType = AnnotationBorderStyleType;\nconst StreamType = {\n  UNKNOWN: "UNKNOWN",\n  FLATE: "FLATE",\n  LZW: "LZW",\n  DCT: "DCT",\n  JPX: "JPX",\n  JBIG: "JBIG",\n  A85: "A85",\n  AHX: "AHX",\n  CCF: "CCF",\n  RLX: "RLX"\n};\nexports.StreamType = StreamType;\nconst FontType = {\n  UNKNOWN: "UNKNOWN",\n  TYPE1: "TYPE1",\n  TYPE1C: "TYPE1C",\n  CIDFONTTYPE0: "CIDFONTTYPE0",\n  CIDFONTTYPE0C: "CIDFONTTYPE0C",\n  TRUETYPE: "TRUETYPE",\n  CIDFONTTYPE2: "CIDFONTTYPE2",\n  TYPE3: "TYPE3",\n  OPENTYPE: "OPENTYPE",\n  TYPE0: "TYPE0",\n  MMTYPE1: "MMTYPE1"\n};\nexports.FontType = FontType;\nconst VerbosityLevel = {\n  ERRORS: 0,\n  WARNINGS: 1,\n  INFOS: 5\n};\nexports.VerbosityLevel = VerbosityLevel;\nconst CMapCompressionType = {\n  NONE: 0,\n  BINARY: 1,\n  STREAM: 2\n};\nexports.CMapCompressionType = CMapCompressionType;\nconst OPS = {\n  dependency: 1,\n  setLineWidth: 2,\n  setLineCap: 3,\n  setLineJoin: 4,\n  setMiterLimit: 5,\n  setDash: 6,\n  setRenderingIntent: 7,\n  setFlatness: 8,\n  setGState: 9,\n  save: 10,\n  restore: 11,\n  transform: 12,\n  moveTo: 13,\n  lineTo: 14,\n  curveTo: 15,\n  curveTo2: 16,\n  curveTo3: 17,\n  closePath: 18,\n  rectangle: 19,\n  stroke: 20,\n  closeStroke: 21,\n  fill: 22,\n  eoFill: 23,\n  fillStroke: 24,\n  eoFillStroke: 25,\n  closeFillStroke: 26,\n  closeEOFillStroke: 27,\n  endPath: 28,\n  clip: 29,\n  eoClip: 30,\n  beginText: 31,\n  endText: 32,\n  setCharSpacing: 33,\n  setWordSpacing: 34,\n  setHScale: 35,\n  setLeading: 36,\n  setFont: 37,\n  setTextRenderingMode: 38,\n  setTextRise: 39,\n  moveText: 40,\n  setLeadingMoveText: 41,\n  setTextMatrix: 42,\n  nextLine: 43,\n  showText: 44,\n  showSpacedText: 45,\n  nextLineShowText: 46,\n  nextLineSetSpacingShowText: 47,\n  setCharWidth: 48,\n  setCharWidthAndBounds: 49,\n  setStrokeColorSpace: 50,\n  setFillColorSpace: 51,\n  setStrokeColor: 52,\n  setStrokeColorN: 53,\n  setFillColor: 54,\n  setFillColorN: 55,\n  setStrokeGray: 56,\n  setFillGray: 57,\n  setStrokeRGBColor: 58,\n  setFillRGBColor: 59,\n  setStrokeCMYKColor: 60,\n  setFillCMYKColor: 61,\n  shadingFill: 62,\n  beginInlineImage: 63,\n  beginImageData: 64,\n  endInlineImage: 65,\n  paintXObject: 66,\n  markPoint: 67,\n  markPointProps: 68,\n  beginMarkedContent: 69,\n  beginMarkedContentProps: 70,\n  endMarkedContent: 71,\n  beginCompat: 72,\n  endCompat: 73,\n  paintFormXObjectBegin: 74,\n  paintFormXObjectEnd: 75,\n  beginGroup: 76,\n  endGroup: 77,\n  beginAnnotations: 78,\n  endAnnotations: 79,\n  beginAnnotation: 80,\n  endAnnotation: 81,\n  paintJpegXObject: 82,\n  paintImageMaskXObject: 83,\n  paintImageMaskXObjectGroup: 84,\n  paintImageXObject: 85,\n  paintInlineImageXObject: 86,\n  paintInlineImageXObjectGroup: 87,\n  paintImageXObjectRepeat: 88,\n  paintImageMaskXObjectRepeat: 89,\n  paintSolidColorImageMask: 90,\n  constructPath: 91\n};\nexports.OPS = OPS;\nconst UNSUPPORTED_FEATURES = {\n  unknown: "unknown",\n  forms: "forms",\n  javaScript: "javaScript",\n  smask: "smask",\n  shadingPattern: "shadingPattern",\n  font: "font",\n  errorTilingPattern: "errorTilingPattern",\n  errorExtGState: "errorExtGState",\n  errorXObject: "errorXObject",\n  errorFontLoadType3: "errorFontLoadType3",\n  errorFontState: "errorFontState",\n  errorFontMissing: "errorFontMissing",\n  errorFontTranslate: "errorFontTranslate",\n  errorColorSpace: "errorColorSpace",\n  errorOperatorList: "errorOperatorList",\n  errorFontToUnicode: "errorFontToUnicode",\n  errorFontLoadNative: "errorFontLoadNative",\n  errorFontGetPath: "errorFontGetPath",\n  errorMarkedContent: "errorMarkedContent"\n};\nexports.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;\nconst PasswordResponses = {\n  NEED_PASSWORD: 1,\n  INCORRECT_PASSWORD: 2\n};\nexports.PasswordResponses = PasswordResponses;\nlet verbosity = VerbosityLevel.WARNINGS;\n\nfunction setVerbosityLevel(level) {\n  if (Number.isInteger(level)) {\n    verbosity = level;\n  }\n}\n\nfunction getVerbosityLevel() {\n  return verbosity;\n}\n\nfunction info(msg) {\n  if (verbosity >= VerbosityLevel.INFOS) {\n    console.log(`Info: ${msg}`);\n  }\n}\n\nfunction warn(msg) {\n  if (verbosity >= VerbosityLevel.WARNINGS) {\n    console.log(`Warning: ${msg}`);\n  }\n}\n\nfunction unreachable(msg) {\n  throw new Error(msg);\n}\n\nfunction assert(cond, msg) {\n  if (!cond) {\n    unreachable(msg);\n  }\n}\n\nfunction isSameOrigin(baseUrl, otherUrl) {\n  let base;\n\n  try {\n    base = new URL(baseUrl);\n\n    if (!base.origin || base.origin === "null") {\n      return false;\n    }\n  } catch (e) {\n    return false;\n  }\n\n  const other = new URL(otherUrl, base);\n  return base.origin === other.origin;\n}\n\nfunction _isValidProtocol(url) {\n  if (!url) {\n    return false;\n  }\n\n  switch (url.protocol) {\n    case "http:":\n    case "https:":\n    case "ftp:":\n    case "mailto:":\n    case "tel:":\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nfunction createValidAbsoluteUrl(url, baseUrl) {\n  if (!url) {\n    return null;\n  }\n\n  try {\n    const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);\n\n    if (_isValidProtocol(absoluteUrl)) {\n      return absoluteUrl;\n    }\n  } catch (ex) {}\n\n  return null;\n}\n\nfunction shadow(obj, prop, value) {\n  Object.defineProperty(obj, prop, {\n    value,\n    enumerable: true,\n    configurable: true,\n    writable: false\n  });\n  return value;\n}\n\nconst BaseException = function BaseExceptionClosure() {\n  function BaseException(message) {\n    if (this.constructor === BaseException) {\n      unreachable("Cannot initialize BaseException.");\n    }\n\n    this.message = message;\n    this.name = this.constructor.name;\n  }\n\n  BaseException.prototype = new Error();\n  BaseException.constructor = BaseException;\n  return BaseException;\n}();\n\nexports.BaseException = BaseException;\n\nclass PasswordException extends BaseException {\n  constructor(msg, code) {\n    super(msg);\n    this.code = code;\n  }\n\n}\n\nexports.PasswordException = PasswordException;\n\nclass UnknownErrorException extends BaseException {\n  constructor(msg, details) {\n    super(msg);\n    this.details = details;\n  }\n\n}\n\nexports.UnknownErrorException = UnknownErrorException;\n\nclass InvalidPDFException extends BaseException {}\n\nexports.InvalidPDFException = InvalidPDFException;\n\nclass MissingPDFException extends BaseException {}\n\nexports.MissingPDFException = MissingPDFException;\n\nclass UnexpectedResponseException extends BaseException {\n  constructor(msg, status) {\n    super(msg);\n    this.status = status;\n  }\n\n}\n\nexports.UnexpectedResponseException = UnexpectedResponseException;\n\nclass FormatError extends BaseException {}\n\nexports.FormatError = FormatError;\n\nclass AbortException extends BaseException {}\n\nexports.AbortException = AbortException;\nconst NullCharactersRegExp = /\\x00/g;\n\nfunction removeNullCharacters(str) {\n  if (typeof str !== "string") {\n    warn("The argument for removeNullCharacters must be a string.");\n    return str;\n  }\n\n  return str.replace(NullCharactersRegExp, "");\n}\n\nfunction bytesToString(bytes) {\n  assert(bytes !== null && typeof bytes === "object" && bytes.length !== undefined, "Invalid argument for bytesToString");\n  const length = bytes.length;\n  const MAX_ARGUMENT_COUNT = 8192;\n\n  if (length < MAX_ARGUMENT_COUNT) {\n    return String.fromCharCode.apply(null, bytes);\n  }\n\n  const strBuf = [];\n\n  for (let i = 0; i < length; i += MAX_ARGUMENT_COUNT) {\n    const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);\n    const chunk = bytes.subarray(i, chunkEnd);\n    strBuf.push(String.fromCharCode.apply(null, chunk));\n  }\n\n  return strBuf.join("");\n}\n\nfunction stringToBytes(str) {\n  assert(typeof str === "string", "Invalid argument for stringToBytes");\n  const length = str.length;\n  const bytes = new Uint8Array(length);\n\n  for (let i = 0; i < length; ++i) {\n    bytes[i] = str.charCodeAt(i) & 0xff;\n  }\n\n  return bytes;\n}\n\nfunction arrayByteLength(arr) {\n  if (arr.length !== undefined) {\n    return arr.length;\n  }\n\n  assert(arr.byteLength !== undefined, "arrayByteLength - invalid argument.");\n  return arr.byteLength;\n}\n\nfunction arraysToBytes(arr) {\n  const length = arr.length;\n\n  if (length === 1 && arr[0] instanceof Uint8Array) {\n    return arr[0];\n  }\n\n  let resultLength = 0;\n\n  for (let i = 0; i < length; i++) {\n    resultLength += arrayByteLength(arr[i]);\n  }\n\n  let pos = 0;\n  const data = new Uint8Array(resultLength);\n\n  for (let i = 0; i < length; i++) {\n    let item = arr[i];\n\n    if (!(item instanceof Uint8Array)) {\n      if (typeof item === "string") {\n        item = stringToBytes(item);\n      } else {\n        item = new Uint8Array(item);\n      }\n    }\n\n    const itemLength = item.byteLength;\n    data.set(item, pos);\n    pos += itemLength;\n  }\n\n  return data;\n}\n\nfunction string32(value) {\n  return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);\n}\n\nfunction isLittleEndian() {\n  const buffer8 = new Uint8Array(4);\n  buffer8[0] = 1;\n  const view32 = new Uint32Array(buffer8.buffer, 0, 1);\n  return view32[0] === 1;\n}\n\nconst IsLittleEndianCached = {\n  get value() {\n    return shadow(this, "value", isLittleEndian());\n  }\n\n};\nexports.IsLittleEndianCached = IsLittleEndianCached;\n\nfunction isEvalSupported() {\n  try {\n    new Function("");\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nconst IsEvalSupportedCached = {\n  get value() {\n    return shadow(this, "value", isEvalSupported());\n  }\n\n};\nexports.IsEvalSupportedCached = IsEvalSupportedCached;\nconst rgbBuf = ["rgb(", 0, ",", 0, ",", 0, ")"];\n\nclass Util {\n  static makeCssRgb(r, g, b) {\n    rgbBuf[1] = r;\n    rgbBuf[3] = g;\n    rgbBuf[5] = b;\n    return rgbBuf.join("");\n  }\n\n  static transform(m1, m2) {\n    return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];\n  }\n\n  static applyTransform(p, m) {\n    const xt = p[0] * m[0] + p[1] * m[2] + m[4];\n    const yt = p[0] * m[1] + p[1] * m[3] + m[5];\n    return [xt, yt];\n  }\n\n  static applyInverseTransform(p, m) {\n    const d = m[0] * m[3] - m[1] * m[2];\n    const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;\n    const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;\n    return [xt, yt];\n  }\n\n  static getAxialAlignedBoundingBox(r, m) {\n    const p1 = Util.applyTransform(r, m);\n    const p2 = Util.applyTransform(r.slice(2, 4), m);\n    const p3 = Util.applyTransform([r[0], r[3]], m);\n    const p4 = Util.applyTransform([r[2], r[1]], m);\n    return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];\n  }\n\n  static inverseTransform(m) {\n    const d = m[0] * m[3] - m[1] * m[2];\n    return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];\n  }\n\n  static apply3dTransform(m, v) {\n    return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];\n  }\n\n  static singularValueDecompose2dScale(m) {\n    const transpose = [m[0], m[2], m[1], m[3]];\n    const a = m[0] * transpose[0] + m[1] * transpose[2];\n    const b = m[0] * transpose[1] + m[1] * transpose[3];\n    const c = m[2] * transpose[0] + m[3] * transpose[2];\n    const d = m[2] * transpose[1] + m[3] * transpose[3];\n    const first = (a + d) / 2;\n    const second = Math.sqrt((a + d) * (a + d) - 4 * (a * d - c * b)) / 2;\n    const sx = first + second || 1;\n    const sy = first - second || 1;\n    return [Math.sqrt(sx), Math.sqrt(sy)];\n  }\n\n  static normalizeRect(rect) {\n    const r = rect.slice(0);\n\n    if (rect[0] > rect[2]) {\n      r[0] = rect[2];\n      r[2] = rect[0];\n    }\n\n    if (rect[1] > rect[3]) {\n      r[1] = rect[3];\n      r[3] = rect[1];\n    }\n\n    return r;\n  }\n\n  static intersect(rect1, rect2) {\n    function compare(a, b) {\n      return a - b;\n    }\n\n    const orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare);\n    const orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare);\n    const result = [];\n    rect1 = Util.normalizeRect(rect1);\n    rect2 = Util.normalizeRect(rect2);\n\n    if (orderedX[0] === rect1[0] && orderedX[1] === rect2[0] || orderedX[0] === rect2[0] && orderedX[1] === rect1[0]) {\n      result[0] = orderedX[1];\n      result[2] = orderedX[2];\n    } else {\n      return null;\n    }\n\n    if (orderedY[0] === rect1[1] && orderedY[1] === rect2[1] || orderedY[0] === rect2[1] && orderedY[1] === rect1[1]) {\n      result[1] = orderedY[1];\n      result[3] = orderedY[2];\n    } else {\n      return null;\n    }\n\n    return result;\n  }\n\n}\n\nexports.Util = Util;\nconst PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2D8, 0x2C7, 0x2C6, 0x2D9, 0x2DD, 0x2DB, 0x2DA, 0x2DC, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192, 0x2044, 0x2039, 0x203A, 0x2212, 0x2030, 0x201E, 0x201C, 0x201D, 0x2018, 0x2019, 0x201A, 0x2122, 0xFB01, 0xFB02, 0x141, 0x152, 0x160, 0x178, 0x17D, 0x131, 0x142, 0x153, 0x161, 0x17E, 0, 0x20AC];\n\nfunction stringToPDFString(str) {\n  const length = str.length,\n        strBuf = [];\n\n  if (str[0] === "\\xFE" && str[1] === "\\xFF") {\n    for (let i = 2; i < length; i += 2) {\n      strBuf.push(String.fromCharCode(str.charCodeAt(i) << 8 | str.charCodeAt(i + 1)));\n    }\n  } else if (str[0] === "\\xFF" && str[1] === "\\xFE") {\n    for (let i = 2; i < length; i += 2) {\n      strBuf.push(String.fromCharCode(str.charCodeAt(i + 1) << 8 | str.charCodeAt(i)));\n    }\n  } else {\n    for (let i = 0; i < length; ++i) {\n      const code = PDFStringTranslateTable[str.charCodeAt(i)];\n      strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));\n    }\n  }\n\n  return strBuf.join("");\n}\n\nfunction escapeString(str) {\n  return str.replace(/([\\(\\)\\\\])/g, "\\\\$1");\n}\n\nfunction stringToUTF8String(str) {\n  return decodeURIComponent(escape(str));\n}\n\nfunction utf8StringToString(str) {\n  return unescape(encodeURIComponent(str));\n}\n\nfunction isBool(v) {\n  return typeof v === "boolean";\n}\n\nfunction isNum(v) {\n  return typeof v === "number";\n}\n\nfunction isString(v) {\n  return typeof v === "string";\n}\n\nfunction isArrayBuffer(v) {\n  return typeof v === "object" && v !== null && v.byteLength !== undefined;\n}\n\nfunction isArrayEqual(arr1, arr2) {\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n\n  return arr1.every(function (element, index) {\n    return element === arr2[index];\n  });\n}\n\nfunction getModificationDate(date = new Date(Date.now())) {\n  const buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, "0"), (date.getUTCDate() + 1).toString().padStart(2, "0"), date.getUTCHours().toString().padStart(2, "0"), date.getUTCMinutes().toString().padStart(2, "0"), date.getUTCSeconds().toString().padStart(2, "0")];\n  return buffer.join("");\n}\n\nfunction createPromiseCapability() {\n  const capability = Object.create(null);\n  let isSettled = false;\n  Object.defineProperty(capability, "settled", {\n    get() {\n      return isSettled;\n    }\n\n  });\n  capability.promise = new Promise(function (resolve, reject) {\n    capability.resolve = function (data) {\n      isSettled = true;\n      resolve(data);\n    };\n\n    capability.reject = function (reason) {\n      isSettled = true;\n      reject(reason);\n    };\n  });\n  return capability;\n}\n\nconst createObjectURL = function createObjectURLClosure() {\n  const digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";\n  return function createObjectURL(data, contentType, forceDataSchema = false) {\n    if (!forceDataSchema && URL.createObjectURL) {\n      const blob = new Blob([data], {\n        type: contentType\n      });\n      return URL.createObjectURL(blob);\n    }\n\n    let buffer = `data:${contentType};base64,`;\n\n    for (let i = 0, ii = data.length; i < ii; i += 3) {\n      const b1 = data[i] & 0xff;\n      const b2 = data[i + 1] & 0xff;\n      const b3 = data[i + 2] & 0xff;\n      const d1 = b1 >> 2,\n            d2 = (b1 & 3) << 4 | b2 >> 4;\n      const d3 = i + 1 < ii ? (b2 & 0xf) << 2 | b3 >> 6 : 64;\n      const d4 = i + 2 < ii ? b3 & 0x3f : 64;\n      buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];\n    }\n\n    return buffer;\n  };\n}();\n\nexports.createObjectURL = createObjectURL;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n"use strict";\n\n\nvar _is_node = __w_pdfjs_require__(4);\n\n;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n"use strict";\n\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.isNodeJS = void 0;\nconst isNodeJS = typeof process === "object" && process + "" === "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");\nexports.isNodeJS = isNodeJS;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n"use strict";\n\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.getDocument = getDocument;\nexports.setPDFNetworkStreamFactory = setPDFNetworkStreamFactory;\nexports.build = exports.version = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFWorker = exports.PDFDataRangeTransport = exports.LoopbackPort = void 0;\n\nvar _util = __w_pdfjs_require__(2);\n\nvar _display_utils = __w_pdfjs_require__(1);\n\nvar _font_loader = __w_pdfjs_require__(6);\n\nvar _node_utils = __w_pdfjs_require__(7);\n\nvar _annotation_storage = __w_pdfjs_require__(8);\n\nvar _api_compatibility = __w_pdfjs_require__(9);\n\nvar _canvas = __w_pdfjs_require__(10);\n\nvar _worker_options = __w_pdfjs_require__(12);\n\nvar _is_node = __w_pdfjs_require__(4);\n\nvar _message_handler = __w_pdfjs_require__(13);\n\nvar _metadata = __w_pdfjs_require__(14);\n\nvar _optional_content_config = __w_pdfjs_require__(16);\n\nvar _transport_stream = __w_pdfjs_require__(17);\n\nvar _webgl = __w_pdfjs_require__(18);\n\nconst DEFAULT_RANGE_CHUNK_SIZE = 65536;\nconst RENDERING_CANCELLED_TIMEOUT = 100;\nconst DefaultCanvasFactory = _is_node.isNodeJS ? _node_utils.NodeCanvasFactory : _display_utils.DOMCanvasFactory;\nconst DefaultCMapReaderFactory = _is_node.isNodeJS ? _node_utils.NodeCMapReaderFactory : _display_utils.DOMCMapReaderFactory;\nlet createPDFNetworkStream;\n\nfunction setPDFNetworkStreamFactory(pdfNetworkStreamFactory) {\n  createPDFNetworkStream = pdfNetworkStreamFactory;\n}\n\nfunction getDocument(src) {\n  const task = new PDFDocumentLoadingTask();\n  let source;\n\n  if (typeof src === "string") {\n    source = {\n      url: src\n    };\n  } else if ((0, _util.isArrayBuffer)(src)) {\n    source = {\n      data: src\n    };\n  } else if (src instanceof PDFDataRangeTransport) {\n    source = {\n      range: src\n    };\n  } else {\n    if (typeof src !== "object") {\n      throw new Error("Invalid parameter in getDocument, " + "need either Uint8Array, string or a parameter object");\n    }\n\n    if (!src.url && !src.data && !src.range) {\n      throw new Error("Invalid parameter object: need either .data, .range or .url");\n    }\n\n    source = src;\n  }\n\n  const params = Object.create(null);\n  let rangeTransport = null,\n      worker = null;\n\n  for (const key in source) {\n    if (key === "url" && typeof window !== "undefined") {\n      params[key] = new URL(source[key], window.location).href;\n      continue;\n    } else if (key === "range") {\n      rangeTransport = source[key];\n      continue;\n    } else if (key === "worker") {\n      worker = source[key];\n      continue;\n    } else if (key === "data" && !(source[key] instanceof Uint8Array)) {\n      const pdfBytes = source[key];\n\n      if (typeof pdfBytes === "string") {\n        params[key] = (0, _util.stringToBytes)(pdfBytes);\n      } else if (typeof pdfBytes === "object" && pdfBytes !== null && !isNaN(pdfBytes.length)) {\n        params[key] = new Uint8Array(pdfBytes);\n      } else if ((0, _util.isArrayBuffer)(pdfBytes)) {\n        params[key] = new Uint8Array(pdfBytes);\n      } else {\n        throw new Error("Invalid PDF binary data: either typed array, " + "string or array-like object is expected in the " + "data property.");\n      }\n\n      continue;\n    }\n\n    params[key] = source[key];\n  }\n\n  params.rangeChunkSize = params.rangeChunkSize || DEFAULT_RANGE_CHUNK_SIZE;\n  params.CMapReaderFactory = params.CMapReaderFactory || DefaultCMapReaderFactory;\n  params.ignoreErrors = params.stopAtErrors !== true;\n  params.fontExtraProperties = params.fontExtraProperties === true;\n  params.pdfBug = params.pdfBug === true;\n\n  if (!Number.isInteger(params.maxImageSize)) {\n    params.maxImageSize = -1;\n  }\n\n  if (typeof params.isEvalSupported !== "boolean") {\n    params.isEvalSupported = true;\n  }\n\n  if (typeof params.disableFontFace !== "boolean") {\n    params.disableFontFace = _api_compatibility.apiCompatibilityParams.disableFontFace || false;\n  }\n\n  if (typeof params.ownerDocument === "undefined") {\n    params.ownerDocument = globalThis.document;\n  }\n\n  if (typeof params.disableRange !== "boolean") {\n    params.disableRange = false;\n  }\n\n  if (typeof params.disableStream !== "boolean") {\n    params.disableStream = false;\n  }\n\n  if (typeof params.disableAutoFetch !== "boolean") {\n    params.disableAutoFetch = false;\n  }\n\n  (0, _util.setVerbosityLevel)(params.verbosity);\n\n  if (!worker) {\n    const workerParams = {\n      verbosity: params.verbosity,\n      port: _worker_options.GlobalWorkerOptions.workerPort\n    };\n    worker = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);\n    task._worker = worker;\n  }\n\n  const docId = task.docId;\n  worker.promise.then(function () {\n    if (task.destroyed) {\n      throw new Error("Loading aborted");\n    }\n\n    const workerIdPromise = _fetchDocument(worker, params, rangeTransport, docId);\n\n    const networkStreamPromise = new Promise(function (resolve) {\n      let networkStream;\n\n      if (rangeTransport) {\n        networkStream = new _transport_stream.PDFDataTransportStream({\n          length: params.length,\n          initialData: params.initialData,\n          progressiveDone: params.progressiveDone,\n          disableRange: params.disableRange,\n          disableStream: params.disableStream\n        }, rangeTransport);\n      } else if (!params.data) {\n        networkStream = createPDFNetworkStream({\n          url: params.url,\n          length: params.length,\n          httpHeaders: params.httpHeaders,\n          withCredentials: params.withCredentials,\n          rangeChunkSize: params.rangeChunkSize,\n          disableRange: params.disableRange,\n          disableStream: params.disableStream\n        });\n      }\n\n      resolve(networkStream);\n    });\n    return Promise.all([workerIdPromise, networkStreamPromise]).then(function ([workerId, networkStream]) {\n      if (task.destroyed) {\n        throw new Error("Loading aborted");\n      }\n\n      const messageHandler = new _message_handler.MessageHandler(docId, workerId, worker.port);\n      messageHandler.postMessageTransfers = worker.postMessageTransfers;\n      const transport = new WorkerTransport(messageHandler, task, networkStream, params);\n      task._transport = transport;\n      messageHandler.send("Ready", null);\n    });\n  }).catch(task._capability.reject);\n  return task;\n}\n\nfunction _fetchDocument(worker, source, pdfDataRangeTransport, docId) {\n  if (worker.destroyed) {\n    return Promise.reject(new Error("Worker was destroyed"));\n  }\n\n  if (pdfDataRangeTransport) {\n    source.length = pdfDataRangeTransport.length;\n    source.initialData = pdfDataRangeTransport.initialData;\n    source.progressiveDone = pdfDataRangeTransport.progressiveDone;\n  }\n\n  return worker.messageHandler.sendWithPromise("GetDocRequest", {\n    docId,\n    apiVersion: \'2.6.347\',\n    source: {\n      data: source.data,\n      url: source.url,\n      password: source.password,\n      disableAutoFetch: source.disableAutoFetch,\n      rangeChunkSize: source.rangeChunkSize,\n      length: source.length\n    },\n    maxImageSize: source.maxImageSize,\n    disableFontFace: source.disableFontFace,\n    postMessageTransfers: worker.postMessageTransfers,\n    docBaseUrl: source.docBaseUrl,\n    ignoreErrors: source.ignoreErrors,\n    isEvalSupported: source.isEvalSupported,\n    fontExtraProperties: source.fontExtraProperties\n  }).then(function (workerId) {\n    if (worker.destroyed) {\n      throw new Error("Worker was destroyed");\n    }\n\n    return workerId;\n  });\n}\n\nconst PDFDocumentLoadingTask = function PDFDocumentLoadingTaskClosure() {\n  let nextDocumentId = 0;\n\n  class PDFDocumentLoadingTask {\n    constructor() {\n      this._capability = (0, _util.createPromiseCapability)();\n      this._transport = null;\n      this._worker = null;\n      this.docId = "d" + nextDocumentId++;\n      this.destroyed = false;\n      this.onPassword = null;\n      this.onProgress = null;\n      this.onUnsupportedFeature = null;\n    }\n\n    get promise() {\n      return this._capability.promise;\n    }\n\n    destroy() {\n      this.destroyed = true;\n      const transportDestroyed = !this._transport ? Promise.resolve() : this._transport.destroy();\n      return transportDestroyed.then(() => {\n        this._transport = null;\n\n        if (this._worker) {\n          this._worker.destroy();\n\n          this._worker = null;\n        }\n      });\n    }\n\n  }\n\n  return PDFDocumentLoadingTask;\n}();\n\nclass PDFDataRangeTransport {\n  constructor(length, initialData, progressiveDone = false) {\n    this.length = length;\n    this.initialData = initialData;\n    this.progressiveDone = progressiveDone;\n    this._rangeListeners = [];\n    this._progressListeners = [];\n    this._progressiveReadListeners = [];\n    this._progressiveDoneListeners = [];\n    this._readyCapability = (0, _util.createPromiseCapability)();\n  }\n\n  addRangeListener(listener) {\n    this._rangeListeners.push(listener);\n  }\n\n  addProgressListener(listener) {\n    this._progressListeners.push(listener);\n  }\n\n  addProgressiveReadListener(listener) {\n    this._progressiveReadListeners.push(listener);\n  }\n\n  addProgressiveDoneListener(listener) {\n    this._progressiveDoneListeners.push(listener);\n  }\n\n  onDataRange(begin, chunk) {\n    for (const listener of this._rangeListeners) {\n      listener(begin, chunk);\n    }\n  }\n\n  onDataProgress(loaded, total) {\n    this._readyCapability.promise.then(() => {\n      for (const listener of this._progressListeners) {\n        listener(loaded, total);\n      }\n    });\n  }\n\n  onDataProgressiveRead(chunk) {\n    this._readyCapability.promise.then(() => {\n      for (const listener of this._progressiveReadListeners) {\n        listener(chunk);\n      }\n    });\n  }\n\n  onDataProgressiveDone() {\n    this._readyCapability.promise.then(() => {\n      for (const listener of this._progressiveDoneListeners) {\n        listener();\n      }\n    });\n  }\n\n  transportReady() {\n    this._readyCapability.resolve();\n  }\n\n  requestDataRange(begin, end) {\n    (0, _util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange");\n  }\n\n  abort() {}\n\n}\n\nexports.PDFDataRangeTransport = PDFDataRangeTransport;\n\nclass PDFDocumentProxy {\n  constructor(pdfInfo, transport) {\n    this._pdfInfo = pdfInfo;\n    this._transport = transport;\n  }\n\n  get annotationStorage() {\n    return (0, _util.shadow)(this, "annotationStorage", new _annotation_storage.AnnotationStorage());\n  }\n\n  get numPages() {\n    return this._pdfInfo.numPages;\n  }\n\n  get fingerprint() {\n    return this._pdfInfo.fingerprint;\n  }\n\n  getPage(pageNumber) {\n    return this._transport.getPage(pageNumber);\n  }\n\n  getPageIndex(ref) {\n    return this._transport.getPageIndex(ref);\n  }\n\n  getDestinations() {\n    return this._transport.getDestinations();\n  }\n\n  getDestination(id) {\n    return this._transport.getDestination(id);\n  }\n\n  getPageLabels() {\n    return this._transport.getPageLabels();\n  }\n\n  getPageLayout() {\n    return this._transport.getPageLayout();\n  }\n\n  getPageMode() {\n    return this._transport.getPageMode();\n  }\n\n  getViewerPreferences() {\n    return this._transport.getViewerPreferences();\n  }\n\n  getOpenAction() {\n    return this._transport.getOpenAction();\n  }\n\n  getAttachments() {\n    return this._transport.getAttachments();\n  }\n\n  getJavaScript() {\n    return this._transport.getJavaScript();\n  }\n\n  getOutline() {\n    return this._transport.getOutline();\n  }\n\n  getOptionalContentConfig() {\n    return this._transport.getOptionalContentConfig();\n  }\n\n  getPermissions() {\n    return this._transport.getPermissions();\n  }\n\n  getMetadata() {\n    return this._transport.getMetadata();\n  }\n\n  getData() {\n    return this._transport.getData();\n  }\n\n  getDownloadInfo() {\n    return this._transport.downloadInfoCapability.promise;\n  }\n\n  getStats() {\n    return this._transport.getStats();\n  }\n\n  cleanup() {\n    return this._transport.startCleanup();\n  }\n\n  destroy() {\n    return this.loadingTask.destroy();\n  }\n\n  get loadingParams() {\n    return this._transport.loadingParams;\n  }\n\n  get loadingTask() {\n    return this._transport.loadingTask;\n  }\n\n  saveDocument(annotationStorage) {\n    return this._transport.saveDocument(annotationStorage);\n  }\n\n}\n\nexports.PDFDocumentProxy = PDFDocumentProxy;\n\nclass PDFPageProxy {\n  constructor(pageIndex, pageInfo, transport, ownerDocument, pdfBug = false) {\n    this._pageIndex = pageIndex;\n    this._pageInfo = pageInfo;\n    this._ownerDocument = ownerDocument;\n    this._transport = transport;\n    this._stats = pdfBug ? new _display_utils.StatTimer() : null;\n    this._pdfBug = pdfBug;\n    this.commonObjs = transport.commonObjs;\n    this.objs = new PDFObjects();\n    this.cleanupAfterRender = false;\n    this.pendingCleanup = false;\n    this._intentStates = new Map();\n    this.destroyed = false;\n  }\n\n  get pageNumber() {\n    return this._pageIndex + 1;\n  }\n\n  get rotate() {\n    return this._pageInfo.rotate;\n  }\n\n  get ref() {\n    return this._pageInfo.ref;\n  }\n\n  get userUnit() {\n    return this._pageInfo.userUnit;\n  }\n\n  get view() {\n    return this._pageInfo.view;\n  }\n\n  getViewport({\n    scale,\n    rotation = this.rotate,\n    offsetX = 0,\n    offsetY = 0,\n    dontFlip = false\n  } = {}) {\n    return new _display_utils.PageViewport({\n      viewBox: this.view,\n      scale,\n      rotation,\n      offsetX,\n      offsetY,\n      dontFlip\n    });\n  }\n\n  getAnnotations({\n    intent = null\n  } = {}) {\n    if (!this.annotationsPromise || this.annotationsIntent !== intent) {\n      this.annotationsPromise = this._transport.getAnnotations(this._pageIndex, intent);\n      this.annotationsIntent = intent;\n    }\n\n    return this.annotationsPromise;\n  }\n\n  render({\n    canvasContext,\n    viewport,\n    intent = "display",\n    enableWebGL = false,\n    renderInteractiveForms = false,\n    transform = null,\n    imageLayer = null,\n    canvasFactory = null,\n    background = null,\n    annotationStorage = null,\n    optionalContentConfigPromise = null\n  }) {\n    if (this._stats) {\n      this._stats.time("Overall");\n    }\n\n    const renderingIntent = intent === "print" ? "print" : "display";\n    this.pendingCleanup = false;\n\n    if (!optionalContentConfigPromise) {\n      optionalContentConfigPromise = this._transport.getOptionalContentConfig();\n    }\n\n    let intentState = this._intentStates.get(renderingIntent);\n\n    if (!intentState) {\n      intentState = Object.create(null);\n\n      this._intentStates.set(renderingIntent, intentState);\n    }\n\n    if (intentState.streamReaderCancelTimeout) {\n      clearTimeout(intentState.streamReaderCancelTimeout);\n      intentState.streamReaderCancelTimeout = null;\n    }\n\n    const canvasFactoryInstance = canvasFactory || new DefaultCanvasFactory({\n      ownerDocument: this._ownerDocument\n    });\n    const webGLContext = new _webgl.WebGLContext({\n      enable: enableWebGL\n    });\n\n    if (!intentState.displayReadyCapability) {\n      intentState.displayReadyCapability = (0, _util.createPromiseCapability)();\n      intentState.operatorList = {\n        fnArray: [],\n        argsArray: [],\n        lastChunk: false\n      };\n\n      if (this._stats) {\n        this._stats.time("Page Request");\n      }\n\n      this._pumpOperatorList({\n        pageIndex: this._pageIndex,\n        intent: renderingIntent,\n        renderInteractiveForms: renderInteractiveForms === true,\n        annotationStorage: annotationStorage && annotationStorage.getAll() || null\n      });\n    }\n\n    const complete = error => {\n      const i = intentState.renderTasks.indexOf(internalRenderTask);\n\n      if (i >= 0) {\n        intentState.renderTasks.splice(i, 1);\n      }\n\n      if (this.cleanupAfterRender || renderingIntent === "print") {\n        this.pendingCleanup = true;\n      }\n\n      this._tryCleanup();\n\n      if (error) {\n        internalRenderTask.capability.reject(error);\n\n        this._abortOperatorList({\n          intentState,\n          reason: error\n        });\n      } else {\n        internalRenderTask.capability.resolve();\n      }\n\n      if (this._stats) {\n        this._stats.timeEnd("Rendering");\n\n        this._stats.timeEnd("Overall");\n      }\n    };\n\n    const internalRenderTask = new InternalRenderTask({\n      callback: complete,\n      params: {\n        canvasContext,\n        viewport,\n        transform,\n        imageLayer,\n        background\n      },\n      objs: this.objs,\n      commonObjs: this.commonObjs,\n      operatorList: intentState.operatorList,\n      pageIndex: this._pageIndex,\n      canvasFactory: canvasFactoryInstance,\n      webGLContext,\n      useRequestAnimationFrame: renderingIntent !== "print",\n      pdfBug: this._pdfBug\n    });\n\n    if (!intentState.renderTasks) {\n      intentState.renderTasks = [];\n    }\n\n    intentState.renderTasks.push(internalRenderTask);\n    const renderTask = internalRenderTask.task;\n    Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(([transparency, optionalContentConfig]) => {\n      if (this.pendingCleanup) {\n        complete();\n        return;\n      }\n\n      if (this._stats) {\n        this._stats.time("Rendering");\n      }\n\n      internalRenderTask.initializeGraphics({\n        transparency,\n        optionalContentConfig\n      });\n      internalRenderTask.operatorListChanged();\n    }).catch(complete);\n    return renderTask;\n  }\n\n  getOperatorList() {\n    function operatorListChanged() {\n      if (intentState.operatorList.lastChunk) {\n        intentState.opListReadCapability.resolve(intentState.operatorList);\n        const i = intentState.renderTasks.indexOf(opListTask);\n\n        if (i >= 0) {\n          intentState.renderTasks.splice(i, 1);\n        }\n      }\n    }\n\n    const renderingIntent = "oplist";\n\n    let intentState = this._intentStates.get(renderingIntent);\n\n    if (!intentState) {\n      intentState = Object.create(null);\n\n      this._intentStates.set(renderingIntent, intentState);\n    }\n\n    let opListTask;\n\n    if (!intentState.opListReadCapability) {\n      opListTask = Object.create(null);\n      opListTask.operatorListChanged = operatorListChanged;\n      intentState.opListReadCapability = (0, _util.createPromiseCapability)();\n      intentState.renderTasks = [];\n      intentState.renderTasks.push(opListTask);\n      intentState.operatorList = {\n        fnArray: [],\n        argsArray: [],\n        lastChunk: false\n      };\n\n      if (this._stats) {\n        this._stats.time("Page Request");\n      }\n\n      this._pumpOperatorList({\n        pageIndex: this._pageIndex,\n        intent: renderingIntent\n      });\n    }\n\n    return intentState.opListReadCapability.promise;\n  }\n\n  streamTextContent({\n    normalizeWhitespace = false,\n    disableCombineTextItems = false\n  } = {}) {\n    const TEXT_CONTENT_CHUNK_SIZE = 100;\n    return this._transport.messageHandler.sendWithStream("GetTextContent", {\n      pageIndex: this._pageIndex,\n      normalizeWhitespace: normalizeWhitespace === true,\n      combineTextItems: disableCombineTextItems !== true\n    }, {\n      highWaterMark: TEXT_CONTENT_CHUNK_SIZE,\n\n      size(textContent) {\n        return textContent.items.length;\n      }\n\n    });\n  }\n\n  getTextContent(params = {}) {\n    const readableStream = this.streamTextContent(params);\n    return new Promise(function (resolve, reject) {\n      function pump() {\n        reader.read().then(function ({\n          value,\n          done\n        }) {\n          if (done) {\n            resolve(textContent);\n            return;\n          }\n\n          Object.assign(textContent.styles, value.styles);\n          textContent.items.push(...value.items);\n          pump();\n        }, reject);\n      }\n\n      const reader = readableStream.getReader();\n      const textContent = {\n        items: [],\n        styles: Object.create(null)\n      };\n      pump();\n    });\n  }\n\n  _destroy() {\n    this.destroyed = true;\n    this._transport.pageCache[this._pageIndex] = null;\n    const waitOn = [];\n\n    for (const [intent, intentState] of this._intentStates) {\n      this._abortOperatorList({\n        intentState,\n        reason: new Error("Page was destroyed."),\n        force: true\n      });\n\n      if (intent === "oplist") {\n        continue;\n      }\n\n      for (const internalRenderTask of intentState.renderTasks) {\n        waitOn.push(internalRenderTask.completed);\n        internalRenderTask.cancel();\n      }\n    }\n\n    this.objs.clear();\n    this.annotationsPromise = null;\n    this.pendingCleanup = false;\n    return Promise.all(waitOn);\n  }\n\n  cleanup(resetStats = false) {\n    this.pendingCleanup = true;\n    return this._tryCleanup(resetStats);\n  }\n\n  _tryCleanup(resetStats = false) {\n    if (!this.pendingCleanup) {\n      return false;\n    }\n\n    for (const {\n      renderTasks,\n      operatorList\n    } of this._intentStates.values()) {\n      if (renderTasks.length !== 0 || !operatorList.lastChunk) {\n        return false;\n      }\n    }\n\n    this._intentStates.clear();\n\n    this.objs.clear();\n    this.annotationsPromise = null;\n\n    if (resetStats && this._stats) {\n      this._stats = new _display_utils.StatTimer();\n    }\n\n    this.pendingCleanup = false;\n    return true;\n  }\n\n  _startRenderPage(transparency, intent) {\n    const intentState = this._intentStates.get(intent);\n\n    if (!intentState) {\n      return;\n    }\n\n    if (this._stats) {\n      this._stats.timeEnd("Page Request");\n    }\n\n    if (intentState.displayReadyCapability) {\n      intentState.displayReadyCapability.resolve(transparency);\n    }\n  }\n\n  _renderPageChunk(operatorListChunk, intentState) {\n    for (let i = 0, ii = operatorListChunk.length; i < ii; i++) {\n      intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);\n      intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);\n    }\n\n    intentState.operatorList.lastChunk = operatorListChunk.lastChunk;\n\n    for (let i = 0; i < intentState.renderTasks.length; i++) {\n      intentState.renderTasks[i].operatorListChanged();\n    }\n\n    if (operatorListChunk.lastChunk) {\n      this._tryCleanup();\n    }\n  }\n\n  _pumpOperatorList(args) {\n    (0, _util.assert)(args.intent, \'PDFPageProxy._pumpOperatorList: Expected "intent" argument.\');\n\n    const readableStream = this._transport.messageHandler.sendWithStream("GetOperatorList", args);\n\n    const reader = readableStream.getReader();\n\n    const intentState = this._intentStates.get(args.intent);\n\n    intentState.streamReader = reader;\n\n    const pump = () => {\n      reader.read().then(({\n        value,\n        done\n      }) => {\n        if (done) {\n          intentState.streamReader = null;\n          return;\n        }\n\n        if (this._transport.destroyed) {\n          return;\n        }\n\n        this._renderPageChunk(value, intentState);\n\n        pump();\n      }, reason => {\n        intentState.streamReader = null;\n\n        if (this._transport.destroyed) {\n          return;\n        }\n\n        if (intentState.operatorList) {\n          intentState.operatorList.lastChunk = true;\n\n          for (let i = 0; i < intentState.renderTasks.length; i++) {\n            intentState.renderTasks[i].operatorListChanged();\n          }\n\n          this._tryCleanup();\n        }\n\n        if (intentState.displayReadyCapability) {\n          intentState.displayReadyCapability.reject(reason);\n        } else if (intentState.opListReadCapability) {\n          intentState.opListReadCapability.reject(reason);\n        } else {\n          throw reason;\n        }\n      });\n    };\n\n    pump();\n  }\n\n  _abortOperatorList({\n    intentState,\n    reason,\n    force = false\n  }) {\n    (0, _util.assert)(reason instanceof Error || typeof reason === "object" && reason !== null, \'PDFPageProxy._abortOperatorList: Expected "reason" argument.\');\n\n    if (!intentState.streamReader) {\n      return;\n    }\n\n    if (!force) {\n      if (intentState.renderTasks.length !== 0) {\n        return;\n      }\n\n      if (reason instanceof _display_utils.RenderingCancelledException) {\n        intentState.streamReaderCancelTimeout = setTimeout(() => {\n          this._abortOperatorList({\n            intentState,\n            reason,\n            force: true\n          });\n\n          intentState.streamReaderCancelTimeout = null;\n        }, RENDERING_CANCELLED_TIMEOUT);\n        return;\n      }\n    }\n\n    intentState.streamReader.cancel(new _util.AbortException(reason && reason.message));\n    intentState.streamReader = null;\n\n    if (this._transport.destroyed) {\n      return;\n    }\n\n    for (const [intent, curIntentState] of this._intentStates) {\n      if (curIntentState === intentState) {\n        this._intentStates.delete(intent);\n\n        break;\n      }\n    }\n\n    this.cleanup();\n  }\n\n  get stats() {\n    return this._stats;\n  }\n\n}\n\nexports.PDFPageProxy = PDFPageProxy;\n\nclass LoopbackPort {\n  constructor(defer = true) {\n    this._listeners = [];\n    this._defer = defer;\n    this._deferred = Promise.resolve(undefined);\n  }\n\n  postMessage(obj, transfers) {\n    function cloneValue(value) {\n      if (typeof value !== "object" || value === null) {\n        return value;\n      }\n\n      if (cloned.has(value)) {\n        return cloned.get(value);\n      }\n\n      let buffer, result;\n\n      if ((buffer = value.buffer) && (0, _util.isArrayBuffer)(buffer)) {\n        const transferable = transfers && transfers.includes(buffer);\n\n        if (transferable) {\n          result = new value.constructor(buffer, value.byteOffset, value.byteLength);\n        } else {\n          result = new value.constructor(value);\n        }\n\n        cloned.set(value, result);\n        return result;\n      }\n\n      result = Array.isArray(value) ? [] : {};\n      cloned.set(value, result);\n\n      for (const i in value) {\n        let desc,\n            p = value;\n\n        while (!(desc = Object.getOwnPropertyDescriptor(p, i))) {\n          p = Object.getPrototypeOf(p);\n        }\n\n        if (typeof desc.value === "undefined") {\n          continue;\n        }\n\n        if (typeof desc.value === "function") {\n          if (value.hasOwnProperty && value.hasOwnProperty(i)) {\n            throw new Error(`LoopbackPort.postMessage - cannot clone: ${value[i]}`);\n          }\n\n          continue;\n        }\n\n        result[i] = cloneValue(desc.value);\n      }\n\n      return result;\n    }\n\n    if (!this._defer) {\n      this._listeners.forEach(listener => {\n        listener.call(this, {\n          data: obj\n        });\n      });\n\n      return;\n    }\n\n    const cloned = new WeakMap();\n    const e = {\n      data: cloneValue(obj)\n    };\n\n    this._deferred.then(() => {\n      this._listeners.forEach(listener => {\n        listener.call(this, e);\n      });\n    });\n  }\n\n  addEventListener(name, listener) {\n    this._listeners.push(listener);\n  }\n\n  removeEventListener(name, listener) {\n    const i = this._listeners.indexOf(listener);\n\n    this._listeners.splice(i, 1);\n  }\n\n  terminate() {\n    this._listeners.length = 0;\n  }\n\n}\n\nexports.LoopbackPort = LoopbackPort;\n\nconst PDFWorker = function PDFWorkerClosure() {\n  const pdfWorkerPorts = new WeakMap();\n  let isWorkerDisabled = false;\n  let fallbackWorkerSrc;\n  let nextFakeWorkerId = 0;\n  let fakeWorkerCapability;\n\n  if (_is_node.isNodeJS && "function" === "function") {\n    isWorkerDisabled = true;\n    fallbackWorkerSrc = "./pdf.worker.js";\n  } else if (typeof document === "object" && "currentScript" in document) {\n    const pdfjsFilePath = document.currentScript && document.currentScript.src;\n\n    if (pdfjsFilePath) {\n      fallbackWorkerSrc = pdfjsFilePath.replace(/(\\.(?:min\\.)?js)(\\?.*)?$/i, ".worker$1$2");\n    }\n  }\n\n  function getWorkerSrc() {\n    if (_worker_options.GlobalWorkerOptions.workerSrc) {\n      return _worker_options.GlobalWorkerOptions.workerSrc;\n    }\n\n    if (typeof fallbackWorkerSrc !== "undefined") {\n      if (!_is_node.isNodeJS) {\n        (0, _display_utils.deprecated)(\'No "GlobalWorkerOptions.workerSrc" specified.\');\n      }\n\n      return fallbackWorkerSrc;\n    }\n\n    throw new Error(\'No "GlobalWorkerOptions.workerSrc" specified.\');\n  }\n\n  function getMainThreadWorkerMessageHandler() {\n    let mainWorkerMessageHandler;\n\n    try {\n      mainWorkerMessageHandler = globalThis.pdfjsWorker && globalThis.pdfjsWorker.WorkerMessageHandler;\n    } catch (ex) {}\n\n    return mainWorkerMessageHandler || null;\n  }\n\n  function setupFakeWorkerGlobal() {\n    if (fakeWorkerCapability) {\n      return fakeWorkerCapability.promise;\n    }\n\n    fakeWorkerCapability = (0, _util.createPromiseCapability)();\n\n    const loader = async function () {\n      const mainWorkerMessageHandler = getMainThreadWorkerMessageHandler();\n\n      if (mainWorkerMessageHandler) {\n        return mainWorkerMessageHandler;\n      }\n\n      if (_is_node.isNodeJS && "function" === "function") {\n        const worker = eval("require")(getWorkerSrc());\n        return worker.WorkerMessageHandler;\n      }\n\n      await (0, _display_utils.loadScript)(getWorkerSrc());\n      return window.pdfjsWorker.WorkerMessageHandler;\n    };\n\n    loader().then(fakeWorkerCapability.resolve, fakeWorkerCapability.reject);\n    return fakeWorkerCapability.promise;\n  }\n\n  function createCDNWrapper(url) {\n    const wrapper = "importScripts(\'" + url + "\');";\n    return URL.createObjectURL(new Blob([wrapper]));\n  }\n\n  class PDFWorker {\n    constructor({\n      name = null,\n      port = null,\n      verbosity = (0, _util.getVerbosityLevel)()\n    } = {}) {\n      if (port && pdfWorkerPorts.has(port)) {\n        throw new Error("Cannot use more than one PDFWorker per port");\n      }\n\n      this.name = name;\n      this.destroyed = false;\n      this.postMessageTransfers = true;\n      this.verbosity = verbosity;\n      this._readyCapability = (0, _util.createPromiseCapability)();\n      this._port = null;\n      this._webWorker = null;\n      this._messageHandler = null;\n\n      if (port) {\n        pdfWorkerPorts.set(port, this);\n\n        this._initializeFromPort(port);\n\n        return;\n      }\n\n      this._initialize();\n    }\n\n    get promise() {\n      return this._readyCapability.promise;\n    }\n\n    get port() {\n      return this._port;\n    }\n\n    get messageHandler() {\n      return this._messageHandler;\n    }\n\n    _initializeFromPort(port) {\n      this._port = port;\n      this._messageHandler = new _message_handler.MessageHandler("main", "worker", port);\n\n      this._messageHandler.on("ready", function () {});\n\n      this._readyCapability.resolve();\n    }\n\n    _initialize() {\n      if (typeof Worker !== "undefined" && !isWorkerDisabled && !getMainThreadWorkerMessageHandler()) {\n        let workerSrc = getWorkerSrc();\n\n        try {\n          if (!(0, _util.isSameOrigin)(window.location.href, workerSrc)) {\n            workerSrc = createCDNWrapper(new URL(workerSrc, window.location).href);\n          }\n\n          const worker = new Worker(workerSrc);\n          const messageHandler = new _message_handler.MessageHandler("main", "worker", worker);\n\n          const terminateEarly = () => {\n            worker.removeEventListener("error", onWorkerError);\n            messageHandler.destroy();\n            worker.terminate();\n\n            if (this.destroyed) {\n              this._readyCapability.reject(new Error("Worker was destroyed"));\n            } else {\n              this._setupFakeWorker();\n            }\n          };\n\n          const onWorkerError = () => {\n            if (!this._webWorker) {\n              terminateEarly();\n            }\n          };\n\n          worker.addEventListener("error", onWorkerError);\n          messageHandler.on("test", data => {\n            worker.removeEventListener("error", onWorkerError);\n\n            if (this.destroyed) {\n              terminateEarly();\n              return;\n            }\n\n            if (data) {\n              this._messageHandler = messageHandler;\n              this._port = worker;\n              this._webWorker = worker;\n\n              if (!data.supportTransfers) {\n                this.postMessageTransfers = false;\n              }\n\n              this._readyCapability.resolve();\n\n              messageHandler.send("configure", {\n                verbosity: this.verbosity\n              });\n            } else {\n              this._setupFakeWorker();\n\n              messageHandler.destroy();\n              worker.terminate();\n            }\n          });\n          messageHandler.on("ready", data => {\n            worker.removeEventListener("error", onWorkerError);\n\n            if (this.destroyed) {\n              terminateEarly();\n              return;\n            }\n\n            try {\n              sendTest();\n            } catch (e) {\n              this._setupFakeWorker();\n            }\n          });\n\n          const sendTest = () => {\n            const testObj = new Uint8Array([this.postMessageTransfers ? 255 : 0]);\n\n            try {\n              messageHandler.send("test", testObj, [testObj.buffer]);\n            } catch (ex) {\n              (0, _util.warn)("Cannot use postMessage transfers.");\n              testObj[0] = 0;\n              messageHandler.send("test", testObj);\n            }\n          };\n\n          sendTest();\n          return;\n        } catch (e) {\n          (0, _util.info)("The worker has been disabled.");\n        }\n      }\n\n      this._setupFakeWorker();\n    }\n\n    _setupFakeWorker() {\n      if (!isWorkerDisabled) {\n        (0, _util.warn)("Setting up fake worker.");\n        isWorkerDisabled = true;\n      }\n\n      setupFakeWorkerGlobal().then(WorkerMessageHandler => {\n        if (this.destroyed) {\n          this._readyCapability.reject(new Error("Worker was destroyed"));\n\n          return;\n        }\n\n        const port = new LoopbackPort();\n        this._port = port;\n        const id = "fake" + nextFakeWorkerId++;\n        const workerHandler = new _message_handler.MessageHandler(id + "_worker", id, port);\n        WorkerMessageHandler.setup(workerHandler, port);\n        const messageHandler = new _message_handler.MessageHandler(id, id + "_worker", port);\n        this._messageHandler = messageHandler;\n\n        this._readyCapability.resolve();\n\n        messageHandler.send("configure", {\n          verbosity: this.verbosity\n        });\n      }).catch(reason => {\n        this._readyCapability.reject(new Error(`Setting up fake worker failed: "${reason.message}".`));\n      });\n    }\n\n    destroy() {\n      this.destroyed = true;\n\n      if (this._webWorker) {\n        this._webWorker.terminate();\n\n        this._webWorker = null;\n      }\n\n      pdfWorkerPorts.delete(this._port);\n      this._port = null;\n\n      if (this._messageHandler) {\n        this._messageHandler.destroy();\n\n        this._messageHandler = null;\n      }\n    }\n\n    static fromPort(params) {\n      if (!params || !params.port) {\n        throw new Error("PDFWorker.fromPort - invalid method signature.");\n      }\n\n      if (pdfWorkerPorts.has(params.port)) {\n        return pdfWorkerPorts.get(params.port);\n      }\n\n      return new PDFWorker(params);\n    }\n\n    static getWorkerSrc() {\n      return getWorkerSrc();\n    }\n\n  }\n\n  return PDFWorker;\n}();\n\nexports.PDFWorker = PDFWorker;\n\nclass WorkerTransport {\n  constructor(messageHandler, loadingTask, networkStream, params) {\n    this.messageHandler = messageHandler;\n    this.loadingTask = loadingTask;\n    this.commonObjs = new PDFObjects();\n    this.fontLoader = new _font_loader.FontLoader({\n      docId: loadingTask.docId,\n      onUnsupportedFeature: this._onUnsupportedFeature.bind(this),\n      ownerDocument: params.ownerDocument\n    });\n    this._params = params;\n    this.CMapReaderFactory = new params.CMapReaderFactory({\n      baseUrl: params.cMapUrl,\n      isCompressed: params.cMapPacked\n    });\n    this.destroyed = false;\n    this.destroyCapability = null;\n    this._passwordCapability = null;\n    this._networkStream = networkStream;\n    this._fullReader = null;\n    this._lastProgress = null;\n    this.pageCache = [];\n    this.pagePromises = [];\n    this.downloadInfoCapability = (0, _util.createPromiseCapability)();\n    this.setupMessageHandler();\n  }\n\n  destroy() {\n    if (this.destroyCapability) {\n      return this.destroyCapability.promise;\n    }\n\n    this.destroyed = true;\n    this.destroyCapability = (0, _util.createPromiseCapability)();\n\n    if (this._passwordCapability) {\n      this._passwordCapability.reject(new Error("Worker was destroyed during onPassword callback"));\n    }\n\n    const waitOn = [];\n    this.pageCache.forEach(function (page) {\n      if (page) {\n        waitOn.push(page._destroy());\n      }\n    });\n    this.pageCache.length = 0;\n    this.pagePromises.length = 0;\n    const terminated = this.messageHandler.sendWithPromise("Terminate", null);\n    waitOn.push(terminated);\n    Promise.all(waitOn).then(() => {\n      this.fontLoader.clear();\n\n      if (this._networkStream) {\n        this._networkStream.cancelAllRequests(new _util.AbortException("Worker was terminated."));\n      }\n\n      if (this.messageHandler) {\n        this.messageHandler.destroy();\n        this.messageHandler = null;\n      }\n\n      this.destroyCapability.resolve();\n    }, this.destroyCapability.reject);\n    return this.destroyCapability.promise;\n  }\n\n  setupMessageHandler() {\n    const {\n      messageHandler,\n      loadingTask\n    } = this;\n    messageHandler.on("GetReader", (data, sink) => {\n      (0, _util.assert)(this._networkStream, "GetReader - no `IPDFStream` instance available.");\n      this._fullReader = this._networkStream.getFullReader();\n\n      this._fullReader.onProgress = evt => {\n        this._lastProgress = {\n          loaded: evt.loaded,\n          total: evt.total\n        };\n      };\n\n      sink.onPull = () => {\n        this._fullReader.read().then(function ({\n          value,\n          done\n        }) {\n          if (done) {\n            sink.close();\n            return;\n          }\n\n          (0, _util.assert)((0, _util.isArrayBuffer)(value), "GetReader - expected an ArrayBuffer.");\n          sink.enqueue(new Uint8Array(value), 1, [value]);\n        }).catch(reason => {\n          sink.error(reason);\n        });\n      };\n\n      sink.onCancel = reason => {\n        this._fullReader.cancel(reason);\n\n        sink.ready.catch(readyReason => {\n          if (this.destroyed) {\n            return;\n          }\n\n          throw readyReason;\n        });\n      };\n    });\n    messageHandler.on("ReaderHeadersReady", data => {\n      const headersCapability = (0, _util.createPromiseCapability)();\n      const fullReader = this._fullReader;\n      fullReader.headersReady.then(() => {\n        if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {\n          if (this._lastProgress && loadingTask.onProgress) {\n            loadingTask.onProgress(this._lastProgress);\n          }\n\n          fullReader.onProgress = evt => {\n            if (loadingTask.onProgress) {\n              loadingTask.onProgress({\n                loaded: evt.loaded,\n                total: evt.total\n              });\n            }\n          };\n        }\n\n        headersCapability.resolve({\n          isStreamingSupported: fullReader.isStreamingSupported,\n          isRangeSupported: fullReader.isRangeSupported,\n          contentLength: fullReader.contentLength\n        });\n      }, headersCapability.reject);\n      return headersCapability.promise;\n    });\n    messageHandler.on("GetRangeReader", (data, sink) => {\n      (0, _util.assert)(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");\n\n      const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);\n\n      if (!rangeReader) {\n        sink.close();\n        return;\n      }\n\n      sink.onPull = () => {\n        rangeReader.read().then(function ({\n          value,\n          done\n        }) {\n          if (done) {\n            sink.close();\n            return;\n          }\n\n          (0, _util.assert)((0, _util.isArrayBuffer)(value), "GetRangeReader - expected an ArrayBuffer.");\n          sink.enqueue(new Uint8Array(value), 1, [value]);\n        }).catch(reason => {\n          sink.error(reason);\n        });\n      };\n\n      sink.onCancel = reason => {\n        rangeReader.cancel(reason);\n        sink.ready.catch(readyReason => {\n          if (this.destroyed) {\n            return;\n          }\n\n          throw readyReason;\n        });\n      };\n    });\n    messageHandler.on("GetDoc", ({\n      pdfInfo\n    }) => {\n      this._numPages = pdfInfo.numPages;\n\n      loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));\n    });\n    messageHandler.on("DocException", function (ex) {\n      let reason;\n\n      switch (ex.name) {\n        case "PasswordException":\n          reason = new _util.PasswordException(ex.message, ex.code);\n          break;\n\n        case "InvalidPDFException":\n          reason = new _util.InvalidPDFException(ex.message);\n          break;\n\n        case "MissingPDFException":\n          reason = new _util.MissingPDFException(ex.message);\n          break;\n\n        case "UnexpectedResponseException":\n          reason = new _util.UnexpectedResponseException(ex.message, ex.status);\n          break;\n\n        case "UnknownErrorException":\n          reason = new _util.UnknownErrorException(ex.message, ex.details);\n          break;\n      }\n\n      if (!(reason instanceof Error)) {\n        const msg = "DocException - expected a valid Error.";\n        (0, _util.warn)(msg);\n      }\n\n      loadingTask._capability.reject(reason);\n    });\n    messageHandler.on("PasswordRequest", exception => {\n      this._passwordCapability = (0, _util.createPromiseCapability)();\n\n      if (loadingTask.onPassword) {\n        const updatePassword = password => {\n          this._passwordCapability.resolve({\n            password\n          });\n        };\n\n        try {\n          loadingTask.onPassword(updatePassword, exception.code);\n        } catch (ex) {\n          this._passwordCapability.reject(ex);\n        }\n      } else {\n        this._passwordCapability.reject(new _util.PasswordException(exception.message, exception.code));\n      }\n\n      return this._passwordCapability.promise;\n    });\n    messageHandler.on("DataLoaded", data => {\n      if (loadingTask.onProgress) {\n        loadingTask.onProgress({\n          loaded: data.length,\n          total: data.length\n        });\n      }\n\n      this.downloadInfoCapability.resolve(data);\n    });\n    messageHandler.on("StartRenderPage", data => {\n      if (this.destroyed) {\n        return;\n      }\n\n      const page = this.pageCache[data.pageIndex];\n\n      page._startRenderPage(data.transparency, data.intent);\n    });\n    messageHandler.on("commonobj", data => {\n      if (this.destroyed) {\n        return;\n      }\n\n      const [id, type, exportedData] = data;\n\n      if (this.commonObjs.has(id)) {\n        return;\n      }\n\n      switch (type) {\n        case "Font":\n          const params = this._params;\n\n          if ("error" in exportedData) {\n            const exportedError = exportedData.error;\n            (0, _util.warn)(`Error during font loading: ${exportedError}`);\n            this.commonObjs.resolve(id, exportedError);\n            break;\n          }\n\n          let fontRegistry = null;\n\n          if (params.pdfBug && globalThis.FontInspector && globalThis.FontInspector.enabled) {\n            fontRegistry = {\n              registerFont(font, url) {\n                globalThis.FontInspector.fontAdded(font, url);\n              }\n\n            };\n          }\n\n          const font = new _font_loader.FontFaceObject(exportedData, {\n            isEvalSupported: params.isEvalSupported,\n            disableFontFace: params.disableFontFace,\n            ignoreErrors: params.ignoreErrors,\n            onUnsupportedFeature: this._onUnsupportedFeature.bind(this),\n            fontRegistry\n          });\n          this.fontLoader.bind(font).catch(reason => {\n            return messageHandler.sendWithPromise("FontFallback", {\n              id\n            });\n          }).finally(() => {\n            if (!params.fontExtraProperties && font.data) {\n              font.data = null;\n            }\n\n            this.commonObjs.resolve(id, font);\n          });\n          break;\n\n        case "FontPath":\n        case "Image":\n          this.commonObjs.resolve(id, exportedData);\n          break;\n\n        default:\n          throw new Error(`Got unknown common object type ${type}`);\n      }\n    });\n    messageHandler.on("obj", data => {\n      if (this.destroyed) {\n        return undefined;\n      }\n\n      const [id, pageIndex, type, imageData] = data;\n      const pageProxy = this.pageCache[pageIndex];\n\n      if (pageProxy.objs.has(id)) {\n        return undefined;\n      }\n\n      switch (type) {\n        case "Image":\n          pageProxy.objs.resolve(id, imageData);\n          const MAX_IMAGE_SIZE_TO_STORE = 8000000;\n\n          if (imageData && "data" in imageData && imageData.data.length > MAX_IMAGE_SIZE_TO_STORE) {\n            pageProxy.cleanupAfterRender = true;\n          }\n\n          break;\n\n        default:\n          throw new Error(`Got unknown object type ${type}`);\n      }\n\n      return undefined;\n    });\n    messageHandler.on("DocProgress", data => {\n      if (this.destroyed) {\n        return;\n      }\n\n      if (loadingTask.onProgress) {\n        loadingTask.onProgress({\n          loaded: data.loaded,\n          total: data.total\n        });\n      }\n    });\n    messageHandler.on("UnsupportedFeature", this._onUnsupportedFeature.bind(this));\n    messageHandler.on("FetchBuiltInCMap", (data, sink) => {\n      if (this.destroyed) {\n        sink.error(new Error("Worker was destroyed"));\n        return;\n      }\n\n      let fetched = false;\n\n      sink.onPull = () => {\n        if (fetched) {\n          sink.close();\n          return;\n        }\n\n        fetched = true;\n        this.CMapReaderFactory.fetch(data).then(function (builtInCMap) {\n          sink.enqueue(builtInCMap, 1, [builtInCMap.cMapData.buffer]);\n        }).catch(function (reason) {\n          sink.error(reason);\n        });\n      };\n    });\n  }\n\n  _onUnsupportedFeature({\n    featureId\n  }) {\n    if (this.destroyed) {\n      return;\n    }\n\n    if (this.loadingTask.onUnsupportedFeature) {\n      this.loadingTask.onUnsupportedFeature(featureId);\n    }\n  }\n\n  getData() {\n    return this.messageHandler.sendWithPromise("GetData", null);\n  }\n\n  getPage(pageNumber) {\n    if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {\n      return Promise.reject(new Error("Invalid page request"));\n    }\n\n    const pageIndex = pageNumber - 1;\n\n    if (pageIndex in this.pagePromises) {\n      return this.pagePromises[pageIndex];\n    }\n\n    const promise = this.messageHandler.sendWithPromise("GetPage", {\n      pageIndex\n    }).then(pageInfo => {\n      if (this.destroyed) {\n        throw new Error("Transport destroyed");\n      }\n\n      const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.ownerDocument, this._params.pdfBug);\n      this.pageCache[pageIndex] = page;\n      return page;\n    });\n    this.pagePromises[pageIndex] = promise;\n    return promise;\n  }\n\n  getPageIndex(ref) {\n    return this.messageHandler.sendWithPromise("GetPageIndex", {\n      ref\n    }).catch(function (reason) {\n      return Promise.reject(new Error(reason));\n    });\n  }\n\n  getAnnotations(pageIndex, intent) {\n    return this.messageHandler.sendWithPromise("GetAnnotations", {\n      pageIndex,\n      intent\n    });\n  }\n\n  saveDocument(annotationStorage) {\n    return this.messageHandler.sendWithPromise("SaveDocument", {\n      numPages: this._numPages,\n      annotationStorage: annotationStorage && annotationStorage.getAll() || null,\n      filename: this._fullReader ? this._fullReader.filename : null\n    }).finally(() => {\n      if (annotationStorage) {\n        annotationStorage.resetModified();\n      }\n    });\n  }\n\n  getDestinations() {\n    return this.messageHandler.sendWithPromise("GetDestinations", null);\n  }\n\n  getDestination(id) {\n    if (typeof id !== "string") {\n      return Promise.reject(new Error("Invalid destination request."));\n    }\n\n    return this.messageHandler.sendWithPromise("GetDestination", {\n      id\n    });\n  }\n\n  getPageLabels() {\n    return this.messageHandler.sendWithPromise("GetPageLabels", null);\n  }\n\n  getPageLayout() {\n    return this.messageHandler.sendWithPromise("GetPageLayout", null);\n  }\n\n  getPageMode() {\n    return this.messageHandler.sendWithPromise("GetPageMode", null);\n  }\n\n  getViewerPreferences() {\n    return this.messageHandler.sendWithPromise("GetViewerPreferences", null);\n  }\n\n  getOpenAction() {\n    return this.messageHandler.sendWithPromise("GetOpenAction", null);\n  }\n\n  getAttachments() {\n    return this.messageHandler.sendWithPromise("GetAttachments", null);\n  }\n\n  getJavaScript() {\n    return this.messageHandler.sendWithPromise("GetJavaScript", null);\n  }\n\n  getOutline() {\n    return this.messageHandler.sendWithPromise("GetOutline", null);\n  }\n\n  getOptionalContentConfig() {\n    return this.messageHandler.sendWithPromise("GetOptionalContentConfig", null).then(results => {\n      return new _optional_content_config.OptionalContentConfig(results);\n    });\n  }\n\n  getPermissions() {\n    return this.messageHandler.sendWithPromise("GetPermissions", null);\n  }\n\n  getMetadata() {\n    return this.messageHandler.sendWithPromise("GetMetadata", null).then(results => {\n      return {\n        info: results[0],\n        metadata: results[1] ? new _metadata.Metadata(results[1]) : null,\n        contentDispositionFilename: this._fullReader ? this._fullReader.filename : null\n      };\n    });\n  }\n\n  getStats() {\n    return this.messageHandler.sendWithPromise("GetStats", null);\n  }\n\n  startCleanup() {\n    return this.messageHandler.sendWithPromise("Cleanup", null).then(() => {\n      for (let i = 0, ii = this.pageCache.length; i < ii; i++) {\n        const page = this.pageCache[i];\n\n        if (page) {\n          const cleanupSuccessful = page.cleanup();\n\n          if (!cleanupSuccessful) {\n            throw new Error(`startCleanup: Page ${i + 1} is currently rendering.`);\n          }\n        }\n      }\n\n      this.commonObjs.clear();\n      this.fontLoader.clear();\n    });\n  }\n\n  get loadingParams() {\n    const params = this._params;\n    return (0, _util.shadow)(this, "loadingParams", {\n      disableAutoFetch: params.disableAutoFetch,\n      disableFontFace: params.disableFontFace\n    });\n  }\n\n}\n\nclass PDFObjects {\n  constructor() {\n    this._objs = Object.create(null);\n  }\n\n  _ensureObj(objId) {\n    if (this._objs[objId]) {\n      return this._objs[objId];\n    }\n\n    return this._objs[objId] = {\n      capability: (0, _util.createPromiseCapability)(),\n      data: null,\n      resolved: false\n    };\n  }\n\n  get(objId, callback = null) {\n    if (callback) {\n      this._ensureObj(objId).capability.promise.then(callback);\n\n      return null;\n    }\n\n    const obj = this._objs[objId];\n\n    if (!obj || !obj.resolved) {\n      throw new Error(`Requesting object that isn\'t resolved yet ${objId}.`);\n    }\n\n    return obj.data;\n  }\n\n  has(objId) {\n    const obj = this._objs[objId];\n    return obj ? obj.resolved : false;\n  }\n\n  resolve(objId, data) {\n    const obj = this._ensureObj(objId);\n\n    obj.resolved = true;\n    obj.data = data;\n    obj.capability.resolve(data);\n  }\n\n  clear() {\n    this._objs = Object.create(null);\n  }\n\n}\n\nclass RenderTask {\n  constructor(internalRenderTask) {\n    this._internalRenderTask = internalRenderTask;\n    this.onContinue = null;\n  }\n\n  get promise() {\n    return this._internalRenderTask.capability.promise;\n  }\n\n  cancel() {\n    this._internalRenderTask.cancel();\n  }\n\n}\n\nconst InternalRenderTask = function InternalRenderTaskClosure() {\n  const canvasInRendering = new WeakSet();\n\n  class InternalRenderTask {\n    constructor({\n      callback,\n      params,\n      objs,\n      commonObjs,\n      operatorList,\n      pageIndex,\n      canvasFactory,\n      webGLContext,\n      useRequestAnimationFrame = false,\n      pdfBug = false\n    }) {\n      this.callback = callback;\n      this.params = params;\n      this.objs = objs;\n      this.commonObjs = commonObjs;\n      this.operatorListIdx = null;\n      this.operatorList = operatorList;\n      this._pageIndex = pageIndex;\n      this.canvasFactory = canvasFactory;\n      this.webGLContext = webGLContext;\n      this._pdfBug = pdfBug;\n      this.running = false;\n      this.graphicsReadyCallback = null;\n      this.graphicsReady = false;\n      this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== "undefined";\n      this.cancelled = false;\n      this.capability = (0, _util.createPromiseCapability)();\n      this.task = new RenderTask(this);\n      this._continueBound = this._continue.bind(this);\n      this._scheduleNextBound = this._scheduleNext.bind(this);\n      this._nextBound = this._next.bind(this);\n      this._canvas = params.canvasContext.canvas;\n    }\n\n    get completed() {\n      return this.capability.promise.catch(function () {});\n    }\n\n    initializeGraphics({\n      transparency = false,\n      optionalContentConfig\n    }) {\n      if (this.cancelled) {\n        return;\n      }\n\n      if (this._canvas) {\n        if (canvasInRendering.has(this._canvas)) {\n          throw new Error("Cannot use the same canvas during multiple render() operations. " + "Use different canvas or ensure previous operations were " + "cancelled or completed.");\n        }\n\n        canvasInRendering.add(this._canvas);\n      }\n\n      if (this._pdfBug && globalThis.StepperManager && globalThis.StepperManager.enabled) {\n        this.stepper = globalThis.StepperManager.create(this._pageIndex);\n        this.stepper.init(this.operatorList);\n        this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();\n      }\n\n      const {\n        canvasContext,\n        viewport,\n        transform,\n        imageLayer,\n        background\n      } = this.params;\n      this.gfx = new _canvas.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.webGLContext, imageLayer, optionalContentConfig);\n      this.gfx.beginDrawing({\n        transform,\n        viewport,\n        transparency,\n        background\n      });\n      this.operatorListIdx = 0;\n      this.graphicsReady = true;\n\n      if (this.graphicsReadyCallback) {\n        this.graphicsReadyCallback();\n      }\n    }\n\n    cancel(error = null) {\n      this.running = false;\n      this.cancelled = true;\n\n      if (this.gfx) {\n        this.gfx.endDrawing();\n      }\n\n      if (this._canvas) {\n        canvasInRendering.delete(this._canvas);\n      }\n\n      this.callback(error || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, "canvas"));\n    }\n\n    operatorListChanged() {\n      if (!this.graphicsReady) {\n        if (!this.graphicsReadyCallback) {\n          this.graphicsReadyCallback = this._continueBound;\n        }\n\n        return;\n      }\n\n      if (this.stepper) {\n        this.stepper.updateOperatorList(this.operatorList);\n      }\n\n      if (this.running) {\n        return;\n      }\n\n      this._continue();\n    }\n\n    _continue() {\n      this.running = true;\n\n      if (this.cancelled) {\n        return;\n      }\n\n      if (this.task.onContinue) {\n        this.task.onContinue(this._scheduleNextBound);\n      } else {\n        this._scheduleNext();\n      }\n    }\n\n    _scheduleNext() {\n      if (this._useRequestAnimationFrame) {\n        window.requestAnimationFrame(() => {\n          this._nextBound().catch(this.cancel.bind(this));\n        });\n      } else {\n        Promise.resolve().then(this._nextBound).catch(this.cancel.bind(this));\n      }\n    }\n\n    async _next() {\n      if (this.cancelled) {\n        return;\n      }\n\n      this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);\n\n      if (this.operatorListIdx === this.operatorList.argsArray.length) {\n        this.running = false;\n\n        if (this.operatorList.lastChunk) {\n          this.gfx.endDrawing();\n\n          if (this._canvas) {\n            canvasInRendering.delete(this._canvas);\n          }\n\n          this.callback();\n        }\n      }\n    }\n\n  }\n\n  return InternalRenderTask;\n}();\n\nconst version = \'2.6.347\';\nexports.version = version;\nconst build = \'3be9c65f\';\nexports.build = build;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n"use strict";\n\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.FontLoader = exports.FontFaceObject = void 0;\n\nvar _util = __w_pdfjs_require__(2);\n\nclass BaseFontLoader {\n  constructor({\n    docId,\n    onUnsupportedFeature,\n    ownerDocument = globalThis.document\n  }) {\n    if (this.constructor === BaseFontLoader) {\n      (0, _util.unreachable)("Cannot initialize BaseFontLoader.");\n    }\n\n    this.docId = docId;\n    this._onUnsupportedFeature = onUnsupportedFeature;\n    this._document = ownerDocument;\n    this.nativeFontFaces = [];\n    this.styleElement = null;\n  }\n\n  addNativeFontFace(nativeFontFace) {\n    this.nativeFontFaces.push(nativeFontFace);\n\n    this._document.fonts.add(nativeFontFace);\n  }\n\n  insertRule(rule) {\n    let styleElement = this.styleElement;\n\n    if (!styleElement) {\n      styleElement = this.styleElement = this._document.createElement("style");\n      styleElement.id = `PDFJS_FONT_STYLE_TAG_${this.docId}`;\n\n      this._document.documentElement.getElementsByTagName("head")[0].appendChild(styleElement);\n    }\n\n    const styleSheet = styleElement.sheet;\n    styleSheet.insertRule(rule, styleSheet.cssRules.length);\n  }\n\n  clear() {\n    this.nativeFontFaces.forEach(nativeFontFace => {\n      this._document.fonts.delete(nativeFontFace);\n    });\n    this.nativeFontFaces.length = 0;\n\n    if (this.styleElement) {\n      this.styleElement.remove();\n      this.styleElement = null;\n    }\n  }\n\n  async bind(font) {\n    if (font.attached || font.missingFile) {\n      return;\n    }\n\n    font.attached = true;\n\n    if (this.isFontLoadingAPISupported) {\n      const nativeFontFace = font.createNativeFontFace();\n\n      if (nativeFontFace) {\n        this.addNativeFontFace(nativeFontFace);\n\n        try {\n          await nativeFontFace.loaded;\n        } catch (ex) {\n          this._onUnsupportedFeature({\n            featureId: _util.UNSUPPORTED_FEATURES.errorFontLoadNative\n          });\n\n          (0, _util.warn)(`Failed to load font \'${nativeFontFace.family}\': \'${ex}\'.`);\n          font.disableFontFace = true;\n          throw ex;\n        }\n      }\n\n      return;\n    }\n\n    const rule = font.createFontFaceRule();\n\n    if (rule) {\n      this.insertRule(rule);\n\n      if (this.isSyncFontLoadingSupported) {\n        return;\n      }\n\n      await new Promise(resolve => {\n        const request = this._queueLoadingCallback(resolve);\n\n        this._prepareFontLoadEvent([rule], [font], request);\n      });\n    }\n  }\n\n  _queueLoadingCallback(callback) {\n    (0, _util.unreachable)("Abstract method `_queueLoadingCallback`.");\n  }\n\n  get isFontLoadingAPISupported() {\n    const supported = typeof this._document !== "undefined" && !!this._document.fonts;\n    return (0, _util.shadow)(this, "isFontLoadingAPISupported", supported);\n  }\n\n  get isSyncFontLoadingSupported() {\n    (0, _util.unreachable)("Abstract method `isSyncFontLoadingSupported`.");\n  }\n\n  get _loadTestFont() {\n    (0, _util.unreachable)("Abstract method `_loadTestFont`.");\n  }\n\n  _prepareFontLoadEvent(rules, fontsToLoad, request) {\n    (0, _util.unreachable)("Abstract method `_prepareFontLoadEvent`.");\n  }\n\n}\n\nlet FontLoader;\nexports.FontLoader = FontLoader;\n{\n  exports.FontLoader = FontLoader = class GenericFontLoader extends BaseFontLoader {\n    constructor(params) {\n      super(params);\n      this.loadingContext = {\n        requests: [],\n        nextRequestId: 0\n      };\n      this.loadTestFontId = 0;\n    }\n\n    get isSyncFontLoadingSupported() {\n      let supported = false;\n\n      if (typeof navigator === "undefined") {\n        supported = true;\n      } else {\n        const m = /Mozilla\\/5.0.*?rv:(\\d+).*? Gecko/.exec(navigator.userAgent);\n\n        if (m && m[1] >= 14) {\n          supported = true;\n        }\n      }\n\n      return (0, _util.shadow)(this, "isSyncFontLoadingSupported", supported);\n    }\n\n    _queueLoadingCallback(callback) {\n      function completeRequest() {\n        (0, _util.assert)(!request.done, "completeRequest() cannot be called twice.");\n        request.done = true;\n\n        while (context.requests.length > 0 && context.requests[0].done) {\n          const otherRequest = context.requests.shift();\n          setTimeout(otherRequest.callback, 0);\n        }\n      }\n\n      const context = this.loadingContext;\n      const request = {\n        id: `pdfjs-font-loading-${context.nextRequestId++}`,\n        done: false,\n        complete: completeRequest,\n        callback\n      };\n      context.requests.push(request);\n      return request;\n    }\n\n    get _loadTestFont() {\n      const getLoadTestFont = function () {\n        return atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA" + "FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA" + "ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA" + "AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1" + "AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD" + "6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM" + "AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D" + "IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA" + "AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA" + "AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB" + "AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY" + "AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA" + "AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA" + "AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC" + "AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3" + "Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj" + "FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");\n      };\n\n      return (0, _util.shadow)(this, "_loadTestFont", getLoadTestFont());\n    }\n\n    _prepareFontLoadEvent(rules, fonts, request) {\n      function int32(data, offset) {\n        return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff;\n      }\n\n      function spliceString(s, offset, remove, insert) {\n        const chunk1 = s.substring(0, offset);\n        const chunk2 = s.substring(offset + remove);\n        return chunk1 + insert + chunk2;\n      }\n\n      let i, ii;\n\n      const canvas = this._document.createElement("canvas");\n\n      canvas.width = 1;\n      canvas.height = 1;\n      const ctx = canvas.getContext("2d");\n      let called = 0;\n\n      function isFontReady(name, callback) {\n        called++;\n\n        if (called > 30) {\n          (0, _util.warn)("Load test font never loaded.");\n          callback();\n          return;\n        }\n\n        ctx.font = "30px " + name;\n        ctx.fillText(".", 0, 20);\n        const imageData = ctx.getImageData(0, 0, 1, 1);\n\n        if (imageData.data[3] > 0) {\n          callback();\n          return;\n        }\n\n        setTimeout(isFontReady.bind(null, name, callback));\n      }\n\n      const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;\n      let data = this._loadTestFont;\n      const COMMENT_OFFSET = 976;\n      data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);\n      const CFF_CHECKSUM_OFFSET = 16;\n      const XXXX_VALUE = 0x58585858;\n      let checksum = int32(data, CFF_CHECKSUM_OFFSET);\n\n      for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {\n        checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;\n      }\n\n      if (i < loadTestFontId.length) {\n        checksum = checksum - XXXX_VALUE + int32(loadTestFontId + "XXX", i) | 0;\n      }\n\n      data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util.string32)(checksum));\n      const url = `url(data:font/opentype;base64,${btoa(data)});`;\n      const rule = `@font-face {font-family:"${loadTestFontId}";src:${url}}`;\n      this.insertRule(rule);\n      const names = [];\n\n      for (i = 0, ii = fonts.length; i < ii; i++) {\n        names.push(fonts[i].loadedName);\n      }\n\n      names.push(loadTestFontId);\n\n      const div = this._document.createElement("div");\n\n      div.style.visibility = "hidden";\n      div.style.width = div.style.height = "10px";\n      div.style.position = "absolute";\n      div.style.top = div.style.left = "0px";\n\n      for (i = 0, ii = names.length; i < ii; ++i) {\n        const span = this._document.createElement("span");\n\n        span.textContent = "Hi";\n        span.style.fontFamily = names[i];\n        div.appendChild(span);\n      }\n\n      this._document.body.appendChild(div);\n\n      isFontReady(loadTestFontId, () => {\n        this._document.body.removeChild(div);\n\n        request.complete();\n      });\n    }\n\n  };\n}\n\nclass FontFaceObject {\n  constructor(translatedData, {\n    isEvalSupported = true,\n    disableFontFace = false,\n    ignoreErrors = false,\n    onUnsupportedFeature = null,\n    fontRegistry = null\n  }) {\n    this.compiledGlyphs = Object.create(null);\n\n    for (const i in translatedData) {\n      this[i] = translatedData[i];\n    }\n\n    this.isEvalSupported = isEvalSupported !== false;\n    this.disableFontFace = disableFontFace === true;\n    this.ignoreErrors = ignoreErrors === true;\n    this._onUnsupportedFeature = onUnsupportedFeature;\n    this.fontRegistry = fontRegistry;\n  }\n\n  createNativeFontFace() {\n    if (!this.data || this.disableFontFace) {\n      return null;\n    }\n\n    const nativeFontFace = new FontFace(this.loadedName, this.data, {});\n\n    if (this.fontRegistry) {\n      this.fontRegistry.registerFont(this);\n    }\n\n    return nativeFontFace;\n  }\n\n  createFontFaceRule() {\n    if (!this.data || this.disableFontFace) {\n      return null;\n    }\n\n    const data = (0, _util.bytesToString)(new Uint8Array(this.data));\n    const url = `url(data:${this.mimetype};base64,${btoa(data)});`;\n    const rule = `@font-face {font-family:"${this.loadedName}";src:${url}}`;\n\n    if (this.fontRegistry) {\n      this.fontRegistry.registerFont(this, url);\n    }\n\n    return rule;\n  }\n\n  getPathGenerator(objs, character) {\n    if (this.compiledGlyphs[character] !== undefined) {\n      return this.compiledGlyphs[character];\n    }\n\n    let cmds, current;\n\n    try {\n      cmds = objs.get(this.loadedName + "_path_" + character);\n    } catch (ex) {\n      if (!this.ignoreErrors) {\n        throw ex;\n      }\n\n      if (this._onUnsupportedFeature) {\n        this._onUnsupportedFeature({\n          featureId: _util.UNSUPPORTED_FEATURES.errorFontGetPath\n        });\n      }\n\n      (0, _util.warn)(`getPathGenerator - ignoring character: "${ex}".`);\n      return this.compiledGlyphs[character] = function (c, size) {};\n    }\n\n    if (this.isEvalSupported && _util.IsEvalSupportedCached.value) {\n      let args,\n          js = "";\n\n      for (let i = 0, ii = cmds.length; i < ii; i++) {\n        current = cmds[i];\n\n        if (current.args !== undefined) {\n          args = current.args.join(",");\n        } else {\n          args = "";\n        }\n\n        js += "c." + current.cmd + "(" + args + ");\\n";\n      }\n\n      return this.compiledGlyphs[character] = new Function("c", "size", js);\n    }\n\n    return this.compiledGlyphs[character] = function (c, size) {\n      for (let i = 0, ii = cmds.length; i < ii; i++) {\n        current = cmds[i];\n\n        if (current.cmd === "scale") {\n          current.args = [size, -size];\n        }\n\n        c[current.cmd].apply(c, current.args);\n      }\n    };\n  }\n\n}\n\nexports.FontFaceObject = FontFaceObject;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n"use strict";\n\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.NodeCMapReaderFactory = exports.NodeCanvasFactory = void 0;\n\nvar _display_utils = __w_pdfjs_require__(1);\n\nvar _is_node = __w_pdfjs_require__(4);\n\nvar _util = __w_pdfjs_require__(2);\n\nlet NodeCanvasFactory = class {\n  constructor() {\n    (0, _util.unreachable)("Not implemented: NodeCanvasFactory");\n  }\n\n};\nexports.NodeCanvasFactory = NodeCanvasFactory;\nlet NodeCMapReaderFactory = class {\n  constructor() {\n    (0, _util.unreachable)("Not implemented: NodeCMapReaderFactory");\n  }\n\n};\nexports.NodeCMapReaderFactory = NodeCMapReaderFactory;\n\nif (_is_node.isNodeJS) {\n  exports.NodeCanvasFactory = NodeCanvasFactory = class extends _display_utils.BaseCanvasFactory {\n    create(width, height) {\n      if (width <= 0 || height <= 0) {\n        throw new Error("Invalid canvas size");\n      }\n\n      const Canvas = __webpack_require__(414);\n\n      const canvas = Canvas.createCanvas(width, height);\n      return {\n        canvas,\n        context: canvas.getContext("2d")\n      };\n    }\n\n  };\n  exports.NodeCMapReaderFactory = NodeCMapReaderFactory = class extends _display_utils.BaseCMapReaderFactory {\n    _fetchData(url, compressionType) {\n      return new Promise((resolve, reject) => {\n        const fs = __webpack_require__(172);\n\n        fs.readFile(url, (error, data) => {\n          if (error || !data) {\n            reject(new Error(error));\n            return;\n          }\n\n          resolve({\n            cMapData: new Uint8Array(data),\n            compressionType\n          });\n        });\n      });\n    }\n\n  };\n}\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n"use strict";\n\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.AnnotationStorage = void 0;\n\nclass AnnotationStorage {\n  constructor() {\n    this._storage = new Map();\n    this._modified = false;\n    this.onSetModified = null;\n    this.onResetModified = null;\n  }\n\n  getOrCreateValue(key, defaultValue) {\n    if (this._storage.has(key)) {\n      return this._storage.get(key);\n    }\n\n    this._storage.set(key, defaultValue);\n\n    return defaultValue;\n  }\n\n  setValue(key, value) {\n    if (this._storage.get(key) !== value) {\n      this._setModified();\n    }\n\n    this._storage.set(key, value);\n  }\n\n  getAll() {\n    if (this._storage.size === 0) {\n      return null;\n    }\n\n    return Object.fromEntries(this._storage);\n  }\n\n  get size() {\n    return this._storage.size;\n  }\n\n  _setModified() {\n    if (!this._modified) {\n      this._modified = true;\n\n      if (typeof this.onSetModified === "function") {\n        this.onSetModified();\n      }\n    }\n  }\n\n  resetModified() {\n    if (this._modified) {\n      this._modified = false;\n\n      if (typeof this.onResetModified === "function") {\n        this.onResetModified();\n      }\n    }\n  }\n\n}\n\nexports.AnnotationStorage = AnnotationStorage;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n"use strict";\n\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.apiCompatibilityParams = void 0;\n\nvar _is_node = __w_pdfjs_require__(4);\n\nconst compatibilityParams = Object.create(null);\n{\n  (function checkFontFace() {\n    if (_is_node.isNodeJS) {\n      compatibilityParams.disableFontFace = true;\n    }\n  })();\n}\nconst apiCompatibilityParams = Object.freeze(compatibilityParams);\nexports.apiCompatibilityParams = apiCompatibilityParams;\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n"use strict";\n\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.CanvasGraphics = void 0;\n\nvar _util = __w_pdfjs_require__(2);\n\nvar _pattern_helper = __w_pdfjs_require__(11);\n\nvar MIN_FONT_SIZE = 16;\nvar MAX_FONT_SIZE = 100;\nvar MAX_GROUP_SIZE = 4096;\nvar MIN_WIDTH_FACTOR = 0.65;\nvar COMPILE_TYPE3_GLYPHS = true;\nvar MAX_SIZE_TO_COMPILE = 1000;\nvar FULL_CHUNK_HEIGHT = 16;\n\nfunction addContextCurrentTransform(ctx) {\n  if (!ctx.mozCurrentTransform) {\n    ctx._originalSave = ctx.save;\n    ctx._originalRestore = ctx.restore;\n    ctx._originalRotate = ctx.rotate;\n    ctx._originalScale = ctx.scale;\n    ctx._originalTranslate = ctx.translate;\n    ctx._originalTransform = ctx.transform;\n    ctx._originalSetTransform = ctx.setTransform;\n    ctx._transformMatrix = ctx._transformMatrix || [1, 0, 0, 1, 0, 0];\n    ctx._transformStack = [];\n    Object.defineProperty(ctx, "mozCurrentTransform", {\n      get: function getCurrentTransform() {\n        return this._transformMatrix;\n      }\n    });\n    Object.defineProperty(ctx, "mozCurrentTransformInverse", {\n      get: function getCurrentTransformInverse() {\n        var m = this._transformMatrix;\n        var a = m[0],\n            b = m[1],\n            c = m[2],\n            d = m[3],\n            e = m[4],\n            f = m[5];\n        var ad_bc = a * d - b * c;\n        var bc_ad = b * c - a * d;\n        return [d / ad_bc, b / bc_ad, c / bc_ad, a / ad_bc, (d * e - c * f) / bc_ad, (b * e - a * f) / ad_bc];\n      }\n    });\n\n    ctx.save = function ctxSave() {\n      var old = this._transformMatrix;\n\n      this._transformStack.push(old);\n\n      this._transformMatrix = old.slice(0, 6);\n\n      this._originalSave();\n    };\n\n    ctx.restore = function ctxRestore() {\n      var prev = this._transformStack.pop();\n\n      if (prev) {\n        this._transformMatrix = prev;\n\n        this._originalRestore();\n      }\n    };\n\n    ctx.translate = function ctxTranslate(x, y) {\n      var m = this._transformMatrix;\n      m[4] = m[0] * x + m[2] * y + m[4];\n      m[5] = m[1] * x + m[3] * y + m[5];\n\n      this._originalTranslate(x, y);\n    };\n\n    ctx.scale = function ctxScale(x, y) {\n      var m = this._transformMatrix;\n      m[0] = m[0] * x;\n      m[1] = m[1] * x;\n      m[2] = m[2] * y;\n      m[3] = m[3] * y;\n\n      this._originalScale(x, y);\n    };\n\n    ctx.transform = function ctxTransform(a, b, c, d, e, f) {\n      var m = this._transformMatrix;\n      this._transformMatrix = [m[0] * a + m[2] * b, m[1] * a + m[3] * b, m[0] * c + m[2] * d, m[1] * c + m[3] * d, m[0] * e + m[2] * f + m[4], m[1] * e + m[3] * f + m[5]];\n\n      ctx._originalTransform(a, b, c, d, e, f);\n    };\n\n    ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {\n      this._transformMatrix = [a, b, c, d, e, f];\n\n      ctx._originalSetTransform(a, b, c, d, e, f);\n    };\n\n    ctx.rotate = function ctxRotate(angle) {\n      var cosValue = Math.cos(angle);\n      var sinValue = Math.sin(angle);\n      var m = this._transformMatrix;\n      this._transformMatrix = [m[0] * cosValue + m[2] * sinValue, m[1] * cosValue + m[3] * sinValue, m[0] * -sinValue + m[2] * cosValue, m[1] * -sinValue + m[3] * cosValue, m[4], m[5]];\n\n      this._originalRotate(angle);\n    };\n  }\n}\n\nvar CachedCanvases = function CachedCanvasesClosure() {\n  function CachedCanvases(canvasFactory) {\n    this.canvasFactory = canvasFactory;\n    this.cache = Object.create(null);\n  }\n\n  CachedCanvases.prototype = {\n    getCanvas: function CachedCanvases_getCanvas(id, width, height, trackTransform) {\n      var canvasEntry;\n\n      if (this.cache[id] !== undefined) {\n        canvasEntry = this.cache[id];\n        this.canvasFactory.reset(canvasEntry, width, height);\n        canvasEntry.context.setTransform(1, 0, 0, 1, 0, 0);\n      } else {\n        canvasEntry = this.canvasFactory.create(width, height);\n        this.cache[id] = canvasEntry;\n      }\n\n      if (trackTransform) {\n        addContextCurrentTransform(canvasEntry.context);\n      }\n\n      return canvasEntry;\n    },\n\n    clear() {\n      for (var id in this.cache) {\n        var canvasEntry = this.cache[id];\n        this.canvasFactory.destroy(canvasEntry);\n        delete this.cache[id];\n      }\n    }\n\n  };\n  return CachedCanvases;\n}();\n\nfunction compileType3Glyph(imgData) {\n  var POINT_TO_PROCESS_LIMIT = 1000;\n  var width = imgData.width,\n      height = imgData.height;\n  var i,\n      j,\n      j0,\n      width1 = width + 1;\n  var points = new Uint8Array(width1 * (height + 1));\n  var POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);\n  var lineSize = width + 7 & ~7,\n      data0 = imgData.data;\n  var data = new Uint8Array(lineSize * height),\n      pos = 0,\n      ii;\n\n  for (i = 0, ii = data0.length; i < ii; i++) {\n    var mask = 128,\n        elem = data0[i];\n\n    while (mask > 0) {\n      data[pos++] = elem & mask ? 0 : 255;\n      mask >>= 1;\n    }\n  }\n\n  var count = 0;\n  pos = 0;\n\n  if (data[pos] !== 0) {\n    points[0] = 1;\n    ++count;\n  }\n\n  for (j = 1; j < width; j++) {\n    if (data[pos] !== data[pos + 1]) {\n      points[j] = data[pos] ? 2 : 1;\n      ++count;\n    }\n\n    pos++;\n  }\n\n  if (data[pos] !== 0) {\n    points[j] = 2;\n    ++count;\n  }\n\n  for (i = 1; i < height; i++) {\n    pos = i * lineSize;\n    j0 = i * width1;\n\n    if (data[pos - lineSize] !== data[pos]) {\n      points[j0] = data[pos] ? 1 : 8;\n      ++count;\n    }\n\n    var sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);\n\n    for (j = 1; j < width; j++) {\n      sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);\n\n      if (POINT_TYPES[sum]) {\n        points[j0 + j] = POINT_TYPES[sum];\n        ++count;\n      }\n\n      pos++;\n    }\n\n    if (data[pos - lineSize] !== data[pos]) {\n      points[j0 + j] = data[pos] ? 2 : 4;\n      ++count;\n    }\n\n    if (count > POINT_TO_PROCESS_LIMIT) {\n      return null;\n    }\n  }\n\n  pos = lineSize * (height - 1);\n  j0 = i * width1;\n\n  if (data[pos] !== 0) {\n    points[j0] = 8;\n    ++count;\n  }\n\n  for (j = 1; j < width; j++) {\n    if (data[pos] !== data[pos + 1]) {\n      points[j0 + j] = data[pos] ? 4 : 8;\n      ++count;\n    }\n\n    pos++;\n  }\n\n  if (data[pos] !== 0) {\n    points[j0 + j] = 4;\n    ++count;\n  }\n\n  if (count > POINT_TO_PROCESS_LIMIT) {\n    return null;\n  }\n\n  var steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);\n  var outlines = [];\n\n  for (i = 0; count && i <= height; i++) {\n    var p = i * width1;\n    var end = p + width;\n\n    while (p < end && !points[p]) {\n      p++;\n    }\n\n    if (p === end) {\n      continue;\n    }\n\n    var coords = [p % width1, i];\n    var type = points[p],\n        p0 = p,\n        pp;\n\n    do {\n      var step = steps[type];\n\n      do {\n        p += step;\n      } while (!points[p]);\n\n      pp = points[p];\n\n      if (pp !== 5 && pp !== 10) {\n        type = pp;\n        points[p] = 0;\n      } else {\n        type = pp & 0x33 * type >> 4;\n        points[p] &= type >> 2 | type << 2;\n      }\n\n      coords.push(p % width1);\n      coords.push(p / width1 | 0);\n\n      if (!points[p]) {\n        --count;\n      }\n    } while (p0 !== p);\n\n    outlines.push(coords);\n    --i;\n  }\n\n  var drawOutline = function (c) {\n    c.save();\n    c.scale(1 / width, -1 / height);\n    c.translate(0, -height);\n    c.beginPath();\n\n    for (let k = 0, kk = outlines.length; k < kk; k++) {\n      var o = outlines[k];\n      c.moveTo(o[0], o[1]);\n\n      for (let l = 2, ll = o.length; l < ll; l += 2) {\n        c.lineTo(o[l], o[l + 1]);\n      }\n    }\n\n    c.fill();\n    c.beginPath();\n    c.restore();\n  };\n\n  return drawOutline;\n}\n\nvar CanvasExtraState = function CanvasExtraStateClosure() {\n  function CanvasExtraState() {\n    this.alphaIsShape = false;\n    this.fontSize = 0;\n    this.fontSizeScale = 1;\n    this.textMatrix = _util.IDENTITY_MATRIX;\n    this.textMatrixScale = 1;\n    this.fontMatrix = _util.FONT_IDENTITY_MATRIX;\n    this.leading = 0;\n    this.x = 0;\n    this.y = 0;\n    this.lineX = 0;\n    this.lineY = 0;\n    this.charSpacing = 0;\n    this.wordSpacing = 0;\n    this.textHScale = 1;\n    this.textRenderingMode = _util.TextRenderingMode.FILL;\n    this.textRise = 0;\n    this.fillColor = "#000000";\n    this.strokeColor = "#000000";\n    this.patternFill = false;\n    this.fillAlpha = 1;\n    this.strokeAlpha = 1;\n    this.lineWidth = 1;\n    this.activeSMask = null;\n    this.resumeSMaskCtx = null;\n    this.transferMaps = null;\n  }\n\n  CanvasExtraState.prototype = {\n    clone: function CanvasExtraState_clone() {\n      return Object.create(this);\n    },\n    setCurrentPoint: function CanvasExtraState_setCurrentPoint(x, y) {\n      this.x = x;\n      this.y = y;\n    }\n  };\n  return CanvasExtraState;\n}();\n\nvar CanvasGraphics = function CanvasGraphicsClosure() {\n  var EXECUTION_TIME = 15;\n  var EXECUTION_STEPS = 10;\n\n  function CanvasGraphics(canvasCtx, commonObjs, objs, canvasFactory, webGLContext, imageLayer, optionalContentConfig) {\n    this.ctx = canvasCtx;\n    this.current = new CanvasExtraState();\n    this.stateStack = [];\n    this.pendingClip = null;\n    this.pendingEOFill = false;\n    this.res = null;\n    this.xobjs = null;\n    this.commonObjs = commonObjs;\n    this.objs = objs;\n    this.canvasFactory = canvasFactory;\n    this.webGLContext = webGLContext;\n    this.imageLayer = imageLayer;\n    this.groupStack = [];\n    this.processingType3 = null;\n    this.baseTransform = null;\n    this.baseTransformStack = [];\n    this.groupLevel = 0;\n    this.smaskStack = [];\n    this.smaskCounter = 0;\n    this.tempSMask = null;\n    this.contentVisible = true;\n    this.markedContentStack = [];\n    this.optionalContentConfig = optionalContentConfig;\n    this.cachedCanvases = new CachedCanvases(this.canvasFactory);\n\n    if (canvasCtx) {\n      addContextCurrentTransform(canvasCtx);\n    }\n\n    this._cachedGetSinglePixelWidth = null;\n  }\n\n  function putBinaryImageData(ctx, imgData, transferMaps = null) {\n    if (typeof ImageData !== "undefined" && imgData instanceof ImageData) {\n      ctx.putImageData(imgData, 0, 0);\n      return;\n    }\n\n    var height = imgData.height,\n        width = imgData.width;\n    var partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n    var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n    var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n    var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n    var srcPos = 0,\n        destPos;\n    var src = imgData.data;\n    var dest = chunkImgData.data;\n    var i, j, thisChunkHeight, elemsInThisChunk;\n    let transferMapRed, transferMapGreen, transferMapBlue, transferMapGray;\n\n    if (transferMaps) {\n      switch (transferMaps.length) {\n        case 1:\n          transferMapRed = transferMaps[0];\n          transferMapGreen = transferMaps[0];\n          transferMapBlue = transferMaps[0];\n          transferMapGray = transferMaps[0];\n          break;\n\n        case 4:\n          transferMapRed = transferMaps[0];\n          transferMapGreen = transferMaps[1];\n          transferMapBlue = transferMaps[2];\n          transferMapGray = transferMaps[3];\n          break;\n      }\n    }\n\n    if (imgData.kind === _util.ImageKind.GRAYSCALE_1BPP) {\n      var srcLength = src.byteLength;\n      var dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);\n      var dest32DataLength = dest32.length;\n      var fullSrcDiff = width + 7 >> 3;\n      var white = 0xffffffff;\n      var black = _util.IsLittleEndianCached.value ? 0xff000000 : 0x000000ff;\n\n      if (transferMapGray) {\n        if (transferMapGray[0] === 0xff && transferMapGray[0xff] === 0) {\n          [white, black] = [black, white];\n        }\n      }\n\n      for (i = 0; i < totalChunks; i++) {\n        thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n        destPos = 0;\n\n        for (j = 0; j < thisChunkHeight; j++) {\n          var srcDiff = srcLength - srcPos;\n          let k = 0;\n          var kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;\n          var kEndUnrolled = kEnd & ~7;\n          var mask = 0;\n          var srcByte = 0;\n\n          for (; k < kEndUnrolled; k += 8) {\n            srcByte = src[srcPos++];\n            dest32[destPos++] = srcByte & 128 ? white : black;\n            dest32[destPos++] = srcByte & 64 ? white : black;\n            dest32[destPos++] = srcByte & 32 ? white : black;\n            dest32[destPos++] = srcByte & 16 ? white : black;\n            dest32[destPos++] = srcByte & 8 ? white : black;\n            dest32[destPos++] = srcByte & 4 ? white : black;\n            dest32[destPos++] = srcByte & 2 ? white : black;\n            dest32[destPos++] = srcByte & 1 ? white : black;\n          }\n\n          for (; k < kEnd; k++) {\n            if (mask === 0) {\n              srcByte = src[srcPos++];\n              mask = 128;\n            }\n\n            dest32[destPos++] = srcByte & mask ? white : black;\n            mask >>= 1;\n          }\n        }\n\n        while (destPos < dest32DataLength) {\n          dest32[destPos++] = 0;\n        }\n\n        ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n      }\n    } else if (imgData.kind === _util.ImageKind.RGBA_32BPP) {\n      const hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);\n      j = 0;\n      elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;\n\n      for (i = 0; i < fullChunks; i++) {\n        dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n        srcPos += elemsInThisChunk;\n\n        if (hasTransferMaps) {\n          for (let k = 0; k < elemsInThisChunk; k += 4) {\n            if (transferMapRed) {\n              dest[k + 0] = transferMapRed[dest[k + 0]];\n            }\n\n            if (transferMapGreen) {\n              dest[k + 1] = transferMapGreen[dest[k + 1]];\n            }\n\n            if (transferMapBlue) {\n              dest[k + 2] = transferMapBlue[dest[k + 2]];\n            }\n          }\n        }\n\n        ctx.putImageData(chunkImgData, 0, j);\n        j += FULL_CHUNK_HEIGHT;\n      }\n\n      if (i < totalChunks) {\n        elemsInThisChunk = width * partialChunkHeight * 4;\n        dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n\n        if (hasTransferMaps) {\n          for (let k = 0; k < elemsInThisChunk; k += 4) {\n            if (transferMapRed) {\n              dest[k + 0] = transferMapRed[dest[k + 0]];\n            }\n\n            if (transferMapGreen) {\n              dest[k + 1] = transferMapGreen[dest[k + 1]];\n            }\n\n            if (transferMapBlue) {\n              dest[k + 2] = transferMapBlue[dest[k + 2]];\n            }\n          }\n        }\n\n        ctx.putImageData(chunkImgData, 0, j);\n      }\n    } else if (imgData.kind === _util.ImageKind.RGB_24BPP) {\n      const hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);\n      thisChunkHeight = FULL_CHUNK_HEIGHT;\n      elemsInThisChunk = width * thisChunkHeight;\n\n      for (i = 0; i < totalChunks; i++) {\n        if (i >= fullChunks) {\n          thisChunkHeight = partialChunkHeight;\n          elemsInThisChunk = width * thisChunkHeight;\n        }\n\n        destPos = 0;\n\n        for (j = elemsInThisChunk; j--;) {\n          dest[destPos++] = src[srcPos++];\n          dest[destPos++] = src[srcPos++];\n          dest[destPos++] = src[srcPos++];\n          dest[destPos++] = 255;\n        }\n\n        if (hasTransferMaps) {\n          for (let k = 0; k < destPos; k += 4) {\n            if (transferMapRed) {\n              dest[k + 0] = transferMapRed[dest[k + 0]];\n            }\n\n            if (transferMapGreen) {\n              dest[k + 1] = transferMapGreen[dest[k + 1]];\n            }\n\n            if (transferMapBlue) {\n              dest[k + 2] = transferMapBlue[dest[k + 2]];\n            }\n          }\n        }\n\n        ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n      }\n    } else {\n      throw new Error(`bad image kind: ${imgData.kind}`);\n    }\n  }\n\n  function putBinaryImageMask(ctx, imgData) {\n    var height = imgData.height,\n        width = imgData.width;\n    var partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n    var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n    var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n    var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n    var srcPos = 0;\n    var src = imgData.data;\n    var dest = chunkImgData.data;\n\n    for (var i = 0; i < totalChunks; i++) {\n      var thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n      var destPos = 3;\n\n      for (var j = 0; j < thisChunkHeight; j++) {\n        var mask = 0;\n\n        for (var k = 0; k < width; k++) {\n          if (!mask) {\n            var elem = src[srcPos++];\n            mask = 128;\n          }\n\n          dest[destPos] = elem & mask ? 0 : 255;\n          destPos += 4;\n          mask >>= 1;\n        }\n      }\n\n      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n    }\n  }\n\n  function copyCtxState(sourceCtx, destCtx) {\n    var properties = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font"];\n\n    for (var i = 0, ii = properties.length; i < ii; i++) {\n      var property = properties[i];\n\n      if (sourceCtx[property] !== undefined) {\n        destCtx[property] = sourceCtx[property];\n      }\n    }\n\n    if (sourceCtx.setLineDash !== undefined) {\n      destCtx.setLineDash(sourceCtx.getLineDash());\n      destCtx.lineDashOffset = sourceCtx.lineDashOffset;\n    }\n  }\n\n  function resetCtxToDefault(ctx) {\n    ctx.strokeStyle = "#000000";\n    ctx.fillStyle = "#000000";\n    ctx.fillRule = "nonzero";\n    ctx.globalAlpha = 1;\n    ctx.lineWidth = 1;\n    ctx.lineCap = "butt";\n    ctx.lineJoin = "miter";\n    ctx.miterLimit = 10;\n    ctx.globalCompositeOperation = "source-over";\n    ctx.font = "10px sans-serif";\n\n    if (ctx.setLineDash !== undefined) {\n      ctx.setLineDash([]);\n      ctx.lineDashOffset = 0;\n    }\n  }\n\n  function composeSMaskBackdrop(bytes, r0, g0, b0) {\n    var length = bytes.length;\n\n    for (var i = 3; i < length; i += 4) {\n      var alpha = bytes[i];\n\n      if (alpha === 0) {\n        bytes[i - 3] = r0;\n        bytes[i - 2] = g0;\n        bytes[i - 1] = b0;\n      } else if (alpha < 255) {\n        var alpha_ = 255 - alpha;\n        bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8;\n        bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8;\n        bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8;\n      }\n    }\n  }\n\n  function composeSMaskAlpha(maskData, layerData, transferMap) {\n    var length = maskData.length;\n    var scale = 1 / 255;\n\n    for (var i = 3; i < length; i += 4) {\n      var alpha = transferMap ? transferMap[maskData[i]] : maskData[i];\n      layerData[i] = layerData[i] * alpha * scale | 0;\n    }\n  }\n\n  function composeSMaskLuminosity(maskData, layerData, transferMap) {\n    var length = maskData.length;\n\n    for (var i = 3; i < length; i += 4) {\n      var y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28;\n      layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16;\n    }\n  }\n\n  function genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap) {\n    var hasBackdrop = !!backdrop;\n    var r0 = hasBackdrop ? backdrop[0] : 0;\n    var g0 = hasBackdrop ? backdrop[1] : 0;\n    var b0 = hasBackdrop ? backdrop[2] : 0;\n    var composeFn;\n\n    if (subtype === "Luminosity") {\n      composeFn = composeSMaskLuminosity;\n    } else {\n      composeFn = composeSMaskAlpha;\n    }\n\n    var PIXELS_TO_PROCESS = 1048576;\n    var chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));\n\n    for (var row = 0; row < height; row += chunkSize) {\n      var chunkHeight = Math.min(chunkSize, height - row);\n      var maskData = maskCtx.getImageData(0, row, width, chunkHeight);\n      var layerData = layerCtx.getImageData(0, row, width, chunkHeight);\n\n      if (hasBackdrop) {\n        composeSMaskBackdrop(maskData.data, r0, g0, b0);\n      }\n\n      composeFn(maskData.data, layerData.data, transferMap);\n      maskCtx.putImageData(layerData, 0, row);\n    }\n  }\n\n  function composeSMask(ctx, smask, layerCtx, webGLContext) {\n    var mask = smask.canvas;\n    var maskCtx = smask.context;\n    ctx.setTransform(smask.scaleX, 0, 0, smask.scaleY, smask.offsetX, smask.offsetY);\n    var backdrop = smask.backdrop || null;\n\n    if (!smask.transferMap && webGLContext.isEnabled) {\n      const composed = webGLContext.composeSMask({\n        layer: layerCtx.canvas,\n        mask,\n        properties: {\n          subtype: smask.subtype,\n          backdrop\n        }\n      });\n      ctx.setTransform(1, 0, 0, 1, 0, 0);\n      ctx.drawImage(composed, smask.offsetX, smask.offsetY);\n      return;\n    }\n\n    genericComposeSMask(maskCtx, layerCtx, mask.width, mask.height, smask.subtype, backdrop, smask.transferMap);\n    ctx.drawImage(mask, 0, 0);\n  }\n\n  var LINE_CAP_STYLES = ["butt", "round", "square"];\n  var LINE_JOIN_STYLES = ["miter", "round", "bevel"];\n  var NORMAL_CLIP = {};\n  var EO_CLIP = {};\n  CanvasGraphics.prototype = {\n    beginDrawing({\n      transform,\n      viewport,\n      transparency = false,\n      background = null\n    }) {\n      var width = this.ctx.canvas.width;\n      var height = this.ctx.canvas.height;\n      this.ctx.save();\n      this.ctx.fillStyle = background || "rgb(255, 255, 255)";\n      this.ctx.fillRect(0, 0, width, height);\n      this.ctx.restore();\n\n      if (transparency) {\n        var transparentCanvas = this.cachedCanvases.getCanvas("transparent", width, height, true);\n        this.compositeCtx = this.ctx;\n        this.transparentCanvas = transparentCanvas.canvas;\n        this.ctx = transparentCanvas.context;\n        this.ctx.save();\n        this.ctx.transform.apply(this.ctx, this.compositeCtx.mozCurrentTransform);\n      }\n\n      this.ctx.save();\n      resetCtxToDefault(this.ctx);\n\n      if (transform) {\n        this.ctx.transform.apply(this.ctx, transform);\n      }\n\n      this.ctx.transform.apply(this.ctx, viewport.transform);\n      this.baseTransform = this.ctx.mozCurrentTransform.slice();\n\n      if (this.imageLayer) {\n        this.imageLayer.beginLayout();\n      }\n    },\n\n    executeOperatorList: function CanvasGraphics_executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {\n      var argsArray = operatorList.argsArray;\n      var fnArray = operatorList.fnArray;\n      var i = executionStartIdx || 0;\n      var argsArrayLen = argsArray.length;\n\n      if (argsArrayLen === i) {\n        return i;\n      }\n\n      var chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === "function";\n      var endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;\n      var steps = 0;\n      var commonObjs = this.commonObjs;\n      var objs = this.objs;\n      var fnId;\n\n      while (true) {\n        if (stepper !== undefined && i === stepper.nextBreakPoint) {\n          stepper.breakIt(i, continueCallback);\n          return i;\n        }\n\n        fnId = fnArray[i];\n\n        if (fnId !== _util.OPS.dependency) {\n          this[fnId].apply(this, argsArray[i]);\n        } else {\n          for (const depObjId of argsArray[i]) {\n            const objsPool = depObjId.startsWith("g_") ? commonObjs : objs;\n\n            if (!objsPool.has(depObjId)) {\n              objsPool.get(depObjId, continueCallback);\n              return i;\n            }\n          }\n        }\n\n        i++;\n\n        if (i === argsArrayLen) {\n          return i;\n        }\n\n        if (chunkOperations && ++steps > EXECUTION_STEPS) {\n          if (Date.now() > endTime) {\n            continueCallback();\n            return i;\n          }\n\n          steps = 0;\n        }\n      }\n    },\n    endDrawing: function CanvasGraphics_endDrawing() {\n      if (this.current.activeSMask !== null) {\n        this.endSMaskGroup();\n      }\n\n      this.ctx.restore();\n\n      if (this.transparentCanvas) {\n        this.ctx = this.compositeCtx;\n        this.ctx.save();\n        this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n        this.ctx.drawImage(this.transparentCanvas, 0, 0);\n        this.ctx.restore();\n        this.transparentCanvas = null;\n      }\n\n      this.cachedCanvases.clear();\n      this.webGLContext.clear();\n\n      if (this.imageLayer) {\n        this.imageLayer.endLayout();\n      }\n    },\n    setLineWidth: function CanvasGraphics_setLineWidth(width) {\n      this.current.lineWidth = width;\n      this.ctx.lineWidth = width;\n    },\n    setLineCap: function CanvasGraphics_setLineCap(style) {\n      this.ctx.lineCap = LINE_CAP_STYLES[style];\n    },\n    setLineJoin: function CanvasGraphics_setLineJoin(style) {\n      this.ctx.lineJoin = LINE_JOIN_STYLES[style];\n    },\n    setMiterLimit: function CanvasGraphics_setMiterLimit(limit) {\n      this.ctx.miterLimit = limit;\n    },\n    setDash: function CanvasGraphics_setDash(dashArray, dashPhase) {\n      var ctx = this.ctx;\n\n      if (ctx.setLineDash !== undefined) {\n        ctx.setLineDash(dashArray);\n        ctx.lineDashOffset = dashPhase;\n      }\n    },\n\n    setRenderingIntent(intent) {},\n\n    setFlatness(flatness) {},\n\n    setGState: function CanvasGraphics_setGState(states) {\n      for (var i = 0, ii = states.length; i < ii; i++) {\n        var state = states[i];\n        var key = state[0];\n        var value = state[1];\n\n        switch (key) {\n          case "LW":\n            this.setLineWidth(value);\n            break;\n\n          case "LC":\n            this.setLineCap(value);\n            break;\n\n          case "LJ":\n            this.setLineJoin(value);\n            break;\n\n          case "ML":\n            this.setMiterLimit(value);\n            break;\n\n          case "D":\n            this.setDash(value[0], value[1]);\n            break;\n\n          case "RI":\n            this.setRenderingIntent(value);\n            break;\n\n          case "FL":\n            this.setFlatness(value);\n            break;\n\n          case "Font":\n            this.setFont(value[0], value[1]);\n            break;\n\n          case "CA":\n            this.current.strokeAlpha = state[1];\n            break;\n\n          case "ca":\n            this.current.fillAlpha = state[1];\n            this.ctx.globalAlpha = state[1];\n            break;\n\n          case "BM":\n            this.ctx.globalCompositeOperation = value;\n            break;\n\n          case "SMask":\n            if (this.current.activeSMask) {\n              if (this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1].activeSMask === this.current.activeSMask) {\n                this.suspendSMaskGroup();\n              } else {\n                this.endSMaskGroup();\n              }\n            }\n\n            this.current.activeSMask = value ? this.tempSMask : null;\n\n            if (this.current.activeSMask) {\n              this.beginSMaskGroup();\n            }\n\n            this.tempSMask = null;\n            break;\n\n          case "TR":\n            this.current.transferMaps = value;\n        }\n      }\n    },\n    beginSMaskGroup: function CanvasGraphics_beginSMaskGroup() {\n      var activeSMask = this.current.activeSMask;\n      var drawnWidth = activeSMask.canvas.width;\n      var drawnHeight = activeSMask.canvas.height;\n      var cacheId = "smaskGroupAt" + this.groupLevel;\n      var scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);\n      var currentCtx = this.ctx;\n      var currentTransform = currentCtx.mozCurrentTransform;\n      this.ctx.save();\n      var groupCtx = scratchCanvas.context;\n      groupCtx.scale(1 / activeSMask.scaleX, 1 / activeSMask.scaleY);\n      groupCtx.translate(-activeSMask.offsetX, -activeSMask.offsetY);\n      groupCtx.transform.apply(groupCtx, currentTransform);\n      activeSMask.startTransformInverse = groupCtx.mozCurrentTransformInverse;\n      copyCtxState(currentCtx, groupCtx);\n      this.ctx = groupCtx;\n      this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);\n      this.groupStack.push(currentCtx);\n      this.groupLevel++;\n    },\n    suspendSMaskGroup: function CanvasGraphics_endSMaskGroup() {\n      var groupCtx = this.ctx;\n      this.groupLevel--;\n      this.ctx = this.groupStack.pop();\n      composeSMask(this.ctx, this.current.activeSMask, groupCtx, this.webGLContext);\n      this.ctx.restore();\n      this.ctx.save();\n      copyCtxState(groupCtx, this.ctx);\n      this.current.resumeSMaskCtx = groupCtx;\n\n      var deltaTransform = _util.Util.transform(this.current.activeSMask.startTransformInverse, groupCtx.mozCurrentTransform);\n\n      this.ctx.transform.apply(this.ctx, deltaTransform);\n      groupCtx.save();\n      groupCtx.setTransform(1, 0, 0, 1, 0, 0);\n      groupCtx.clearRect(0, 0, groupCtx.canvas.width, groupCtx.canvas.height);\n      groupCtx.restore();\n    },\n    resumeSMaskGroup: function CanvasGraphics_endSMaskGroup() {\n      var groupCtx = this.current.resumeSMaskCtx;\n      var currentCtx = this.ctx;\n      this.ctx = groupCtx;\n      this.groupStack.push(currentCtx);\n      this.groupLevel++;\n    },\n    endSMaskGroup: function CanvasGraphics_endSMaskGroup() {\n      var groupCtx = this.ctx;\n      this.groupLevel--;\n      this.ctx = this.groupStack.pop();\n      composeSMask(this.ctx, this.current.activeSMask, groupCtx, this.webGLContext);\n      this.ctx.restore();\n      copyCtxState(groupCtx, this.ctx);\n\n      var deltaTransform = _util.Util.transform(this.current.activeSMask.startTransformInverse, groupCtx.mozCurrentTransform);\n\n      this.ctx.transform.apply(this.ctx, deltaTransform);\n    },\n    save: function CanvasGraphics_save() {\n      this.ctx.save();\n      var old = this.current;\n      this.stateStack.push(old);\n      this.current = old.clone();\n      this.current.resumeSMaskCtx = null;\n    },\n    restore: function CanvasGraphics_restore() {\n      if (this.current.resumeSMaskCtx) {\n        this.resumeSMaskGroup();\n      }\n\n      if (this.current.activeSMask !== null && (this.stateStack.length === 0 || this.stateStack[this.stateStack.length - 1].activeSMask !== this.current.activeSMask)) {\n        this.endSMaskGroup();\n      }\n\n      if (this.stateStack.length !== 0) {\n        this.current = this.stateStack.pop();\n        this.ctx.restore();\n        this.pendingClip = null;\n        this._cachedGetSinglePixelWidth = null;\n      }\n    },\n    transform: function CanvasGraphics_transform(a, b, c, d, e, f) {\n      this.ctx.transform(a, b, c, d, e, f);\n      this._cachedGetSinglePixelWidth = null;\n    },\n    constructPath: function CanvasGraphics_constructPath(ops, args) {\n      var ctx = this.ctx;\n      var current = this.current;\n      var x = current.x,\n          y = current.y;\n\n      for (var i = 0, j = 0, ii = ops.length; i < ii; i++) {\n        switch (ops[i] | 0) {\n          case _util.OPS.rectangle:\n            x = args[j++];\n            y = args[j++];\n            var width = args[j++];\n            var height = args[j++];\n\n            if (width === 0 && ctx.lineWidth < this.getSinglePixelWidth()) {\n              width = this.getSinglePixelWidth();\n            }\n\n            if (height === 0 && ctx.lineWidth < this.getSinglePixelWidth()) {\n              height = this.getSinglePixelWidth();\n            }\n\n            var xw = x + width;\n            var yh = y + height;\n            ctx.moveTo(x, y);\n            ctx.lineTo(xw, y);\n            ctx.lineTo(xw, yh);\n            ctx.lineTo(x, yh);\n            ctx.lineTo(x, y);\n            ctx.closePath();\n            break;\n\n          case _util.OPS.moveTo:\n            x = args[j++];\n            y = args[j++];\n            ctx.moveTo(x, y);\n            break;\n\n          case _util.OPS.lineTo:\n            x = args[j++];\n            y = args[j++];\n            ctx.lineTo(x, y);\n            break;\n\n          case _util.OPS.curveTo:\n            x = args[j + 4];\n            y = args[j + 5];\n            ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);\n            j += 6;\n            break;\n\n          case _util.OPS.curveTo2:\n            ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);\n            x = args[j + 2];\n            y = args[j + 3];\n            j += 4;\n            break;\n\n          case _util.OPS.curveTo3:\n            x = args[j + 2];\n            y = args[j + 3];\n            ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);\n            j += 4;\n            break;\n\n          case _util.OPS.closePath:\n            ctx.closePath();\n            break;\n        }\n      }\n\n      current.setCurrentPoint(x, y);\n    },\n    closePath: function CanvasGraphics_closePath() {\n      this.ctx.closePath();\n    },\n    stroke: function CanvasGraphics_stroke(consumePath) {\n      consumePath = typeof consumePath !== "undefined" ? consumePath : true;\n      var ctx = this.ctx;\n      var strokeColor = this.current.strokeColor;\n      ctx.globalAlpha = this.current.strokeAlpha;\n\n      if (this.contentVisible) {\n        if (strokeColor && strokeColor.hasOwnProperty("type") && strokeColor.type === "Pattern") {\n          ctx.save();\n          const transform = ctx.mozCurrentTransform;\n\n          const scale = _util.Util.singularValueDecompose2dScale(transform)[0];\n\n          ctx.strokeStyle = strokeColor.getPattern(ctx, this);\n          ctx.lineWidth = Math.max(this.getSinglePixelWidth() * MIN_WIDTH_FACTOR, this.current.lineWidth * scale);\n          ctx.stroke();\n          ctx.restore();\n        } else {\n          ctx.lineWidth = Math.max(this.getSinglePixelWidth() * MIN_WIDTH_FACTOR, this.current.lineWidth);\n          ctx.stroke();\n        }\n      }\n\n      if (consumePath) {\n        this.consumePath();\n      }\n\n      ctx.globalAlpha = this.current.fillAlpha;\n    },\n    closeStroke: function CanvasGraphics_closeStroke() {\n      this.closePath();\n      this.stroke();\n    },\n    fill: function CanvasGraphics_fill(consumePath) {\n      consumePath = typeof consumePath !== "undefined" ? consumePath : true;\n      var ctx = this.ctx;\n      var fillColor = this.current.fillColor;\n      var isPatternFill = this.current.patternFill;\n      var needRestore = false;\n\n      if (isPatternFill) {\n        ctx.save();\n\n        if (this.baseTransform) {\n          ctx.setTransform.apply(ctx, this.baseTransform);\n        }\n\n        ctx.fillStyle = fillColor.getPattern(ctx, this);\n        needRestore = true;\n      }\n\n      if (this.contentVisible) {\n        if (this.pendingEOFill) {\n          ctx.fill("evenodd");\n          this.pendingEOFill = false;\n        } else {\n          ctx.fill();\n        }\n      }\n\n      if (needRestore) {\n        ctx.restore();\n      }\n\n      if (consumePath) {\n        this.consumePath();\n      }\n    },\n    eoFill: function CanvasGraphics_eoFill() {\n      this.pendingEOFill = true;\n      this.fill();\n    },\n    fillStroke: function CanvasGraphics_fillStroke() {\n      this.fill(false);\n      this.stroke(false);\n      this.consumePath();\n    },\n    eoFillStroke: function CanvasGraphics_eoFillStroke() {\n      this.pendingEOFill = true;\n      this.fillStroke();\n    },\n    closeFillStroke: function CanvasGraphics_closeFillStroke() {\n      this.closePath();\n      this.fillStroke();\n    },\n    closeEOFillStroke: function CanvasGraphics_closeEOFillStroke() {\n      this.pendingEOFill = true;\n      this.closePath();\n      this.fillStroke();\n    },\n    endPath: function CanvasGraphics_endPath() {\n      this.consumePath();\n    },\n    clip: function CanvasGraphics_clip() {\n      this.pendingClip = NORMAL_CLIP;\n    },\n    eoClip: function CanvasGraphics_eoClip() {\n      this.pendingClip = EO_CLIP;\n    },\n    beginText: function CanvasGraphics_beginText() {\n      this.current.textMatrix = _util.IDENTITY_MATRIX;\n      this.current.textMatrixScale = 1;\n      this.current.x = this.current.lineX = 0;\n      this.current.y = this.current.lineY = 0;\n    },\n    endText: function CanvasGraphics_endText() {\n      var paths = this.pendingTextPaths;\n      var ctx = this.ctx;\n\n      if (paths === undefined) {\n        ctx.beginPath();\n        return;\n      }\n\n      ctx.save();\n      ctx.beginPath();\n\n      for (var i = 0; i < paths.length; i++) {\n        var path = paths[i];\n        ctx.setTransform.apply(ctx, path.transform);\n        ctx.translate(path.x, path.y);\n        path.addToPath(ctx, path.fontSize);\n      }\n\n      ctx.restore();\n      ctx.clip();\n      ctx.beginPath();\n      delete this.pendingTextPaths;\n    },\n    setCharSpacing: function CanvasGraphics_setCharSpacing(spacing) {\n      this.current.charSpacing = spacing;\n    },\n    setWordSpacing: function CanvasGraphics_setWordSpacing(spacing) {\n      this.current.wordSpacing = spacing;\n    },\n    setHScale: function CanvasGraphics_setHScale(scale) {\n      this.current.textHScale = scale / 100;\n    },\n    setLeading: function CanvasGraphics_setLeading(leading) {\n      this.current.leading = -leading;\n    },\n    setFont: function CanvasGraphics_setFont(fontRefName, size) {\n      var fontObj = this.commonObjs.get(fontRefName);\n      var current = this.current;\n\n      if (!fontObj) {\n        throw new Error(`Can\'t find font for ${fontRefName}`);\n      }\n\n      current.fontMatrix = fontObj.fontMatrix ? fontObj.fontMatrix : _util.FONT_IDENTITY_MATRIX;\n\n      if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {\n        (0, _util.warn)("Invalid font matrix for font " + fontRefName);\n      }\n\n      if (size < 0) {\n        size = -size;\n        current.fontDirection = -1;\n      } else {\n        current.fontDirection = 1;\n      }\n\n      this.current.font = fontObj;\n      this.current.fontSize = size;\n\n      if (fontObj.isType3Font) {\n        return;\n      }\n\n      var name = fontObj.loadedName || "sans-serif";\n      let bold = "normal";\n\n      if (fontObj.black) {\n        bold = "900";\n      } else if (fontObj.bold) {\n        bold = "bold";\n      }\n\n      var italic = fontObj.italic ? "italic" : "normal";\n      var typeface = `"${name}", ${fontObj.fallbackName}`;\n      let browserFontSize = size;\n\n      if (size < MIN_FONT_SIZE) {\n        browserFontSize = MIN_FONT_SIZE;\n      } else if (size > MAX_FONT_SIZE) {\n        browserFontSize = MAX_FONT_SIZE;\n      }\n\n      this.current.fontSizeScale = size / browserFontSize;\n      this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;\n    },\n    setTextRenderingMode: function CanvasGraphics_setTextRenderingMode(mode) {\n      this.current.textRenderingMode = mode;\n    },\n    setTextRise: function CanvasGraphics_setTextRise(rise) {\n      this.current.textRise = rise;\n    },\n    moveText: function CanvasGraphics_moveText(x, y) {\n      this.current.x = this.current.lineX += x;\n      this.current.y = this.current.lineY += y;\n    },\n    setLeadingMoveText: function CanvasGraphics_setLeadingMoveText(x, y) {\n      this.setLeading(-y);\n      this.moveText(x, y);\n    },\n    setTextMatrix: function CanvasGraphics_setTextMatrix(a, b, c, d, e, f) {\n      this.current.textMatrix = [a, b, c, d, e, f];\n      this.current.textMatrixScale = Math.sqrt(a * a + b * b);\n      this.current.x = this.current.lineX = 0;\n      this.current.y = this.current.lineY = 0;\n    },\n    nextLine: function CanvasGraphics_nextLine() {\n      this.moveText(0, this.current.leading);\n    },\n\n    paintChar(character, x, y, patternTransform) {\n      var ctx = this.ctx;\n      var current = this.current;\n      var font = current.font;\n      var textRenderingMode = current.textRenderingMode;\n      var fontSize = current.fontSize / current.fontSizeScale;\n      var fillStrokeMode = textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;\n      var isAddToPathSet = !!(textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG);\n      const patternFill = current.patternFill && !font.missingFile;\n      var addToPath;\n\n      if (font.disableFontFace || isAddToPathSet || patternFill) {\n        addToPath = font.getPathGenerator(this.commonObjs, character);\n      }\n\n      if (font.disableFontFace || patternFill) {\n        ctx.save();\n        ctx.translate(x, y);\n        ctx.beginPath();\n        addToPath(ctx, fontSize);\n\n        if (patternTransform) {\n          ctx.setTransform.apply(ctx, patternTransform);\n        }\n\n        if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n          ctx.fill();\n        }\n\n        if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n          ctx.stroke();\n        }\n\n        ctx.restore();\n      } else {\n        if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n          ctx.fillText(character, x, y);\n        }\n\n        if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n          ctx.strokeText(character, x, y);\n        }\n      }\n\n      if (isAddToPathSet) {\n        var paths = this.pendingTextPaths || (this.pendingTextPaths = []);\n        paths.push({\n          transform: ctx.mozCurrentTransform,\n          x,\n          y,\n          fontSize,\n          addToPath\n        });\n      }\n    },\n\n    get isFontSubpixelAAEnabled() {\n      const {\n        context: ctx\n      } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);\n      ctx.scale(1.5, 1);\n      ctx.fillText("I", 0, 10);\n      var data = ctx.getImageData(0, 0, 10, 10).data;\n      var enabled = false;\n\n      for (var i = 3; i < data.length; i += 4) {\n        if (data[i] > 0 && data[i] < 255) {\n          enabled = true;\n          break;\n        }\n      }\n\n      return (0, _util.shadow)(this, "isFontSubpixelAAEnabled", enabled);\n    },\n\n    showText: function CanvasGraphics_showText(glyphs) {\n      var current = this.current;\n      var font = current.font;\n\n      if (font.isType3Font) {\n        return this.showType3Text(glyphs);\n      }\n\n      var fontSize = current.fontSize;\n\n      if (fontSize === 0) {\n        return undefined;\n      }\n\n      var ctx = this.ctx;\n      var fontSizeScale = current.fontSizeScale;\n      var charSpacing = current.charSpacing;\n      var wordSpacing = current.wordSpacing;\n      var fontDirection = current.fontDirection;\n      var textHScale = current.textHScale * fontDirection;\n      var glyphsLength = glyphs.length;\n      var vertical = font.vertical;\n      var spacingDir = vertical ? 1 : -1;\n      var defaultVMetrics = font.defaultVMetrics;\n      var widthAdvanceScale = fontSize * current.fontMatrix[0];\n      var simpleFillText = current.textRenderingMode === _util.TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;\n      ctx.save();\n      let patternTransform;\n\n      if (current.patternFill) {\n        ctx.save();\n        const pattern = current.fillColor.getPattern(ctx, this);\n        patternTransform = ctx.mozCurrentTransform;\n        ctx.restore();\n        ctx.fillStyle = pattern;\n      }\n\n      ctx.transform.apply(ctx, current.textMatrix);\n      ctx.translate(current.x, current.y + current.textRise);\n\n      if (fontDirection > 0) {\n        ctx.scale(textHScale, -1);\n      } else {\n        ctx.scale(textHScale, 1);\n      }\n\n      var lineWidth = current.lineWidth;\n      var scale = current.textMatrixScale;\n\n      if (scale === 0 || lineWidth === 0) {\n        var fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;\n\n        if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n          this._cachedGetSinglePixelWidth = null;\n          lineWidth = this.getSinglePixelWidth() * MIN_WIDTH_FACTOR;\n        }\n      } else {\n        lineWidth /= scale;\n      }\n\n      if (fontSizeScale !== 1.0) {\n        ctx.scale(fontSizeScale, fontSizeScale);\n        lineWidth /= fontSizeScale;\n      }\n\n      ctx.lineWidth = lineWidth;\n      var x = 0,\n          i;\n\n      for (i = 0; i < glyphsLength; ++i) {\n        var glyph = glyphs[i];\n\n        if ((0, _util.isNum)(glyph)) {\n          x += spacingDir * glyph * fontSize / 1000;\n          continue;\n        }\n\n        var restoreNeeded = false;\n        var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n        var character = glyph.fontChar;\n        var accent = glyph.accent;\n        var scaledX, scaledY, scaledAccentX, scaledAccentY;\n        var width = glyph.width;\n\n        if (vertical) {\n          var vmetric, vx, vy;\n          vmetric = glyph.vmetric || defaultVMetrics;\n          vx = glyph.vmetric ? vmetric[1] : width * 0.5;\n          vx = -vx * widthAdvanceScale;\n          vy = vmetric[2] * widthAdvanceScale;\n          width = vmetric ? -vmetric[0] : width;\n          scaledX = vx / fontSizeScale;\n          scaledY = (x + vy) / fontSizeScale;\n        } else {\n          scaledX = x / fontSizeScale;\n          scaledY = 0;\n        }\n\n        if (font.remeasure && width > 0) {\n          var measuredWidth = ctx.measureText(character).width * 1000 / fontSize * fontSizeScale;\n\n          if (width < measuredWidth && this.isFontSubpixelAAEnabled) {\n            var characterScaleX = width / measuredWidth;\n            restoreNeeded = true;\n            ctx.save();\n            ctx.scale(characterScaleX, 1);\n            scaledX /= characterScaleX;\n          } else if (width !== measuredWidth) {\n            scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale;\n          }\n        }\n\n        if (this.contentVisible && (glyph.isInFont || font.missingFile)) {\n          if (simpleFillText && !accent) {\n            ctx.fillText(character, scaledX, scaledY);\n          } else {\n            this.paintChar(character, scaledX, scaledY, patternTransform);\n\n            if (accent) {\n              scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;\n              scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;\n              this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform);\n            }\n          }\n        }\n\n        var charWidth;\n\n        if (vertical) {\n          charWidth = width * widthAdvanceScale - spacing * fontDirection;\n        } else {\n          charWidth = width * widthAdvanceScale + spacing * fontDirection;\n        }\n\n        x += charWidth;\n\n        if (restoreNeeded) {\n          ctx.restore();\n        }\n      }\n\n      if (vertical) {\n        current.y -= x;\n      } else {\n        current.x += x * textHScale;\n      }\n\n      ctx.restore();\n    },\n    showType3Text: function CanvasGraphics_showType3Text(glyphs) {\n      var ctx = this.ctx;\n      var current = this.current;\n      var font = current.font;\n      var fontSize = current.fontSize;\n      var fontDirection = current.fontDirection;\n      var spacingDir = font.vertical ? 1 : -1;\n      var charSpacing = current.charSpacing;\n      var wordSpacing = current.wordSpacing;\n      var textHScale = current.textHScale * fontDirection;\n      var fontMatrix = current.fontMatrix || _util.FONT_IDENTITY_MATRIX;\n      var glyphsLength = glyphs.length;\n      var isTextInvisible = current.textRenderingMode === _util.TextRenderingMode.INVISIBLE;\n      var i, glyph, width, spacingLength;\n\n      if (isTextInvisible || fontSize === 0) {\n        return;\n      }\n\n      this._cachedGetSinglePixelWidth = null;\n      ctx.save();\n      ctx.transform.apply(ctx, current.textMatrix);\n      ctx.translate(current.x, current.y);\n      ctx.scale(textHScale, fontDirection);\n\n      for (i = 0; i < glyphsLength; ++i) {\n        glyph = glyphs[i];\n\n        if ((0, _util.isNum)(glyph)) {\n          spacingLength = spacingDir * glyph * fontSize / 1000;\n          this.ctx.translate(spacingLength, 0);\n          current.x += spacingLength * textHScale;\n          continue;\n        }\n\n        var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n        var operatorList = font.charProcOperatorList[glyph.operatorListId];\n\n        if (!operatorList) {\n          (0, _util.warn)(`Type3 character "${glyph.operatorListId}" is not available.`);\n          continue;\n        }\n\n        if (this.contentVisible) {\n          this.processingType3 = glyph;\n          this.save();\n          ctx.scale(fontSize, fontSize);\n          ctx.transform.apply(ctx, fontMatrix);\n          this.executeOperatorList(operatorList);\n          this.restore();\n        }\n\n        var transformed = _util.Util.applyTransform([glyph.width, 0], fontMatrix);\n\n        width = transformed[0] * fontSize + spacing;\n        ctx.translate(width, 0);\n        current.x += width * textHScale;\n      }\n\n      ctx.restore();\n      this.processingType3 = null;\n    },\n    setCharWidth: function CanvasGraphics_setCharWidth(xWidth, yWidth) {},\n    setCharWidthAndBounds: function CanvasGraphics_setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {\n      this.ctx.rect(llx, lly, urx - llx, ury - lly);\n      this.clip();\n      this.endPath();\n    },\n    getColorN_Pattern: function CanvasGraphics_getColorN_Pattern(IR) {\n      var pattern;\n\n      if (IR[0] === "TilingPattern") {\n        var color = IR[1];\n        var baseTransform = this.baseTransform || this.ctx.mozCurrentTransform.slice();\n        var canvasGraphicsFactory = {\n          createCanvasGraphics: ctx => {\n            return new CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory, this.webGLContext);\n          }\n        };\n        pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);\n      } else {\n        pattern = (0, _pattern_helper.getShadingPatternFromIR)(IR);\n      }\n\n      return pattern;\n    },\n    setStrokeColorN: function CanvasGraphics_setStrokeColorN() {\n      this.current.strokeColor = this.getColorN_Pattern(arguments);\n    },\n    setFillColorN: function CanvasGraphics_setFillColorN() {\n      this.current.fillColor = this.getColorN_Pattern(arguments);\n      this.current.patternFill = true;\n    },\n    setStrokeRGBColor: function CanvasGraphics_setStrokeRGBColor(r, g, b) {\n      var color = _util.Util.makeCssRgb(r, g, b);\n\n      this.ctx.strokeStyle = color;\n      this.current.strokeColor = color;\n    },\n    setFillRGBColor: function CanvasGraphics_setFillRGBColor(r, g, b) {\n      var color = _util.Util.makeCssRgb(r, g, b);\n\n      this.ctx.fillStyle = color;\n      this.current.fillColor = color;\n      this.current.patternFill = false;\n    },\n    shadingFill: function CanvasGraphics_shadingFill(patternIR) {\n      if (!this.contentVisible) {\n        return;\n      }\n\n      var ctx = this.ctx;\n      this.save();\n      var pattern = (0, _pattern_helper.getShadingPatternFromIR)(patternIR);\n      ctx.fillStyle = pattern.getPattern(ctx, this, true);\n      var inv = ctx.mozCurrentTransformInverse;\n\n      if (inv) {\n        var canvas = ctx.canvas;\n        var width = canvas.width;\n        var height = canvas.height;\n\n        var bl = _util.Util.applyTransform([0, 0], inv);\n\n        var br = _util.Util.applyTransform([0, height], inv);\n\n        var ul = _util.Util.applyTransform([width, 0], inv);\n\n        var ur = _util.Util.applyTransform([width, height], inv);\n\n        var x0 = Math.min(bl[0], br[0], ul[0], ur[0]);\n        var y0 = Math.min(bl[1], br[1], ul[1], ur[1]);\n        var x1 = Math.max(bl[0], br[0], ul[0], ur[0]);\n        var y1 = Math.max(bl[1], br[1], ul[1], ur[1]);\n        this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);\n      } else {\n        this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);\n      }\n\n      this.restore();\n    },\n    beginInlineImage: function CanvasGraphics_beginInlineImage() {\n      (0, _util.unreachable)("Should not call beginInlineImage");\n    },\n    beginImageData: function CanvasGraphics_beginImageData() {\n      (0, _util.unreachable)("Should not call beginImageData");\n    },\n    paintFormXObjectBegin: function CanvasGraphics_paintFormXObjectBegin(matrix, bbox) {\n      if (!this.contentVisible) {\n        return;\n      }\n\n      this.save();\n      this.baseTransformStack.push(this.baseTransform);\n\n      if (Array.isArray(matrix) && matrix.length === 6) {\n        this.transform.apply(this, matrix);\n      }\n\n      this.baseTransform = this.ctx.mozCurrentTransform;\n\n      if (bbox) {\n        var width = bbox[2] - bbox[0];\n        var height = bbox[3] - bbox[1];\n        this.ctx.rect(bbox[0], bbox[1], width, height);\n        this.clip();\n        this.endPath();\n      }\n    },\n    paintFormXObjectEnd: function CanvasGraphics_paintFormXObjectEnd() {\n      if (!this.contentVisible) {\n        return;\n      }\n\n      this.restore();\n      this.baseTransform = this.baseTransformStack.pop();\n    },\n    beginGroup: function CanvasGraphics_beginGroup(group) {\n      if (!this.contentVisible) {\n        return;\n      }\n\n      this.save();\n      var currentCtx = this.ctx;\n\n      if (!group.isolated) {\n        (0, _util.info)("TODO: Support non-isolated groups.");\n      }\n\n      if (group.knockout) {\n        (0, _util.warn)("Knockout groups not supported.");\n      }\n\n      var currentTransform = currentCtx.mozCurrentTransform;\n\n      if (group.matrix) {\n        currentCtx.transform.apply(currentCtx, group.matrix);\n      }\n\n      if (!group.bbox) {\n        throw new Error("Bounding box is required.");\n      }\n\n      var bounds = _util.Util.getAxialAlignedBoundingBox(group.bbox, currentCtx.mozCurrentTransform);\n\n      var canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];\n      bounds = _util.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];\n      var offsetX = Math.floor(bounds[0]);\n      var offsetY = Math.floor(bounds[1]);\n      var drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);\n      var drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);\n      var scaleX = 1,\n          scaleY = 1;\n\n      if (drawnWidth > MAX_GROUP_SIZE) {\n        scaleX = drawnWidth / MAX_GROUP_SIZE;\n        drawnWidth = MAX_GROUP_SIZE;\n      }\n\n      if (drawnHeight > MAX_GROUP_SIZE) {\n        scaleY = drawnHeight / MAX_GROUP_SIZE;\n        drawnHeight = MAX_GROUP_SIZE;\n      }\n\n      var cacheId = "groupAt" + this.groupLevel;\n\n      if (group.smask) {\n        cacheId += "_smask_" + this.smaskCounter++ % 2;\n      }\n\n      var scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);\n      var groupCtx = scratchCanvas.context;\n      groupCtx.scale(1 / scaleX, 1 / scaleY);\n      groupCtx.translate(-offsetX, -offsetY);\n      groupCtx.transform.apply(groupCtx, currentTransform);\n\n      if (group.smask) {\n        this.smaskStack.push({\n          canvas: scratchCanvas.canvas,\n          context: groupCtx,\n          offsetX,\n          offsetY,\n          scaleX,\n          scaleY,\n          subtype: group.smask.subtype,\n          backdrop: group.smask.backdrop,\n          transferMap: group.smask.transferMap || null,\n          startTransformInverse: null\n        });\n      } else {\n        currentCtx.setTransform(1, 0, 0, 1, 0, 0);\n        currentCtx.translate(offsetX, offsetY);\n        currentCtx.scale(scaleX, scaleY);\n      }\n\n      copyCtxState(currentCtx, groupCtx);\n      this.ctx = groupCtx;\n      this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);\n      this.groupStack.push(currentCtx);\n      this.groupLevel++;\n      this.current.activeSMask = null;\n    },\n    endGroup: function CanvasGraphics_endGroup(group) {\n      if (!this.contentVisible) {\n        return;\n      }\n\n      this.groupLevel--;\n      var groupCtx = this.ctx;\n      this.ctx = this.groupStack.pop();\n\n      if (this.ctx.imageSmoothingEnabled !== undefined) {\n        this.ctx.imageSmoothingEnabled = false;\n      } else {\n        this.ctx.mozImageSmoothingEnabled = false;\n      }\n\n      if (group.smask) {\n        this.tempSMask = this.smaskStack.pop();\n      } else {\n        this.ctx.drawImage(groupCtx.canvas, 0, 0);\n      }\n\n      this.restore();\n    },\n    beginAnnotations: function CanvasGraphics_beginAnnotations() {\n      this.save();\n\n      if (this.baseTransform) {\n        this.ctx.setTransform.apply(this.ctx, this.baseTransform);\n      }\n    },\n    endAnnotations: function CanvasGraphics_endAnnotations() {\n      this.restore();\n    },\n    beginAnnotation: function CanvasGraphics_beginAnnotation(rect, transform, matrix) {\n      this.save();\n      resetCtxToDefault(this.ctx);\n      this.current = new CanvasExtraState();\n\n      if (Array.isArray(rect) && rect.length === 4) {\n        var width = rect[2] - rect[0];\n        var height = rect[3] - rect[1];\n        this.ctx.rect(rect[0], rect[1], width, height);\n        this.clip();\n        this.endPath();\n      }\n\n      this.transform.apply(this, transform);\n      this.transform.apply(this, matrix);\n    },\n    endAnnotation: function CanvasGraphics_endAnnotation() {\n      this.restore();\n    },\n    paintImageMaskXObject: function CanvasGraphics_paintImageMaskXObject(img) {\n      if (!this.contentVisible) {\n        return;\n      }\n\n      var ctx = this.ctx;\n      var width = img.width,\n          height = img.height;\n      var fillColor = this.current.fillColor;\n      var isPatternFill = this.current.patternFill;\n      var glyph = this.processingType3;\n\n      if (COMPILE_TYPE3_GLYPHS && glyph && glyph.compiled === undefined) {\n        if (width <= MAX_SIZE_TO_COMPILE && height <= MAX_SIZE_TO_COMPILE) {\n          glyph.compiled = compileType3Glyph({\n            data: img.data,\n            width,\n            height\n          });\n        } else {\n          glyph.compiled = null;\n        }\n      }\n\n      if (glyph && glyph.compiled) {\n        glyph.compiled(ctx);\n        return;\n      }\n\n      var maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);\n      var maskCtx = maskCanvas.context;\n      maskCtx.save();\n      putBinaryImageMask(maskCtx, img);\n      maskCtx.globalCompositeOperation = "source-in";\n      maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;\n      maskCtx.fillRect(0, 0, width, height);\n      maskCtx.restore();\n      this.paintInlineImageXObject(maskCanvas.canvas);\n    },\n\n    paintImageMaskXObjectRepeat(imgData, scaleX, skewX = 0, skewY = 0, scaleY, positions) {\n      if (!this.contentVisible) {\n        return;\n      }\n\n      var width = imgData.width;\n      var height = imgData.height;\n      var fillColor = this.current.fillColor;\n      var isPatternFill = this.current.patternFill;\n      var maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);\n      var maskCtx = maskCanvas.context;\n      maskCtx.save();\n      putBinaryImageMask(maskCtx, imgData);\n      maskCtx.globalCompositeOperation = "source-in";\n      maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;\n      maskCtx.fillRect(0, 0, width, height);\n      maskCtx.restore();\n      var ctx = this.ctx;\n\n      for (var i = 0, ii = positions.length; i < ii; i += 2) {\n        ctx.save();\n        ctx.transform(scaleX, skewX, skewY, scaleY, positions[i], positions[i + 1]);\n        ctx.scale(1, -1);\n        ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);\n        ctx.restore();\n      }\n    },\n\n    paintImageMaskXObjectGroup: function CanvasGraphics_paintImageMaskXObjectGroup(images) {\n      if (!this.contentVisible) {\n        return;\n      }\n\n      var ctx = this.ctx;\n      var fillColor = this.current.fillColor;\n      var isPatternFill = this.current.patternFill;\n\n      for (var i = 0, ii = images.length; i < ii; i++) {\n        var image = images[i];\n        var width = image.width,\n            height = image.height;\n        var maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);\n        var maskCtx = maskCanvas.context;\n        maskCtx.save();\n        putBinaryImageMask(maskCtx, image);\n        maskCtx.globalCompositeOperation = "source-in";\n        maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;\n        maskCtx.fillRect(0, 0, width, height);\n        maskCtx.restore();\n        ctx.save();\n        ctx.transform.apply(ctx, image.transform);\n        ctx.scale(1, -1);\n        ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);\n        ctx.restore();\n      }\n    },\n    paintImageXObject: function CanvasGraphics_paintImageXObject(objId) {\n      if (!this.contentVisible) {\n        return;\n      }\n\n      const imgData = objId.startsWith("g_") ? this.commonObjs.get(objId) : this.objs.get(objId);\n\n      if (!imgData) {\n        (0, _util.warn)("Dependent image isn\'t ready yet");\n        return;\n      }\n\n      this.paintInlineImageXObject(imgData);\n    },\n    paintImageXObjectRepeat: function CanvasGraphics_paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {\n      if (!this.contentVisible) {\n        return;\n      }\n\n      const imgData = objId.startsWith("g_") ? this.commonObjs.get(objId) : this.objs.get(objId);\n\n      if (!imgData) {\n        (0, _util.warn)("Dependent image isn\'t ready yet");\n        return;\n      }\n\n      var width = imgData.width;\n      var height = imgData.height;\n      var map = [];\n\n      for (var i = 0, ii = positions.length; i < ii; i += 2) {\n        map.push({\n          transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],\n          x: 0,\n          y: 0,\n          w: width,\n          h: height\n        });\n      }\n\n      this.paintInlineImageXObjectGroup(imgData, map);\n    },\n    paintInlineImageXObject: function CanvasGraphics_paintInlineImageXObject(imgData) {\n      if (!this.contentVisible) {\n        return;\n      }\n\n      var width = imgData.width;\n      var height = imgData.height;\n      var ctx = this.ctx;\n      this.save();\n      ctx.scale(1 / width, -1 / height);\n      var currentTransform = ctx.mozCurrentTransformInverse;\n      var a = currentTransform[0],\n          b = currentTransform[1];\n      var widthScale = Math.max(Math.sqrt(a * a + b * b), 1);\n      var c = currentTransform[2],\n          d = currentTransform[3];\n      var heightScale = Math.max(Math.sqrt(c * c + d * d), 1);\n      var imgToPaint, tmpCanvas;\n\n      if (typeof HTMLElement === "function" && imgData instanceof HTMLElement || !imgData.data) {\n        imgToPaint = imgData;\n      } else {\n        tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height);\n        var tmpCtx = tmpCanvas.context;\n        putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);\n        imgToPaint = tmpCanvas.canvas;\n      }\n\n      var paintWidth = width,\n          paintHeight = height;\n      var tmpCanvasId = "prescale1";\n\n      while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {\n        var newWidth = paintWidth,\n            newHeight = paintHeight;\n\n        if (widthScale > 2 && paintWidth > 1) {\n          newWidth = Math.ceil(paintWidth / 2);\n          widthScale /= paintWidth / newWidth;\n        }\n\n        if (heightScale > 2 && paintHeight > 1) {\n          newHeight = Math.ceil(paintHeight / 2);\n          heightScale /= paintHeight / newHeight;\n        }\n\n        tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);\n        tmpCtx = tmpCanvas.context;\n        tmpCtx.clearRect(0, 0, newWidth, newHeight);\n        tmpCtx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);\n        imgToPaint = tmpCanvas.canvas;\n        paintWidth = newWidth;\n        paintHeight = newHeight;\n        tmpCanvasId = tmpCanvasId === "prescale1" ? "prescale2" : "prescale1";\n      }\n\n      ctx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight, 0, -height, width, height);\n\n      if (this.imageLayer) {\n        var position = this.getCanvasPosition(0, -height);\n        this.imageLayer.appendImage({\n          imgData,\n          left: position[0],\n          top: position[1],\n          width: width / currentTransform[0],\n          height: height / currentTransform[3]\n        });\n      }\n\n      this.restore();\n    },\n    paintInlineImageXObjectGroup: function CanvasGraphics_paintInlineImageXObjectGroup(imgData, map) {\n      if (!this.contentVisible) {\n        return;\n      }\n\n      var ctx = this.ctx;\n      var w = imgData.width;\n      var h = imgData.height;\n      var tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", w, h);\n      var tmpCtx = tmpCanvas.context;\n      putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);\n\n      for (var i = 0, ii = map.length; i < ii; i++) {\n        var entry = map[i];\n        ctx.save();\n        ctx.transform.apply(ctx, entry.transform);\n        ctx.scale(1, -1);\n        ctx.drawImage(tmpCanvas.canvas, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);\n\n        if (this.imageLayer) {\n          var position = this.getCanvasPosition(entry.x, entry.y);\n          this.imageLayer.appendImage({\n            imgData,\n            left: position[0],\n            top: position[1],\n            width: w,\n            height: h\n          });\n        }\n\n        ctx.restore();\n      }\n    },\n    paintSolidColorImageMask: function CanvasGraphics_paintSolidColorImageMask() {\n      if (!this.contentVisible) {\n        return;\n      }\n\n      this.ctx.fillRect(0, 0, 1, 1);\n    },\n    markPoint: function CanvasGraphics_markPoint(tag) {},\n    markPointProps: function CanvasGraphics_markPointProps(tag, properties) {},\n    beginMarkedContent: function CanvasGraphics_beginMarkedContent(tag) {\n      this.markedContentStack.push({\n        visible: true\n      });\n    },\n    beginMarkedContentProps: function CanvasGraphics_beginMarkedContentProps(tag, properties) {\n      if (tag === "OC") {\n        this.markedContentStack.push({\n          visible: this.optionalContentConfig.isVisible(properties)\n        });\n      } else {\n        this.markedContentStack.push({\n          visible: true\n        });\n      }\n\n      this.contentVisible = this.isContentVisible();\n    },\n    endMarkedContent: function CanvasGraphics_endMarkedContent() {\n      this.markedContentStack.pop();\n      this.contentVisible = this.isContentVisible();\n    },\n    beginCompat: function CanvasGraphics_beginCompat() {},\n    endCompat: function CanvasGraphics_endCompat() {},\n    consumePath: function CanvasGraphics_consumePath() {\n      var ctx = this.ctx;\n\n      if (this.pendingClip) {\n        if (this.pendingClip === EO_CLIP) {\n          ctx.clip("evenodd");\n        } else {\n          ctx.clip();\n        }\n\n        this.pendingClip = null;\n      }\n\n      ctx.beginPath();\n    },\n\n    getSinglePixelWidth(scale) {\n      if (this._cachedGetSinglePixelWidth === null) {\n        const inverse = this.ctx.mozCurrentTransformInverse;\n        this._cachedGetSinglePixelWidth = Math.sqrt(Math.max(inverse[0] * inverse[0] + inverse[1] * inverse[1], inverse[2] * inverse[2] + inverse[3] * inverse[3]));\n      }\n\n      return this._cachedGetSinglePixelWidth;\n    },\n\n    getCanvasPosition: function CanvasGraphics_getCanvasPosition(x, y) {\n      var transform = this.ctx.mozCurrentTransform;\n      return [transform[0] * x + transform[2] * y + transform[4], transform[1] * x + transform[3] * y + transform[5]];\n    },\n    isContentVisible: function CanvasGraphics_isContentVisible() {\n      for (let i = this.markedContentStack.length - 1; i >= 0; i--) {\n        if (!this.markedContentStack[i].visible) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  };\n\n  for (var op in _util.OPS) {\n    CanvasGraphics.prototype[_util.OPS[op]] = CanvasGraphics.prototype[op];\n  }\n\n  return CanvasGraphics;\n}();\n\nexports.CanvasGraphics = CanvasGraphics;\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n"use strict";\n\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.getShadingPatternFromIR = getShadingPatternFromIR;\nexports.TilingPattern = void 0;\n\nvar _util = __w_pdfjs_require__(2);\n\nvar ShadingIRs = {};\n\nfunction applyBoundingBox(ctx, bbox) {\n  if (!bbox || typeof Path2D === "undefined") {\n    return;\n  }\n\n  const width = bbox[2] - bbox[0];\n  const height = bbox[3] - bbox[1];\n  const region = new Path2D();\n  region.rect(bbox[0], bbox[1], width, height);\n  ctx.clip(region);\n}\n\nShadingIRs.RadialAxial = {\n  fromIR: function RadialAxial_fromIR(raw) {\n    var type = raw[1];\n    var bbox = raw[2];\n    var colorStops = raw[3];\n    var p0 = raw[4];\n    var p1 = raw[5];\n    var r0 = raw[6];\n    var r1 = raw[7];\n    return {\n      type: "Pattern",\n      getPattern: function RadialAxial_getPattern(ctx) {\n        applyBoundingBox(ctx, bbox);\n        var grad;\n\n        if (type === "axial") {\n          grad = ctx.createLinearGradient(p0[0], p0[1], p1[0], p1[1]);\n        } else if (type === "radial") {\n          grad = ctx.createRadialGradient(p0[0], p0[1], r0, p1[0], p1[1], r1);\n        }\n\n        for (var i = 0, ii = colorStops.length; i < ii; ++i) {\n          var c = colorStops[i];\n          grad.addColorStop(c[0], c[1]);\n        }\n\n        return grad;\n      }\n    };\n  }\n};\n\nvar createMeshCanvas = function createMeshCanvasClosure() {\n  function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {\n    var coords = context.coords,\n        colors = context.colors;\n    var bytes = data.data,\n        rowSize = data.width * 4;\n    var tmp;\n\n    if (coords[p1 + 1] > coords[p2 + 1]) {\n      tmp = p1;\n      p1 = p2;\n      p2 = tmp;\n      tmp = c1;\n      c1 = c2;\n      c2 = tmp;\n    }\n\n    if (coords[p2 + 1] > coords[p3 + 1]) {\n      tmp = p2;\n      p2 = p3;\n      p3 = tmp;\n      tmp = c2;\n      c2 = c3;\n      c3 = tmp;\n    }\n\n    if (coords[p1 + 1] > coords[p2 + 1]) {\n      tmp = p1;\n      p1 = p2;\n      p2 = tmp;\n      tmp = c1;\n      c1 = c2;\n      c2 = tmp;\n    }\n\n    var x1 = (coords[p1] + context.offsetX) * context.scaleX;\n    var y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;\n    var x2 = (coords[p2] + context.offsetX) * context.scaleX;\n    var y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;\n    var x3 = (coords[p3] + context.offsetX) * context.scaleX;\n    var y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;\n\n    if (y1 >= y3) {\n      return;\n    }\n\n    var c1r = colors[c1],\n        c1g = colors[c1 + 1],\n        c1b = colors[c1 + 2];\n    var c2r = colors[c2],\n        c2g = colors[c2 + 1],\n        c2b = colors[c2 + 2];\n    var c3r = colors[c3],\n        c3g = colors[c3 + 1],\n        c3b = colors[c3 + 2];\n    var minY = Math.round(y1),\n        maxY = Math.round(y3);\n    var xa, car, cag, cab;\n    var xb, cbr, cbg, cbb;\n\n    for (var y = minY; y <= maxY; y++) {\n      if (y < y2) {\n        let k;\n\n        if (y < y1) {\n          k = 0;\n        } else if (y1 === y2) {\n          k = 1;\n        } else {\n          k = (y1 - y) / (y1 - y2);\n        }\n\n        xa = x1 - (x1 - x2) * k;\n        car = c1r - (c1r - c2r) * k;\n        cag = c1g - (c1g - c2g) * k;\n        cab = c1b - (c1b - c2b) * k;\n      } else {\n        let k;\n\n        if (y > y3) {\n          k = 1;\n        } else if (y2 === y3) {\n          k = 0;\n        } else {\n          k = (y2 - y) / (y2 - y3);\n        }\n\n        xa = x2 - (x2 - x3) * k;\n        car = c2r - (c2r - c3r) * k;\n        cag = c2g - (c2g - c3g) * k;\n        cab = c2b - (c2b - c3b) * k;\n      }\n\n      let k;\n\n      if (y < y1) {\n        k = 0;\n      } else if (y > y3) {\n        k = 1;\n      } else {\n        k = (y1 - y) / (y1 - y3);\n      }\n\n      xb = x1 - (x1 - x3) * k;\n      cbr = c1r - (c1r - c3r) * k;\n      cbg = c1g - (c1g - c3g) * k;\n      cbb = c1b - (c1b - c3b) * k;\n      var x1_ = Math.round(Math.min(xa, xb));\n      var x2_ = Math.round(Math.max(xa, xb));\n      var j = rowSize * y + x1_ * 4;\n\n      for (var x = x1_; x <= x2_; x++) {\n        k = (xa - x) / (xa - xb);\n\n        if (k < 0) {\n          k = 0;\n        } else if (k > 1) {\n          k = 1;\n        }\n\n        bytes[j++] = car - (car - cbr) * k | 0;\n        bytes[j++] = cag - (cag - cbg) * k | 0;\n        bytes[j++] = cab - (cab - cbb) * k | 0;\n        bytes[j++] = 255;\n      }\n    }\n  }\n\n  function drawFigure(data, figure, context) {\n    var ps = figure.coords;\n    var cs = figure.colors;\n    var i, ii;\n\n    switch (figure.type) {\n      case "lattice":\n        var verticesPerRow = figure.verticesPerRow;\n        var rows = Math.floor(ps.length / verticesPerRow) - 1;\n        var cols = verticesPerRow - 1;\n\n        for (i = 0; i < rows; i++) {\n          var q = i * verticesPerRow;\n\n          for (var j = 0; j < cols; j++, q++) {\n            drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);\n            drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);\n          }\n        }\n\n        break;\n\n      case "triangles":\n        for (i = 0, ii = ps.length; i < ii; i += 3) {\n          drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);\n        }\n\n        break;\n\n      default:\n        throw new Error("illegal figure");\n    }\n  }\n\n  function createMeshCanvas(bounds, combinesScale, coords, colors, figures, backgroundColor, cachedCanvases, webGLContext) {\n    var EXPECTED_SCALE = 1.1;\n    var MAX_PATTERN_SIZE = 3000;\n    var BORDER_SIZE = 2;\n    var offsetX = Math.floor(bounds[0]);\n    var offsetY = Math.floor(bounds[1]);\n    var boundsWidth = Math.ceil(bounds[2]) - offsetX;\n    var boundsHeight = Math.ceil(bounds[3]) - offsetY;\n    var width = Math.min(Math.ceil(Math.abs(boundsWidth * combinesScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n    var height = Math.min(Math.ceil(Math.abs(boundsHeight * combinesScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n    var scaleX = boundsWidth / width;\n    var scaleY = boundsHeight / height;\n    var context = {\n      coords,\n      colors,\n      offsetX: -offsetX,\n      offsetY: -offsetY,\n      scaleX: 1 / scaleX,\n      scaleY: 1 / scaleY\n    };\n    var paddedWidth = width + BORDER_SIZE * 2;\n    var paddedHeight = height + BORDER_SIZE * 2;\n    var canvas, tmpCanvas, i, ii;\n\n    if (webGLContext.isEnabled) {\n      canvas = webGLContext.drawFigures({\n        width,\n        height,\n        backgroundColor,\n        figures,\n        context\n      });\n      tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight, false);\n      tmpCanvas.context.drawImage(canvas, BORDER_SIZE, BORDER_SIZE);\n      canvas = tmpCanvas.canvas;\n    } else {\n      tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight, false);\n      var tmpCtx = tmpCanvas.context;\n      var data = tmpCtx.createImageData(width, height);\n\n      if (backgroundColor) {\n        var bytes = data.data;\n\n        for (i = 0, ii = bytes.length; i < ii; i += 4) {\n          bytes[i] = backgroundColor[0];\n          bytes[i + 1] = backgroundColor[1];\n          bytes[i + 2] = backgroundColor[2];\n          bytes[i + 3] = 255;\n        }\n      }\n\n      for (i = 0; i < figures.length; i++) {\n        drawFigure(data, figures[i], context);\n      }\n\n      tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);\n      canvas = tmpCanvas.canvas;\n    }\n\n    return {\n      canvas,\n      offsetX: offsetX - BORDER_SIZE * scaleX,\n      offsetY: offsetY - BORDER_SIZE * scaleY,\n      scaleX,\n      scaleY\n    };\n  }\n\n  return createMeshCanvas;\n}();\n\nShadingIRs.Mesh = {\n  fromIR: function Mesh_fromIR(raw) {\n    var coords = raw[2];\n    var colors = raw[3];\n    var figures = raw[4];\n    var bounds = raw[5];\n    var matrix = raw[6];\n    var bbox = raw[7];\n    var background = raw[8];\n    return {\n      type: "Pattern",\n      getPattern: function Mesh_getPattern(ctx, owner, shadingFill) {\n        applyBoundingBox(ctx, bbox);\n        var scale;\n\n        if (shadingFill) {\n          scale = _util.Util.singularValueDecompose2dScale(ctx.mozCurrentTransform);\n        } else {\n          scale = _util.Util.singularValueDecompose2dScale(owner.baseTransform);\n\n          if (matrix) {\n            var matrixScale = _util.Util.singularValueDecompose2dScale(matrix);\n\n            scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];\n          }\n        }\n\n        var temporaryPatternCanvas = createMeshCanvas(bounds, scale, coords, colors, figures, shadingFill ? null : background, owner.cachedCanvases, owner.webGLContext);\n\n        if (!shadingFill) {\n          ctx.setTransform.apply(ctx, owner.baseTransform);\n\n          if (matrix) {\n            ctx.transform.apply(ctx, matrix);\n          }\n        }\n\n        ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n        ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);\n        return ctx.createPattern(temporaryPatternCanvas.canvas, "no-repeat");\n      }\n    };\n  }\n};\nShadingIRs.Dummy = {\n  fromIR: function Dummy_fromIR() {\n    return {\n      type: "Pattern",\n      getPattern: function Dummy_fromIR_getPattern() {\n        return "hotpink";\n      }\n    };\n  }\n};\n\nfunction getShadingPatternFromIR(raw) {\n  var shadingIR = ShadingIRs[raw[0]];\n\n  if (!shadingIR) {\n    throw new Error(`Unknown IR type: ${raw[0]}`);\n  }\n\n  return shadingIR.fromIR(raw);\n}\n\nvar TilingPattern = function TilingPatternClosure() {\n  var PaintType = {\n    COLORED: 1,\n    UNCOLORED: 2\n  };\n  var MAX_PATTERN_SIZE = 3000;\n\n  function TilingPattern(IR, color, ctx, canvasGraphicsFactory, baseTransform) {\n    this.operatorList = IR[2];\n    this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];\n    this.bbox = IR[4];\n    this.xstep = IR[5];\n    this.ystep = IR[6];\n    this.paintType = IR[7];\n    this.tilingType = IR[8];\n    this.color = color;\n    this.canvasGraphicsFactory = canvasGraphicsFactory;\n    this.baseTransform = baseTransform;\n    this.type = "Pattern";\n    this.ctx = ctx;\n  }\n\n  TilingPattern.prototype = {\n    createPatternCanvas: function TilinPattern_createPatternCanvas(owner) {\n      var operatorList = this.operatorList;\n      var bbox = this.bbox;\n      var xstep = this.xstep;\n      var ystep = this.ystep;\n      var paintType = this.paintType;\n      var tilingType = this.tilingType;\n      var color = this.color;\n      var canvasGraphicsFactory = this.canvasGraphicsFactory;\n      (0, _util.info)("TilingType: " + tilingType);\n      var x0 = bbox[0],\n          y0 = bbox[1],\n          x1 = bbox[2],\n          y1 = bbox[3];\n\n      var matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);\n\n      var curMatrixScale = _util.Util.singularValueDecompose2dScale(this.baseTransform);\n\n      var combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];\n      var dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]);\n      var dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]);\n      var tmpCanvas = owner.cachedCanvases.getCanvas("pattern", dimx.size, dimy.size, true);\n      var tmpCtx = tmpCanvas.context;\n      var graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);\n      graphics.groupLevel = owner.groupLevel;\n      this.setFillAndStrokeStyleToContext(graphics, paintType, color);\n      graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);\n      graphics.transform(1, 0, 0, 1, -x0, -y0);\n      this.clipBbox(graphics, bbox, x0, y0, x1, y1);\n      graphics.executeOperatorList(operatorList);\n      this.ctx.transform(1, 0, 0, 1, x0, y0);\n      this.ctx.scale(1 / dimx.scale, 1 / dimy.scale);\n      return tmpCanvas.canvas;\n    },\n    getSizeAndScale: function TilingPattern_getSizeAndScale(step, realOutputSize, scale) {\n      step = Math.abs(step);\n      var maxSize = Math.max(MAX_PATTERN_SIZE, realOutputSize);\n      var size = Math.ceil(step * scale);\n\n      if (size >= maxSize) {\n        size = maxSize;\n      } else {\n        scale = size / step;\n      }\n\n      return {\n        scale,\n        size\n      };\n    },\n    clipBbox: function clipBbox(graphics, bbox, x0, y0, x1, y1) {\n      if (Array.isArray(bbox) && bbox.length === 4) {\n        var bboxWidth = x1 - x0;\n        var bboxHeight = y1 - y0;\n        graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);\n        graphics.clip();\n        graphics.endPath();\n      }\n    },\n    setFillAndStrokeStyleToContext: function setFillAndStrokeStyleToContext(graphics, paintType, color) {\n      const context = graphics.ctx,\n            current = graphics.current;\n\n      switch (paintType) {\n        case PaintType.COLORED:\n          var ctx = this.ctx;\n          context.fillStyle = ctx.fillStyle;\n          context.strokeStyle = ctx.strokeStyle;\n          current.fillColor = ctx.fillStyle;\n          current.strokeColor = ctx.strokeStyle;\n          break;\n\n        case PaintType.UNCOLORED:\n          var cssColor = _util.Util.makeCssRgb(color[0], color[1], color[2]);\n\n          context.fillStyle = cssColor;\n          context.strokeStyle = cssColor;\n          current.fillColor = cssColor;\n          current.strokeColor = cssColor;\n          break;\n\n        default:\n          throw new _util.FormatError(`Unsupported paint type: ${paintType}`);\n      }\n    },\n    getPattern: function TilingPattern_getPattern(ctx, owner) {\n      ctx = this.ctx;\n      ctx.setTransform.apply(ctx, this.baseTransform);\n      ctx.transform.apply(ctx, this.matrix);\n      var temporaryPatternCanvas = this.createPatternCanvas(owner);\n      return ctx.createPattern(temporaryPatternCanvas, "repeat");\n    }\n  };\n  return TilingPattern;\n}();\n\nexports.TilingPattern = TilingPattern;\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n"use strict";\n\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.GlobalWorkerOptions = void 0;\nconst GlobalWorkerOptions = Object.create(null);\nexports.GlobalWorkerOptions = GlobalWorkerOptions;\nGlobalWorkerOptions.workerPort = GlobalWorkerOptions.workerPort === undefined ? null : GlobalWorkerOptions.workerPort;\nGlobalWorkerOptions.workerSrc = GlobalWorkerOptions.workerSrc === undefined ? "" : GlobalWorkerOptions.workerSrc;\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n"use strict";\n\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.MessageHandler = void 0;\n\nvar _util = __w_pdfjs_require__(2);\n\nconst CallbackKind = {\n  UNKNOWN: 0,\n  DATA: 1,\n  ERROR: 2\n};\nconst StreamKind = {\n  UNKNOWN: 0,\n  CANCEL: 1,\n  CANCEL_COMPLETE: 2,\n  CLOSE: 3,\n  ENQUEUE: 4,\n  ERROR: 5,\n  PULL: 6,\n  PULL_COMPLETE: 7,\n  START_COMPLETE: 8\n};\n\nfunction wrapReason(reason) {\n  if (typeof reason !== "object" || reason === null) {\n    return reason;\n  }\n\n  switch (reason.name) {\n    case "AbortException":\n      return new _util.AbortException(reason.message);\n\n    case "MissingPDFException":\n      return new _util.MissingPDFException(reason.message);\n\n    case "UnexpectedResponseException":\n      return new _util.UnexpectedResponseException(reason.message, reason.status);\n\n    case "UnknownErrorException":\n      return new _util.UnknownErrorException(reason.message, reason.details);\n\n    default:\n      return new _util.UnknownErrorException(reason.message, reason.toString());\n  }\n}\n\nclass MessageHandler {\n  constructor(sourceName, targetName, comObj) {\n    this.sourceName = sourceName;\n    this.targetName = targetName;\n    this.comObj = comObj;\n    this.callbackId = 1;\n    this.streamId = 1;\n    this.postMessageTransfers = true;\n    this.streamSinks = Object.create(null);\n    this.streamControllers = Object.create(null);\n    this.callbackCapabilities = Object.create(null);\n    this.actionHandler = Object.create(null);\n\n    this._onComObjOnMessage = event => {\n      const data = event.data;\n\n      if (data.targetName !== this.sourceName) {\n        return;\n      }\n\n      if (data.stream) {\n        this._processStreamMessage(data);\n\n        return;\n      }\n\n      if (data.callback) {\n        const callbackId = data.callbackId;\n        const capability = this.callbackCapabilities[callbackId];\n\n        if (!capability) {\n          throw new Error(`Cannot resolve callback ${callbackId}`);\n        }\n\n        delete this.callbackCapabilities[callbackId];\n\n        if (data.callback === CallbackKind.DATA) {\n          capability.resolve(data.data);\n        } else if (data.callback === CallbackKind.ERROR) {\n          capability.reject(wrapReason(data.reason));\n        } else {\n          throw new Error("Unexpected callback case");\n        }\n\n        return;\n      }\n\n      const action = this.actionHandler[data.action];\n\n      if (!action) {\n        throw new Error(`Unknown action from worker: ${data.action}`);\n      }\n\n      if (data.callbackId) {\n        const cbSourceName = this.sourceName;\n        const cbTargetName = data.sourceName;\n        new Promise(function (resolve) {\n          resolve(action(data.data));\n        }).then(function (result) {\n          comObj.postMessage({\n            sourceName: cbSourceName,\n            targetName: cbTargetName,\n            callback: CallbackKind.DATA,\n            callbackId: data.callbackId,\n            data: result\n          });\n        }, function (reason) {\n          comObj.postMessage({\n            sourceName: cbSourceName,\n            targetName: cbTargetName,\n            callback: CallbackKind.ERROR,\n            callbackId: data.callbackId,\n            reason: wrapReason(reason)\n          });\n        });\n        return;\n      }\n\n      if (data.streamId) {\n        this._createStreamSink(data);\n\n        return;\n      }\n\n      action(data.data);\n    };\n\n    comObj.addEventListener("message", this._onComObjOnMessage);\n  }\n\n  on(actionName, handler) {\n    const ah = this.actionHandler;\n\n    if (ah[actionName]) {\n      throw new Error(`There is already an actionName called "${actionName}"`);\n    }\n\n    ah[actionName] = handler;\n  }\n\n  send(actionName, data, transfers) {\n    this._postMessage({\n      sourceName: this.sourceName,\n      targetName: this.targetName,\n      action: actionName,\n      data\n    }, transfers);\n  }\n\n  sendWithPromise(actionName, data, transfers) {\n    const callbackId = this.callbackId++;\n    const capability = (0, _util.createPromiseCapability)();\n    this.callbackCapabilities[callbackId] = capability;\n\n    try {\n      this._postMessage({\n        sourceName: this.sourceName,\n        targetName: this.targetName,\n        action: actionName,\n        callbackId,\n        data\n      }, transfers);\n    } catch (ex) {\n      capability.reject(ex);\n    }\n\n    return capability.promise;\n  }\n\n  sendWithStream(actionName, data, queueingStrategy, transfers) {\n    const streamId = this.streamId++;\n    const sourceName = this.sourceName;\n    const targetName = this.targetName;\n    const comObj = this.comObj;\n    return new ReadableStream({\n      start: controller => {\n        const startCapability = (0, _util.createPromiseCapability)();\n        this.streamControllers[streamId] = {\n          controller,\n          startCall: startCapability,\n          pullCall: null,\n          cancelCall: null,\n          isClosed: false\n        };\n\n        this._postMessage({\n          sourceName,\n          targetName,\n          action: actionName,\n          streamId,\n          data,\n          desiredSize: controller.desiredSize\n        }, transfers);\n\n        return startCapability.promise;\n      },\n      pull: controller => {\n        const pullCapability = (0, _util.createPromiseCapability)();\n        this.streamControllers[streamId].pullCall = pullCapability;\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.PULL,\n          streamId,\n          desiredSize: controller.desiredSize\n        });\n        return pullCapability.promise;\n      },\n      cancel: reason => {\n        (0, _util.assert)(reason instanceof Error, "cancel must have a valid reason");\n        const cancelCapability = (0, _util.createPromiseCapability)();\n        this.streamControllers[streamId].cancelCall = cancelCapability;\n        this.streamControllers[streamId].isClosed = true;\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.CANCEL,\n          streamId,\n          reason: wrapReason(reason)\n        });\n        return cancelCapability.promise;\n      }\n    }, queueingStrategy);\n  }\n\n  _createStreamSink(data) {\n    const self = this;\n    const action = this.actionHandler[data.action];\n    const streamId = data.streamId;\n    const sourceName = this.sourceName;\n    const targetName = data.sourceName;\n    const comObj = this.comObj;\n    const streamSink = {\n      enqueue(chunk, size = 1, transfers) {\n        if (this.isCancelled) {\n          return;\n        }\n\n        const lastDesiredSize = this.desiredSize;\n        this.desiredSize -= size;\n\n        if (lastDesiredSize > 0 && this.desiredSize <= 0) {\n          this.sinkCapability = (0, _util.createPromiseCapability)();\n          this.ready = this.sinkCapability.promise;\n        }\n\n        self._postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.ENQUEUE,\n          streamId,\n          chunk\n        }, transfers);\n      },\n\n      close() {\n        if (this.isCancelled) {\n          return;\n        }\n\n        this.isCancelled = true;\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.CLOSE,\n          streamId\n        });\n        delete self.streamSinks[streamId];\n      },\n\n      error(reason) {\n        (0, _util.assert)(reason instanceof Error, "error must have a valid reason");\n\n        if (this.isCancelled) {\n          return;\n        }\n\n        this.isCancelled = true;\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.ERROR,\n          streamId,\n          reason: wrapReason(reason)\n        });\n      },\n\n      sinkCapability: (0, _util.createPromiseCapability)(),\n      onPull: null,\n      onCancel: null,\n      isCancelled: false,\n      desiredSize: data.desiredSize,\n      ready: null\n    };\n    streamSink.sinkCapability.resolve();\n    streamSink.ready = streamSink.sinkCapability.promise;\n    this.streamSinks[streamId] = streamSink;\n    new Promise(function (resolve) {\n      resolve(action(data.data, streamSink));\n    }).then(function () {\n      comObj.postMessage({\n        sourceName,\n        targetName,\n        stream: StreamKind.START_COMPLETE,\n        streamId,\n        success: true\n      });\n    }, function (reason) {\n      comObj.postMessage({\n        sourceName,\n        targetName,\n        stream: StreamKind.START_COMPLETE,\n        streamId,\n        reason: wrapReason(reason)\n      });\n    });\n  }\n\n  _processStreamMessage(data) {\n    const streamId = data.streamId;\n    const sourceName = this.sourceName;\n    const targetName = data.sourceName;\n    const comObj = this.comObj;\n\n    switch (data.stream) {\n      case StreamKind.START_COMPLETE:\n        if (data.success) {\n          this.streamControllers[streamId].startCall.resolve();\n        } else {\n          this.streamControllers[streamId].startCall.reject(wrapReason(data.reason));\n        }\n\n        break;\n\n      case StreamKind.PULL_COMPLETE:\n        if (data.success) {\n          this.streamControllers[streamId].pullCall.resolve();\n        } else {\n          this.streamControllers[streamId].pullCall.reject(wrapReason(data.reason));\n        }\n\n        break;\n\n      case StreamKind.PULL:\n        if (!this.streamSinks[streamId]) {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.PULL_COMPLETE,\n            streamId,\n            success: true\n          });\n          break;\n        }\n\n        if (this.streamSinks[streamId].desiredSize <= 0 && data.desiredSize > 0) {\n          this.streamSinks[streamId].sinkCapability.resolve();\n        }\n\n        this.streamSinks[streamId].desiredSize = data.desiredSize;\n        const {\n          onPull\n        } = this.streamSinks[data.streamId];\n        new Promise(function (resolve) {\n          resolve(onPull && onPull());\n        }).then(function () {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.PULL_COMPLETE,\n            streamId,\n            success: true\n          });\n        }, function (reason) {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.PULL_COMPLETE,\n            streamId,\n            reason: wrapReason(reason)\n          });\n        });\n        break;\n\n      case StreamKind.ENQUEUE:\n        (0, _util.assert)(this.streamControllers[streamId], "enqueue should have stream controller");\n\n        if (this.streamControllers[streamId].isClosed) {\n          break;\n        }\n\n        this.streamControllers[streamId].controller.enqueue(data.chunk);\n        break;\n\n      case StreamKind.CLOSE:\n        (0, _util.assert)(this.streamControllers[streamId], "close should have stream controller");\n\n        if (this.streamControllers[streamId].isClosed) {\n          break;\n        }\n\n        this.streamControllers[streamId].isClosed = true;\n        this.streamControllers[streamId].controller.close();\n\n        this._deleteStreamController(streamId);\n\n        break;\n\n      case StreamKind.ERROR:\n        (0, _util.assert)(this.streamControllers[streamId], "error should have stream controller");\n        this.streamControllers[streamId].controller.error(wrapReason(data.reason));\n\n        this._deleteStreamController(streamId);\n\n        break;\n\n      case StreamKind.CANCEL_COMPLETE:\n        if (data.success) {\n          this.streamControllers[streamId].cancelCall.resolve();\n        } else {\n          this.streamControllers[streamId].cancelCall.reject(wrapReason(data.reason));\n        }\n\n        this._deleteStreamController(streamId);\n\n        break;\n\n      case StreamKind.CANCEL:\n        if (!this.streamSinks[streamId]) {\n          break;\n        }\n\n        const {\n          onCancel\n        } = this.streamSinks[data.streamId];\n        new Promise(function (resolve) {\n          resolve(onCancel && onCancel(wrapReason(data.reason)));\n        }).then(function () {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.CANCEL_COMPLETE,\n            streamId,\n            success: true\n          });\n        }, function (reason) {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.CANCEL_COMPLETE,\n            streamId,\n            reason: wrapReason(reason)\n          });\n        });\n        this.streamSinks[streamId].sinkCapability.reject(wrapReason(data.reason));\n        this.streamSinks[streamId].isCancelled = true;\n        delete this.streamSinks[streamId];\n        break;\n\n      default:\n        throw new Error("Unexpected stream case");\n    }\n  }\n\n  async _deleteStreamController(streamId) {\n    await Promise.allSettled([this.streamControllers[streamId].startCall, this.streamControllers[streamId].pullCall, this.streamControllers[streamId].cancelCall].map(function (capability) {\n      return capability && capability.promise;\n    }));\n    delete this.streamControllers[streamId];\n  }\n\n  _postMessage(message, transfers) {\n    if (transfers && this.postMessageTransfers) {\n      this.comObj.postMessage(message, transfers);\n    } else {\n      this.comObj.postMessage(message);\n    }\n  }\n\n  destroy() {\n    this.comObj.removeEventListener("message", this._onComObjOnMessage);\n  }\n\n}\n\nexports.MessageHandler = MessageHandler;\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n"use strict";\n\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.Metadata = void 0;\n\nvar _util = __w_pdfjs_require__(2);\n\nvar _xml_parser = __w_pdfjs_require__(15);\n\nclass Metadata {\n  constructor(data) {\n    (0, _util.assert)(typeof data === "string", "Metadata: input is not a string");\n    data = this._repair(data);\n    const parser = new _xml_parser.SimpleXMLParser();\n    const xmlDocument = parser.parseFromString(data);\n    this._metadataMap = new Map();\n\n    if (xmlDocument) {\n      this._parse(xmlDocument);\n    }\n  }\n\n  _repair(data) {\n    return data.replace(/^[^<]+/, "").replace(/>\\\\376\\\\377([^<]+)/g, function (all, codes) {\n      const bytes = codes.replace(/\\\\([0-3])([0-7])([0-7])/g, function (code, d1, d2, d3) {\n        return String.fromCharCode(d1 * 64 + d2 * 8 + d3 * 1);\n      }).replace(/&(amp|apos|gt|lt|quot);/g, function (str, name) {\n        switch (name) {\n          case "amp":\n            return "&";\n\n          case "apos":\n            return "\'";\n\n          case "gt":\n            return ">";\n\n          case "lt":\n            return "<";\n\n          case "quot":\n            return \'"\';\n        }\n\n        throw new Error(`_repair: ${name} isn\'t defined.`);\n      });\n      let chars = "";\n\n      for (let i = 0, ii = bytes.length; i < ii; i += 2) {\n        const code = bytes.charCodeAt(i) * 256 + bytes.charCodeAt(i + 1);\n\n        if (code >= 32 && code < 127 && code !== 60 && code !== 62 && code !== 38) {\n          chars += String.fromCharCode(code);\n        } else {\n          chars += "&#x" + (0x10000 + code).toString(16).substring(1) + ";";\n        }\n      }\n\n      return ">" + chars;\n    });\n  }\n\n  _parse(xmlDocument) {\n    let rdf = xmlDocument.documentElement;\n\n    if (rdf.nodeName.toLowerCase() !== "rdf:rdf") {\n      rdf = rdf.firstChild;\n\n      while (rdf && rdf.nodeName.toLowerCase() !== "rdf:rdf") {\n        rdf = rdf.nextSibling;\n      }\n    }\n\n    const nodeName = rdf ? rdf.nodeName.toLowerCase() : null;\n\n    if (!rdf || nodeName !== "rdf:rdf" || !rdf.hasChildNodes()) {\n      return;\n    }\n\n    const children = rdf.childNodes;\n\n    for (let i = 0, ii = children.length; i < ii; i++) {\n      const desc = children[i];\n\n      if (desc.nodeName.toLowerCase() !== "rdf:description") {\n        continue;\n      }\n\n      for (let j = 0, jj = desc.childNodes.length; j < jj; j++) {\n        if (desc.childNodes[j].nodeName.toLowerCase() !== "#text") {\n          const entry = desc.childNodes[j];\n          const name = entry.nodeName.toLowerCase();\n\n          this._metadataMap.set(name, entry.textContent.trim());\n        }\n      }\n    }\n  }\n\n  get(name) {\n    return this._metadataMap.has(name) ? this._metadataMap.get(name) : null;\n  }\n\n  getAll() {\n    return Object.fromEntries(this._metadataMap);\n  }\n\n  has(name) {\n    return this._metadataMap.has(name);\n  }\n\n}\n\nexports.Metadata = Metadata;\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n"use strict";\n\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.SimpleXMLParser = void 0;\nconst XMLParserErrorCode = {\n  NoError: 0,\n  EndOfDocument: -1,\n  UnterminatedCdat: -2,\n  UnterminatedXmlDeclaration: -3,\n  UnterminatedDoctypeDeclaration: -4,\n  UnterminatedComment: -5,\n  MalformedElement: -6,\n  OutOfMemory: -7,\n  UnterminatedAttributeValue: -8,\n  UnterminatedElement: -9,\n  ElementNeverBegun: -10\n};\n\nfunction isWhitespace(s, index) {\n  const ch = s[index];\n  return ch === " " || ch === "\\n" || ch === "\\r" || ch === "\\t";\n}\n\nfunction isWhitespaceString(s) {\n  for (let i = 0, ii = s.length; i < ii; i++) {\n    if (!isWhitespace(s, i)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nclass XMLParserBase {\n  _resolveEntities(s) {\n    return s.replace(/&([^;]+);/g, (all, entity) => {\n      if (entity.substring(0, 2) === "#x") {\n        return String.fromCharCode(parseInt(entity.substring(2), 16));\n      } else if (entity.substring(0, 1) === "#") {\n        return String.fromCharCode(parseInt(entity.substring(1), 10));\n      }\n\n      switch (entity) {\n        case "lt":\n          return "<";\n\n        case "gt":\n          return ">";\n\n        case "amp":\n          return "&";\n\n        case "quot":\n          return \'"\';\n      }\n\n      return this.onResolveEntity(entity);\n    });\n  }\n\n  _parseContent(s, start) {\n    const attributes = [];\n    let pos = start;\n\n    function skipWs() {\n      while (pos < s.length && isWhitespace(s, pos)) {\n        ++pos;\n      }\n    }\n\n    while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== ">" && s[pos] !== "/") {\n      ++pos;\n    }\n\n    const name = s.substring(start, pos);\n    skipWs();\n\n    while (pos < s.length && s[pos] !== ">" && s[pos] !== "/" && s[pos] !== "?") {\n      skipWs();\n      let attrName = "",\n          attrValue = "";\n\n      while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== "=") {\n        attrName += s[pos];\n        ++pos;\n      }\n\n      skipWs();\n\n      if (s[pos] !== "=") {\n        return null;\n      }\n\n      ++pos;\n      skipWs();\n      const attrEndChar = s[pos];\n\n      if (attrEndChar !== \'"\' && attrEndChar !== "\'") {\n        return null;\n      }\n\n      const attrEndIndex = s.indexOf(attrEndChar, ++pos);\n\n      if (attrEndIndex < 0) {\n        return null;\n      }\n\n      attrValue = s.substring(pos, attrEndIndex);\n      attributes.push({\n        name: attrName,\n        value: this._resolveEntities(attrValue)\n      });\n      pos = attrEndIndex + 1;\n      skipWs();\n    }\n\n    return {\n      name,\n      attributes,\n      parsed: pos - start\n    };\n  }\n\n  _parseProcessingInstruction(s, start) {\n    let pos = start;\n\n    function skipWs() {\n      while (pos < s.length && isWhitespace(s, pos)) {\n        ++pos;\n      }\n    }\n\n    while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== ">" && s[pos] !== "/") {\n      ++pos;\n    }\n\n    const name = s.substring(start, pos);\n    skipWs();\n    const attrStart = pos;\n\n    while (pos < s.length && (s[pos] !== "?" || s[pos + 1] !== ">")) {\n      ++pos;\n    }\n\n    const value = s.substring(attrStart, pos);\n    return {\n      name,\n      value,\n      parsed: pos - start\n    };\n  }\n\n  parseXml(s) {\n    let i = 0;\n\n    while (i < s.length) {\n      const ch = s[i];\n      let j = i;\n\n      if (ch === "<") {\n        ++j;\n        const ch2 = s[j];\n        let q;\n\n        switch (ch2) {\n          case "/":\n            ++j;\n            q = s.indexOf(">", j);\n\n            if (q < 0) {\n              this.onError(XMLParserErrorCode.UnterminatedElement);\n              return;\n            }\n\n            this.onEndElement(s.substring(j, q));\n            j = q + 1;\n            break;\n\n          case "?":\n            ++j;\n\n            const pi = this._parseProcessingInstruction(s, j);\n\n            if (s.substring(j + pi.parsed, j + pi.parsed + 2) !== "?>") {\n              this.onError(XMLParserErrorCode.UnterminatedXmlDeclaration);\n              return;\n            }\n\n            this.onPi(pi.name, pi.value);\n            j += pi.parsed + 2;\n            break;\n\n          case "!":\n            if (s.substring(j + 1, j + 3) === "--") {\n              q = s.indexOf("--\x3e", j + 3);\n\n              if (q < 0) {\n                this.onError(XMLParserErrorCode.UnterminatedComment);\n                return;\n              }\n\n              this.onComment(s.substring(j + 3, q));\n              j = q + 3;\n            } else if (s.substring(j + 1, j + 8) === "[CDATA[") {\n              q = s.indexOf("]]>", j + 8);\n\n              if (q < 0) {\n                this.onError(XMLParserErrorCode.UnterminatedCdat);\n                return;\n              }\n\n              this.onCdata(s.substring(j + 8, q));\n              j = q + 3;\n            } else if (s.substring(j + 1, j + 8) === "DOCTYPE") {\n              const q2 = s.indexOf("[", j + 8);\n              let complexDoctype = false;\n              q = s.indexOf(">", j + 8);\n\n              if (q < 0) {\n                this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration);\n                return;\n              }\n\n              if (q2 > 0 && q > q2) {\n                q = s.indexOf("]>", j + 8);\n\n                if (q < 0) {\n                  this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration);\n                  return;\n                }\n\n                complexDoctype = true;\n              }\n\n              const doctypeContent = s.substring(j + 8, q + (complexDoctype ? 1 : 0));\n              this.onDoctype(doctypeContent);\n              j = q + (complexDoctype ? 2 : 1);\n            } else {\n              this.onError(XMLParserErrorCode.MalformedElement);\n              return;\n            }\n\n            break;\n\n          default:\n            const content = this._parseContent(s, j);\n\n            if (content === null) {\n              this.onError(XMLParserErrorCode.MalformedElement);\n              return;\n            }\n\n            let isClosed = false;\n\n            if (s.substring(j + content.parsed, j + content.parsed + 2) === "/>") {\n              isClosed = true;\n            } else if (s.substring(j + content.parsed, j + content.parsed + 1) !== ">") {\n              this.onError(XMLParserErrorCode.UnterminatedElement);\n              return;\n            }\n\n            this.onBeginElement(content.name, content.attributes, isClosed);\n            j += content.parsed + (isClosed ? 2 : 1);\n            break;\n        }\n      } else {\n        while (j < s.length && s[j] !== "<") {\n          j++;\n        }\n\n        const text = s.substring(i, j);\n        this.onText(this._resolveEntities(text));\n      }\n\n      i = j;\n    }\n  }\n\n  onResolveEntity(name) {\n    return `&${name};`;\n  }\n\n  onPi(name, value) {}\n\n  onComment(text) {}\n\n  onCdata(text) {}\n\n  onDoctype(doctypeContent) {}\n\n  onText(text) {}\n\n  onBeginElement(name, attributes, isEmpty) {}\n\n  onEndElement(name) {}\n\n  onError(code) {}\n\n}\n\nclass SimpleDOMNode {\n  constructor(nodeName, nodeValue) {\n    this.nodeName = nodeName;\n    this.nodeValue = nodeValue;\n    Object.defineProperty(this, "parentNode", {\n      value: null,\n      writable: true\n    });\n  }\n\n  get firstChild() {\n    return this.childNodes && this.childNodes[0];\n  }\n\n  get nextSibling() {\n    const childNodes = this.parentNode.childNodes;\n\n    if (!childNodes) {\n      return undefined;\n    }\n\n    const index = childNodes.indexOf(this);\n\n    if (index === -1) {\n      return undefined;\n    }\n\n    return childNodes[index + 1];\n  }\n\n  get textContent() {\n    if (!this.childNodes) {\n      return this.nodeValue || "";\n    }\n\n    return this.childNodes.map(function (child) {\n      return child.textContent;\n    }).join("");\n  }\n\n  hasChildNodes() {\n    return this.childNodes && this.childNodes.length > 0;\n  }\n\n}\n\nclass SimpleXMLParser extends XMLParserBase {\n  constructor() {\n    super();\n    this._currentFragment = null;\n    this._stack = null;\n    this._errorCode = XMLParserErrorCode.NoError;\n  }\n\n  parseFromString(data) {\n    this._currentFragment = [];\n    this._stack = [];\n    this._errorCode = XMLParserErrorCode.NoError;\n    this.parseXml(data);\n\n    if (this._errorCode !== XMLParserErrorCode.NoError) {\n      return undefined;\n    }\n\n    const [documentElement] = this._currentFragment;\n\n    if (!documentElement) {\n      return undefined;\n    }\n\n    return {\n      documentElement\n    };\n  }\n\n  onResolveEntity(name) {\n    switch (name) {\n      case "apos":\n        return "\'";\n    }\n\n    return super.onResolveEntity(name);\n  }\n\n  onText(text) {\n    if (isWhitespaceString(text)) {\n      return;\n    }\n\n    const node = new SimpleDOMNode("#text", text);\n\n    this._currentFragment.push(node);\n  }\n\n  onCdata(text) {\n    const node = new SimpleDOMNode("#text", text);\n\n    this._currentFragment.push(node);\n  }\n\n  onBeginElement(name, attributes, isEmpty) {\n    const node = new SimpleDOMNode(name);\n    node.childNodes = [];\n\n    this._currentFragment.push(node);\n\n    if (isEmpty) {\n      return;\n    }\n\n    this._stack.push(this._currentFragment);\n\n    this._currentFragment = node.childNodes;\n  }\n\n  onEndElement(name) {\n    this._currentFragment = this._stack.pop() || [];\n    const lastElement = this._currentFragment[this._currentFragment.length - 1];\n\n    if (!lastElement) {\n      return;\n    }\n\n    for (let i = 0, ii = lastElement.childNodes.length; i < ii; i++) {\n      lastElement.childNodes[i].parentNode = lastElement;\n    }\n  }\n\n  onError(code) {\n    this._errorCode = code;\n  }\n\n}\n\nexports.SimpleXMLParser = SimpleXMLParser;\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n"use strict";\n\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.OptionalContentConfig = void 0;\n\nvar _util = __w_pdfjs_require__(2);\n\nclass OptionalContentGroup {\n  constructor(name, intent) {\n    this.visible = true;\n    this.name = name;\n    this.intent = intent;\n  }\n\n}\n\nclass OptionalContentConfig {\n  constructor(data) {\n    this.name = null;\n    this.creator = null;\n    this._order = null;\n    this._groups = new Map();\n\n    if (data === null) {\n      return;\n    }\n\n    this.name = data.name;\n    this.creator = data.creator;\n    this._order = data.order;\n\n    for (const group of data.groups) {\n      this._groups.set(group.id, new OptionalContentGroup(group.name, group.intent));\n    }\n\n    if (data.baseState === "OFF") {\n      for (const group of this._groups) {\n        group.visible = false;\n      }\n    }\n\n    for (const on of data.on) {\n      this._groups.get(on).visible = true;\n    }\n\n    for (const off of data.off) {\n      this._groups.get(off).visible = false;\n    }\n  }\n\n  isVisible(group) {\n    if (group.type === "OCG") {\n      if (!this._groups.has(group.id)) {\n        (0, _util.warn)(`Optional content group not found: ${group.id}`);\n        return true;\n      }\n\n      return this._groups.get(group.id).visible;\n    } else if (group.type === "OCMD") {\n      if (group.expression) {\n        (0, _util.warn)("Visibility expression not supported yet.");\n      }\n\n      if (!group.policy || group.policy === "AnyOn") {\n        for (const id of group.ids) {\n          if (!this._groups.has(id)) {\n            (0, _util.warn)(`Optional content group not found: ${id}`);\n            return true;\n          }\n\n          if (this._groups.get(id).visible) {\n            return true;\n          }\n        }\n\n        return false;\n      } else if (group.policy === "AllOn") {\n        for (const id of group.ids) {\n          if (!this._groups.has(id)) {\n            (0, _util.warn)(`Optional content group not found: ${id}`);\n            return true;\n          }\n\n          if (!this._groups.get(id).visible) {\n            return false;\n          }\n        }\n\n        return true;\n      } else if (group.policy === "AnyOff") {\n        for (const id of group.ids) {\n          if (!this._groups.has(id)) {\n            (0, _util.warn)(`Optional content group not found: ${id}`);\n            return true;\n          }\n\n          if (!this._groups.get(id).visible) {\n            return true;\n          }\n        }\n\n        return false;\n      } else if (group.policy === "AllOff") {\n        for (const id of group.ids) {\n          if (!this._groups.has(id)) {\n            (0, _util.warn)(`Optional content group not found: ${id}`);\n            return true;\n          }\n\n          if (this._groups.get(id).visible) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      (0, _util.warn)(`Unknown optional content policy ${group.policy}.`);\n      return true;\n    }\n\n    (0, _util.warn)(`Unknown group type ${group.type}.`);\n    return true;\n  }\n\n  setVisibility(id, visible = true) {\n    if (!this._groups.has(id)) {\n      (0, _util.warn)(`Optional content group not found: ${id}`);\n      return;\n    }\n\n    this._groups.get(id).visible = !!visible;\n  }\n\n  getOrder() {\n    if (!this._groups.size) {\n      return null;\n    }\n\n    if (this._order) {\n      return this._order.slice();\n    }\n\n    return Array.from(this._groups.keys());\n  }\n\n  getGroups() {\n    if (!this._groups.size) {\n      return null;\n    }\n\n    return Object.fromEntries(this._groups);\n  }\n\n  getGroup(id) {\n    return this._groups.get(id) || null;\n  }\n\n}\n\nexports.OptionalContentConfig = OptionalContentConfig;\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n"use strict";\n\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.PDFDataTransportStream = void 0;\n\nvar _util = __w_pdfjs_require__(2);\n\nclass PDFDataTransportStream {\n  constructor(params, pdfDataRangeTransport) {\n    (0, _util.assert)(pdfDataRangeTransport, \'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.\');\n    this._queuedChunks = [];\n    this._progressiveDone = params.progressiveDone || false;\n    const initialData = params.initialData;\n\n    if (initialData && initialData.length > 0) {\n      const buffer = new Uint8Array(initialData).buffer;\n\n      this._queuedChunks.push(buffer);\n    }\n\n    this._pdfDataRangeTransport = pdfDataRangeTransport;\n    this._isStreamingSupported = !params.disableStream;\n    this._isRangeSupported = !params.disableRange;\n    this._contentLength = params.length;\n    this._fullRequestReader = null;\n    this._rangeReaders = [];\n\n    this._pdfDataRangeTransport.addRangeListener((begin, chunk) => {\n      this._onReceiveData({\n        begin,\n        chunk\n      });\n    });\n\n    this._pdfDataRangeTransport.addProgressListener((loaded, total) => {\n      this._onProgress({\n        loaded,\n        total\n      });\n    });\n\n    this._pdfDataRangeTransport.addProgressiveReadListener(chunk => {\n      this._onReceiveData({\n        chunk\n      });\n    });\n\n    this._pdfDataRangeTransport.addProgressiveDoneListener(() => {\n      this._onProgressiveDone();\n    });\n\n    this._pdfDataRangeTransport.transportReady();\n  }\n\n  _onReceiveData(args) {\n    const buffer = new Uint8Array(args.chunk).buffer;\n\n    if (args.begin === undefined) {\n      if (this._fullRequestReader) {\n        this._fullRequestReader._enqueue(buffer);\n      } else {\n        this._queuedChunks.push(buffer);\n      }\n    } else {\n      const found = this._rangeReaders.some(function (rangeReader) {\n        if (rangeReader._begin !== args.begin) {\n          return false;\n        }\n\n        rangeReader._enqueue(buffer);\n\n        return true;\n      });\n\n      (0, _util.assert)(found, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");\n    }\n  }\n\n  get _progressiveDataLength() {\n    return this._fullRequestReader ? this._fullRequestReader._loaded : 0;\n  }\n\n  _onProgress(evt) {\n    if (evt.total === undefined) {\n      const firstReader = this._rangeReaders[0];\n\n      if (firstReader && firstReader.onProgress) {\n        firstReader.onProgress({\n          loaded: evt.loaded\n        });\n      }\n    } else {\n      const fullReader = this._fullRequestReader;\n\n      if (fullReader && fullReader.onProgress) {\n        fullReader.onProgress({\n          loaded: evt.loaded,\n          total: evt.total\n        });\n      }\n    }\n  }\n\n  _onProgressiveDone() {\n    if (this._fullRequestReader) {\n      this._fullRequestReader.progressiveDone();\n    }\n\n    this._progressiveDone = true;\n  }\n\n  _removeRangeReader(reader) {\n    const i = this._rangeReaders.indexOf(reader);\n\n    if (i >= 0) {\n      this._rangeReaders.splice(i, 1);\n    }\n  }\n\n  getFullReader() {\n    (0, _util.assert)(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");\n    const queuedChunks = this._queuedChunks;\n    this._queuedChunks = null;\n    return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone);\n  }\n\n  getRangeReader(begin, end) {\n    if (end <= this._progressiveDataLength) {\n      return null;\n    }\n\n    const reader = new PDFDataTransportStreamRangeReader(this, begin, end);\n\n    this._pdfDataRangeTransport.requestDataRange(begin, end);\n\n    this._rangeReaders.push(reader);\n\n    return reader;\n  }\n\n  cancelAllRequests(reason) {\n    if (this._fullRequestReader) {\n      this._fullRequestReader.cancel(reason);\n    }\n\n    const readers = this._rangeReaders.slice(0);\n\n    readers.forEach(function (rangeReader) {\n      rangeReader.cancel(reason);\n    });\n\n    this._pdfDataRangeTransport.abort();\n  }\n\n}\n\nexports.PDFDataTransportStream = PDFDataTransportStream;\n\nclass PDFDataTransportStreamReader {\n  constructor(stream, queuedChunks, progressiveDone = false) {\n    this._stream = stream;\n    this._done = progressiveDone || false;\n    this._filename = null;\n    this._queuedChunks = queuedChunks || [];\n    this._loaded = 0;\n\n    for (const chunk of this._queuedChunks) {\n      this._loaded += chunk.byteLength;\n    }\n\n    this._requests = [];\n    this._headersReady = Promise.resolve();\n    stream._fullRequestReader = this;\n    this.onProgress = null;\n  }\n\n  _enqueue(chunk) {\n    if (this._done) {\n      return;\n    }\n\n    if (this._requests.length > 0) {\n      const requestCapability = this._requests.shift();\n\n      requestCapability.resolve({\n        value: chunk,\n        done: false\n      });\n    } else {\n      this._queuedChunks.push(chunk);\n    }\n\n    this._loaded += chunk.byteLength;\n  }\n\n  get headersReady() {\n    return this._headersReady;\n  }\n\n  get filename() {\n    return this._filename;\n  }\n\n  get isRangeSupported() {\n    return this._stream._isRangeSupported;\n  }\n\n  get isStreamingSupported() {\n    return this._stream._isStreamingSupported;\n  }\n\n  get contentLength() {\n    return this._stream._contentLength;\n  }\n\n  async read() {\n    if (this._queuedChunks.length > 0) {\n      const chunk = this._queuedChunks.shift();\n\n      return {\n        value: chunk,\n        done: false\n      };\n    }\n\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n\n    const requestCapability = (0, _util.createPromiseCapability)();\n\n    this._requests.push(requestCapability);\n\n    return requestCapability.promise;\n  }\n\n  cancel(reason) {\n    this._done = true;\n\n    this._requests.forEach(function (requestCapability) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    });\n\n    this._requests = [];\n  }\n\n  progressiveDone() {\n    if (this._done) {\n      return;\n    }\n\n    this._done = true;\n  }\n\n}\n\nclass PDFDataTransportStreamRangeReader {\n  constructor(stream, begin, end) {\n    this._stream = stream;\n    this._begin = begin;\n    this._end = end;\n    this._queuedChunk = null;\n    this._requests = [];\n    this._done = false;\n    this.onProgress = null;\n  }\n\n  _enqueue(chunk) {\n    if (this._done) {\n      return;\n    }\n\n    if (this._requests.length === 0) {\n      this._queuedChunk = chunk;\n    } else {\n      const requestsCapability = this._requests.shift();\n\n      requestsCapability.resolve({\n        value: chunk,\n        done: false\n      });\n\n      this._requests.forEach(function (requestCapability) {\n        requestCapability.resolve({\n          value: undefined,\n          done: true\n        });\n      });\n\n      this._requests = [];\n    }\n\n    this._done = true;\n\n    this._stream._removeRangeReader(this);\n  }\n\n  get isStreamingSupported() {\n    return false;\n  }\n\n  async read() {\n    if (this._queuedChunk) {\n      const chunk = this._queuedChunk;\n      this._queuedChunk = null;\n      return {\n        value: chunk,\n        done: false\n      };\n    }\n\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n\n    const requestCapability = (0, _util.createPromiseCapability)();\n\n    this._requests.push(requestCapability);\n\n    return requestCapability.promise;\n  }\n\n  cancel(reason) {\n    this._done = true;\n\n    this._requests.forEach(function (requestCapability) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    });\n\n    this._requests = [];\n\n    this._stream._removeRangeReader(this);\n  }\n\n}\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n"use strict";\n\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.WebGLContext = void 0;\n\nvar _util = __w_pdfjs_require__(2);\n\nclass WebGLContext {\n  constructor({\n    enable = false\n  }) {\n    this._enabled = enable === true;\n  }\n\n  get isEnabled() {\n    let enabled = this._enabled;\n\n    if (enabled) {\n      enabled = WebGLUtils.tryInitGL();\n    }\n\n    return (0, _util.shadow)(this, "isEnabled", enabled);\n  }\n\n  composeSMask({\n    layer,\n    mask,\n    properties\n  }) {\n    return WebGLUtils.composeSMask(layer, mask, properties);\n  }\n\n  drawFigures({\n    width,\n    height,\n    backgroundColor,\n    figures,\n    context\n  }) {\n    return WebGLUtils.drawFigures(width, height, backgroundColor, figures, context);\n  }\n\n  clear() {\n    WebGLUtils.cleanup();\n  }\n\n}\n\nexports.WebGLContext = WebGLContext;\n\nvar WebGLUtils = function WebGLUtilsClosure() {\n  function loadShader(gl, code, shaderType) {\n    var shader = gl.createShader(shaderType);\n    gl.shaderSource(shader, code);\n    gl.compileShader(shader);\n    var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n\n    if (!compiled) {\n      var errorMsg = gl.getShaderInfoLog(shader);\n      throw new Error("Error during shader compilation: " + errorMsg);\n    }\n\n    return shader;\n  }\n\n  function createVertexShader(gl, code) {\n    return loadShader(gl, code, gl.VERTEX_SHADER);\n  }\n\n  function createFragmentShader(gl, code) {\n    return loadShader(gl, code, gl.FRAGMENT_SHADER);\n  }\n\n  function createProgram(gl, shaders) {\n    var program = gl.createProgram();\n\n    for (var i = 0, ii = shaders.length; i < ii; ++i) {\n      gl.attachShader(program, shaders[i]);\n    }\n\n    gl.linkProgram(program);\n    var linked = gl.getProgramParameter(program, gl.LINK_STATUS);\n\n    if (!linked) {\n      var errorMsg = gl.getProgramInfoLog(program);\n      throw new Error("Error during program linking: " + errorMsg);\n    }\n\n    return program;\n  }\n\n  function createTexture(gl, image, textureId) {\n    gl.activeTexture(textureId);\n    var texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\n    return texture;\n  }\n\n  var currentGL, currentCanvas;\n\n  function generateGL() {\n    if (currentGL) {\n      return;\n    }\n\n    currentCanvas = document.createElement("canvas");\n    currentGL = currentCanvas.getContext("webgl", {\n      premultipliedalpha: false\n    });\n  }\n\n  var smaskVertexShaderCode = "\\\n  attribute vec2 a_position;                                    \\\n  attribute vec2 a_texCoord;                                    \\\n                                                                \\\n  uniform vec2 u_resolution;                                    \\\n                                                                \\\n  varying vec2 v_texCoord;                                      \\\n                                                                \\\n  void main() {                                                 \\\n    vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;   \\\n    gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);          \\\n                                                                \\\n    v_texCoord = a_texCoord;                                    \\\n  }                                                             ";\n  var smaskFragmentShaderCode = "\\\n  precision mediump float;                                      \\\n                                                                \\\n  uniform vec4 u_backdrop;                                      \\\n  uniform int u_subtype;                                        \\\n  uniform sampler2D u_image;                                    \\\n  uniform sampler2D u_mask;                                     \\\n                                                                \\\n  varying vec2 v_texCoord;                                      \\\n                                                                \\\n  void main() {                                                 \\\n    vec4 imageColor = texture2D(u_image, v_texCoord);           \\\n    vec4 maskColor = texture2D(u_mask, v_texCoord);             \\\n    if (u_backdrop.a > 0.0) {                                   \\\n      maskColor.rgb = maskColor.rgb * maskColor.a +             \\\n                      u_backdrop.rgb * (1.0 - maskColor.a);     \\\n    }                                                           \\\n    float lum;                                                  \\\n    if (u_subtype == 0) {                                       \\\n      lum = maskColor.a;                                        \\\n    } else {                                                    \\\n      lum = maskColor.r * 0.3 + maskColor.g * 0.59 +            \\\n            maskColor.b * 0.11;                                 \\\n    }                                                           \\\n    imageColor.a *= lum;                                        \\\n    imageColor.rgb *= imageColor.a;                             \\\n    gl_FragColor = imageColor;                                  \\\n  }                                                             ";\n  var smaskCache = null;\n\n  function initSmaskGL() {\n    var canvas, gl;\n    generateGL();\n    canvas = currentCanvas;\n    currentCanvas = null;\n    gl = currentGL;\n    currentGL = null;\n    var vertexShader = createVertexShader(gl, smaskVertexShaderCode);\n    var fragmentShader = createFragmentShader(gl, smaskFragmentShaderCode);\n    var program = createProgram(gl, [vertexShader, fragmentShader]);\n    gl.useProgram(program);\n    var cache = {};\n    cache.gl = gl;\n    cache.canvas = canvas;\n    cache.resolutionLocation = gl.getUniformLocation(program, "u_resolution");\n    cache.positionLocation = gl.getAttribLocation(program, "a_position");\n    cache.backdropLocation = gl.getUniformLocation(program, "u_backdrop");\n    cache.subtypeLocation = gl.getUniformLocation(program, "u_subtype");\n    var texCoordLocation = gl.getAttribLocation(program, "a_texCoord");\n    var texLayerLocation = gl.getUniformLocation(program, "u_image");\n    var texMaskLocation = gl.getUniformLocation(program, "u_mask");\n    var texCoordBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]), gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(texCoordLocation);\n    gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);\n    gl.uniform1i(texLayerLocation, 0);\n    gl.uniform1i(texMaskLocation, 1);\n    smaskCache = cache;\n  }\n\n  function composeSMask(layer, mask, properties) {\n    var width = layer.width,\n        height = layer.height;\n\n    if (!smaskCache) {\n      initSmaskGL();\n    }\n\n    var cache = smaskCache,\n        canvas = cache.canvas,\n        gl = cache.gl;\n    canvas.width = width;\n    canvas.height = height;\n    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n    gl.uniform2f(cache.resolutionLocation, width, height);\n\n    if (properties.backdrop) {\n      gl.uniform4f(cache.resolutionLocation, properties.backdrop[0], properties.backdrop[1], properties.backdrop[2], 1);\n    } else {\n      gl.uniform4f(cache.resolutionLocation, 0, 0, 0, 0);\n    }\n\n    gl.uniform1i(cache.subtypeLocation, properties.subtype === "Luminosity" ? 1 : 0);\n    var texture = createTexture(gl, layer, gl.TEXTURE0);\n    var maskTexture = createTexture(gl, mask, gl.TEXTURE1);\n    var buffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, width, 0, 0, height, 0, height, width, 0, width, height]), gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(cache.positionLocation);\n    gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0);\n    gl.clearColor(0, 0, 0, 0);\n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\n    gl.flush();\n    gl.deleteTexture(texture);\n    gl.deleteTexture(maskTexture);\n    gl.deleteBuffer(buffer);\n    return canvas;\n  }\n\n  var figuresVertexShaderCode = "\\\n  attribute vec2 a_position;                                    \\\n  attribute vec3 a_color;                                       \\\n                                                                \\\n  uniform vec2 u_resolution;                                    \\\n  uniform vec2 u_scale;                                         \\\n  uniform vec2 u_offset;                                        \\\n                                                                \\\n  varying vec4 v_color;                                         \\\n                                                                \\\n  void main() {                                                 \\\n    vec2 position = (a_position + u_offset) * u_scale;          \\\n    vec2 clipSpace = (position / u_resolution) * 2.0 - 1.0;     \\\n    gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);          \\\n                                                                \\\n    v_color = vec4(a_color / 255.0, 1.0);                       \\\n  }                                                             ";\n  var figuresFragmentShaderCode = "\\\n  precision mediump float;                                      \\\n                                                                \\\n  varying vec4 v_color;                                         \\\n                                                                \\\n  void main() {                                                 \\\n    gl_FragColor = v_color;                                     \\\n  }                                                             ";\n  var figuresCache = null;\n\n  function initFiguresGL() {\n    var canvas, gl;\n    generateGL();\n    canvas = currentCanvas;\n    currentCanvas = null;\n    gl = currentGL;\n    currentGL = null;\n    var vertexShader = createVertexShader(gl, figuresVertexShaderCode);\n    var fragmentShader = createFragmentShader(gl, figuresFragmentShaderCode);\n    var program = createProgram(gl, [vertexShader, fragmentShader]);\n    gl.useProgram(program);\n    var cache = {};\n    cache.gl = gl;\n    cache.canvas = canvas;\n    cache.resolutionLocation = gl.getUniformLocation(program, "u_resolution");\n    cache.scaleLocation = gl.getUniformLocation(program, "u_scale");\n    cache.offsetLocation = gl.getUniformLocation(program, "u_offset");\n    cache.positionLocation = gl.getAttribLocation(program, "a_position");\n    cache.colorLocation = gl.getAttribLocation(program, "a_color");\n    figuresCache = cache;\n  }\n\n  function drawFigures(width, height, backgroundColor, figures, context) {\n    if (!figuresCache) {\n      initFiguresGL();\n    }\n\n    var cache = figuresCache,\n        canvas = cache.canvas,\n        gl = cache.gl;\n    canvas.width = width;\n    canvas.height = height;\n    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n    gl.uniform2f(cache.resolutionLocation, width, height);\n    var count = 0;\n    var i, ii, rows;\n\n    for (i = 0, ii = figures.length; i < ii; i++) {\n      switch (figures[i].type) {\n        case "lattice":\n          rows = figures[i].coords.length / figures[i].verticesPerRow | 0;\n          count += (rows - 1) * (figures[i].verticesPerRow - 1) * 6;\n          break;\n\n        case "triangles":\n          count += figures[i].coords.length;\n          break;\n      }\n    }\n\n    var coords = new Float32Array(count * 2);\n    var colors = new Uint8Array(count * 3);\n    var coordsMap = context.coords,\n        colorsMap = context.colors;\n    var pIndex = 0,\n        cIndex = 0;\n\n    for (i = 0, ii = figures.length; i < ii; i++) {\n      var figure = figures[i],\n          ps = figure.coords,\n          cs = figure.colors;\n\n      switch (figure.type) {\n        case "lattice":\n          var cols = figure.verticesPerRow;\n          rows = ps.length / cols | 0;\n\n          for (var row = 1; row < rows; row++) {\n            var offset = row * cols + 1;\n\n            for (var col = 1; col < cols; col++, offset++) {\n              coords[pIndex] = coordsMap[ps[offset - cols - 1]];\n              coords[pIndex + 1] = coordsMap[ps[offset - cols - 1] + 1];\n              coords[pIndex + 2] = coordsMap[ps[offset - cols]];\n              coords[pIndex + 3] = coordsMap[ps[offset - cols] + 1];\n              coords[pIndex + 4] = coordsMap[ps[offset - 1]];\n              coords[pIndex + 5] = coordsMap[ps[offset - 1] + 1];\n              colors[cIndex] = colorsMap[cs[offset - cols - 1]];\n              colors[cIndex + 1] = colorsMap[cs[offset - cols - 1] + 1];\n              colors[cIndex + 2] = colorsMap[cs[offset - cols - 1] + 2];\n              colors[cIndex + 3] = colorsMap[cs[offset - cols]];\n              colors[cIndex + 4] = colorsMap[cs[offset - cols] + 1];\n              colors[cIndex + 5] = colorsMap[cs[offset - cols] + 2];\n              colors[cIndex + 6] = colorsMap[cs[offset - 1]];\n              colors[cIndex + 7] = colorsMap[cs[offset - 1] + 1];\n              colors[cIndex + 8] = colorsMap[cs[offset - 1] + 2];\n              coords[pIndex + 6] = coords[pIndex + 2];\n              coords[pIndex + 7] = coords[pIndex + 3];\n              coords[pIndex + 8] = coords[pIndex + 4];\n              coords[pIndex + 9] = coords[pIndex + 5];\n              coords[pIndex + 10] = coordsMap[ps[offset]];\n              coords[pIndex + 11] = coordsMap[ps[offset] + 1];\n              colors[cIndex + 9] = colors[cIndex + 3];\n              colors[cIndex + 10] = colors[cIndex + 4];\n              colors[cIndex + 11] = colors[cIndex + 5];\n              colors[cIndex + 12] = colors[cIndex + 6];\n              colors[cIndex + 13] = colors[cIndex + 7];\n              colors[cIndex + 14] = colors[cIndex + 8];\n              colors[cIndex + 15] = colorsMap[cs[offset]];\n              colors[cIndex + 16] = colorsMap[cs[offset] + 1];\n              colors[cIndex + 17] = colorsMap[cs[offset] + 2];\n              pIndex += 12;\n              cIndex += 18;\n            }\n          }\n\n          break;\n\n        case "triangles":\n          for (var j = 0, jj = ps.length; j < jj; j++) {\n            coords[pIndex] = coordsMap[ps[j]];\n            coords[pIndex + 1] = coordsMap[ps[j] + 1];\n            colors[cIndex] = colorsMap[cs[j]];\n            colors[cIndex + 1] = colorsMap[cs[j] + 1];\n            colors[cIndex + 2] = colorsMap[cs[j] + 2];\n            pIndex += 2;\n            cIndex += 3;\n          }\n\n          break;\n      }\n    }\n\n    if (backgroundColor) {\n      gl.clearColor(backgroundColor[0] / 255, backgroundColor[1] / 255, backgroundColor[2] / 255, 1.0);\n    } else {\n      gl.clearColor(0, 0, 0, 0);\n    }\n\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    var coordsBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, coordsBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, coords, gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(cache.positionLocation);\n    gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0);\n    var colorsBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, colorsBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(cache.colorLocation);\n    gl.vertexAttribPointer(cache.colorLocation, 3, gl.UNSIGNED_BYTE, false, 0, 0);\n    gl.uniform2f(cache.scaleLocation, context.scaleX, context.scaleY);\n    gl.uniform2f(cache.offsetLocation, context.offsetX, context.offsetY);\n    gl.drawArrays(gl.TRIANGLES, 0, count);\n    gl.flush();\n    gl.deleteBuffer(coordsBuffer);\n    gl.deleteBuffer(colorsBuffer);\n    return canvas;\n  }\n\n  return {\n    tryInitGL() {\n      try {\n        generateGL();\n        return !!currentGL;\n      } catch (ex) {}\n\n      return false;\n    },\n\n    composeSMask,\n    drawFigures,\n\n    cleanup() {\n      if (smaskCache && smaskCache.canvas) {\n        smaskCache.canvas.width = 0;\n        smaskCache.canvas.height = 0;\n      }\n\n      if (figuresCache && figuresCache.canvas) {\n        figuresCache.canvas.width = 0;\n        figuresCache.canvas.height = 0;\n      }\n\n      smaskCache = null;\n      figuresCache = null;\n    }\n\n  };\n}();\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n"use strict";\n\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.AnnotationLayer = void 0;\n\nvar _display_utils = __w_pdfjs_require__(1);\n\nvar _util = __w_pdfjs_require__(2);\n\nvar _annotation_storage = __w_pdfjs_require__(8);\n\nclass AnnotationElementFactory {\n  static create(parameters) {\n    const subtype = parameters.data.annotationType;\n\n    switch (subtype) {\n      case _util.AnnotationType.LINK:\n        return new LinkAnnotationElement(parameters);\n\n      case _util.AnnotationType.TEXT:\n        return new TextAnnotationElement(parameters);\n\n      case _util.AnnotationType.WIDGET:\n        const fieldType = parameters.data.fieldType;\n\n        switch (fieldType) {\n          case "Tx":\n            return new TextWidgetAnnotationElement(parameters);\n\n          case "Btn":\n            if (parameters.data.radioButton) {\n              return new RadioButtonWidgetAnnotationElement(parameters);\n            } else if (parameters.data.checkBox) {\n              return new CheckboxWidgetAnnotationElement(parameters);\n            }\n\n            return new PushButtonWidgetAnnotationElement(parameters);\n\n          case "Ch":\n            return new ChoiceWidgetAnnotationElement(parameters);\n        }\n\n        return new WidgetAnnotationElement(parameters);\n\n      case _util.AnnotationType.POPUP:\n        return new PopupAnnotationElement(parameters);\n\n      case _util.AnnotationType.FREETEXT:\n        return new FreeTextAnnotationElement(parameters);\n\n      case _util.AnnotationType.LINE:\n        return new LineAnnotationElement(parameters);\n\n      case _util.AnnotationType.SQUARE:\n        return new SquareAnnotationElement(parameters);\n\n      case _util.AnnotationType.CIRCLE:\n        return new CircleAnnotationElement(parameters);\n\n      case _util.AnnotationType.POLYLINE:\n        return new PolylineAnnotationElement(parameters);\n\n      case _util.AnnotationType.CARET:\n        return new CaretAnnotationElement(parameters);\n\n      case _util.AnnotationType.INK:\n        return new InkAnnotationElement(parameters);\n\n      case _util.AnnotationType.POLYGON:\n        return new PolygonAnnotationElement(parameters);\n\n      case _util.AnnotationType.HIGHLIGHT:\n        return new HighlightAnnotationElement(parameters);\n\n      case _util.AnnotationType.UNDERLINE:\n        return new UnderlineAnnotationElement(parameters);\n\n      case _util.AnnotationType.SQUIGGLY:\n        return new SquigglyAnnotationElement(parameters);\n\n      case _util.AnnotationType.STRIKEOUT:\n        return new StrikeOutAnnotationElement(parameters);\n\n      case _util.AnnotationType.STAMP:\n        return new StampAnnotationElement(parameters);\n\n      case _util.AnnotationType.FILEATTACHMENT:\n        return new FileAttachmentAnnotationElement(parameters);\n\n      default:\n        return new AnnotationElement(parameters);\n    }\n  }\n\n}\n\nclass AnnotationElement {\n  constructor(parameters, isRenderable = false, ignoreBorder = false) {\n    this.isRenderable = isRenderable;\n    this.data = parameters.data;\n    this.layer = parameters.layer;\n    this.page = parameters.page;\n    this.viewport = parameters.viewport;\n    this.linkService = parameters.linkService;\n    this.downloadManager = parameters.downloadManager;\n    this.imageResourcesPath = parameters.imageResourcesPath;\n    this.renderInteractiveForms = parameters.renderInteractiveForms;\n    this.svgFactory = parameters.svgFactory;\n    this.annotationStorage = parameters.annotationStorage;\n\n    if (isRenderable) {\n      this.container = this._createContainer(ignoreBorder);\n    }\n  }\n\n  _createContainer(ignoreBorder = false) {\n    const data = this.data,\n          page = this.page,\n          viewport = this.viewport;\n    const container = document.createElement("section");\n    let width = data.rect[2] - data.rect[0];\n    let height = data.rect[3] - data.rect[1];\n    container.setAttribute("data-annotation-id", data.id);\n\n    const rect = _util.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);\n\n    container.style.transform = `matrix(${viewport.transform.join(",")})`;\n    container.style.transformOrigin = `-${rect[0]}px -${rect[1]}px`;\n\n    if (!ignoreBorder && data.borderStyle.width > 0) {\n      container.style.borderWidth = `${data.borderStyle.width}px`;\n\n      if (data.borderStyle.style !== _util.AnnotationBorderStyleType.UNDERLINE) {\n        width = width - 2 * data.borderStyle.width;\n        height = height - 2 * data.borderStyle.width;\n      }\n\n      const horizontalRadius = data.borderStyle.horizontalCornerRadius;\n      const verticalRadius = data.borderStyle.verticalCornerRadius;\n\n      if (horizontalRadius > 0 || verticalRadius > 0) {\n        const radius = `${horizontalRadius}px / ${verticalRadius}px`;\n        container.style.borderRadius = radius;\n      }\n\n      switch (data.borderStyle.style) {\n        case _util.AnnotationBorderStyleType.SOLID:\n          container.style.borderStyle = "solid";\n          break;\n\n        case _util.AnnotationBorderStyleType.DASHED:\n          container.style.borderStyle = "dashed";\n          break;\n\n        case _util.AnnotationBorderStyleType.BEVELED:\n          (0, _util.warn)("Unimplemented border style: beveled");\n          break;\n\n        case _util.AnnotationBorderStyleType.INSET:\n          (0, _util.warn)("Unimplemented border style: inset");\n          break;\n\n        case _util.AnnotationBorderStyleType.UNDERLINE:\n          container.style.borderBottomStyle = "solid";\n          break;\n\n        default:\n          break;\n      }\n\n      if (data.color) {\n        container.style.borderColor = _util.Util.makeCssRgb(data.color[0] | 0, data.color[1] | 0, data.color[2] | 0);\n      } else {\n        container.style.borderWidth = 0;\n      }\n    }\n\n    container.style.left = `${rect[0]}px`;\n    container.style.top = `${rect[1]}px`;\n    container.style.width = `${width}px`;\n    container.style.height = `${height}px`;\n    return container;\n  }\n\n  _createPopup(container, trigger, data) {\n    if (!trigger) {\n      trigger = document.createElement("div");\n      trigger.style.height = container.style.height;\n      trigger.style.width = container.style.width;\n      container.appendChild(trigger);\n    }\n\n    const popupElement = new PopupElement({\n      container,\n      trigger,\n      color: data.color,\n      title: data.title,\n      modificationDate: data.modificationDate,\n      contents: data.contents,\n      hideWrapper: true\n    });\n    const popup = popupElement.render();\n    popup.style.left = container.style.width;\n    container.appendChild(popup);\n  }\n\n  render() {\n    (0, _util.unreachable)("Abstract method `AnnotationElement.render` called");\n  }\n\n}\n\nclass LinkAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.url || parameters.data.dest || parameters.data.action);\n    super(parameters, isRenderable);\n  }\n\n  render() {\n    this.container.className = "linkAnnotation";\n    const {\n      data,\n      linkService\n    } = this;\n    const link = document.createElement("a");\n\n    if (data.url) {\n      (0, _display_utils.addLinkAttributes)(link, {\n        url: data.url,\n        target: data.newWindow ? _display_utils.LinkTarget.BLANK : linkService.externalLinkTarget,\n        rel: linkService.externalLinkRel,\n        enabled: linkService.externalLinkEnabled\n      });\n    } else if (data.action) {\n      this._bindNamedAction(link, data.action);\n    } else {\n      this._bindLink(link, data.dest);\n    }\n\n    this.container.appendChild(link);\n    return this.container;\n  }\n\n  _bindLink(link, destination) {\n    link.href = this.linkService.getDestinationHash(destination);\n\n    link.onclick = () => {\n      if (destination) {\n        this.linkService.navigateTo(destination);\n      }\n\n      return false;\n    };\n\n    if (destination) {\n      link.className = "internalLink";\n    }\n  }\n\n  _bindNamedAction(link, action) {\n    link.href = this.linkService.getAnchorUrl("");\n\n    link.onclick = () => {\n      this.linkService.executeNamedAction(action);\n      return false;\n    };\n\n    link.className = "internalLink";\n  }\n\n}\n\nclass TextAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n    super(parameters, isRenderable);\n  }\n\n  render() {\n    this.container.className = "textAnnotation";\n    const image = document.createElement("img");\n    image.style.height = this.container.style.height;\n    image.style.width = this.container.style.width;\n    image.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg";\n    image.alt = "[{{type}} Annotation]";\n    image.dataset.l10nId = "text_annotation_type";\n    image.dataset.l10nArgs = JSON.stringify({\n      type: this.data.name\n    });\n\n    if (!this.data.hasPopup) {\n      this._createPopup(this.container, image, this.data);\n    }\n\n    this.container.appendChild(image);\n    return this.container;\n  }\n\n}\n\nclass WidgetAnnotationElement extends AnnotationElement {\n  render() {\n    return this.container;\n  }\n\n}\n\nclass TextWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    const isRenderable = parameters.renderInteractiveForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue;\n    super(parameters, isRenderable);\n  }\n\n  render() {\n    const TEXT_ALIGNMENT = ["left", "center", "right"];\n    const storage = this.annotationStorage;\n    const id = this.data.id;\n    this.container.className = "textWidgetAnnotation";\n    let element = null;\n\n    if (this.renderInteractiveForms) {\n      const textContent = storage.getOrCreateValue(id, this.data.fieldValue);\n\n      if (this.data.multiLine) {\n        element = document.createElement("textarea");\n        element.textContent = textContent;\n      } else {\n        element = document.createElement("input");\n        element.type = "text";\n        element.setAttribute("value", textContent);\n      }\n\n      element.addEventListener("input", function (event) {\n        storage.setValue(id, event.target.value);\n      });\n      element.disabled = this.data.readOnly;\n      element.name = this.data.fieldName;\n\n      if (this.data.maxLen !== null) {\n        element.maxLength = this.data.maxLen;\n      }\n\n      if (this.data.comb) {\n        const fieldWidth = this.data.rect[2] - this.data.rect[0];\n        const combWidth = fieldWidth / this.data.maxLen;\n        element.classList.add("comb");\n        element.style.letterSpacing = `calc(${combWidth}px - 1ch)`;\n      }\n    } else {\n      element = document.createElement("div");\n      element.textContent = this.data.fieldValue;\n      element.style.verticalAlign = "middle";\n      element.style.display = "table-cell";\n      let font = null;\n\n      if (this.data.fontRefName && this.page.commonObjs.has(this.data.fontRefName)) {\n        font = this.page.commonObjs.get(this.data.fontRefName);\n      }\n\n      this._setTextStyle(element, font);\n    }\n\n    if (this.data.textAlignment !== null) {\n      element.style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];\n    }\n\n    this.container.appendChild(element);\n    return this.container;\n  }\n\n  _setTextStyle(element, font) {\n    const style = element.style;\n    style.fontSize = `${this.data.fontSize}px`;\n    style.direction = this.data.fontDirection < 0 ? "rtl" : "ltr";\n\n    if (!font) {\n      return;\n    }\n\n    let bold = "normal";\n\n    if (font.black) {\n      bold = "900";\n    } else if (font.bold) {\n      bold = "bold";\n    }\n\n    style.fontWeight = bold;\n    style.fontStyle = font.italic ? "italic" : "normal";\n    const fontFamily = font.loadedName ? `"${font.loadedName}", ` : "";\n    const fallbackName = font.fallbackName || "Helvetica, sans-serif";\n    style.fontFamily = fontFamily + fallbackName;\n  }\n\n}\n\nclass CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    super(parameters, parameters.renderInteractiveForms);\n  }\n\n  render() {\n    const storage = this.annotationStorage;\n    const data = this.data;\n    const id = data.id;\n    const value = storage.getOrCreateValue(id, data.fieldValue && data.fieldValue !== "Off");\n    this.container.className = "buttonWidgetAnnotation checkBox";\n    const element = document.createElement("input");\n    element.disabled = data.readOnly;\n    element.type = "checkbox";\n    element.name = this.data.fieldName;\n\n    if (value) {\n      element.setAttribute("checked", true);\n    }\n\n    element.addEventListener("change", function (event) {\n      storage.setValue(id, event.target.checked);\n    });\n    this.container.appendChild(element);\n    return this.container;\n  }\n\n}\n\nclass RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    super(parameters, parameters.renderInteractiveForms);\n  }\n\n  render() {\n    this.container.className = "buttonWidgetAnnotation radioButton";\n    const storage = this.annotationStorage;\n    const data = this.data;\n    const id = data.id;\n    const value = storage.getOrCreateValue(id, data.fieldValue === data.buttonValue);\n    const element = document.createElement("input");\n    element.disabled = data.readOnly;\n    element.type = "radio";\n    element.name = data.fieldName;\n\n    if (value) {\n      element.setAttribute("checked", true);\n    }\n\n    element.addEventListener("change", function (event) {\n      const name = event.target.name;\n\n      for (const radio of document.getElementsByName(name)) {\n        if (radio !== event.target) {\n          storage.setValue(radio.parentNode.getAttribute("data-annotation-id"), false);\n        }\n      }\n\n      storage.setValue(id, event.target.checked);\n    });\n    this.container.appendChild(element);\n    return this.container;\n  }\n\n}\n\nclass PushButtonWidgetAnnotationElement extends LinkAnnotationElement {\n  render() {\n    const container = super.render();\n    container.className = "buttonWidgetAnnotation pushButton";\n    return container;\n  }\n\n}\n\nclass ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    super(parameters, parameters.renderInteractiveForms);\n  }\n\n  render() {\n    this.container.className = "choiceWidgetAnnotation";\n    const storage = this.annotationStorage;\n    const id = this.data.id;\n    storage.getOrCreateValue(id, this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : null);\n    const selectElement = document.createElement("select");\n    selectElement.disabled = this.data.readOnly;\n    selectElement.name = this.data.fieldName;\n\n    if (!this.data.combo) {\n      selectElement.size = this.data.options.length;\n\n      if (this.data.multiSelect) {\n        selectElement.multiple = true;\n      }\n    }\n\n    for (const option of this.data.options) {\n      const optionElement = document.createElement("option");\n      optionElement.textContent = option.displayValue;\n      optionElement.value = option.exportValue;\n\n      if (this.data.fieldValue.includes(option.exportValue)) {\n        optionElement.setAttribute("selected", true);\n      }\n\n      selectElement.appendChild(optionElement);\n    }\n\n    selectElement.addEventListener("input", function (event) {\n      const options = event.target.options;\n      const value = options[options.selectedIndex].value;\n      storage.setValue(id, value);\n    });\n    this.container.appendChild(selectElement);\n    return this.container;\n  }\n\n}\n\nclass PopupAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.title || parameters.data.contents);\n    super(parameters, isRenderable);\n  }\n\n  render() {\n    const IGNORE_TYPES = ["Line", "Square", "Circle", "PolyLine", "Polygon", "Ink"];\n    this.container.className = "popupAnnotation";\n\n    if (IGNORE_TYPES.includes(this.data.parentType)) {\n      return this.container;\n    }\n\n    const selector = `[data-annotation-id="${this.data.parentId}"]`;\n    const parentElement = this.layer.querySelector(selector);\n\n    if (!parentElement) {\n      return this.container;\n    }\n\n    const popup = new PopupElement({\n      container: this.container,\n      trigger: parentElement,\n      color: this.data.color,\n      title: this.data.title,\n      modificationDate: this.data.modificationDate,\n      contents: this.data.contents\n    });\n    const parentLeft = parseFloat(parentElement.style.left);\n    const parentWidth = parseFloat(parentElement.style.width);\n    this.container.style.transformOrigin = `-${parentLeft + parentWidth}px -${parentElement.style.top}`;\n    this.container.style.left = `${parentLeft + parentWidth}px`;\n    this.container.appendChild(popup.render());\n    return this.container;\n  }\n\n}\n\nclass PopupElement {\n  constructor(parameters) {\n    this.container = parameters.container;\n    this.trigger = parameters.trigger;\n    this.color = parameters.color;\n    this.title = parameters.title;\n    this.modificationDate = parameters.modificationDate;\n    this.contents = parameters.contents;\n    this.hideWrapper = parameters.hideWrapper || false;\n    this.pinned = false;\n  }\n\n  render() {\n    const BACKGROUND_ENLIGHT = 0.7;\n    const wrapper = document.createElement("div");\n    wrapper.className = "popupWrapper";\n    this.hideElement = this.hideWrapper ? wrapper : this.container;\n    this.hideElement.setAttribute("hidden", true);\n    const popup = document.createElement("div");\n    popup.className = "popup";\n    const color = this.color;\n\n    if (color) {\n      const r = BACKGROUND_ENLIGHT * (255 - color[0]) + color[0];\n      const g = BACKGROUND_ENLIGHT * (255 - color[1]) + color[1];\n      const b = BACKGROUND_ENLIGHT * (255 - color[2]) + color[2];\n      popup.style.backgroundColor = _util.Util.makeCssRgb(r | 0, g | 0, b | 0);\n    }\n\n    const title = document.createElement("h1");\n    title.textContent = this.title;\n    popup.appendChild(title);\n\n    const dateObject = _display_utils.PDFDateString.toDateObject(this.modificationDate);\n\n    if (dateObject) {\n      const modificationDate = document.createElement("span");\n      modificationDate.textContent = "{{date}}, {{time}}";\n      modificationDate.dataset.l10nId = "annotation_date_string";\n      modificationDate.dataset.l10nArgs = JSON.stringify({\n        date: dateObject.toLocaleDateString(),\n        time: dateObject.toLocaleTimeString()\n      });\n      popup.appendChild(modificationDate);\n    }\n\n    const contents = this._formatContents(this.contents);\n\n    popup.appendChild(contents);\n    this.trigger.addEventListener("click", this._toggle.bind(this));\n    this.trigger.addEventListener("mouseover", this._show.bind(this, false));\n    this.trigger.addEventListener("mouseout", this._hide.bind(this, false));\n    popup.addEventListener("click", this._hide.bind(this, true));\n    wrapper.appendChild(popup);\n    return wrapper;\n  }\n\n  _formatContents(contents) {\n    const p = document.createElement("p");\n    const lines = contents.split(/(?:\\r\\n?|\\n)/);\n\n    for (let i = 0, ii = lines.length; i < ii; ++i) {\n      const line = lines[i];\n      p.appendChild(document.createTextNode(line));\n\n      if (i < ii - 1) {\n        p.appendChild(document.createElement("br"));\n      }\n    }\n\n    return p;\n  }\n\n  _toggle() {\n    if (this.pinned) {\n      this._hide(true);\n    } else {\n      this._show(true);\n    }\n  }\n\n  _show(pin = false) {\n    if (pin) {\n      this.pinned = true;\n    }\n\n    if (this.hideElement.hasAttribute("hidden")) {\n      this.hideElement.removeAttribute("hidden");\n      this.container.style.zIndex += 1;\n    }\n  }\n\n  _hide(unpin = true) {\n    if (unpin) {\n      this.pinned = false;\n    }\n\n    if (!this.hideElement.hasAttribute("hidden") && !this.pinned) {\n      this.hideElement.setAttribute("hidden", true);\n      this.container.style.zIndex -= 1;\n    }\n  }\n\n}\n\nclass FreeTextAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n    super(parameters, isRenderable, true);\n  }\n\n  render() {\n    this.container.className = "freeTextAnnotation";\n\n    if (!this.data.hasPopup) {\n      this._createPopup(this.container, null, this.data);\n    }\n\n    return this.container;\n  }\n\n}\n\nclass LineAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n    super(parameters, isRenderable, true);\n  }\n\n  render() {\n    this.container.className = "lineAnnotation";\n    const data = this.data;\n    const width = data.rect[2] - data.rect[0];\n    const height = data.rect[3] - data.rect[1];\n    const svg = this.svgFactory.create(width, height);\n    const line = this.svgFactory.createElement("svg:line");\n    line.setAttribute("x1", data.rect[2] - data.lineCoordinates[0]);\n    line.setAttribute("y1", data.rect[3] - data.lineCoordinates[1]);\n    line.setAttribute("x2", data.rect[2] - data.lineCoordinates[2]);\n    line.setAttribute("y2", data.rect[3] - data.lineCoordinates[3]);\n    line.setAttribute("stroke-width", data.borderStyle.width || 1);\n    line.setAttribute("stroke", "transparent");\n    svg.appendChild(line);\n    this.container.append(svg);\n\n    this._createPopup(this.container, line, data);\n\n    return this.container;\n  }\n\n}\n\nclass SquareAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n    super(parameters, isRenderable, true);\n  }\n\n  render() {\n    this.container.className = "squareAnnotation";\n    const data = this.data;\n    const width = data.rect[2] - data.rect[0];\n    const height = data.rect[3] - data.rect[1];\n    const svg = this.svgFactory.create(width, height);\n    const borderWidth = data.borderStyle.width;\n    const square = this.svgFactory.createElement("svg:rect");\n    square.setAttribute("x", borderWidth / 2);\n    square.setAttribute("y", borderWidth / 2);\n    square.setAttribute("width", width - borderWidth);\n    square.setAttribute("height", height - borderWidth);\n    square.setAttribute("stroke-width", borderWidth || 1);\n    square.setAttribute("stroke", "transparent");\n    square.setAttribute("fill", "none");\n    svg.appendChild(square);\n    this.container.append(svg);\n\n    this._createPopup(this.container, square, data);\n\n    return this.container;\n  }\n\n}\n\nclass CircleAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n    super(parameters, isRenderable, true);\n  }\n\n  render() {\n    this.container.className = "circleAnnotation";\n    const data = this.data;\n    const width = data.rect[2] - data.rect[0];\n    const height = data.rect[3] - data.rect[1];\n    const svg = this.svgFactory.create(width, height);\n    const borderWidth = data.borderStyle.width;\n    const circle = this.svgFactory.createElement("svg:ellipse");\n    circle.setAttribute("cx", width / 2);\n    circle.setAttribute("cy", height / 2);\n    circle.setAttribute("rx", width / 2 - borderWidth / 2);\n    circle.setAttribute("ry", height / 2 - borderWidth / 2);\n    circle.setAttribute("stroke-width", borderWidth || 1);\n    circle.setAttribute("stroke", "transparent");\n    circle.setAttribute("fill", "none");\n    svg.appendChild(circle);\n    this.container.append(svg);\n\n    this._createPopup(this.container, circle, data);\n\n    return this.container;\n  }\n\n}\n\nclass PolylineAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n    super(parameters, isRenderable, true);\n    this.containerClassName = "polylineAnnotation";\n    this.svgElementName = "svg:polyline";\n  }\n\n  render() {\n    this.container.className = this.containerClassName;\n    const data = this.data;\n    const width = data.rect[2] - data.rect[0];\n    const height = data.rect[3] - data.rect[1];\n    const svg = this.svgFactory.create(width, height);\n    let points = [];\n\n    for (const coordinate of data.vertices) {\n      const x = coordinate.x - data.rect[0];\n      const y = data.rect[3] - coordinate.y;\n      points.push(x + "," + y);\n    }\n\n    points = points.join(" ");\n    const polyline = this.svgFactory.createElement(this.svgElementName);\n    polyline.setAttribute("points", points);\n    polyline.setAttribute("stroke-width", data.borderStyle.width || 1);\n    polyline.setAttribute("stroke", "transparent");\n    polyline.setAttribute("fill", "none");\n    svg.appendChild(polyline);\n    this.container.append(svg);\n\n    this._createPopup(this.container, polyline, data);\n\n    return this.container;\n  }\n\n}\n\nclass PolygonAnnotationElement extends PolylineAnnotationElement {\n  constructor(parameters) {\n    super(parameters);\n    this.containerClassName = "polygonAnnotation";\n    this.svgElementName = "svg:polygon";\n  }\n\n}\n\nclass CaretAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n    super(parameters, isRenderable, true);\n  }\n\n  render() {\n    this.container.className = "caretAnnotation";\n\n    if (!this.data.hasPopup) {\n      this._createPopup(this.container, null, this.data);\n    }\n\n    return this.container;\n  }\n\n}\n\nclass InkAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n    super(parameters, isRenderable, true);\n    this.containerClassName = "inkAnnotation";\n    this.svgElementName = "svg:polyline";\n  }\n\n  render() {\n    this.container.className = this.containerClassName;\n    const data = this.data;\n    const width = data.rect[2] - data.rect[0];\n    const height = data.rect[3] - data.rect[1];\n    const svg = this.svgFactory.create(width, height);\n\n    for (const inkList of data.inkLists) {\n      let points = [];\n\n      for (const coordinate of inkList) {\n        const x = coordinate.x - data.rect[0];\n        const y = data.rect[3] - coordinate.y;\n        points.push(`${x},${y}`);\n      }\n\n      points = points.join(" ");\n      const polyline = this.svgFactory.createElement(this.svgElementName);\n      polyline.setAttribute("points", points);\n      polyline.setAttribute("stroke-width", data.borderStyle.width || 1);\n      polyline.setAttribute("stroke", "transparent");\n      polyline.setAttribute("fill", "none");\n\n      this._createPopup(this.container, polyline, data);\n\n      svg.appendChild(polyline);\n    }\n\n    this.container.append(svg);\n    return this.container;\n  }\n\n}\n\nclass HighlightAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n    super(parameters, isRenderable, true);\n  }\n\n  render() {\n    this.container.className = "highlightAnnotation";\n\n    if (!this.data.hasPopup) {\n      this._createPopup(this.container, null, this.data);\n    }\n\n    return this.container;\n  }\n\n}\n\nclass UnderlineAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n    super(parameters, isRenderable, true);\n  }\n\n  render() {\n    this.container.className = "underlineAnnotation";\n\n    if (!this.data.hasPopup) {\n      this._createPopup(this.container, null, this.data);\n    }\n\n    return this.container;\n  }\n\n}\n\nclass SquigglyAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n    super(parameters, isRenderable, true);\n  }\n\n  render() {\n    this.container.className = "squigglyAnnotation";\n\n    if (!this.data.hasPopup) {\n      this._createPopup(this.container, null, this.data);\n    }\n\n    return this.container;\n  }\n\n}\n\nclass StrikeOutAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n    super(parameters, isRenderable, true);\n  }\n\n  render() {\n    this.container.className = "strikeoutAnnotation";\n\n    if (!this.data.hasPopup) {\n      this._createPopup(this.container, null, this.data);\n    }\n\n    return this.container;\n  }\n\n}\n\nclass StampAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n    super(parameters, isRenderable, true);\n  }\n\n  render() {\n    this.container.className = "stampAnnotation";\n\n    if (!this.data.hasPopup) {\n      this._createPopup(this.container, null, this.data);\n    }\n\n    return this.container;\n  }\n\n}\n\nclass FileAttachmentAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    super(parameters, true);\n    const {\n      filename,\n      content\n    } = this.data.file;\n    this.filename = (0, _display_utils.getFilenameFromUrl)(filename);\n    this.content = content;\n\n    if (this.linkService.eventBus) {\n      this.linkService.eventBus.dispatch("fileattachmentannotation", {\n        source: this,\n        id: (0, _util.stringToPDFString)(filename),\n        filename,\n        content\n      });\n    }\n  }\n\n  render() {\n    this.container.className = "fileAttachmentAnnotation";\n    const trigger = document.createElement("div");\n    trigger.style.height = this.container.style.height;\n    trigger.style.width = this.container.style.width;\n    trigger.addEventListener("dblclick", this._download.bind(this));\n\n    if (!this.data.hasPopup && (this.data.title || this.data.contents)) {\n      this._createPopup(this.container, trigger, this.data);\n    }\n\n    this.container.appendChild(trigger);\n    return this.container;\n  }\n\n  _download() {\n    if (!this.downloadManager) {\n      (0, _util.warn)("Download cannot be started due to unavailable download manager");\n      return;\n    }\n\n    this.downloadManager.downloadData(this.content, this.filename, "");\n  }\n\n}\n\nclass AnnotationLayer {\n  static render(parameters) {\n    const sortedAnnotations = [],\n          popupAnnotations = [];\n\n    for (const data of parameters.annotations) {\n      if (!data) {\n        continue;\n      }\n\n      if (data.annotationType === _util.AnnotationType.POPUP) {\n        popupAnnotations.push(data);\n        continue;\n      }\n\n      sortedAnnotations.push(data);\n    }\n\n    if (popupAnnotations.length) {\n      sortedAnnotations.push(...popupAnnotations);\n    }\n\n    for (const data of sortedAnnotations) {\n      const element = AnnotationElementFactory.create({\n        data,\n        layer: parameters.div,\n        page: parameters.page,\n        viewport: parameters.viewport,\n        linkService: parameters.linkService,\n        downloadManager: parameters.downloadManager,\n        imageResourcesPath: parameters.imageResourcesPath || "",\n        renderInteractiveForms: typeof parameters.renderInteractiveForms === "boolean" ? parameters.renderInteractiveForms : true,\n        svgFactory: new _display_utils.DOMSVGFactory(),\n        annotationStorage: parameters.annotationStorage || new _annotation_storage.AnnotationStorage()\n      });\n\n      if (element.isRenderable) {\n        parameters.div.appendChild(element.render());\n      }\n    }\n  }\n\n  static update(parameters) {\n    for (const data of parameters.annotations) {\n      const element = parameters.div.querySelector(`[data-annotation-id="${data.id}"]`);\n\n      if (element) {\n        element.style.transform = `matrix(${parameters.viewport.transform.join(",")})`;\n      }\n    }\n\n    parameters.div.removeAttribute("hidden");\n  }\n\n}\n\nexports.AnnotationLayer = AnnotationLayer;\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n"use strict";\n\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.renderTextLayer = void 0;\n\nvar _util = __w_pdfjs_require__(2);\n\nvar renderTextLayer = function renderTextLayerClosure() {\n  var MAX_TEXT_DIVS_TO_RENDER = 100000;\n  var NonWhitespaceRegexp = /\\S/;\n\n  function isAllWhitespace(str) {\n    return !NonWhitespaceRegexp.test(str);\n  }\n\n  function appendText(task, geom, styles) {\n    var textDiv = document.createElement("span");\n    var textDivProperties = {\n      angle: 0,\n      canvasWidth: 0,\n      isWhitespace: false,\n      originalTransform: null,\n      paddingBottom: 0,\n      paddingLeft: 0,\n      paddingRight: 0,\n      paddingTop: 0,\n      scale: 1\n    };\n\n    task._textDivs.push(textDiv);\n\n    if (isAllWhitespace(geom.str)) {\n      textDivProperties.isWhitespace = true;\n\n      task._textDivProperties.set(textDiv, textDivProperties);\n\n      return;\n    }\n\n    var tx = _util.Util.transform(task._viewport.transform, geom.transform);\n\n    var angle = Math.atan2(tx[1], tx[0]);\n    var style = styles[geom.fontName];\n\n    if (style.vertical) {\n      angle += Math.PI / 2;\n    }\n\n    var fontHeight = Math.sqrt(tx[2] * tx[2] + tx[3] * tx[3]);\n    var fontAscent = fontHeight;\n\n    if (style.ascent) {\n      fontAscent = style.ascent * fontAscent;\n    } else if (style.descent) {\n      fontAscent = (1 + style.descent) * fontAscent;\n    }\n\n    let left, top;\n\n    if (angle === 0) {\n      left = tx[4];\n      top = tx[5] - fontAscent;\n    } else {\n      left = tx[4] + fontAscent * Math.sin(angle);\n      top = tx[5] - fontAscent * Math.cos(angle);\n    }\n\n    textDiv.style.left = `${left}px`;\n    textDiv.style.top = `${top}px`;\n    textDiv.style.fontSize = `${fontHeight}px`;\n    textDiv.style.fontFamily = style.fontFamily;\n    textDiv.textContent = geom.str;\n\n    if (task._fontInspectorEnabled) {\n      textDiv.dataset.fontName = geom.fontName;\n    }\n\n    if (angle !== 0) {\n      textDivProperties.angle = angle * (180 / Math.PI);\n    }\n\n    let shouldScaleText = false;\n\n    if (geom.str.length > 1) {\n      shouldScaleText = true;\n    } else if (geom.transform[0] !== geom.transform[3]) {\n      const absScaleX = Math.abs(geom.transform[0]),\n            absScaleY = Math.abs(geom.transform[3]);\n\n      if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {\n        shouldScaleText = true;\n      }\n    }\n\n    if (shouldScaleText) {\n      if (style.vertical) {\n        textDivProperties.canvasWidth = geom.height * task._viewport.scale;\n      } else {\n        textDivProperties.canvasWidth = geom.width * task._viewport.scale;\n      }\n    }\n\n    task._textDivProperties.set(textDiv, textDivProperties);\n\n    if (task._textContentStream) {\n      task._layoutText(textDiv);\n    }\n\n    if (task._enhanceTextSelection) {\n      var angleCos = 1,\n          angleSin = 0;\n\n      if (angle !== 0) {\n        angleCos = Math.cos(angle);\n        angleSin = Math.sin(angle);\n      }\n\n      var divWidth = (style.vertical ? geom.height : geom.width) * task._viewport.scale;\n      var divHeight = fontHeight;\n      var m, b;\n\n      if (angle !== 0) {\n        m = [angleCos, angleSin, -angleSin, angleCos, left, top];\n        b = _util.Util.getAxialAlignedBoundingBox([0, 0, divWidth, divHeight], m);\n      } else {\n        b = [left, top, left + divWidth, top + divHeight];\n      }\n\n      task._bounds.push({\n        left: b[0],\n        top: b[1],\n        right: b[2],\n        bottom: b[3],\n        div: textDiv,\n        size: [divWidth, divHeight],\n        m\n      });\n    }\n  }\n\n  function render(task) {\n    if (task._canceled) {\n      return;\n    }\n\n    var textDivs = task._textDivs;\n    var capability = task._capability;\n    var textDivsLength = textDivs.length;\n\n    if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {\n      task._renderingDone = true;\n      capability.resolve();\n      return;\n    }\n\n    if (!task._textContentStream) {\n      for (var i = 0; i < textDivsLength; i++) {\n        task._layoutText(textDivs[i]);\n      }\n    }\n\n    task._renderingDone = true;\n    capability.resolve();\n  }\n\n  function findPositiveMin(ts, offset, count) {\n    let result = 0;\n\n    for (let i = 0; i < count; i++) {\n      const t = ts[offset++];\n\n      if (t > 0) {\n        result = result ? Math.min(t, result) : t;\n      }\n    }\n\n    return result;\n  }\n\n  function expand(task) {\n    var bounds = task._bounds;\n    var viewport = task._viewport;\n    var expanded = expandBounds(viewport.width, viewport.height, bounds);\n\n    for (var i = 0; i < expanded.length; i++) {\n      var div = bounds[i].div;\n\n      var divProperties = task._textDivProperties.get(div);\n\n      if (divProperties.angle === 0) {\n        divProperties.paddingLeft = bounds[i].left - expanded[i].left;\n        divProperties.paddingTop = bounds[i].top - expanded[i].top;\n        divProperties.paddingRight = expanded[i].right - bounds[i].right;\n        divProperties.paddingBottom = expanded[i].bottom - bounds[i].bottom;\n\n        task._textDivProperties.set(div, divProperties);\n\n        continue;\n      }\n\n      var e = expanded[i],\n          b = bounds[i];\n      var m = b.m,\n          c = m[0],\n          s = m[1];\n      var points = [[0, 0], [0, b.size[1]], [b.size[0], 0], b.size];\n      var ts = new Float64Array(64);\n      points.forEach(function (p, j) {\n        var t = _util.Util.applyTransform(p, m);\n\n        ts[j + 0] = c && (e.left - t[0]) / c;\n        ts[j + 4] = s && (e.top - t[1]) / s;\n        ts[j + 8] = c && (e.right - t[0]) / c;\n        ts[j + 12] = s && (e.bottom - t[1]) / s;\n        ts[j + 16] = s && (e.left - t[0]) / -s;\n        ts[j + 20] = c && (e.top - t[1]) / c;\n        ts[j + 24] = s && (e.right - t[0]) / -s;\n        ts[j + 28] = c && (e.bottom - t[1]) / c;\n        ts[j + 32] = c && (e.left - t[0]) / -c;\n        ts[j + 36] = s && (e.top - t[1]) / -s;\n        ts[j + 40] = c && (e.right - t[0]) / -c;\n        ts[j + 44] = s && (e.bottom - t[1]) / -s;\n        ts[j + 48] = s && (e.left - t[0]) / s;\n        ts[j + 52] = c && (e.top - t[1]) / -c;\n        ts[j + 56] = s && (e.right - t[0]) / s;\n        ts[j + 60] = c && (e.bottom - t[1]) / -c;\n      });\n      var boxScale = 1 + Math.min(Math.abs(c), Math.abs(s));\n      divProperties.paddingLeft = findPositiveMin(ts, 32, 16) / boxScale;\n      divProperties.paddingTop = findPositiveMin(ts, 48, 16) / boxScale;\n      divProperties.paddingRight = findPositiveMin(ts, 0, 16) / boxScale;\n      divProperties.paddingBottom = findPositiveMin(ts, 16, 16) / boxScale;\n\n      task._textDivProperties.set(div, divProperties);\n    }\n  }\n\n  function expandBounds(width, height, boxes) {\n    var bounds = boxes.map(function (box, i) {\n      return {\n        x1: box.left,\n        y1: box.top,\n        x2: box.right,\n        y2: box.bottom,\n        index: i,\n        x1New: undefined,\n        x2New: undefined\n      };\n    });\n    expandBoundsLTR(width, bounds);\n    var expanded = new Array(boxes.length);\n    bounds.forEach(function (b) {\n      var i = b.index;\n      expanded[i] = {\n        left: b.x1New,\n        top: 0,\n        right: b.x2New,\n        bottom: 0\n      };\n    });\n    boxes.map(function (box, i) {\n      var e = expanded[i],\n          b = bounds[i];\n      b.x1 = box.top;\n      b.y1 = width - e.right;\n      b.x2 = box.bottom;\n      b.y2 = width - e.left;\n      b.index = i;\n      b.x1New = undefined;\n      b.x2New = undefined;\n    });\n    expandBoundsLTR(height, bounds);\n    bounds.forEach(function (b) {\n      var i = b.index;\n      expanded[i].top = b.x1New;\n      expanded[i].bottom = b.x2New;\n    });\n    return expanded;\n  }\n\n  function expandBoundsLTR(width, bounds) {\n    bounds.sort(function (a, b) {\n      return a.x1 - b.x1 || a.index - b.index;\n    });\n    var fakeBoundary = {\n      x1: -Infinity,\n      y1: -Infinity,\n      x2: 0,\n      y2: Infinity,\n      index: -1,\n      x1New: 0,\n      x2New: 0\n    };\n    var horizon = [{\n      start: -Infinity,\n      end: Infinity,\n      boundary: fakeBoundary\n    }];\n    bounds.forEach(function (boundary) {\n      var i = 0;\n\n      while (i < horizon.length && horizon[i].end <= boundary.y1) {\n        i++;\n      }\n\n      var j = horizon.length - 1;\n\n      while (j >= 0 && horizon[j].start >= boundary.y2) {\n        j--;\n      }\n\n      var horizonPart, affectedBoundary;\n      var q,\n          k,\n          maxXNew = -Infinity;\n\n      for (q = i; q <= j; q++) {\n        horizonPart = horizon[q];\n        affectedBoundary = horizonPart.boundary;\n        var xNew;\n\n        if (affectedBoundary.x2 > boundary.x1) {\n          xNew = affectedBoundary.index > boundary.index ? affectedBoundary.x1New : boundary.x1;\n        } else if (affectedBoundary.x2New === undefined) {\n          xNew = (affectedBoundary.x2 + boundary.x1) / 2;\n        } else {\n          xNew = affectedBoundary.x2New;\n        }\n\n        if (xNew > maxXNew) {\n          maxXNew = xNew;\n        }\n      }\n\n      boundary.x1New = maxXNew;\n\n      for (q = i; q <= j; q++) {\n        horizonPart = horizon[q];\n        affectedBoundary = horizonPart.boundary;\n\n        if (affectedBoundary.x2New === undefined) {\n          if (affectedBoundary.x2 > boundary.x1) {\n            if (affectedBoundary.index > boundary.index) {\n              affectedBoundary.x2New = affectedBoundary.x2;\n            }\n          } else {\n            affectedBoundary.x2New = maxXNew;\n          }\n        } else if (affectedBoundary.x2New > maxXNew) {\n          affectedBoundary.x2New = Math.max(maxXNew, affectedBoundary.x2);\n        }\n      }\n\n      var changedHorizon = [],\n          lastBoundary = null;\n\n      for (q = i; q <= j; q++) {\n        horizonPart = horizon[q];\n        affectedBoundary = horizonPart.boundary;\n        var useBoundary = affectedBoundary.x2 > boundary.x2 ? affectedBoundary : boundary;\n\n        if (lastBoundary === useBoundary) {\n          changedHorizon[changedHorizon.length - 1].end = horizonPart.end;\n        } else {\n          changedHorizon.push({\n            start: horizonPart.start,\n            end: horizonPart.end,\n            boundary: useBoundary\n          });\n          lastBoundary = useBoundary;\n        }\n      }\n\n      if (horizon[i].start < boundary.y1) {\n        changedHorizon[0].start = boundary.y1;\n        changedHorizon.unshift({\n          start: horizon[i].start,\n          end: boundary.y1,\n          boundary: horizon[i].boundary\n        });\n      }\n\n      if (boundary.y2 < horizon[j].end) {\n        changedHorizon[changedHorizon.length - 1].end = boundary.y2;\n        changedHorizon.push({\n          start: boundary.y2,\n          end: horizon[j].end,\n          boundary: horizon[j].boundary\n        });\n      }\n\n      for (q = i; q <= j; q++) {\n        horizonPart = horizon[q];\n        affectedBoundary = horizonPart.boundary;\n\n        if (affectedBoundary.x2New !== undefined) {\n          continue;\n        }\n\n        var used = false;\n\n        for (k = i - 1; !used && k >= 0 && horizon[k].start >= affectedBoundary.y1; k--) {\n          used = horizon[k].boundary === affectedBoundary;\n        }\n\n        for (k = j + 1; !used && k < horizon.length && horizon[k].end <= affectedBoundary.y2; k++) {\n          used = horizon[k].boundary === affectedBoundary;\n        }\n\n        for (k = 0; !used && k < changedHorizon.length; k++) {\n          used = changedHorizon[k].boundary === affectedBoundary;\n        }\n\n        if (!used) {\n          affectedBoundary.x2New = maxXNew;\n        }\n      }\n\n      Array.prototype.splice.apply(horizon, [i, j - i + 1].concat(changedHorizon));\n    });\n    horizon.forEach(function (horizonPart) {\n      var affectedBoundary = horizonPart.boundary;\n\n      if (affectedBoundary.x2New === undefined) {\n        affectedBoundary.x2New = Math.max(width, affectedBoundary.x2);\n      }\n    });\n  }\n\n  function TextLayerRenderTask({\n    textContent,\n    textContentStream,\n    container,\n    viewport,\n    textDivs,\n    textContentItemsStr,\n    enhanceTextSelection\n  }) {\n    this._textContent = textContent;\n    this._textContentStream = textContentStream;\n    this._container = container;\n    this._document = container.ownerDocument;\n    this._viewport = viewport;\n    this._textDivs = textDivs || [];\n    this._textContentItemsStr = textContentItemsStr || [];\n    this._enhanceTextSelection = !!enhanceTextSelection;\n    this._fontInspectorEnabled = !!(globalThis.FontInspector && globalThis.FontInspector.enabled);\n    this._reader = null;\n    this._layoutTextLastFontSize = null;\n    this._layoutTextLastFontFamily = null;\n    this._layoutTextCtx = null;\n    this._textDivProperties = new WeakMap();\n    this._renderingDone = false;\n    this._canceled = false;\n    this._capability = (0, _util.createPromiseCapability)();\n    this._renderTimer = null;\n    this._bounds = [];\n\n    this._capability.promise.finally(() => {\n      if (this._layoutTextCtx) {\n        this._layoutTextCtx.canvas.width = 0;\n        this._layoutTextCtx.canvas.height = 0;\n        this._layoutTextCtx = null;\n      }\n    }).catch(() => {});\n  }\n\n  TextLayerRenderTask.prototype = {\n    get promise() {\n      return this._capability.promise;\n    },\n\n    cancel: function TextLayer_cancel() {\n      this._canceled = true;\n\n      if (this._reader) {\n        this._reader.cancel(new _util.AbortException("TextLayer task cancelled."));\n\n        this._reader = null;\n      }\n\n      if (this._renderTimer !== null) {\n        clearTimeout(this._renderTimer);\n        this._renderTimer = null;\n      }\n\n      this._capability.reject(new Error("TextLayer task cancelled."));\n    },\n\n    _processItems(items, styleCache) {\n      for (let i = 0, len = items.length; i < len; i++) {\n        this._textContentItemsStr.push(items[i].str);\n\n        appendText(this, items[i], styleCache);\n      }\n    },\n\n    _layoutText(textDiv) {\n      const textDivProperties = this._textDivProperties.get(textDiv);\n\n      if (textDivProperties.isWhitespace) {\n        return;\n      }\n\n      let transform = "";\n\n      if (textDivProperties.canvasWidth !== 0) {\n        const {\n          fontSize,\n          fontFamily\n        } = textDiv.style;\n\n        if (fontSize !== this._layoutTextLastFontSize || fontFamily !== this._layoutTextLastFontFamily) {\n          this._layoutTextCtx.font = `${fontSize} ${fontFamily}`;\n          this._layoutTextLastFontSize = fontSize;\n          this._layoutTextLastFontFamily = fontFamily;\n        }\n\n        const {\n          width\n        } = this._layoutTextCtx.measureText(textDiv.textContent);\n\n        if (width > 0) {\n          textDivProperties.scale = textDivProperties.canvasWidth / width;\n          transform = `scaleX(${textDivProperties.scale})`;\n        }\n      }\n\n      if (textDivProperties.angle !== 0) {\n        transform = `rotate(${textDivProperties.angle}deg) ${transform}`;\n      }\n\n      if (transform.length > 0) {\n        if (this._enhanceTextSelection) {\n          textDivProperties.originalTransform = transform;\n        }\n\n        textDiv.style.transform = transform;\n      }\n\n      this._textDivProperties.set(textDiv, textDivProperties);\n\n      this._container.appendChild(textDiv);\n    },\n\n    _render: function TextLayer_render(timeout) {\n      const capability = (0, _util.createPromiseCapability)();\n      let styleCache = Object.create(null);\n\n      const canvas = this._document.createElement("canvas");\n\n      canvas.mozOpaque = true;\n      this._layoutTextCtx = canvas.getContext("2d", {\n        alpha: false\n      });\n\n      if (this._textContent) {\n        const textItems = this._textContent.items;\n        const textStyles = this._textContent.styles;\n\n        this._processItems(textItems, textStyles);\n\n        capability.resolve();\n      } else if (this._textContentStream) {\n        const pump = () => {\n          this._reader.read().then(({\n            value,\n            done\n          }) => {\n            if (done) {\n              capability.resolve();\n              return;\n            }\n\n            Object.assign(styleCache, value.styles);\n\n            this._processItems(value.items, styleCache);\n\n            pump();\n          }, capability.reject);\n        };\n\n        this._reader = this._textContentStream.getReader();\n        pump();\n      } else {\n        throw new Error(\'Neither "textContent" nor "textContentStream"\' + " parameters specified.");\n      }\n\n      capability.promise.then(() => {\n        styleCache = null;\n\n        if (!timeout) {\n          render(this);\n        } else {\n          this._renderTimer = setTimeout(() => {\n            render(this);\n            this._renderTimer = null;\n          }, timeout);\n        }\n      }, this._capability.reject);\n    },\n    expandTextDivs: function TextLayer_expandTextDivs(expandDivs) {\n      if (!this._enhanceTextSelection || !this._renderingDone) {\n        return;\n      }\n\n      if (this._bounds !== null) {\n        expand(this);\n        this._bounds = null;\n      }\n\n      const transformBuf = [],\n            paddingBuf = [];\n\n      for (var i = 0, ii = this._textDivs.length; i < ii; i++) {\n        const div = this._textDivs[i];\n\n        const divProps = this._textDivProperties.get(div);\n\n        if (divProps.isWhitespace) {\n          continue;\n        }\n\n        if (expandDivs) {\n          transformBuf.length = 0;\n          paddingBuf.length = 0;\n\n          if (divProps.originalTransform) {\n            transformBuf.push(divProps.originalTransform);\n          }\n\n          if (divProps.paddingTop > 0) {\n            paddingBuf.push(`${divProps.paddingTop}px`);\n            transformBuf.push(`translateY(${-divProps.paddingTop}px)`);\n          } else {\n            paddingBuf.push(0);\n          }\n\n          if (divProps.paddingRight > 0) {\n            paddingBuf.push(`${divProps.paddingRight / divProps.scale}px`);\n          } else {\n            paddingBuf.push(0);\n          }\n\n          if (divProps.paddingBottom > 0) {\n            paddingBuf.push(`${divProps.paddingBottom}px`);\n          } else {\n            paddingBuf.push(0);\n          }\n\n          if (divProps.paddingLeft > 0) {\n            paddingBuf.push(`${divProps.paddingLeft / divProps.scale}px`);\n            transformBuf.push(`translateX(${-divProps.paddingLeft / divProps.scale}px)`);\n          } else {\n            paddingBuf.push(0);\n          }\n\n          div.style.padding = paddingBuf.join(" ");\n\n          if (transformBuf.length) {\n            div.style.transform = transformBuf.join(" ");\n          }\n        } else {\n          div.style.padding = null;\n          div.style.transform = divProps.originalTransform;\n        }\n      }\n    }\n  };\n\n  function renderTextLayer(renderParameters) {\n    var task = new TextLayerRenderTask({\n      textContent: renderParameters.textContent,\n      textContentStream: renderParameters.textContentStream,\n      container: renderParameters.container,\n      viewport: renderParameters.viewport,\n      textDivs: renderParameters.textDivs,\n      textContentItemsStr: renderParameters.textContentItemsStr,\n      enhanceTextSelection: renderParameters.enhanceTextSelection\n    });\n\n    task._render(renderParameters.timeout);\n\n    return task;\n  }\n\n  return renderTextLayer;\n}();\n\nexports.renderTextLayer = renderTextLayer;\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n"use strict";\n\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.SVGGraphics = void 0;\n\nvar _util = __w_pdfjs_require__(2);\n\nvar _display_utils = __w_pdfjs_require__(1);\n\nvar _is_node = __w_pdfjs_require__(4);\n\nlet SVGGraphics = function () {\n  throw new Error("Not implemented: SVGGraphics");\n};\n\nexports.SVGGraphics = SVGGraphics;\n{\n  const SVG_DEFAULTS = {\n    fontStyle: "normal",\n    fontWeight: "normal",\n    fillColor: "#000000"\n  };\n  const XML_NS = "http://www.w3.org/XML/1998/namespace";\n  const XLINK_NS = "http://www.w3.org/1999/xlink";\n  const LINE_CAP_STYLES = ["butt", "round", "square"];\n  const LINE_JOIN_STYLES = ["miter", "round", "bevel"];\n\n  const convertImgDataToPng = function () {\n    const PNG_HEADER = new Uint8Array([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]);\n    const CHUNK_WRAPPER_SIZE = 12;\n    const crcTable = new Int32Array(256);\n\n    for (let i = 0; i < 256; i++) {\n      let c = i;\n\n      for (let h = 0; h < 8; h++) {\n        if (c & 1) {\n          c = 0xedb88320 ^ c >> 1 & 0x7fffffff;\n        } else {\n          c = c >> 1 & 0x7fffffff;\n        }\n      }\n\n      crcTable[i] = c;\n    }\n\n    function crc32(data, start, end) {\n      let crc = -1;\n\n      for (let i = start; i < end; i++) {\n        const a = (crc ^ data[i]) & 0xff;\n        const b = crcTable[a];\n        crc = crc >>> 8 ^ b;\n      }\n\n      return crc ^ -1;\n    }\n\n    function writePngChunk(type, body, data, offset) {\n      let p = offset;\n      const len = body.length;\n      data[p] = len >> 24 & 0xff;\n      data[p + 1] = len >> 16 & 0xff;\n      data[p + 2] = len >> 8 & 0xff;\n      data[p + 3] = len & 0xff;\n      p += 4;\n      data[p] = type.charCodeAt(0) & 0xff;\n      data[p + 1] = type.charCodeAt(1) & 0xff;\n      data[p + 2] = type.charCodeAt(2) & 0xff;\n      data[p + 3] = type.charCodeAt(3) & 0xff;\n      p += 4;\n      data.set(body, p);\n      p += body.length;\n      const crc = crc32(data, offset + 4, p);\n      data[p] = crc >> 24 & 0xff;\n      data[p + 1] = crc >> 16 & 0xff;\n      data[p + 2] = crc >> 8 & 0xff;\n      data[p + 3] = crc & 0xff;\n    }\n\n    function adler32(data, start, end) {\n      let a = 1;\n      let b = 0;\n\n      for (let i = start; i < end; ++i) {\n        a = (a + (data[i] & 0xff)) % 65521;\n        b = (b + a) % 65521;\n      }\n\n      return b << 16 | a;\n    }\n\n    function deflateSync(literals) {\n      if (!_is_node.isNodeJS) {\n        return deflateSyncUncompressed(literals);\n      }\n\n      try {\n        let input;\n\n        if (parseInt(process.versions.node) >= 8) {\n          input = literals;\n        } else {\n          input = Buffer.from(literals);\n        }\n\n        const output = __webpack_require__(258).deflateSync(input, {\n          level: 9\n        });\n\n        return output instanceof Uint8Array ? output : new Uint8Array(output);\n      } catch (e) {\n        (0, _util.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + e);\n      }\n\n      return deflateSyncUncompressed(literals);\n    }\n\n    function deflateSyncUncompressed(literals) {\n      let len = literals.length;\n      const maxBlockLength = 0xffff;\n      const deflateBlocks = Math.ceil(len / maxBlockLength);\n      const idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);\n      let pi = 0;\n      idat[pi++] = 0x78;\n      idat[pi++] = 0x9c;\n      let pos = 0;\n\n      while (len > maxBlockLength) {\n        idat[pi++] = 0x00;\n        idat[pi++] = 0xff;\n        idat[pi++] = 0xff;\n        idat[pi++] = 0x00;\n        idat[pi++] = 0x00;\n        idat.set(literals.subarray(pos, pos + maxBlockLength), pi);\n        pi += maxBlockLength;\n        pos += maxBlockLength;\n        len -= maxBlockLength;\n      }\n\n      idat[pi++] = 0x01;\n      idat[pi++] = len & 0xff;\n      idat[pi++] = len >> 8 & 0xff;\n      idat[pi++] = ~len & 0xffff & 0xff;\n      idat[pi++] = (~len & 0xffff) >> 8 & 0xff;\n      idat.set(literals.subarray(pos), pi);\n      pi += literals.length - pos;\n      const adler = adler32(literals, 0, literals.length);\n      idat[pi++] = adler >> 24 & 0xff;\n      idat[pi++] = adler >> 16 & 0xff;\n      idat[pi++] = adler >> 8 & 0xff;\n      idat[pi++] = adler & 0xff;\n      return idat;\n    }\n\n    function encode(imgData, kind, forceDataSchema, isMask) {\n      const width = imgData.width;\n      const height = imgData.height;\n      let bitDepth, colorType, lineSize;\n      const bytes = imgData.data;\n\n      switch (kind) {\n        case _util.ImageKind.GRAYSCALE_1BPP:\n          colorType = 0;\n          bitDepth = 1;\n          lineSize = width + 7 >> 3;\n          break;\n\n        case _util.ImageKind.RGB_24BPP:\n          colorType = 2;\n          bitDepth = 8;\n          lineSize = width * 3;\n          break;\n\n        case _util.ImageKind.RGBA_32BPP:\n          colorType = 6;\n          bitDepth = 8;\n          lineSize = width * 4;\n          break;\n\n        default:\n          throw new Error("invalid format");\n      }\n\n      const literals = new Uint8Array((1 + lineSize) * height);\n      let offsetLiterals = 0,\n          offsetBytes = 0;\n\n      for (let y = 0; y < height; ++y) {\n        literals[offsetLiterals++] = 0;\n        literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);\n        offsetBytes += lineSize;\n        offsetLiterals += lineSize;\n      }\n\n      if (kind === _util.ImageKind.GRAYSCALE_1BPP && isMask) {\n        offsetLiterals = 0;\n\n        for (let y = 0; y < height; y++) {\n          offsetLiterals++;\n\n          for (let i = 0; i < lineSize; i++) {\n            literals[offsetLiterals++] ^= 0xff;\n          }\n        }\n      }\n\n      const ihdr = new Uint8Array([width >> 24 & 0xff, width >> 16 & 0xff, width >> 8 & 0xff, width & 0xff, height >> 24 & 0xff, height >> 16 & 0xff, height >> 8 & 0xff, height & 0xff, bitDepth, colorType, 0x00, 0x00, 0x00]);\n      const idat = deflateSync(literals);\n      const pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;\n      const data = new Uint8Array(pngLength);\n      let offset = 0;\n      data.set(PNG_HEADER, offset);\n      offset += PNG_HEADER.length;\n      writePngChunk("IHDR", ihdr, data, offset);\n      offset += CHUNK_WRAPPER_SIZE + ihdr.length;\n      writePngChunk("IDATA", idat, data, offset);\n      offset += CHUNK_WRAPPER_SIZE + idat.length;\n      writePngChunk("IEND", new Uint8Array(0), data, offset);\n      return (0, _util.createObjectURL)(data, "image/png", forceDataSchema);\n    }\n\n    return function convertImgDataToPng(imgData, forceDataSchema, isMask) {\n      const kind = imgData.kind === undefined ? _util.ImageKind.GRAYSCALE_1BPP : imgData.kind;\n      return encode(imgData, kind, forceDataSchema, isMask);\n    };\n  }();\n\n  class SVGExtraState {\n    constructor() {\n      this.fontSizeScale = 1;\n      this.fontWeight = SVG_DEFAULTS.fontWeight;\n      this.fontSize = 0;\n      this.textMatrix = _util.IDENTITY_MATRIX;\n      this.fontMatrix = _util.FONT_IDENTITY_MATRIX;\n      this.leading = 0;\n      this.textRenderingMode = _util.TextRenderingMode.FILL;\n      this.textMatrixScale = 1;\n      this.x = 0;\n      this.y = 0;\n      this.lineX = 0;\n      this.lineY = 0;\n      this.charSpacing = 0;\n      this.wordSpacing = 0;\n      this.textHScale = 1;\n      this.textRise = 0;\n      this.fillColor = SVG_DEFAULTS.fillColor;\n      this.strokeColor = "#000000";\n      this.fillAlpha = 1;\n      this.strokeAlpha = 1;\n      this.lineWidth = 1;\n      this.lineJoin = "";\n      this.lineCap = "";\n      this.miterLimit = 0;\n      this.dashArray = [];\n      this.dashPhase = 0;\n      this.dependencies = [];\n      this.activeClipUrl = null;\n      this.clipGroup = null;\n      this.maskId = "";\n    }\n\n    clone() {\n      return Object.create(this);\n    }\n\n    setCurrentPoint(x, y) {\n      this.x = x;\n      this.y = y;\n    }\n\n  }\n\n  function opListToTree(opList) {\n    let opTree = [];\n    const tmp = [];\n\n    for (const opListElement of opList) {\n      if (opListElement.fn === "save") {\n        opTree.push({\n          fnId: 92,\n          fn: "group",\n          items: []\n        });\n        tmp.push(opTree);\n        opTree = opTree[opTree.length - 1].items;\n        continue;\n      }\n\n      if (opListElement.fn === "restore") {\n        opTree = tmp.pop();\n      } else {\n        opTree.push(opListElement);\n      }\n    }\n\n    return opTree;\n  }\n\n  function pf(value) {\n    if (Number.isInteger(value)) {\n      return value.toString();\n    }\n\n    const s = value.toFixed(10);\n    let i = s.length - 1;\n\n    if (s[i] !== "0") {\n      return s;\n    }\n\n    do {\n      i--;\n    } while (s[i] === "0");\n\n    return s.substring(0, s[i] === "." ? i : i + 1);\n  }\n\n  function pm(m) {\n    if (m[4] === 0 && m[5] === 0) {\n      if (m[1] === 0 && m[2] === 0) {\n        if (m[0] === 1 && m[3] === 1) {\n          return "";\n        }\n\n        return `scale(${pf(m[0])} ${pf(m[3])})`;\n      }\n\n      if (m[0] === m[3] && m[1] === -m[2]) {\n        const a = Math.acos(m[0]) * 180 / Math.PI;\n        return `rotate(${pf(a)})`;\n      }\n    } else {\n      if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {\n        return `translate(${pf(m[4])} ${pf(m[5])})`;\n      }\n    }\n\n    return `matrix(${pf(m[0])} ${pf(m[1])} ${pf(m[2])} ${pf(m[3])} ${pf(m[4])} ` + `${pf(m[5])})`;\n  }\n\n  let clipCount = 0;\n  let maskCount = 0;\n  let shadingCount = 0;\n  exports.SVGGraphics = SVGGraphics = class SVGGraphics {\n    constructor(commonObjs, objs, forceDataSchema = false) {\n      this.svgFactory = new _display_utils.DOMSVGFactory();\n      this.current = new SVGExtraState();\n      this.transformMatrix = _util.IDENTITY_MATRIX;\n      this.transformStack = [];\n      this.extraStack = [];\n      this.commonObjs = commonObjs;\n      this.objs = objs;\n      this.pendingClip = null;\n      this.pendingEOFill = false;\n      this.embedFonts = false;\n      this.embeddedFonts = Object.create(null);\n      this.cssStyle = null;\n      this.forceDataSchema = !!forceDataSchema;\n      this._operatorIdMapping = [];\n\n      for (const op in _util.OPS) {\n        this._operatorIdMapping[_util.OPS[op]] = op;\n      }\n    }\n\n    save() {\n      this.transformStack.push(this.transformMatrix);\n      const old = this.current;\n      this.extraStack.push(old);\n      this.current = old.clone();\n    }\n\n    restore() {\n      this.transformMatrix = this.transformStack.pop();\n      this.current = this.extraStack.pop();\n      this.pendingClip = null;\n      this.tgrp = null;\n    }\n\n    group(items) {\n      this.save();\n      this.executeOpTree(items);\n      this.restore();\n    }\n\n    loadDependencies(operatorList) {\n      const fnArray = operatorList.fnArray;\n      const argsArray = operatorList.argsArray;\n\n      for (let i = 0, ii = fnArray.length; i < ii; i++) {\n        if (fnArray[i] !== _util.OPS.dependency) {\n          continue;\n        }\n\n        for (const obj of argsArray[i]) {\n          const objsPool = obj.startsWith("g_") ? this.commonObjs : this.objs;\n          const promise = new Promise(resolve => {\n            objsPool.get(obj, resolve);\n          });\n          this.current.dependencies.push(promise);\n        }\n      }\n\n      return Promise.all(this.current.dependencies);\n    }\n\n    transform(a, b, c, d, e, f) {\n      const transformMatrix = [a, b, c, d, e, f];\n      this.transformMatrix = _util.Util.transform(this.transformMatrix, transformMatrix);\n      this.tgrp = null;\n    }\n\n    getSVG(operatorList, viewport) {\n      this.viewport = viewport;\n\n      const svgElement = this._initialize(viewport);\n\n      return this.loadDependencies(operatorList).then(() => {\n        this.transformMatrix = _util.IDENTITY_MATRIX;\n        this.executeOpTree(this.convertOpList(operatorList));\n        return svgElement;\n      });\n    }\n\n    convertOpList(operatorList) {\n      const operatorIdMapping = this._operatorIdMapping;\n      const argsArray = operatorList.argsArray;\n      const fnArray = operatorList.fnArray;\n      const opList = [];\n\n      for (let i = 0, ii = fnArray.length; i < ii; i++) {\n        const fnId = fnArray[i];\n        opList.push({\n          fnId,\n          fn: operatorIdMapping[fnId],\n          args: argsArray[i]\n        });\n      }\n\n      return opListToTree(opList);\n    }\n\n    executeOpTree(opTree) {\n      for (const opTreeElement of opTree) {\n        const fn = opTreeElement.fn;\n        const fnId = opTreeElement.fnId;\n        const args = opTreeElement.args;\n\n        switch (fnId | 0) {\n          case _util.OPS.beginText:\n            this.beginText();\n            break;\n\n          case _util.OPS.dependency:\n            break;\n\n          case _util.OPS.setLeading:\n            this.setLeading(args);\n            break;\n\n          case _util.OPS.setLeadingMoveText:\n            this.setLeadingMoveText(args[0], args[1]);\n            break;\n\n          case _util.OPS.setFont:\n            this.setFont(args);\n            break;\n\n          case _util.OPS.showText:\n            this.showText(args[0]);\n            break;\n\n          case _util.OPS.showSpacedText:\n            this.showText(args[0]);\n            break;\n\n          case _util.OPS.endText:\n            this.endText();\n            break;\n\n          case _util.OPS.moveText:\n            this.moveText(args[0], args[1]);\n            break;\n\n          case _util.OPS.setCharSpacing:\n            this.setCharSpacing(args[0]);\n            break;\n\n          case _util.OPS.setWordSpacing:\n            this.setWordSpacing(args[0]);\n            break;\n\n          case _util.OPS.setHScale:\n            this.setHScale(args[0]);\n            break;\n\n          case _util.OPS.setTextMatrix:\n            this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);\n            break;\n\n          case _util.OPS.setTextRise:\n            this.setTextRise(args[0]);\n            break;\n\n          case _util.OPS.setTextRenderingMode:\n            this.setTextRenderingMode(args[0]);\n            break;\n\n          case _util.OPS.setLineWidth:\n            this.setLineWidth(args[0]);\n            break;\n\n          case _util.OPS.setLineJoin:\n            this.setLineJoin(args[0]);\n            break;\n\n          case _util.OPS.setLineCap:\n            this.setLineCap(args[0]);\n            break;\n\n          case _util.OPS.setMiterLimit:\n            this.setMiterLimit(args[0]);\n            break;\n\n          case _util.OPS.setFillRGBColor:\n            this.setFillRGBColor(args[0], args[1], args[2]);\n            break;\n\n          case _util.OPS.setStrokeRGBColor:\n            this.setStrokeRGBColor(args[0], args[1], args[2]);\n            break;\n\n          case _util.OPS.setStrokeColorN:\n            this.setStrokeColorN(args);\n            break;\n\n          case _util.OPS.setFillColorN:\n            this.setFillColorN(args);\n            break;\n\n          case _util.OPS.shadingFill:\n            this.shadingFill(args[0]);\n            break;\n\n          case _util.OPS.setDash:\n            this.setDash(args[0], args[1]);\n            break;\n\n          case _util.OPS.setRenderingIntent:\n            this.setRenderingIntent(args[0]);\n            break;\n\n          case _util.OPS.setFlatness:\n            this.setFlatness(args[0]);\n            break;\n\n          case _util.OPS.setGState:\n            this.setGState(args[0]);\n            break;\n\n          case _util.OPS.fill:\n            this.fill();\n            break;\n\n          case _util.OPS.eoFill:\n            this.eoFill();\n            break;\n\n          case _util.OPS.stroke:\n            this.stroke();\n            break;\n\n          case _util.OPS.fillStroke:\n            this.fillStroke();\n            break;\n\n          case _util.OPS.eoFillStroke:\n            this.eoFillStroke();\n            break;\n\n          case _util.OPS.clip:\n            this.clip("nonzero");\n            break;\n\n          case _util.OPS.eoClip:\n            this.clip("evenodd");\n            break;\n\n          case _util.OPS.paintSolidColorImageMask:\n            this.paintSolidColorImageMask();\n            break;\n\n          case _util.OPS.paintImageXObject:\n            this.paintImageXObject(args[0]);\n            break;\n\n          case _util.OPS.paintInlineImageXObject:\n            this.paintInlineImageXObject(args[0]);\n            break;\n\n          case _util.OPS.paintImageMaskXObject:\n            this.paintImageMaskXObject(args[0]);\n            break;\n\n          case _util.OPS.paintFormXObjectBegin:\n            this.paintFormXObjectBegin(args[0], args[1]);\n            break;\n\n          case _util.OPS.paintFormXObjectEnd:\n            this.paintFormXObjectEnd();\n            break;\n\n          case _util.OPS.closePath:\n            this.closePath();\n            break;\n\n          case _util.OPS.closeStroke:\n            this.closeStroke();\n            break;\n\n          case _util.OPS.closeFillStroke:\n            this.closeFillStroke();\n            break;\n\n          case _util.OPS.closeEOFillStroke:\n            this.closeEOFillStroke();\n            break;\n\n          case _util.OPS.nextLine:\n            this.nextLine();\n            break;\n\n          case _util.OPS.transform:\n            this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);\n            break;\n\n          case _util.OPS.constructPath:\n            this.constructPath(args[0], args[1]);\n            break;\n\n          case _util.OPS.endPath:\n            this.endPath();\n            break;\n\n          case 92:\n            this.group(opTreeElement.items);\n            break;\n\n          default:\n            (0, _util.warn)(`Unimplemented operator ${fn}`);\n            break;\n        }\n      }\n    }\n\n    setWordSpacing(wordSpacing) {\n      this.current.wordSpacing = wordSpacing;\n    }\n\n    setCharSpacing(charSpacing) {\n      this.current.charSpacing = charSpacing;\n    }\n\n    nextLine() {\n      this.moveText(0, this.current.leading);\n    }\n\n    setTextMatrix(a, b, c, d, e, f) {\n      const current = this.current;\n      current.textMatrix = current.lineMatrix = [a, b, c, d, e, f];\n      current.textMatrixScale = Math.sqrt(a * a + b * b);\n      current.x = current.lineX = 0;\n      current.y = current.lineY = 0;\n      current.xcoords = [];\n      current.ycoords = [];\n      current.tspan = this.svgFactory.createElement("svg:tspan");\n      current.tspan.setAttributeNS(null, "font-family", current.fontFamily);\n      current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);\n      current.tspan.setAttributeNS(null, "y", pf(-current.y));\n      current.txtElement = this.svgFactory.createElement("svg:text");\n      current.txtElement.appendChild(current.tspan);\n    }\n\n    beginText() {\n      const current = this.current;\n      current.x = current.lineX = 0;\n      current.y = current.lineY = 0;\n      current.textMatrix = _util.IDENTITY_MATRIX;\n      current.lineMatrix = _util.IDENTITY_MATRIX;\n      current.textMatrixScale = 1;\n      current.tspan = this.svgFactory.createElement("svg:tspan");\n      current.txtElement = this.svgFactory.createElement("svg:text");\n      current.txtgrp = this.svgFactory.createElement("svg:g");\n      current.xcoords = [];\n      current.ycoords = [];\n    }\n\n    moveText(x, y) {\n      const current = this.current;\n      current.x = current.lineX += x;\n      current.y = current.lineY += y;\n      current.xcoords = [];\n      current.ycoords = [];\n      current.tspan = this.svgFactory.createElement("svg:tspan");\n      current.tspan.setAttributeNS(null, "font-family", current.fontFamily);\n      current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);\n      current.tspan.setAttributeNS(null, "y", pf(-current.y));\n    }\n\n    showText(glyphs) {\n      const current = this.current;\n      const font = current.font;\n      const fontSize = current.fontSize;\n\n      if (fontSize === 0) {\n        return;\n      }\n\n      const fontSizeScale = current.fontSizeScale;\n      const charSpacing = current.charSpacing;\n      const wordSpacing = current.wordSpacing;\n      const fontDirection = current.fontDirection;\n      const textHScale = current.textHScale * fontDirection;\n      const vertical = font.vertical;\n      const spacingDir = vertical ? 1 : -1;\n      const defaultVMetrics = font.defaultVMetrics;\n      const widthAdvanceScale = fontSize * current.fontMatrix[0];\n      let x = 0;\n\n      for (const glyph of glyphs) {\n        if (glyph === null) {\n          x += fontDirection * wordSpacing;\n          continue;\n        } else if ((0, _util.isNum)(glyph)) {\n          x += spacingDir * glyph * fontSize / 1000;\n          continue;\n        }\n\n        const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n        const character = glyph.fontChar;\n        let scaledX, scaledY;\n        let width = glyph.width;\n\n        if (vertical) {\n          let vx;\n          const vmetric = glyph.vmetric || defaultVMetrics;\n          vx = glyph.vmetric ? vmetric[1] : width * 0.5;\n          vx = -vx * widthAdvanceScale;\n          const vy = vmetric[2] * widthAdvanceScale;\n          width = vmetric ? -vmetric[0] : width;\n          scaledX = vx / fontSizeScale;\n          scaledY = (x + vy) / fontSizeScale;\n        } else {\n          scaledX = x / fontSizeScale;\n          scaledY = 0;\n        }\n\n        if (glyph.isInFont || font.missingFile) {\n          current.xcoords.push(current.x + scaledX);\n\n          if (vertical) {\n            current.ycoords.push(-current.y + scaledY);\n          }\n\n          current.tspan.textContent += character;\n        } else {}\n\n        let charWidth;\n\n        if (vertical) {\n          charWidth = width * widthAdvanceScale - spacing * fontDirection;\n        } else {\n          charWidth = width * widthAdvanceScale + spacing * fontDirection;\n        }\n\n        x += charWidth;\n      }\n\n      current.tspan.setAttributeNS(null, "x", current.xcoords.map(pf).join(" "));\n\n      if (vertical) {\n        current.tspan.setAttributeNS(null, "y", current.ycoords.map(pf).join(" "));\n      } else {\n        current.tspan.setAttributeNS(null, "y", pf(-current.y));\n      }\n\n      if (vertical) {\n        current.y -= x;\n      } else {\n        current.x += x * textHScale;\n      }\n\n      current.tspan.setAttributeNS(null, "font-family", current.fontFamily);\n      current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);\n\n      if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {\n        current.tspan.setAttributeNS(null, "font-style", current.fontStyle);\n      }\n\n      if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {\n        current.tspan.setAttributeNS(null, "font-weight", current.fontWeight);\n      }\n\n      const fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;\n\n      if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n        if (current.fillColor !== SVG_DEFAULTS.fillColor) {\n          current.tspan.setAttributeNS(null, "fill", current.fillColor);\n        }\n\n        if (current.fillAlpha < 1) {\n          current.tspan.setAttributeNS(null, "fill-opacity", current.fillAlpha);\n        }\n      } else if (current.textRenderingMode === _util.TextRenderingMode.ADD_TO_PATH) {\n        current.tspan.setAttributeNS(null, "fill", "transparent");\n      } else {\n        current.tspan.setAttributeNS(null, "fill", "none");\n      }\n\n      if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n        const lineWidthScale = 1 / (current.textMatrixScale || 1);\n\n        this._setStrokeAttributes(current.tspan, lineWidthScale);\n      }\n\n      let textMatrix = current.textMatrix;\n\n      if (current.textRise !== 0) {\n        textMatrix = textMatrix.slice();\n        textMatrix[5] += current.textRise;\n      }\n\n      current.txtElement.setAttributeNS(null, "transform", `${pm(textMatrix)} scale(${pf(textHScale)}, -1)`);\n      current.txtElement.setAttributeNS(XML_NS, "xml:space", "preserve");\n      current.txtElement.appendChild(current.tspan);\n      current.txtgrp.appendChild(current.txtElement);\n\n      this._ensureTransformGroup().appendChild(current.txtElement);\n    }\n\n    setLeadingMoveText(x, y) {\n      this.setLeading(-y);\n      this.moveText(x, y);\n    }\n\n    addFontStyle(fontObj) {\n      if (!fontObj.data) {\n        throw new Error("addFontStyle: No font data available, " + \'ensure that the "fontExtraProperties" API parameter is set.\');\n      }\n\n      if (!this.cssStyle) {\n        this.cssStyle = this.svgFactory.createElement("svg:style");\n        this.cssStyle.setAttributeNS(null, "type", "text/css");\n        this.defs.appendChild(this.cssStyle);\n      }\n\n      const url = (0, _util.createObjectURL)(fontObj.data, fontObj.mimetype, this.forceDataSchema);\n      this.cssStyle.textContent += `@font-face { font-family: "${fontObj.loadedName}";` + ` src: url(${url}); }\\n`;\n    }\n\n    setFont(details) {\n      const current = this.current;\n      const fontObj = this.commonObjs.get(details[0]);\n      let size = details[1];\n      current.font = fontObj;\n\n      if (this.embedFonts && !fontObj.missingFile && !this.embeddedFonts[fontObj.loadedName]) {\n        this.addFontStyle(fontObj);\n        this.embeddedFonts[fontObj.loadedName] = fontObj;\n      }\n\n      current.fontMatrix = fontObj.fontMatrix ? fontObj.fontMatrix : _util.FONT_IDENTITY_MATRIX;\n      let bold = "normal";\n\n      if (fontObj.black) {\n        bold = "900";\n      } else if (fontObj.bold) {\n        bold = "bold";\n      }\n\n      const italic = fontObj.italic ? "italic" : "normal";\n\n      if (size < 0) {\n        size = -size;\n        current.fontDirection = -1;\n      } else {\n        current.fontDirection = 1;\n      }\n\n      current.fontSize = size;\n      current.fontFamily = fontObj.loadedName;\n      current.fontWeight = bold;\n      current.fontStyle = italic;\n      current.tspan = this.svgFactory.createElement("svg:tspan");\n      current.tspan.setAttributeNS(null, "y", pf(-current.y));\n      current.xcoords = [];\n      current.ycoords = [];\n    }\n\n    endText() {\n      const current = this.current;\n\n      if (current.textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG && current.txtElement && current.txtElement.hasChildNodes()) {\n        current.element = current.txtElement;\n        this.clip("nonzero");\n        this.endPath();\n      }\n    }\n\n    setLineWidth(width) {\n      if (width > 0) {\n        this.current.lineWidth = width;\n      }\n    }\n\n    setLineCap(style) {\n      this.current.lineCap = LINE_CAP_STYLES[style];\n    }\n\n    setLineJoin(style) {\n      this.current.lineJoin = LINE_JOIN_STYLES[style];\n    }\n\n    setMiterLimit(limit) {\n      this.current.miterLimit = limit;\n    }\n\n    setStrokeAlpha(strokeAlpha) {\n      this.current.strokeAlpha = strokeAlpha;\n    }\n\n    setStrokeRGBColor(r, g, b) {\n      this.current.strokeColor = _util.Util.makeCssRgb(r, g, b);\n    }\n\n    setFillAlpha(fillAlpha) {\n      this.current.fillAlpha = fillAlpha;\n    }\n\n    setFillRGBColor(r, g, b) {\n      this.current.fillColor = _util.Util.makeCssRgb(r, g, b);\n      this.current.tspan = this.svgFactory.createElement("svg:tspan");\n      this.current.xcoords = [];\n      this.current.ycoords = [];\n    }\n\n    setStrokeColorN(args) {\n      this.current.strokeColor = this._makeColorN_Pattern(args);\n    }\n\n    setFillColorN(args) {\n      this.current.fillColor = this._makeColorN_Pattern(args);\n    }\n\n    shadingFill(args) {\n      const width = this.viewport.width;\n      const height = this.viewport.height;\n\n      const inv = _util.Util.inverseTransform(this.transformMatrix);\n\n      const bl = _util.Util.applyTransform([0, 0], inv);\n\n      const br = _util.Util.applyTransform([0, height], inv);\n\n      const ul = _util.Util.applyTransform([width, 0], inv);\n\n      const ur = _util.Util.applyTransform([width, height], inv);\n\n      const x0 = Math.min(bl[0], br[0], ul[0], ur[0]);\n      const y0 = Math.min(bl[1], br[1], ul[1], ur[1]);\n      const x1 = Math.max(bl[0], br[0], ul[0], ur[0]);\n      const y1 = Math.max(bl[1], br[1], ul[1], ur[1]);\n      const rect = this.svgFactory.createElement("svg:rect");\n      rect.setAttributeNS(null, "x", x0);\n      rect.setAttributeNS(null, "y", y0);\n      rect.setAttributeNS(null, "width", x1 - x0);\n      rect.setAttributeNS(null, "height", y1 - y0);\n      rect.setAttributeNS(null, "fill", this._makeShadingPattern(args));\n\n      if (this.current.fillAlpha < 1) {\n        rect.setAttributeNS(null, "fill-opacity", this.current.fillAlpha);\n      }\n\n      this._ensureTransformGroup().appendChild(rect);\n    }\n\n    _makeColorN_Pattern(args) {\n      if (args[0] === "TilingPattern") {\n        return this._makeTilingPattern(args);\n      }\n\n      return this._makeShadingPattern(args);\n    }\n\n    _makeTilingPattern(args) {\n      const color = args[1];\n      const operatorList = args[2];\n      const matrix = args[3] || _util.IDENTITY_MATRIX;\n      const [x0, y0, x1, y1] = args[4];\n      const xstep = args[5];\n      const ystep = args[6];\n      const paintType = args[7];\n      const tilingId = `shading${shadingCount++}`;\n\n      const [tx0, ty0] = _util.Util.applyTransform([x0, y0], matrix);\n\n      const [tx1, ty1] = _util.Util.applyTransform([x1, y1], matrix);\n\n      const [xscale, yscale] = _util.Util.singularValueDecompose2dScale(matrix);\n\n      const txstep = xstep * xscale;\n      const tystep = ystep * yscale;\n      const tiling = this.svgFactory.createElement("svg:pattern");\n      tiling.setAttributeNS(null, "id", tilingId);\n      tiling.setAttributeNS(null, "patternUnits", "userSpaceOnUse");\n      tiling.setAttributeNS(null, "width", txstep);\n      tiling.setAttributeNS(null, "height", tystep);\n      tiling.setAttributeNS(null, "x", `${tx0}`);\n      tiling.setAttributeNS(null, "y", `${ty0}`);\n      const svg = this.svg;\n      const transformMatrix = this.transformMatrix;\n      const fillColor = this.current.fillColor;\n      const strokeColor = this.current.strokeColor;\n      const bbox = this.svgFactory.create(tx1 - tx0, ty1 - ty0);\n      this.svg = bbox;\n      this.transformMatrix = matrix;\n\n      if (paintType === 2) {\n        const cssColor = _util.Util.makeCssRgb(...color);\n\n        this.current.fillColor = cssColor;\n        this.current.strokeColor = cssColor;\n      }\n\n      this.executeOpTree(this.convertOpList(operatorList));\n      this.svg = svg;\n      this.transformMatrix = transformMatrix;\n      this.current.fillColor = fillColor;\n      this.current.strokeColor = strokeColor;\n      tiling.appendChild(bbox.childNodes[0]);\n      this.defs.appendChild(tiling);\n      return `url(#${tilingId})`;\n    }\n\n    _makeShadingPattern(args) {\n      switch (args[0]) {\n        case "RadialAxial":\n          const shadingId = `shading${shadingCount++}`;\n          const colorStops = args[3];\n          let gradient;\n\n          switch (args[1]) {\n            case "axial":\n              const point0 = args[4];\n              const point1 = args[5];\n              gradient = this.svgFactory.createElement("svg:linearGradient");\n              gradient.setAttributeNS(null, "id", shadingId);\n              gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");\n              gradient.setAttributeNS(null, "x1", point0[0]);\n              gradient.setAttributeNS(null, "y1", point0[1]);\n              gradient.setAttributeNS(null, "x2", point1[0]);\n              gradient.setAttributeNS(null, "y2", point1[1]);\n              break;\n\n            case "radial":\n              const focalPoint = args[4];\n              const circlePoint = args[5];\n              const focalRadius = args[6];\n              const circleRadius = args[7];\n              gradient = this.svgFactory.createElement("svg:radialGradient");\n              gradient.setAttributeNS(null, "id", shadingId);\n              gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");\n              gradient.setAttributeNS(null, "cx", circlePoint[0]);\n              gradient.setAttributeNS(null, "cy", circlePoint[1]);\n              gradient.setAttributeNS(null, "r", circleRadius);\n              gradient.setAttributeNS(null, "fx", focalPoint[0]);\n              gradient.setAttributeNS(null, "fy", focalPoint[1]);\n              gradient.setAttributeNS(null, "fr", focalRadius);\n              break;\n\n            default:\n              throw new Error(`Unknown RadialAxial type: ${args[1]}`);\n          }\n\n          for (const colorStop of colorStops) {\n            const stop = this.svgFactory.createElement("svg:stop");\n            stop.setAttributeNS(null, "offset", colorStop[0]);\n            stop.setAttributeNS(null, "stop-color", colorStop[1]);\n            gradient.appendChild(stop);\n          }\n\n          this.defs.appendChild(gradient);\n          return `url(#${shadingId})`;\n\n        case "Mesh":\n          (0, _util.warn)("Unimplemented pattern Mesh");\n          return null;\n\n        case "Dummy":\n          return "hotpink";\n\n        default:\n          throw new Error(`Unknown IR type: ${args[0]}`);\n      }\n    }\n\n    setDash(dashArray, dashPhase) {\n      this.current.dashArray = dashArray;\n      this.current.dashPhase = dashPhase;\n    }\n\n    constructPath(ops, args) {\n      const current = this.current;\n      let x = current.x,\n          y = current.y;\n      let d = [];\n      let j = 0;\n\n      for (const op of ops) {\n        switch (op | 0) {\n          case _util.OPS.rectangle:\n            x = args[j++];\n            y = args[j++];\n            const width = args[j++];\n            const height = args[j++];\n            const xw = x + width;\n            const yh = y + height;\n            d.push("M", pf(x), pf(y), "L", pf(xw), pf(y), "L", pf(xw), pf(yh), "L", pf(x), pf(yh), "Z");\n            break;\n\n          case _util.OPS.moveTo:\n            x = args[j++];\n            y = args[j++];\n            d.push("M", pf(x), pf(y));\n            break;\n\n          case _util.OPS.lineTo:\n            x = args[j++];\n            y = args[j++];\n            d.push("L", pf(x), pf(y));\n            break;\n\n          case _util.OPS.curveTo:\n            x = args[j + 4];\n            y = args[j + 5];\n            d.push("C", pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y));\n            j += 6;\n            break;\n\n          case _util.OPS.curveTo2:\n            d.push("C", pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]));\n            x = args[j + 2];\n            y = args[j + 3];\n            j += 4;\n            break;\n\n          case _util.OPS.curveTo3:\n            x = args[j + 2];\n            y = args[j + 3];\n            d.push("C", pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y));\n            j += 4;\n            break;\n\n          case _util.OPS.closePath:\n            d.push("Z");\n            break;\n        }\n      }\n\n      d = d.join(" ");\n\n      if (current.path && ops.length > 0 && ops[0] !== _util.OPS.rectangle && ops[0] !== _util.OPS.moveTo) {\n        d = current.path.getAttributeNS(null, "d") + d;\n      } else {\n        current.path = this.svgFactory.createElement("svg:path");\n\n        this._ensureTransformGroup().appendChild(current.path);\n      }\n\n      current.path.setAttributeNS(null, "d", d);\n      current.path.setAttributeNS(null, "fill", "none");\n      current.element = current.path;\n      current.setCurrentPoint(x, y);\n    }\n\n    endPath() {\n      const current = this.current;\n      current.path = null;\n\n      if (!this.pendingClip) {\n        return;\n      }\n\n      if (!current.element) {\n        this.pendingClip = null;\n        return;\n      }\n\n      const clipId = `clippath${clipCount++}`;\n      const clipPath = this.svgFactory.createElement("svg:clipPath");\n      clipPath.setAttributeNS(null, "id", clipId);\n      clipPath.setAttributeNS(null, "transform", pm(this.transformMatrix));\n      const clipElement = current.element.cloneNode(true);\n\n      if (this.pendingClip === "evenodd") {\n        clipElement.setAttributeNS(null, "clip-rule", "evenodd");\n      } else {\n        clipElement.setAttributeNS(null, "clip-rule", "nonzero");\n      }\n\n      this.pendingClip = null;\n      clipPath.appendChild(clipElement);\n      this.defs.appendChild(clipPath);\n\n      if (current.activeClipUrl) {\n        current.clipGroup = null;\n        this.extraStack.forEach(function (prev) {\n          prev.clipGroup = null;\n        });\n        clipPath.setAttributeNS(null, "clip-path", current.activeClipUrl);\n      }\n\n      current.activeClipUrl = `url(#${clipId})`;\n      this.tgrp = null;\n    }\n\n    clip(type) {\n      this.pendingClip = type;\n    }\n\n    closePath() {\n      const current = this.current;\n\n      if (current.path) {\n        const d = `${current.path.getAttributeNS(null, "d")}Z`;\n        current.path.setAttributeNS(null, "d", d);\n      }\n    }\n\n    setLeading(leading) {\n      this.current.leading = -leading;\n    }\n\n    setTextRise(textRise) {\n      this.current.textRise = textRise;\n    }\n\n    setTextRenderingMode(textRenderingMode) {\n      this.current.textRenderingMode = textRenderingMode;\n    }\n\n    setHScale(scale) {\n      this.current.textHScale = scale / 100;\n    }\n\n    setRenderingIntent(intent) {}\n\n    setFlatness(flatness) {}\n\n    setGState(states) {\n      for (const [key, value] of states) {\n        switch (key) {\n          case "LW":\n            this.setLineWidth(value);\n            break;\n\n          case "LC":\n            this.setLineCap(value);\n            break;\n\n          case "LJ":\n            this.setLineJoin(value);\n            break;\n\n          case "ML":\n            this.setMiterLimit(value);\n            break;\n\n          case "D":\n            this.setDash(value[0], value[1]);\n            break;\n\n          case "RI":\n            this.setRenderingIntent(value);\n            break;\n\n          case "FL":\n            this.setFlatness(value);\n            break;\n\n          case "Font":\n            this.setFont(value);\n            break;\n\n          case "CA":\n            this.setStrokeAlpha(value);\n            break;\n\n          case "ca":\n            this.setFillAlpha(value);\n            break;\n\n          default:\n            (0, _util.warn)(`Unimplemented graphic state operator ${key}`);\n            break;\n        }\n      }\n    }\n\n    fill() {\n      const current = this.current;\n\n      if (current.element) {\n        current.element.setAttributeNS(null, "fill", current.fillColor);\n        current.element.setAttributeNS(null, "fill-opacity", current.fillAlpha);\n        this.endPath();\n      }\n    }\n\n    stroke() {\n      const current = this.current;\n\n      if (current.element) {\n        this._setStrokeAttributes(current.element);\n\n        current.element.setAttributeNS(null, "fill", "none");\n        this.endPath();\n      }\n    }\n\n    _setStrokeAttributes(element, lineWidthScale = 1) {\n      const current = this.current;\n      let dashArray = current.dashArray;\n\n      if (lineWidthScale !== 1 && dashArray.length > 0) {\n        dashArray = dashArray.map(function (value) {\n          return lineWidthScale * value;\n        });\n      }\n\n      element.setAttributeNS(null, "stroke", current.strokeColor);\n      element.setAttributeNS(null, "stroke-opacity", current.strokeAlpha);\n      element.setAttributeNS(null, "stroke-miterlimit", pf(current.miterLimit));\n      element.setAttributeNS(null, "stroke-linecap", current.lineCap);\n      element.setAttributeNS(null, "stroke-linejoin", current.lineJoin);\n      element.setAttributeNS(null, "stroke-width", pf(lineWidthScale * current.lineWidth) + "px");\n      element.setAttributeNS(null, "stroke-dasharray", dashArray.map(pf).join(" "));\n      element.setAttributeNS(null, "stroke-dashoffset", pf(lineWidthScale * current.dashPhase) + "px");\n    }\n\n    eoFill() {\n      if (this.current.element) {\n        this.current.element.setAttributeNS(null, "fill-rule", "evenodd");\n      }\n\n      this.fill();\n    }\n\n    fillStroke() {\n      this.stroke();\n      this.fill();\n    }\n\n    eoFillStroke() {\n      if (this.current.element) {\n        this.current.element.setAttributeNS(null, "fill-rule", "evenodd");\n      }\n\n      this.fillStroke();\n    }\n\n    closeStroke() {\n      this.closePath();\n      this.stroke();\n    }\n\n    closeFillStroke() {\n      this.closePath();\n      this.fillStroke();\n    }\n\n    closeEOFillStroke() {\n      this.closePath();\n      this.eoFillStroke();\n    }\n\n    paintSolidColorImageMask() {\n      const rect = this.svgFactory.createElement("svg:rect");\n      rect.setAttributeNS(null, "x", "0");\n      rect.setAttributeNS(null, "y", "0");\n      rect.setAttributeNS(null, "width", "1px");\n      rect.setAttributeNS(null, "height", "1px");\n      rect.setAttributeNS(null, "fill", this.current.fillColor);\n\n      this._ensureTransformGroup().appendChild(rect);\n    }\n\n    paintImageXObject(objId) {\n      const imgData = objId.startsWith("g_") ? this.commonObjs.get(objId) : this.objs.get(objId);\n\n      if (!imgData) {\n        (0, _util.warn)(`Dependent image with object ID ${objId} is not ready yet`);\n        return;\n      }\n\n      this.paintInlineImageXObject(imgData);\n    }\n\n    paintInlineImageXObject(imgData, mask) {\n      const width = imgData.width;\n      const height = imgData.height;\n      const imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask);\n      const cliprect = this.svgFactory.createElement("svg:rect");\n      cliprect.setAttributeNS(null, "x", "0");\n      cliprect.setAttributeNS(null, "y", "0");\n      cliprect.setAttributeNS(null, "width", pf(width));\n      cliprect.setAttributeNS(null, "height", pf(height));\n      this.current.element = cliprect;\n      this.clip("nonzero");\n      const imgEl = this.svgFactory.createElement("svg:image");\n      imgEl.setAttributeNS(XLINK_NS, "xlink:href", imgSrc);\n      imgEl.setAttributeNS(null, "x", "0");\n      imgEl.setAttributeNS(null, "y", pf(-height));\n      imgEl.setAttributeNS(null, "width", pf(width) + "px");\n      imgEl.setAttributeNS(null, "height", pf(height) + "px");\n      imgEl.setAttributeNS(null, "transform", `scale(${pf(1 / width)} ${pf(-1 / height)})`);\n\n      if (mask) {\n        mask.appendChild(imgEl);\n      } else {\n        this._ensureTransformGroup().appendChild(imgEl);\n      }\n    }\n\n    paintImageMaskXObject(imgData) {\n      const current = this.current;\n      const width = imgData.width;\n      const height = imgData.height;\n      const fillColor = current.fillColor;\n      current.maskId = `mask${maskCount++}`;\n      const mask = this.svgFactory.createElement("svg:mask");\n      mask.setAttributeNS(null, "id", current.maskId);\n      const rect = this.svgFactory.createElement("svg:rect");\n      rect.setAttributeNS(null, "x", "0");\n      rect.setAttributeNS(null, "y", "0");\n      rect.setAttributeNS(null, "width", pf(width));\n      rect.setAttributeNS(null, "height", pf(height));\n      rect.setAttributeNS(null, "fill", fillColor);\n      rect.setAttributeNS(null, "mask", `url(#${current.maskId})`);\n      this.defs.appendChild(mask);\n\n      this._ensureTransformGroup().appendChild(rect);\n\n      this.paintInlineImageXObject(imgData, mask);\n    }\n\n    paintFormXObjectBegin(matrix, bbox) {\n      if (Array.isArray(matrix) && matrix.length === 6) {\n        this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);\n      }\n\n      if (bbox) {\n        const width = bbox[2] - bbox[0];\n        const height = bbox[3] - bbox[1];\n        const cliprect = this.svgFactory.createElement("svg:rect");\n        cliprect.setAttributeNS(null, "x", bbox[0]);\n        cliprect.setAttributeNS(null, "y", bbox[1]);\n        cliprect.setAttributeNS(null, "width", pf(width));\n        cliprect.setAttributeNS(null, "height", pf(height));\n        this.current.element = cliprect;\n        this.clip("nonzero");\n        this.endPath();\n      }\n    }\n\n    paintFormXObjectEnd() {}\n\n    _initialize(viewport) {\n      const svg = this.svgFactory.create(viewport.width, viewport.height);\n      const definitions = this.svgFactory.createElement("svg:defs");\n      svg.appendChild(definitions);\n      this.defs = definitions;\n      const rootGroup = this.svgFactory.createElement("svg:g");\n      rootGroup.setAttributeNS(null, "transform", pm(viewport.transform));\n      svg.appendChild(rootGroup);\n      this.svg = rootGroup;\n      return svg;\n    }\n\n    _ensureClipGroup() {\n      if (!this.current.clipGroup) {\n        const clipGroup = this.svgFactory.createElement("svg:g");\n        clipGroup.setAttributeNS(null, "clip-path", this.current.activeClipUrl);\n        this.svg.appendChild(clipGroup);\n        this.current.clipGroup = clipGroup;\n      }\n\n      return this.current.clipGroup;\n    }\n\n    _ensureTransformGroup() {\n      if (!this.tgrp) {\n        this.tgrp = this.svgFactory.createElement("svg:g");\n        this.tgrp.setAttributeNS(null, "transform", pm(this.transformMatrix));\n\n        if (this.current.activeClipUrl) {\n          this._ensureClipGroup().appendChild(this.tgrp);\n        } else {\n          this.svg.appendChild(this.tgrp);\n        }\n      }\n\n      return this.tgrp;\n    }\n\n  };\n}\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n"use strict";\n\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.PDFNodeStream = void 0;\n\nvar _util = __w_pdfjs_require__(2);\n\nvar _network_utils = __w_pdfjs_require__(23);\n\n;\n\nconst fs = __webpack_require__(172);\n\nconst http = __webpack_require__(1);\n\nconst https = __webpack_require__(779);\n\nconst url = __webpack_require__(558);\n\nconst fileUriRegex = /^file:\\/\\/\\/[a-zA-Z]:\\//;\n\nfunction parseUrl(sourceUrl) {\n  const parsedUrl = url.parse(sourceUrl);\n\n  if (parsedUrl.protocol === "file:" || parsedUrl.host) {\n    return parsedUrl;\n  }\n\n  if (/^[a-z]:[/\\\\]/i.test(sourceUrl)) {\n    return url.parse(`file:///${sourceUrl}`);\n  }\n\n  if (!parsedUrl.host) {\n    parsedUrl.protocol = "file:";\n  }\n\n  return parsedUrl;\n}\n\nclass PDFNodeStream {\n  constructor(source) {\n    this.source = source;\n    this.url = parseUrl(source.url);\n    this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:";\n    this.isFsUrl = this.url.protocol === "file:";\n    this.httpHeaders = this.isHttp && source.httpHeaders || {};\n    this._fullRequestReader = null;\n    this._rangeRequestReaders = [];\n  }\n\n  get _progressiveDataLength() {\n    return this._fullRequestReader ? this._fullRequestReader._loaded : 0;\n  }\n\n  getFullReader() {\n    (0, _util.assert)(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once.");\n    this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);\n    return this._fullRequestReader;\n  }\n\n  getRangeReader(start, end) {\n    if (end <= this._progressiveDataLength) {\n      return null;\n    }\n\n    const rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);\n\n    this._rangeRequestReaders.push(rangeReader);\n\n    return rangeReader;\n  }\n\n  cancelAllRequests(reason) {\n    if (this._fullRequestReader) {\n      this._fullRequestReader.cancel(reason);\n    }\n\n    const readers = this._rangeRequestReaders.slice(0);\n\n    readers.forEach(function (reader) {\n      reader.cancel(reason);\n    });\n  }\n\n}\n\nexports.PDFNodeStream = PDFNodeStream;\n\nclass BaseFullReader {\n  constructor(stream) {\n    this._url = stream.url;\n    this._done = false;\n    this._storedError = null;\n    this.onProgress = null;\n    const source = stream.source;\n    this._contentLength = source.length;\n    this._loaded = 0;\n    this._filename = null;\n    this._disableRange = source.disableRange || false;\n    this._rangeChunkSize = source.rangeChunkSize;\n\n    if (!this._rangeChunkSize && !this._disableRange) {\n      this._disableRange = true;\n    }\n\n    this._isStreamingSupported = !source.disableStream;\n    this._isRangeSupported = !source.disableRange;\n    this._readableStream = null;\n    this._readCapability = (0, _util.createPromiseCapability)();\n    this._headersCapability = (0, _util.createPromiseCapability)();\n  }\n\n  get headersReady() {\n    return this._headersCapability.promise;\n  }\n\n  get filename() {\n    return this._filename;\n  }\n\n  get contentLength() {\n    return this._contentLength;\n  }\n\n  get isRangeSupported() {\n    return this._isRangeSupported;\n  }\n\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n\n  async read() {\n    await this._readCapability.promise;\n\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n\n    if (this._storedError) {\n      throw this._storedError;\n    }\n\n    const chunk = this._readableStream.read();\n\n    if (chunk === null) {\n      this._readCapability = (0, _util.createPromiseCapability)();\n      return this.read();\n    }\n\n    this._loaded += chunk.length;\n\n    if (this.onProgress) {\n      this.onProgress({\n        loaded: this._loaded,\n        total: this._contentLength\n      });\n    }\n\n    const buffer = new Uint8Array(chunk).buffer;\n    return {\n      value: buffer,\n      done: false\n    };\n  }\n\n  cancel(reason) {\n    if (!this._readableStream) {\n      this._error(reason);\n\n      return;\n    }\n\n    this._readableStream.destroy(reason);\n  }\n\n  _error(reason) {\n    this._storedError = reason;\n\n    this._readCapability.resolve();\n  }\n\n  _setReadableStream(readableStream) {\n    this._readableStream = readableStream;\n    readableStream.on("readable", () => {\n      this._readCapability.resolve();\n    });\n    readableStream.on("end", () => {\n      readableStream.destroy();\n      this._done = true;\n\n      this._readCapability.resolve();\n    });\n    readableStream.on("error", reason => {\n      this._error(reason);\n    });\n\n    if (!this._isStreamingSupported && this._isRangeSupported) {\n      this._error(new _util.AbortException("streaming is disabled"));\n    }\n\n    if (this._storedError) {\n      this._readableStream.destroy(this._storedError);\n    }\n  }\n\n}\n\nclass BaseRangeReader {\n  constructor(stream) {\n    this._url = stream.url;\n    this._done = false;\n    this._storedError = null;\n    this.onProgress = null;\n    this._loaded = 0;\n    this._readableStream = null;\n    this._readCapability = (0, _util.createPromiseCapability)();\n    const source = stream.source;\n    this._isStreamingSupported = !source.disableStream;\n  }\n\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n\n  async read() {\n    await this._readCapability.promise;\n\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n\n    if (this._storedError) {\n      throw this._storedError;\n    }\n\n    const chunk = this._readableStream.read();\n\n    if (chunk === null) {\n      this._readCapability = (0, _util.createPromiseCapability)();\n      return this.read();\n    }\n\n    this._loaded += chunk.length;\n\n    if (this.onProgress) {\n      this.onProgress({\n        loaded: this._loaded\n      });\n    }\n\n    const buffer = new Uint8Array(chunk).buffer;\n    return {\n      value: buffer,\n      done: false\n    };\n  }\n\n  cancel(reason) {\n    if (!this._readableStream) {\n      this._error(reason);\n\n      return;\n    }\n\n    this._readableStream.destroy(reason);\n  }\n\n  _error(reason) {\n    this._storedError = reason;\n\n    this._readCapability.resolve();\n  }\n\n  _setReadableStream(readableStream) {\n    this._readableStream = readableStream;\n    readableStream.on("readable", () => {\n      this._readCapability.resolve();\n    });\n    readableStream.on("end", () => {\n      readableStream.destroy();\n      this._done = true;\n\n      this._readCapability.resolve();\n    });\n    readableStream.on("error", reason => {\n      this._error(reason);\n    });\n\n    if (this._storedError) {\n      this._readableStream.destroy(this._storedError);\n    }\n  }\n\n}\n\nfunction createRequestOptions(parsedUrl, headers) {\n  return {\n    protocol: parsedUrl.protocol,\n    auth: parsedUrl.auth,\n    host: parsedUrl.hostname,\n    port: parsedUrl.port,\n    path: parsedUrl.path,\n    method: "GET",\n    headers\n  };\n}\n\nclass PDFNodeStreamFullReader extends BaseFullReader {\n  constructor(stream) {\n    super(stream);\n\n    const handleResponse = response => {\n      if (response.statusCode === 404) {\n        const error = new _util.MissingPDFException(`Missing PDF "${this._url}".`);\n        this._storedError = error;\n\n        this._headersCapability.reject(error);\n\n        return;\n      }\n\n      this._headersCapability.resolve();\n\n      this._setReadableStream(response);\n\n      const getResponseHeader = name => {\n        return this._readableStream.headers[name.toLowerCase()];\n      };\n\n      const {\n        allowRangeRequests,\n        suggestedLength\n      } = (0, _network_utils.validateRangeRequestCapabilities)({\n        getResponseHeader,\n        isHttp: stream.isHttp,\n        rangeChunkSize: this._rangeChunkSize,\n        disableRange: this._disableRange\n      });\n      this._isRangeSupported = allowRangeRequests;\n      this._contentLength = suggestedLength || this._contentLength;\n      this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\n    };\n\n    this._request = null;\n\n    if (this._url.protocol === "http:") {\n      this._request = http.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);\n    } else {\n      this._request = https.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);\n    }\n\n    this._request.on("error", reason => {\n      this._storedError = reason;\n\n      this._headersCapability.reject(reason);\n    });\n\n    this._request.end();\n  }\n\n}\n\nclass PDFNodeStreamRangeReader extends BaseRangeReader {\n  constructor(stream, start, end) {\n    super(stream);\n    this._httpHeaders = {};\n\n    for (const property in stream.httpHeaders) {\n      const value = stream.httpHeaders[property];\n\n      if (typeof value === "undefined") {\n        continue;\n      }\n\n      this._httpHeaders[property] = value;\n    }\n\n    this._httpHeaders.Range = `bytes=${start}-${end - 1}`;\n\n    const handleResponse = response => {\n      if (response.statusCode === 404) {\n        const error = new _util.MissingPDFException(`Missing PDF "${this._url}".`);\n        this._storedError = error;\n        return;\n      }\n\n      this._setReadableStream(response);\n    };\n\n    this._request = null;\n\n    if (this._url.protocol === "http:") {\n      this._request = http.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);\n    } else {\n      this._request = https.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);\n    }\n\n    this._request.on("error", reason => {\n      this._storedError = reason;\n    });\n\n    this._request.end();\n  }\n\n}\n\nclass PDFNodeStreamFsFullReader extends BaseFullReader {\n  constructor(stream) {\n    super(stream);\n    let path = decodeURIComponent(this._url.path);\n\n    if (fileUriRegex.test(this._url.href)) {\n      path = path.replace(/^\\//, "");\n    }\n\n    fs.lstat(path, (error, stat) => {\n      if (error) {\n        if (error.code === "ENOENT") {\n          error = new _util.MissingPDFException(`Missing PDF "${path}".`);\n        }\n\n        this._storedError = error;\n\n        this._headersCapability.reject(error);\n\n        return;\n      }\n\n      this._contentLength = stat.size;\n\n      this._setReadableStream(fs.createReadStream(path));\n\n      this._headersCapability.resolve();\n    });\n  }\n\n}\n\nclass PDFNodeStreamFsRangeReader extends BaseRangeReader {\n  constructor(stream, start, end) {\n    super(stream);\n    let path = decodeURIComponent(this._url.path);\n\n    if (fileUriRegex.test(this._url.href)) {\n      path = path.replace(/^\\//, "");\n    }\n\n    this._setReadableStream(fs.createReadStream(path, {\n      start,\n      end: end - 1\n    }));\n  }\n\n}\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n"use strict";\n\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.createResponseStatusError = createResponseStatusError;\nexports.extractFilenameFromHeader = extractFilenameFromHeader;\nexports.validateRangeRequestCapabilities = validateRangeRequestCapabilities;\nexports.validateResponseStatus = validateResponseStatus;\n\nvar _util = __w_pdfjs_require__(2);\n\nvar _content_disposition = __w_pdfjs_require__(24);\n\nfunction validateRangeRequestCapabilities({\n  getResponseHeader,\n  isHttp,\n  rangeChunkSize,\n  disableRange\n}) {\n  (0, _util.assert)(rangeChunkSize > 0, "Range chunk size must be larger than zero");\n  const returnValues = {\n    allowRangeRequests: false,\n    suggestedLength: undefined\n  };\n  const length = parseInt(getResponseHeader("Content-Length"), 10);\n\n  if (!Number.isInteger(length)) {\n    return returnValues;\n  }\n\n  returnValues.suggestedLength = length;\n\n  if (length <= 2 * rangeChunkSize) {\n    return returnValues;\n  }\n\n  if (disableRange || !isHttp) {\n    return returnValues;\n  }\n\n  if (getResponseHeader("Accept-Ranges") !== "bytes") {\n    return returnValues;\n  }\n\n  const contentEncoding = getResponseHeader("Content-Encoding") || "identity";\n\n  if (contentEncoding !== "identity") {\n    return returnValues;\n  }\n\n  returnValues.allowRangeRequests = true;\n  return returnValues;\n}\n\nfunction extractFilenameFromHeader(getResponseHeader) {\n  const contentDisposition = getResponseHeader("Content-Disposition");\n\n  if (contentDisposition) {\n    let filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition);\n\n    if (filename.includes("%")) {\n      try {\n        filename = decodeURIComponent(filename);\n      } catch (ex) {}\n    }\n\n    if (/\\.pdf$/i.test(filename)) {\n      return filename;\n    }\n  }\n\n  return null;\n}\n\nfunction createResponseStatusError(status, url) {\n  if (status === 404 || status === 0 && url.startsWith("file:")) {\n    return new _util.MissingPDFException(\'Missing PDF "\' + url + \'".\');\n  }\n\n  return new _util.UnexpectedResponseException("Unexpected server response (" + status + \') while retrieving PDF "\' + url + \'".\', status);\n}\n\nfunction validateResponseStatus(status) {\n  return status === 200 || status === 206;\n}\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n"use strict";\n\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader;\n\nfunction getFilenameFromContentDispositionHeader(contentDisposition) {\n  let needsEncodingFixup = true;\n  let tmp = toParamRegExp("filename\\\\*", "i").exec(contentDisposition);\n\n  if (tmp) {\n    tmp = tmp[1];\n    let filename = rfc2616unquote(tmp);\n    filename = unescape(filename);\n    filename = rfc5987decode(filename);\n    filename = rfc2047decode(filename);\n    return fixupEncoding(filename);\n  }\n\n  tmp = rfc2231getparam(contentDisposition);\n\n  if (tmp) {\n    const filename = rfc2047decode(tmp);\n    return fixupEncoding(filename);\n  }\n\n  tmp = toParamRegExp("filename", "i").exec(contentDisposition);\n\n  if (tmp) {\n    tmp = tmp[1];\n    let filename = rfc2616unquote(tmp);\n    filename = rfc2047decode(filename);\n    return fixupEncoding(filename);\n  }\n\n  function toParamRegExp(attributePattern, flags) {\n    return new RegExp("(?:^|;)\\\\s*" + attributePattern + "\\\\s*=\\\\s*" + "(" + \'[^";\\\\s][^;\\\\s]*\' + "|" + \'"(?:[^"\\\\\\\\]|\\\\\\\\"?)+"?\' + ")", flags);\n  }\n\n  function textdecode(encoding, value) {\n    if (encoding) {\n      if (!/^[\\x00-\\xFF]+$/.test(value)) {\n        return value;\n      }\n\n      try {\n        const decoder = new TextDecoder(encoding, {\n          fatal: true\n        });\n        const bytes = Array.from(value, function (ch) {\n          return ch.charCodeAt(0) & 0xff;\n        });\n        value = decoder.decode(new Uint8Array(bytes));\n        needsEncodingFixup = false;\n      } catch (e) {\n        if (/^utf-?8$/i.test(encoding)) {\n          try {\n            value = decodeURIComponent(escape(value));\n            needsEncodingFixup = false;\n          } catch (err) {}\n        }\n      }\n    }\n\n    return value;\n  }\n\n  function fixupEncoding(value) {\n    if (needsEncodingFixup && /[\\x80-\\xff]/.test(value)) {\n      value = textdecode("utf-8", value);\n\n      if (needsEncodingFixup) {\n        value = textdecode("iso-8859-1", value);\n      }\n    }\n\n    return value;\n  }\n\n  function rfc2231getparam(contentDispositionStr) {\n    const matches = [];\n    let match;\n    const iter = toParamRegExp("filename\\\\*((?!0\\\\d)\\\\d+)(\\\\*?)", "ig");\n\n    while ((match = iter.exec(contentDispositionStr)) !== null) {\n      let [, n, quot, part] = match;\n      n = parseInt(n, 10);\n\n      if (n in matches) {\n        if (n === 0) {\n          break;\n        }\n\n        continue;\n      }\n\n      matches[n] = [quot, part];\n    }\n\n    const parts = [];\n\n    for (let n = 0; n < matches.length; ++n) {\n      if (!(n in matches)) {\n        break;\n      }\n\n      let [quot, part] = matches[n];\n      part = rfc2616unquote(part);\n\n      if (quot) {\n        part = unescape(part);\n\n        if (n === 0) {\n          part = rfc5987decode(part);\n        }\n      }\n\n      parts.push(part);\n    }\n\n    return parts.join("");\n  }\n\n  function rfc2616unquote(value) {\n    if (value.startsWith(\'"\')) {\n      const parts = value.slice(1).split(\'\\\\"\');\n\n      for (let i = 0; i < parts.length; ++i) {\n        const quotindex = parts[i].indexOf(\'"\');\n\n        if (quotindex !== -1) {\n          parts[i] = parts[i].slice(0, quotindex);\n          parts.length = i + 1;\n        }\n\n        parts[i] = parts[i].replace(/\\\\(.)/g, "$1");\n      }\n\n      value = parts.join(\'"\');\n    }\n\n    return value;\n  }\n\n  function rfc5987decode(extvalue) {\n    const encodingend = extvalue.indexOf("\'");\n\n    if (encodingend === -1) {\n      return extvalue;\n    }\n\n    const encoding = extvalue.slice(0, encodingend);\n    const langvalue = extvalue.slice(encodingend + 1);\n    const value = langvalue.replace(/^[^\']*\'/, "");\n    return textdecode(encoding, value);\n  }\n\n  function rfc2047decode(value) {\n    if (!value.startsWith("=?") || /[\\x00-\\x19\\x80-\\xff]/.test(value)) {\n      return value;\n    }\n\n    return value.replace(/=\\?([\\w-]*)\\?([QqBb])\\?((?:[^?]|\\?(?!=))*)\\?=/g, function (matches, charset, encoding, text) {\n      if (encoding === "q" || encoding === "Q") {\n        text = text.replace(/_/g, " ");\n        text = text.replace(/=([0-9a-fA-F]{2})/g, function (match, hex) {\n          return String.fromCharCode(parseInt(hex, 16));\n        });\n        return textdecode(charset, text);\n      }\n\n      try {\n        text = atob(text);\n      } catch (e) {}\n\n      return textdecode(charset, text);\n    });\n  }\n\n  return "";\n}\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n"use strict";\n\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.PDFNetworkStream = void 0;\n\nvar _util = __w_pdfjs_require__(2);\n\nvar _network_utils = __w_pdfjs_require__(23);\n\n;\nconst OK_RESPONSE = 200;\nconst PARTIAL_CONTENT_RESPONSE = 206;\n\nfunction getArrayBuffer(xhr) {\n  const data = xhr.response;\n\n  if (typeof data !== "string") {\n    return data;\n  }\n\n  const array = (0, _util.stringToBytes)(data);\n  return array.buffer;\n}\n\nclass NetworkManager {\n  constructor(url, args) {\n    this.url = url;\n    args = args || {};\n    this.isHttp = /^https?:/i.test(url);\n    this.httpHeaders = this.isHttp && args.httpHeaders || {};\n    this.withCredentials = args.withCredentials || false;\n\n    this.getXhr = args.getXhr || function NetworkManager_getXhr() {\n      return new XMLHttpRequest();\n    };\n\n    this.currXhrId = 0;\n    this.pendingRequests = Object.create(null);\n  }\n\n  requestRange(begin, end, listeners) {\n    const args = {\n      begin,\n      end\n    };\n\n    for (const prop in listeners) {\n      args[prop] = listeners[prop];\n    }\n\n    return this.request(args);\n  }\n\n  requestFull(listeners) {\n    return this.request(listeners);\n  }\n\n  request(args) {\n    const xhr = this.getXhr();\n    const xhrId = this.currXhrId++;\n    const pendingRequest = this.pendingRequests[xhrId] = {\n      xhr\n    };\n    xhr.open("GET", this.url);\n    xhr.withCredentials = this.withCredentials;\n\n    for (const property in this.httpHeaders) {\n      const value = this.httpHeaders[property];\n\n      if (typeof value === "undefined") {\n        continue;\n      }\n\n      xhr.setRequestHeader(property, value);\n    }\n\n    if (this.isHttp && "begin" in args && "end" in args) {\n      xhr.setRequestHeader("Range", `bytes=${args.begin}-${args.end - 1}`);\n      pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;\n    } else {\n      pendingRequest.expectedStatus = OK_RESPONSE;\n    }\n\n    xhr.responseType = "arraybuffer";\n\n    if (args.onError) {\n      xhr.onerror = function (evt) {\n        args.onError(xhr.status);\n      };\n    }\n\n    xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);\n    xhr.onprogress = this.onProgress.bind(this, xhrId);\n    pendingRequest.onHeadersReceived = args.onHeadersReceived;\n    pendingRequest.onDone = args.onDone;\n    pendingRequest.onError = args.onError;\n    pendingRequest.onProgress = args.onProgress;\n    xhr.send(null);\n    return xhrId;\n  }\n\n  onProgress(xhrId, evt) {\n    const pendingRequest = this.pendingRequests[xhrId];\n\n    if (!pendingRequest) {\n      return;\n    }\n\n    if (pendingRequest.onProgress) {\n      pendingRequest.onProgress(evt);\n    }\n  }\n\n  onStateChange(xhrId, evt) {\n    const pendingRequest = this.pendingRequests[xhrId];\n\n    if (!pendingRequest) {\n      return;\n    }\n\n    const xhr = pendingRequest.xhr;\n\n    if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {\n      pendingRequest.onHeadersReceived();\n      delete pendingRequest.onHeadersReceived;\n    }\n\n    if (xhr.readyState !== 4) {\n      return;\n    }\n\n    if (!(xhrId in this.pendingRequests)) {\n      return;\n    }\n\n    delete this.pendingRequests[xhrId];\n\n    if (xhr.status === 0 && this.isHttp) {\n      if (pendingRequest.onError) {\n        pendingRequest.onError(xhr.status);\n      }\n\n      return;\n    }\n\n    const xhrStatus = xhr.status || OK_RESPONSE;\n    const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;\n\n    if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {\n      if (pendingRequest.onError) {\n        pendingRequest.onError(xhr.status);\n      }\n\n      return;\n    }\n\n    const chunk = getArrayBuffer(xhr);\n\n    if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {\n      const rangeHeader = xhr.getResponseHeader("Content-Range");\n      const matches = /bytes (\\d+)-(\\d+)\\/(\\d+)/.exec(rangeHeader);\n      pendingRequest.onDone({\n        begin: parseInt(matches[1], 10),\n        chunk\n      });\n    } else if (chunk) {\n      pendingRequest.onDone({\n        begin: 0,\n        chunk\n      });\n    } else if (pendingRequest.onError) {\n      pendingRequest.onError(xhr.status);\n    }\n  }\n\n  getRequestXhr(xhrId) {\n    return this.pendingRequests[xhrId].xhr;\n  }\n\n  isPendingRequest(xhrId) {\n    return xhrId in this.pendingRequests;\n  }\n\n  abortRequest(xhrId) {\n    const xhr = this.pendingRequests[xhrId].xhr;\n    delete this.pendingRequests[xhrId];\n    xhr.abort();\n  }\n\n}\n\nclass PDFNetworkStream {\n  constructor(source) {\n    this._source = source;\n    this._manager = new NetworkManager(source.url, {\n      httpHeaders: source.httpHeaders,\n      withCredentials: source.withCredentials\n    });\n    this._rangeChunkSize = source.rangeChunkSize;\n    this._fullRequestReader = null;\n    this._rangeRequestReaders = [];\n  }\n\n  _onRangeRequestReaderClosed(reader) {\n    const i = this._rangeRequestReaders.indexOf(reader);\n\n    if (i >= 0) {\n      this._rangeRequestReaders.splice(i, 1);\n    }\n  }\n\n  getFullReader() {\n    (0, _util.assert)(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once.");\n    this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);\n    return this._fullRequestReader;\n  }\n\n  getRangeReader(begin, end) {\n    const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);\n    reader.onClosed = this._onRangeRequestReaderClosed.bind(this);\n\n    this._rangeRequestReaders.push(reader);\n\n    return reader;\n  }\n\n  cancelAllRequests(reason) {\n    if (this._fullRequestReader) {\n      this._fullRequestReader.cancel(reason);\n    }\n\n    const readers = this._rangeRequestReaders.slice(0);\n\n    readers.forEach(function (reader) {\n      reader.cancel(reason);\n    });\n  }\n\n}\n\nexports.PDFNetworkStream = PDFNetworkStream;\n\nclass PDFNetworkStreamFullRequestReader {\n  constructor(manager, source) {\n    this._manager = manager;\n    const args = {\n      onHeadersReceived: this._onHeadersReceived.bind(this),\n      onDone: this._onDone.bind(this),\n      onError: this._onError.bind(this),\n      onProgress: this._onProgress.bind(this)\n    };\n    this._url = source.url;\n    this._fullRequestId = manager.requestFull(args);\n    this._headersReceivedCapability = (0, _util.createPromiseCapability)();\n    this._disableRange = source.disableRange || false;\n    this._contentLength = source.length;\n    this._rangeChunkSize = source.rangeChunkSize;\n\n    if (!this._rangeChunkSize && !this._disableRange) {\n      this._disableRange = true;\n    }\n\n    this._isStreamingSupported = false;\n    this._isRangeSupported = false;\n    this._cachedChunks = [];\n    this._requests = [];\n    this._done = false;\n    this._storedError = undefined;\n    this._filename = null;\n    this.onProgress = null;\n  }\n\n  _onHeadersReceived() {\n    const fullRequestXhrId = this._fullRequestId;\n\n    const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);\n\n    const getResponseHeader = name => {\n      return fullRequestXhr.getResponseHeader(name);\n    };\n\n    const {\n      allowRangeRequests,\n      suggestedLength\n    } = (0, _network_utils.validateRangeRequestCapabilities)({\n      getResponseHeader,\n      isHttp: this._manager.isHttp,\n      rangeChunkSize: this._rangeChunkSize,\n      disableRange: this._disableRange\n    });\n\n    if (allowRangeRequests) {\n      this._isRangeSupported = true;\n    }\n\n    this._contentLength = suggestedLength || this._contentLength;\n    this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\n\n    if (this._isRangeSupported) {\n      this._manager.abortRequest(fullRequestXhrId);\n    }\n\n    this._headersReceivedCapability.resolve();\n  }\n\n  _onDone(args) {\n    if (args) {\n      if (this._requests.length > 0) {\n        const requestCapability = this._requests.shift();\n\n        requestCapability.resolve({\n          value: args.chunk,\n          done: false\n        });\n      } else {\n        this._cachedChunks.push(args.chunk);\n      }\n    }\n\n    this._done = true;\n\n    if (this._cachedChunks.length > 0) {\n      return;\n    }\n\n    this._requests.forEach(function (requestCapability) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    });\n\n    this._requests = [];\n  }\n\n  _onError(status) {\n    const url = this._url;\n    const exception = (0, _network_utils.createResponseStatusError)(status, url);\n    this._storedError = exception;\n\n    this._headersReceivedCapability.reject(exception);\n\n    this._requests.forEach(function (requestCapability) {\n      requestCapability.reject(exception);\n    });\n\n    this._requests = [];\n    this._cachedChunks = [];\n  }\n\n  _onProgress(data) {\n    if (this.onProgress) {\n      this.onProgress({\n        loaded: data.loaded,\n        total: data.lengthComputable ? data.total : this._contentLength\n      });\n    }\n  }\n\n  get filename() {\n    return this._filename;\n  }\n\n  get isRangeSupported() {\n    return this._isRangeSupported;\n  }\n\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n\n  get contentLength() {\n    return this._contentLength;\n  }\n\n  get headersReady() {\n    return this._headersReceivedCapability.promise;\n  }\n\n  async read() {\n    if (this._storedError) {\n      throw this._storedError;\n    }\n\n    if (this._cachedChunks.length > 0) {\n      const chunk = this._cachedChunks.shift();\n\n      return {\n        value: chunk,\n        done: false\n      };\n    }\n\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n\n    const requestCapability = (0, _util.createPromiseCapability)();\n\n    this._requests.push(requestCapability);\n\n    return requestCapability.promise;\n  }\n\n  cancel(reason) {\n    this._done = true;\n\n    this._headersReceivedCapability.reject(reason);\n\n    this._requests.forEach(function (requestCapability) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    });\n\n    this._requests = [];\n\n    if (this._manager.isPendingRequest(this._fullRequestId)) {\n      this._manager.abortRequest(this._fullRequestId);\n    }\n\n    this._fullRequestReader = null;\n  }\n\n}\n\nclass PDFNetworkStreamRangeRequestReader {\n  constructor(manager, begin, end) {\n    this._manager = manager;\n    const args = {\n      onDone: this._onDone.bind(this),\n      onProgress: this._onProgress.bind(this)\n    };\n    this._requestId = manager.requestRange(begin, end, args);\n    this._requests = [];\n    this._queuedChunk = null;\n    this._done = false;\n    this.onProgress = null;\n    this.onClosed = null;\n  }\n\n  _close() {\n    if (this.onClosed) {\n      this.onClosed(this);\n    }\n  }\n\n  _onDone(data) {\n    const chunk = data.chunk;\n\n    if (this._requests.length > 0) {\n      const requestCapability = this._requests.shift();\n\n      requestCapability.resolve({\n        value: chunk,\n        done: false\n      });\n    } else {\n      this._queuedChunk = chunk;\n    }\n\n    this._done = true;\n\n    this._requests.forEach(function (requestCapability) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    });\n\n    this._requests = [];\n\n    this._close();\n  }\n\n  _onProgress(evt) {\n    if (!this.isStreamingSupported && this.onProgress) {\n      this.onProgress({\n        loaded: evt.loaded\n      });\n    }\n  }\n\n  get isStreamingSupported() {\n    return false;\n  }\n\n  async read() {\n    if (this._queuedChunk !== null) {\n      const chunk = this._queuedChunk;\n      this._queuedChunk = null;\n      return {\n        value: chunk,\n        done: false\n      };\n    }\n\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n\n    const requestCapability = (0, _util.createPromiseCapability)();\n\n    this._requests.push(requestCapability);\n\n    return requestCapability.promise;\n  }\n\n  cancel(reason) {\n    this._done = true;\n\n    this._requests.forEach(function (requestCapability) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    });\n\n    this._requests = [];\n\n    if (this._manager.isPendingRequest(this._requestId)) {\n      this._manager.abortRequest(this._requestId);\n    }\n\n    this._close();\n  }\n\n}\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n"use strict";\n\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.PDFFetchStream = void 0;\n\nvar _util = __w_pdfjs_require__(2);\n\nvar _network_utils = __w_pdfjs_require__(23);\n\n;\n\nfunction createFetchOptions(headers, withCredentials, abortController) {\n  return {\n    method: "GET",\n    headers,\n    signal: abortController && abortController.signal,\n    mode: "cors",\n    credentials: withCredentials ? "include" : "same-origin",\n    redirect: "follow"\n  };\n}\n\nfunction createHeaders(httpHeaders) {\n  const headers = new Headers();\n\n  for (const property in httpHeaders) {\n    const value = httpHeaders[property];\n\n    if (typeof value === "undefined") {\n      continue;\n    }\n\n    headers.append(property, value);\n  }\n\n  return headers;\n}\n\nclass PDFFetchStream {\n  constructor(source) {\n    this.source = source;\n    this.isHttp = /^https?:/i.test(source.url);\n    this.httpHeaders = this.isHttp && source.httpHeaders || {};\n    this._fullRequestReader = null;\n    this._rangeRequestReaders = [];\n  }\n\n  get _progressiveDataLength() {\n    return this._fullRequestReader ? this._fullRequestReader._loaded : 0;\n  }\n\n  getFullReader() {\n    (0, _util.assert)(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once.");\n    this._fullRequestReader = new PDFFetchStreamReader(this);\n    return this._fullRequestReader;\n  }\n\n  getRangeReader(begin, end) {\n    if (end <= this._progressiveDataLength) {\n      return null;\n    }\n\n    const reader = new PDFFetchStreamRangeReader(this, begin, end);\n\n    this._rangeRequestReaders.push(reader);\n\n    return reader;\n  }\n\n  cancelAllRequests(reason) {\n    if (this._fullRequestReader) {\n      this._fullRequestReader.cancel(reason);\n    }\n\n    const readers = this._rangeRequestReaders.slice(0);\n\n    readers.forEach(function (reader) {\n      reader.cancel(reason);\n    });\n  }\n\n}\n\nexports.PDFFetchStream = PDFFetchStream;\n\nclass PDFFetchStreamReader {\n  constructor(stream) {\n    this._stream = stream;\n    this._reader = null;\n    this._loaded = 0;\n    this._filename = null;\n    const source = stream.source;\n    this._withCredentials = source.withCredentials || false;\n    this._contentLength = source.length;\n    this._headersCapability = (0, _util.createPromiseCapability)();\n    this._disableRange = source.disableRange || false;\n    this._rangeChunkSize = source.rangeChunkSize;\n\n    if (!this._rangeChunkSize && !this._disableRange) {\n      this._disableRange = true;\n    }\n\n    if (typeof AbortController !== "undefined") {\n      this._abortController = new AbortController();\n    }\n\n    this._isStreamingSupported = !source.disableStream;\n    this._isRangeSupported = !source.disableRange;\n    this._headers = createHeaders(this._stream.httpHeaders);\n    const url = source.url;\n    fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(response => {\n      if (!(0, _network_utils.validateResponseStatus)(response.status)) {\n        throw (0, _network_utils.createResponseStatusError)(response.status, url);\n      }\n\n      this._reader = response.body.getReader();\n\n      this._headersCapability.resolve();\n\n      const getResponseHeader = name => {\n        return response.headers.get(name);\n      };\n\n      const {\n        allowRangeRequests,\n        suggestedLength\n      } = (0, _network_utils.validateRangeRequestCapabilities)({\n        getResponseHeader,\n        isHttp: this._stream.isHttp,\n        rangeChunkSize: this._rangeChunkSize,\n        disableRange: this._disableRange\n      });\n      this._isRangeSupported = allowRangeRequests;\n      this._contentLength = suggestedLength || this._contentLength;\n      this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\n\n      if (!this._isStreamingSupported && this._isRangeSupported) {\n        this.cancel(new _util.AbortException("Streaming is disabled."));\n      }\n    }).catch(this._headersCapability.reject);\n    this.onProgress = null;\n  }\n\n  get headersReady() {\n    return this._headersCapability.promise;\n  }\n\n  get filename() {\n    return this._filename;\n  }\n\n  get contentLength() {\n    return this._contentLength;\n  }\n\n  get isRangeSupported() {\n    return this._isRangeSupported;\n  }\n\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n\n  async read() {\n    await this._headersCapability.promise;\n    const {\n      value,\n      done\n    } = await this._reader.read();\n\n    if (done) {\n      return {\n        value,\n        done\n      };\n    }\n\n    this._loaded += value.byteLength;\n\n    if (this.onProgress) {\n      this.onProgress({\n        loaded: this._loaded,\n        total: this._contentLength\n      });\n    }\n\n    const buffer = new Uint8Array(value).buffer;\n    return {\n      value: buffer,\n      done: false\n    };\n  }\n\n  cancel(reason) {\n    if (this._reader) {\n      this._reader.cancel(reason);\n    }\n\n    if (this._abortController) {\n      this._abortController.abort();\n    }\n  }\n\n}\n\nclass PDFFetchStreamRangeReader {\n  constructor(stream, begin, end) {\n    this._stream = stream;\n    this._reader = null;\n    this._loaded = 0;\n    const source = stream.source;\n    this._withCredentials = source.withCredentials || false;\n    this._readCapability = (0, _util.createPromiseCapability)();\n    this._isStreamingSupported = !source.disableStream;\n\n    if (typeof AbortController !== "undefined") {\n      this._abortController = new AbortController();\n    }\n\n    this._headers = createHeaders(this._stream.httpHeaders);\n\n    this._headers.append("Range", `bytes=${begin}-${end - 1}`);\n\n    const url = source.url;\n    fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(response => {\n      if (!(0, _network_utils.validateResponseStatus)(response.status)) {\n        throw (0, _network_utils.createResponseStatusError)(response.status, url);\n      }\n\n      this._readCapability.resolve();\n\n      this._reader = response.body.getReader();\n    }).catch(reason => {\n      if (reason && reason.name === "AbortError") {\n        return;\n      }\n\n      throw reason;\n    });\n    this.onProgress = null;\n  }\n\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n\n  async read() {\n    await this._readCapability.promise;\n    const {\n      value,\n      done\n    } = await this._reader.read();\n\n    if (done) {\n      return {\n        value,\n        done\n      };\n    }\n\n    this._loaded += value.byteLength;\n\n    if (this.onProgress) {\n      this.onProgress({\n        loaded: this._loaded\n      });\n    }\n\n    const buffer = new Uint8Array(value).buffer;\n    return {\n      value: buffer,\n      done: false\n    };\n  }\n\n  cancel(reason) {\n    if (this._reader) {\n      this._reader.cancel(reason);\n    }\n\n    if (this._abortController) {\n      this._abortController.abort();\n    }\n  }\n\n}\n\n/***/ })\n/******/ ]);\n});\n//# sourceMappingURL=pdf.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9QZGZDb21wb25lbnRzLy4vbm9kZV9tb2R1bGVzL3BkZmpzLWRpc3QvYnVpbGQvcGRmLmpzPzk1MTEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxJQUF5RDtBQUM3RDtBQUNBLE1BQU0sRUFLcUQ7QUFDM0QsQ0FBQztBQUNELG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxnQ0FBZ0M7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGtCQUFrQjtBQUNsRjtBQUNBLHlEQUF5RCxjQUFjO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGlDQUFpQztBQUNsRix3SEFBd0gsbUJBQW1CLEVBQUU7QUFDN0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDBCQUEwQixFQUFFO0FBQy9ELHlDQUF5QyxlQUFlO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsK0RBQStEO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRyxLQUFLO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLG1DQUFtQyxXQUFXLElBQUk7QUFDMUYsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsS0FBSztBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEtBQUs7QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSw4QkFBOEIsZUFBZTs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0RBQXNELEtBQUs7QUFDM0Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0RBQXdELEtBQUs7QUFDN0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLDBCQUEwQixHQUFHLFNBQVM7QUFDM0Q7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQsV0FBVztBQUM1RDs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9EQUFvRCxFQUFFLFdBQVcsRUFBRSxZQUFZLEVBQUUsWUFBWSxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQUUsMkJBQTJCLEVBQUUsbUJBQW1CLEVBQUU7QUFDN0s7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLElBQUk7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLElBQUk7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLFlBQVk7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0EsR0FBRztBQUNILG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsbUJBQW1CLFlBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBLHlCQUF5QixhQUFhOztBQUV0QyxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxLQUFLO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLEdBQUcsS0FBSztBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRyxLQUFLO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1Asa0ZBQWtGLGVBQWU7QUFDakcsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMERBQTBELGNBQWM7QUFDeEU7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0REFBNEQsS0FBSztBQUNqRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxxREFBcUQsS0FBSztBQUMxRDs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpREFBaUQsUUFBUTtBQUN6RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0RBQWtELE1BQU07QUFDeEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxtRUFBbUUsTUFBTTtBQUN6RTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlEQUF5RDtBQUN6RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEseUdBQXlHLG9CQUFvQjtBQUM3SDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0QsV0FBVzs7QUFFM0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7O0FBRVgsa0RBQWtELHNCQUFzQixNQUFNLEdBQUc7QUFDakY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0Msd0JBQXdCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0NBQWtDLFdBQVcsRUFBRSxzQkFBc0I7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlEQUFpRCxRQUFRO0FBQ3pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLFNBQVMsV0FBVyxFQUFFO0FBQ2hFLGdDQUFnQyxlQUFlLGVBQWUsRUFBRSxNQUFNLEtBQUs7QUFDM0U7QUFDQTs7QUFFQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxRQUFRO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNFQUFzRTs7QUFFdEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsZUFBZSxTQUFTLFdBQVcsRUFBRTtBQUNqRSw4QkFBOEIsZUFBZSxnQkFBZ0IsRUFBRSxNQUFNLEtBQUs7O0FBRTFFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQSxpRUFBaUUsR0FBRztBQUNwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsUUFBUTtBQUMvQzs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsbURBQW1EO0FBQ25EOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixtQkFBTyxDQUFDLEdBQVE7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLEdBQUk7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxpQ0FBaUM7O0FBRWpDLDRCQUE0Qjs7QUFFNUI7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNM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QUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCx3REFBd0Q7QUFDeEQsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHlEQUF5RDtBQUN6RCxxREFBcUQ7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxzREFBc0QsUUFBUTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsVUFBVTtBQUNqQzs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsVUFBVTtBQUM3Qjs7QUFFQSx5QkFBeUIsVUFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixvQkFBb0I7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlFQUFpRSxVQUFVO0FBQzNFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxREFBcUQsV0FBVztBQUNoRTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHVEQUF1RCxZQUFZO0FBQ25FOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0VBQWdFLFdBQVc7QUFDM0U7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sa0NBQWtDO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DLEtBQUs7QUFDekMsT0FBTztBQUNQOztBQUVBLHdDQUF3QyxRQUFRO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsMEVBQTBFO0FBQzFFO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx5Q0FBeUMsUUFBUTtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0RBQWtELFFBQVE7QUFDMUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQixJQUFJO0FBQy9CO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE1BQU07QUFDckI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdURBQXVELFFBQVE7QUFDL0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxTQUFTO0FBQ3RFO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxHQUFHO0FBQ3BFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLGlFQUFpRSxHQUFHO0FBQ3BFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLGlFQUFpRSxHQUFHO0FBQ3BFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLGlFQUFpRSxHQUFHO0FBQ3BFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5REFBeUQsYUFBYTtBQUN0RTtBQUNBOztBQUVBLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJEQUEyRCxHQUFHO0FBQzlEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsWUFBWTtBQUN2Qzs7QUFFQSw2QkFBNkIsWUFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtB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OztBQUVBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsTUFBTSxJQUFJLE1BQU07QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsRUFBRSxHQUFHLEVBQUU7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkVBQTJFLFFBQVE7O0FBRW5GO0FBQ0EsNENBQTRDLHdDQUF3QztBQUNwRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsS0FBSztBQUNqQywyQkFBMkIsSUFBSTtBQUMvQixnQ0FBZ0MsV0FBVztBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLG9CQUFvQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLFdBQVc7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIscUJBQXFCO0FBQ3hDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHVCQUF1Qiw0REFBNEQ7QUFDbkY7QUFDQTs7QUFFQSx1QkFBdUIsc0VBQXNFO0FBQzdGO0FBQ0E7O0FBRUEsbUJBQW1CLG9DQUFvQztBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxnQkFBZ0I7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSx3Q0FBd0MsU0FBUyxHQUFHLFdBQVc7QUFDL0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxnQ0FBZ0Msd0JBQXdCO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIsd0JBQXdCLE9BQU8sVUFBVTtBQUN2RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaURBQWlELFFBQVE7QUFDekQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0Isb0JBQW9CO0FBQ25ELDRDQUE0QyxxQkFBcUI7QUFDakUsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsdUNBQXVDO0FBQ3RFLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLHVCQUF1QjtBQUN0RCxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixzQ0FBc0M7QUFDckUsNENBQTRDLHVDQUF1QztBQUNuRixXQUFXO0FBQ1g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLFNBQVM7QUFDNUI7O0FBRUEscUJBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlCQUF5QixTQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsU0FBUztBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSx1QkFBdUIsb0NBQTJCO0FBQ2xEO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUJBQXVCLFlBQVk7QUFDbkM7O0FBRUEseUJBQXlCLGNBQWM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLFNBQVMsR0FBRyxTQUFTO0FBQzdDOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUIsTUFBTTtBQUMvQjtBQUNBLEtBQUs7QUFDTDtBQUNBLDRCQUE0QixTQUFTLEdBQUcsU0FBUztBQUNqRDtBQUNBOztBQUVBLHFCQUFxQixTQUFTLEdBQUcsU0FBUyxHQUFHLFNBQVMsR0FBRyxTQUFTLEdBQUcsU0FBUyxRQUFRLFNBQVM7QUFDL0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNEQUFzRCxHQUFHO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELHFCQUFxQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELHFCQUFxQjtBQUM5RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLHlEQUF5RCxxQkFBcUI7O0FBRTlFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhEQUE4RCxlQUFlLFNBQVMsZUFBZTtBQUNyRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdELGlCQUFpQixtQkFBbUIsRUFBRSxpQkFBaUIsSUFBSSxFQUFFLEVBQUU7QUFDL0c7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGVBQWU7O0FBRWhEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLElBQUk7QUFDOUMsMENBQTBDLElBQUk7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZUFBZTtBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyREFBMkQsUUFBUTtBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsVUFBVTs7QUFFbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDLFlBQVk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsdUNBQXVDO0FBQzVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0VBQW9FLElBQUk7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwREFBMEQsTUFBTTtBQUNoRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxjQUFjLEdBQUcsZ0JBQWdCOztBQUV4RjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFlBQVk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxlQUFlO0FBQy9EOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxXQUFXLG1CQUFPLENBQUMsR0FBSTs7QUFFdkIsYUFBYSxtQkFBTyxDQUFDLENBQU07O0FBRTNCLGNBQWMsbUJBQU8sQ0FBQyxHQUFPOztBQUU3QixZQUFZLG1CQUFPLENBQUMsR0FBSzs7QUFFekI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0MsVUFBVTtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9FQUFvRSxVQUFVO0FBQzlFOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVDQUF1QyxNQUFNLEdBQUcsUUFBUTs7QUFFeEQ7QUFDQTtBQUNBLG9FQUFvRSxVQUFVO0FBQzlFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsS0FBSztBQUNyRTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixxREFBcUQsT0FBTztBQUN6Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsa0JBQWtCO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLEVBQUU7QUFDN0M7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkMsV0FBVyxHQUFHLGFBQWE7QUFDeEU7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwyQ0FBMkMsTUFBTSxHQUFHLFFBQVE7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBLENBQUM7QUFDRCIsImZpbGUiOiIyOTkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNzdGFydCBUaGUgZm9sbG93aW5nIGlzIHRoZSBlbnRpcmUgbGljZW5zZSBub3RpY2UgZm9yIHRoZVxuICogSmF2YXNjcmlwdCBjb2RlIGluIHRoaXMgcGFnZVxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1vemlsbGEgRm91bmRhdGlvblxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAbGljZW5kIFRoZSBhYm92ZSBpcyB0aGUgZW50aXJlIGxpY2Vuc2Ugbm90aWNlIGZvciB0aGVcbiAqIEphdmFzY3JpcHQgY29kZSBpbiB0aGlzIHBhZ2VcbiAqL1xuXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShcInBkZmpzLWRpc3QvYnVpbGQvcGRmXCIsIFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcInBkZmpzLWRpc3QvYnVpbGQvcGRmXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcInBkZmpzLWRpc3QvYnVpbGQvcGRmXCJdID0gcm9vdC5wZGZqc0xpYiA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193X3BkZmpzX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193X3BkZmpzX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd19wZGZqc19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193X3BkZmpzX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd19wZGZqc19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dfcGRmanNfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4vKioqKioqLyBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4vKioqKioqLyBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4vKioqKioqLyBcdF9fd19wZGZqc19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193X3BkZmpzX3JlcXVpcmVfXyh2YWx1ZSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKioqKioqLyBcdFx0X193X3BkZmpzX3JlcXVpcmVfXy5yKG5zKTtcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193X3BkZmpzX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuLyoqKioqKi8gXHRcdHJldHVybiBucztcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd19wZGZqc19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193X3BkZmpzX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193X3BkZmpzX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193X3BkZmpzX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd19wZGZqc19yZXF1aXJlX18oX193X3BkZmpzX3JlcXVpcmVfXy5zID0gMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhZGRMaW5rQXR0cmlidXRlc1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfZGlzcGxheV91dGlscy5hZGRMaW5rQXR0cmlidXRlcztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRGaWxlbmFtZUZyb21VcmxcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2Rpc3BsYXlfdXRpbHMuZ2V0RmlsZW5hbWVGcm9tVXJsO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxpbmtUYXJnZXRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2Rpc3BsYXlfdXRpbHMuTGlua1RhcmdldDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJsb2FkU2NyaXB0XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9kaXNwbGF5X3V0aWxzLmxvYWRTY3JpcHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUERGRGF0ZVN0cmluZ1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfZGlzcGxheV91dGlscy5QREZEYXRlU3RyaW5nO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfZGlzcGxheV91dGlscy5SZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb247XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYnVpbGRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2FwaS5idWlsZDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXREb2N1bWVudFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfYXBpLmdldERvY3VtZW50O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxvb3BiYWNrUG9ydFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfYXBpLkxvb3BiYWNrUG9ydDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQREZEYXRhUmFuZ2VUcmFuc3BvcnRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2FwaS5QREZEYXRhUmFuZ2VUcmFuc3BvcnQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUERGV29ya2VyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9hcGkuUERGV29ya2VyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInZlcnNpb25cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2FwaS52ZXJzaW9uO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNNYXBDb21wcmVzc2lvblR5cGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWwuQ01hcENvbXByZXNzaW9uVHlwZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVPYmplY3RVUkxcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWwuY3JlYXRlT2JqZWN0VVJMO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZVByb21pc2VDYXBhYmlsaXR5XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlsLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZVZhbGlkQWJzb2x1dGVVcmxcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWwuY3JlYXRlVmFsaWRBYnNvbHV0ZVVybDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbnZhbGlkUERGRXhjZXB0aW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlsLkludmFsaWRQREZFeGNlcHRpb247XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWlzc2luZ1BERkV4Y2VwdGlvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbC5NaXNzaW5nUERGRXhjZXB0aW9uO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk9QU1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbC5PUFM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUGFzc3dvcmRSZXNwb25zZXNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWwuUGFzc3dvcmRSZXNwb25zZXM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUGVybWlzc2lvbkZsYWdcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWwuUGVybWlzc2lvbkZsYWc7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVtb3ZlTnVsbENoYXJhY3RlcnNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWwucmVtb3ZlTnVsbENoYXJhY3RlcnM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2hhZG93XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlsLnNoYWRvdztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb25cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWwuVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVOU1VQUE9SVEVEX0ZFQVRVUkVTXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlsLlVOU1VQUE9SVEVEX0ZFQVRVUkVTO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlV0aWxcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWwuVXRpbDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJWZXJib3NpdHlMZXZlbFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbC5WZXJib3NpdHlMZXZlbDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBbm5vdGF0aW9uTGF5ZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2Fubm90YXRpb25fbGF5ZXIuQW5ub3RhdGlvbkxheWVyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFwaUNvbXBhdGliaWxpdHlQYXJhbXNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2FwaV9jb21wYXRpYmlsaXR5LmFwaUNvbXBhdGliaWxpdHlQYXJhbXM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiR2xvYmFsV29ya2VyT3B0aW9uc1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfd29ya2VyX29wdGlvbnMuR2xvYmFsV29ya2VyT3B0aW9ucztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZW5kZXJUZXh0TGF5ZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3RleHRfbGF5ZXIucmVuZGVyVGV4dExheWVyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNWR0dyYXBoaWNzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9zdmcuU1ZHR3JhcGhpY3M7XG4gIH1cbn0pO1xuXG52YXIgX2Rpc3BsYXlfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2FwaSA9IF9fd19wZGZqc19yZXF1aXJlX18oNSk7XG5cbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMik7XG5cbnZhciBfYW5ub3RhdGlvbl9sYXllciA9IF9fd19wZGZqc19yZXF1aXJlX18oMTkpO1xuXG52YXIgX2FwaV9jb21wYXRpYmlsaXR5ID0gX193X3BkZmpzX3JlcXVpcmVfXyg5KTtcblxudmFyIF93b3JrZXJfb3B0aW9ucyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTIpO1xuXG52YXIgX3RleHRfbGF5ZXIgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIwKTtcblxudmFyIF9zdmcgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIxKTtcblxuY29uc3QgcGRmanNWZXJzaW9uID0gJzIuNi4zNDcnO1xuY29uc3QgcGRmanNCdWlsZCA9ICczYmU5YzY1Zic7XG57XG4gIGNvbnN0IHtcbiAgICBpc05vZGVKU1xuICB9ID0gX193X3BkZmpzX3JlcXVpcmVfXyg0KTtcblxuICBpZiAoaXNOb2RlSlMpIHtcbiAgICBjb25zdCBQREZOb2RlU3RyZWFtID0gX193X3BkZmpzX3JlcXVpcmVfXygyMikuUERGTm9kZVN0cmVhbTtcblxuICAgICgwLCBfYXBpLnNldFBERk5ldHdvcmtTdHJlYW1GYWN0b3J5KShwYXJhbXMgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBQREZOb2RlU3RyZWFtKHBhcmFtcyk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgUERGTmV0d29ya1N0cmVhbSA9IF9fd19wZGZqc19yZXF1aXJlX18oMjUpLlBERk5ldHdvcmtTdHJlYW07XG5cbiAgICBsZXQgUERGRmV0Y2hTdHJlYW07XG5cbiAgICBpZiAoKDAsIF9kaXNwbGF5X3V0aWxzLmlzRmV0Y2hTdXBwb3J0ZWQpKCkpIHtcbiAgICAgIFBERkZldGNoU3RyZWFtID0gX193X3BkZmpzX3JlcXVpcmVfXygyNikuUERGRmV0Y2hTdHJlYW07XG4gICAgfVxuXG4gICAgKDAsIF9hcGkuc2V0UERGTmV0d29ya1N0cmVhbUZhY3RvcnkpKHBhcmFtcyA9PiB7XG4gICAgICBpZiAoUERGRmV0Y2hTdHJlYW0gJiYgKDAsIF9kaXNwbGF5X3V0aWxzLmlzVmFsaWRGZXRjaFVybCkocGFyYW1zLnVybCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQREZGZXRjaFN0cmVhbShwYXJhbXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFBERk5ldHdvcmtTdHJlYW0ocGFyYW1zKTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuYWRkTGlua0F0dHJpYnV0ZXMgPSBhZGRMaW5rQXR0cmlidXRlcztcbmV4cG9ydHMuZ2V0RmlsZW5hbWVGcm9tVXJsID0gZ2V0RmlsZW5hbWVGcm9tVXJsO1xuZXhwb3J0cy5pc0ZldGNoU3VwcG9ydGVkID0gaXNGZXRjaFN1cHBvcnRlZDtcbmV4cG9ydHMuaXNWYWxpZEZldGNoVXJsID0gaXNWYWxpZEZldGNoVXJsO1xuZXhwb3J0cy5sb2FkU2NyaXB0ID0gbG9hZFNjcmlwdDtcbmV4cG9ydHMuZGVwcmVjYXRlZCA9IGRlcHJlY2F0ZWQ7XG5leHBvcnRzLlBERkRhdGVTdHJpbmcgPSBleHBvcnRzLlN0YXRUaW1lciA9IGV4cG9ydHMuRE9NU1ZHRmFjdG9yeSA9IGV4cG9ydHMuRE9NQ01hcFJlYWRlckZhY3RvcnkgPSBleHBvcnRzLkJhc2VDTWFwUmVhZGVyRmFjdG9yeSA9IGV4cG9ydHMuRE9NQ2FudmFzRmFjdG9yeSA9IGV4cG9ydHMuQmFzZUNhbnZhc0ZhY3RvcnkgPSBleHBvcnRzLkRFRkFVTFRfTElOS19SRUwgPSBleHBvcnRzLkxpbmtUYXJnZXQgPSBleHBvcnRzLlJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbiA9IGV4cG9ydHMuUGFnZVZpZXdwb3J0ID0gdm9pZCAwO1xuXG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIpO1xuXG5jb25zdCBERUZBVUxUX0xJTktfUkVMID0gXCJub29wZW5lciBub3JlZmVycmVyIG5vZm9sbG93XCI7XG5leHBvcnRzLkRFRkFVTFRfTElOS19SRUwgPSBERUZBVUxUX0xJTktfUkVMO1xuY29uc3QgU1ZHX05TID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO1xuXG5jbGFzcyBCYXNlQ2FudmFzRmFjdG9yeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBCYXNlQ2FudmFzRmFjdG9yeSkge1xuICAgICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkNhbm5vdCBpbml0aWFsaXplIEJhc2VDYW52YXNGYWN0b3J5LlwiKTtcbiAgICB9XG4gIH1cblxuICBjcmVhdGUod2lkdGgsIGhlaWdodCkge1xuICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJBYnN0cmFjdCBtZXRob2QgYGNyZWF0ZWAgY2FsbGVkLlwiKTtcbiAgfVxuXG4gIHJlc2V0KGNhbnZhc0FuZENvbnRleHQsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAoIWNhbnZhc0FuZENvbnRleHQuY2FudmFzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW52YXMgaXMgbm90IHNwZWNpZmllZFwiKTtcbiAgICB9XG5cbiAgICBpZiAod2lkdGggPD0gMCB8fCBoZWlnaHQgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjYW52YXMgc2l6ZVwiKTtcbiAgICB9XG5cbiAgICBjYW52YXNBbmRDb250ZXh0LmNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnZhc0FuZENvbnRleHQuY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgfVxuXG4gIGRlc3Ryb3koY2FudmFzQW5kQ29udGV4dCkge1xuICAgIGlmICghY2FudmFzQW5kQ29udGV4dC5jYW52YXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbnZhcyBpcyBub3Qgc3BlY2lmaWVkXCIpO1xuICAgIH1cblxuICAgIGNhbnZhc0FuZENvbnRleHQuY2FudmFzLndpZHRoID0gMDtcbiAgICBjYW52YXNBbmRDb250ZXh0LmNhbnZhcy5oZWlnaHQgPSAwO1xuICAgIGNhbnZhc0FuZENvbnRleHQuY2FudmFzID0gbnVsbDtcbiAgICBjYW52YXNBbmRDb250ZXh0LmNvbnRleHQgPSBudWxsO1xuICB9XG5cbn1cblxuZXhwb3J0cy5CYXNlQ2FudmFzRmFjdG9yeSA9IEJhc2VDYW52YXNGYWN0b3J5O1xuXG5jbGFzcyBET01DYW52YXNGYWN0b3J5IGV4dGVuZHMgQmFzZUNhbnZhc0ZhY3Rvcnkge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgb3duZXJEb2N1bWVudCA9IGdsb2JhbFRoaXMuZG9jdW1lbnRcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9kb2N1bWVudCA9IG93bmVyRG9jdW1lbnQ7XG4gIH1cblxuICBjcmVhdGUod2lkdGgsIGhlaWdodCkge1xuICAgIGlmICh3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNhbnZhcyBzaXplXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG5cbiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHJldHVybiB7XG4gICAgICBjYW52YXMsXG4gICAgICBjb250ZXh0XG4gICAgfTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuRE9NQ2FudmFzRmFjdG9yeSA9IERPTUNhbnZhc0ZhY3Rvcnk7XG5cbmNsYXNzIEJhc2VDTWFwUmVhZGVyRmFjdG9yeSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBiYXNlVXJsID0gbnVsbCxcbiAgICBpc0NvbXByZXNzZWQgPSBmYWxzZVxuICB9KSB7XG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IEJhc2VDTWFwUmVhZGVyRmFjdG9yeSkge1xuICAgICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkNhbm5vdCBpbml0aWFsaXplIEJhc2VDTWFwUmVhZGVyRmFjdG9yeS5cIik7XG4gICAgfVxuXG4gICAgdGhpcy5iYXNlVXJsID0gYmFzZVVybDtcbiAgICB0aGlzLmlzQ29tcHJlc3NlZCA9IGlzQ29tcHJlc3NlZDtcbiAgfVxuXG4gIGFzeW5jIGZldGNoKHtcbiAgICBuYW1lXG4gIH0pIHtcbiAgICBpZiAoIXRoaXMuYmFzZVVybCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgQ01hcCBcImJhc2VVcmxcIiBwYXJhbWV0ZXIgbXVzdCBiZSBzcGVjaWZpZWQsIGVuc3VyZSB0aGF0ICcgKyAndGhlIFwiY01hcFVybFwiIGFuZCBcImNNYXBQYWNrZWRcIiBBUEkgcGFyYW1ldGVycyBhcmUgcHJvdmlkZWQuJyk7XG4gICAgfVxuXG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDTWFwIG5hbWUgbXVzdCBiZSBzcGVjaWZpZWQuXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IHVybCA9IHRoaXMuYmFzZVVybCArIG5hbWUgKyAodGhpcy5pc0NvbXByZXNzZWQgPyBcIi5iY21hcFwiIDogXCJcIik7XG4gICAgY29uc3QgY29tcHJlc3Npb25UeXBlID0gdGhpcy5pc0NvbXByZXNzZWQgPyBfdXRpbC5DTWFwQ29tcHJlc3Npb25UeXBlLkJJTkFSWSA6IF91dGlsLkNNYXBDb21wcmVzc2lvblR5cGUuTk9ORTtcbiAgICByZXR1cm4gdGhpcy5fZmV0Y2hEYXRhKHVybCwgY29tcHJlc3Npb25UeXBlKS5jYXRjaChyZWFzb24gPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gbG9hZCAke3RoaXMuaXNDb21wcmVzc2VkID8gXCJiaW5hcnkgXCIgOiBcIlwifUNNYXAgYXQ6ICR7dXJsfWApO1xuICAgIH0pO1xuICB9XG5cbiAgX2ZldGNoRGF0YSh1cmwsIGNvbXByZXNzaW9uVHlwZSkge1xuICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJBYnN0cmFjdCBtZXRob2QgYF9mZXRjaERhdGFgIGNhbGxlZC5cIik7XG4gIH1cblxufVxuXG5leHBvcnRzLkJhc2VDTWFwUmVhZGVyRmFjdG9yeSA9IEJhc2VDTWFwUmVhZGVyRmFjdG9yeTtcblxuY2xhc3MgRE9NQ01hcFJlYWRlckZhY3RvcnkgZXh0ZW5kcyBCYXNlQ01hcFJlYWRlckZhY3Rvcnkge1xuICBfZmV0Y2hEYXRhKHVybCwgY29tcHJlc3Npb25UeXBlKSB7XG4gICAgaWYgKGlzRmV0Y2hTdXBwb3J0ZWQoKSAmJiBpc1ZhbGlkRmV0Y2hVcmwodXJsLCBkb2N1bWVudC5iYXNlVVJJKSkge1xuICAgICAgcmV0dXJuIGZldGNoKHVybCkudGhlbihhc3luYyByZXNwb25zZSA9PiB7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY01hcERhdGE7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNDb21wcmVzc2VkKSB7XG4gICAgICAgICAgY01hcERhdGEgPSBuZXcgVWludDhBcnJheShhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjTWFwRGF0YSA9ICgwLCBfdXRpbC5zdHJpbmdUb0J5dGVzKShhd2FpdCByZXNwb25zZS50ZXh0KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjTWFwRGF0YSxcbiAgICAgICAgICBjb21wcmVzc2lvblR5cGVcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICByZXF1ZXN0Lm9wZW4oXCJHRVRcIiwgdXJsLCB0cnVlKTtcblxuICAgICAgaWYgKHRoaXMuaXNDb21wcmVzc2VkKSB7XG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xuICAgICAgfVxuXG4gICAgICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgaWYgKHJlcXVlc3QucmVhZHlTdGF0ZSAhPT0gWE1MSHR0cFJlcXVlc3QuRE9ORSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMjAwIHx8IHJlcXVlc3Quc3RhdHVzID09PSAwKSB7XG4gICAgICAgICAgbGV0IGNNYXBEYXRhO1xuXG4gICAgICAgICAgaWYgKHRoaXMuaXNDb21wcmVzc2VkICYmIHJlcXVlc3QucmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGNNYXBEYXRhID0gbmV3IFVpbnQ4QXJyYXkocmVxdWVzdC5yZXNwb25zZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5pc0NvbXByZXNzZWQgJiYgcmVxdWVzdC5yZXNwb25zZVRleHQpIHtcbiAgICAgICAgICAgIGNNYXBEYXRhID0gKDAsIF91dGlsLnN0cmluZ1RvQnl0ZXMpKHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY01hcERhdGEpIHtcbiAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICBjTWFwRGF0YSxcbiAgICAgICAgICAgICAgY29tcHJlc3Npb25UeXBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZWplY3QobmV3IEVycm9yKHJlcXVlc3Quc3RhdHVzVGV4dCkpO1xuICAgICAgfTtcblxuICAgICAgcmVxdWVzdC5zZW5kKG51bGwpO1xuICAgIH0pO1xuICB9XG5cbn1cblxuZXhwb3J0cy5ET01DTWFwUmVhZGVyRmFjdG9yeSA9IERPTUNNYXBSZWFkZXJGYWN0b3J5O1xuXG5jbGFzcyBET01TVkdGYWN0b3J5IHtcbiAgY3JlYXRlKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAoMCwgX3V0aWwuYXNzZXJ0KSh3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMCwgXCJJbnZhbGlkIFNWRyBkaW1lbnNpb25zXCIpO1xuICAgIGNvbnN0IHN2ZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIFwic3ZnOnN2Z1wiKTtcbiAgICBzdmcuc2V0QXR0cmlidXRlKFwidmVyc2lvblwiLCBcIjEuMVwiKTtcbiAgICBzdmcuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgd2lkdGggKyBcInB4XCIpO1xuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgaGVpZ2h0ICsgXCJweFwiKTtcbiAgICBzdmcuc2V0QXR0cmlidXRlKFwicHJlc2VydmVBc3BlY3RSYXRpb1wiLCBcIm5vbmVcIik7XG4gICAgc3ZnLnNldEF0dHJpYnV0ZShcInZpZXdCb3hcIiwgXCIwIDAgXCIgKyB3aWR0aCArIFwiIFwiICsgaGVpZ2h0KTtcbiAgICByZXR1cm4gc3ZnO1xuICB9XG5cbiAgY3JlYXRlRWxlbWVudCh0eXBlKSB7XG4gICAgKDAsIF91dGlsLmFzc2VydCkodHlwZW9mIHR5cGUgPT09IFwic3RyaW5nXCIsIFwiSW52YWxpZCBTVkcgZWxlbWVudCB0eXBlXCIpO1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCB0eXBlKTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuRE9NU1ZHRmFjdG9yeSA9IERPTVNWR0ZhY3Rvcnk7XG5cbmNsYXNzIFBhZ2VWaWV3cG9ydCB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB2aWV3Qm94LFxuICAgIHNjYWxlLFxuICAgIHJvdGF0aW9uLFxuICAgIG9mZnNldFggPSAwLFxuICAgIG9mZnNldFkgPSAwLFxuICAgIGRvbnRGbGlwID0gZmFsc2VcbiAgfSkge1xuICAgIHRoaXMudmlld0JveCA9IHZpZXdCb3g7XG4gICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xuICAgIHRoaXMucm90YXRpb24gPSByb3RhdGlvbjtcbiAgICB0aGlzLm9mZnNldFggPSBvZmZzZXRYO1xuICAgIHRoaXMub2Zmc2V0WSA9IG9mZnNldFk7XG4gICAgY29uc3QgY2VudGVyWCA9ICh2aWV3Qm94WzJdICsgdmlld0JveFswXSkgLyAyO1xuICAgIGNvbnN0IGNlbnRlclkgPSAodmlld0JveFszXSArIHZpZXdCb3hbMV0pIC8gMjtcbiAgICBsZXQgcm90YXRlQSwgcm90YXRlQiwgcm90YXRlQywgcm90YXRlRDtcbiAgICByb3RhdGlvbiA9IHJvdGF0aW9uICUgMzYwO1xuICAgIHJvdGF0aW9uID0gcm90YXRpb24gPCAwID8gcm90YXRpb24gKyAzNjAgOiByb3RhdGlvbjtcblxuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByb3RhdGVBID0gLTE7XG4gICAgICAgIHJvdGF0ZUIgPSAwO1xuICAgICAgICByb3RhdGVDID0gMDtcbiAgICAgICAgcm90YXRlRCA9IDE7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDkwOlxuICAgICAgICByb3RhdGVBID0gMDtcbiAgICAgICAgcm90YXRlQiA9IDE7XG4gICAgICAgIHJvdGF0ZUMgPSAxO1xuICAgICAgICByb3RhdGVEID0gMDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByb3RhdGVBID0gMDtcbiAgICAgICAgcm90YXRlQiA9IC0xO1xuICAgICAgICByb3RhdGVDID0gLTE7XG4gICAgICAgIHJvdGF0ZUQgPSAwO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAwOlxuICAgICAgICByb3RhdGVBID0gMTtcbiAgICAgICAgcm90YXRlQiA9IDA7XG4gICAgICAgIHJvdGF0ZUMgPSAwO1xuICAgICAgICByb3RhdGVEID0gLTE7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYWdlVmlld3BvcnQ6IEludmFsaWQgcm90YXRpb24sIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA5MCBkZWdyZWVzLlwiKTtcbiAgICB9XG5cbiAgICBpZiAoZG9udEZsaXApIHtcbiAgICAgIHJvdGF0ZUMgPSAtcm90YXRlQztcbiAgICAgIHJvdGF0ZUQgPSAtcm90YXRlRDtcbiAgICB9XG5cbiAgICBsZXQgb2Zmc2V0Q2FudmFzWCwgb2Zmc2V0Q2FudmFzWTtcbiAgICBsZXQgd2lkdGgsIGhlaWdodDtcblxuICAgIGlmIChyb3RhdGVBID09PSAwKSB7XG4gICAgICBvZmZzZXRDYW52YXNYID0gTWF0aC5hYnMoY2VudGVyWSAtIHZpZXdCb3hbMV0pICogc2NhbGUgKyBvZmZzZXRYO1xuICAgICAgb2Zmc2V0Q2FudmFzWSA9IE1hdGguYWJzKGNlbnRlclggLSB2aWV3Qm94WzBdKSAqIHNjYWxlICsgb2Zmc2V0WTtcbiAgICAgIHdpZHRoID0gTWF0aC5hYnModmlld0JveFszXSAtIHZpZXdCb3hbMV0pICogc2NhbGU7XG4gICAgICBoZWlnaHQgPSBNYXRoLmFicyh2aWV3Qm94WzJdIC0gdmlld0JveFswXSkgKiBzY2FsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0Q2FudmFzWCA9IE1hdGguYWJzKGNlbnRlclggLSB2aWV3Qm94WzBdKSAqIHNjYWxlICsgb2Zmc2V0WDtcbiAgICAgIG9mZnNldENhbnZhc1kgPSBNYXRoLmFicyhjZW50ZXJZIC0gdmlld0JveFsxXSkgKiBzY2FsZSArIG9mZnNldFk7XG4gICAgICB3aWR0aCA9IE1hdGguYWJzKHZpZXdCb3hbMl0gLSB2aWV3Qm94WzBdKSAqIHNjYWxlO1xuICAgICAgaGVpZ2h0ID0gTWF0aC5hYnModmlld0JveFszXSAtIHZpZXdCb3hbMV0pICogc2NhbGU7XG4gICAgfVxuXG4gICAgdGhpcy50cmFuc2Zvcm0gPSBbcm90YXRlQSAqIHNjYWxlLCByb3RhdGVCICogc2NhbGUsIHJvdGF0ZUMgKiBzY2FsZSwgcm90YXRlRCAqIHNjYWxlLCBvZmZzZXRDYW52YXNYIC0gcm90YXRlQSAqIHNjYWxlICogY2VudGVyWCAtIHJvdGF0ZUMgKiBzY2FsZSAqIGNlbnRlclksIG9mZnNldENhbnZhc1kgLSByb3RhdGVCICogc2NhbGUgKiBjZW50ZXJYIC0gcm90YXRlRCAqIHNjYWxlICogY2VudGVyWV07XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICB9XG5cbiAgY2xvbmUoe1xuICAgIHNjYWxlID0gdGhpcy5zY2FsZSxcbiAgICByb3RhdGlvbiA9IHRoaXMucm90YXRpb24sXG4gICAgb2Zmc2V0WCA9IHRoaXMub2Zmc2V0WCxcbiAgICBvZmZzZXRZID0gdGhpcy5vZmZzZXRZLFxuICAgIGRvbnRGbGlwID0gZmFsc2VcbiAgfSA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBQYWdlVmlld3BvcnQoe1xuICAgICAgdmlld0JveDogdGhpcy52aWV3Qm94LnNsaWNlKCksXG4gICAgICBzY2FsZSxcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgb2Zmc2V0WCxcbiAgICAgIG9mZnNldFksXG4gICAgICBkb250RmxpcFxuICAgIH0pO1xuICB9XG5cbiAgY29udmVydFRvVmlld3BvcnRQb2ludCh4LCB5KSB7XG4gICAgcmV0dXJuIF91dGlsLlV0aWwuYXBwbHlUcmFuc2Zvcm0oW3gsIHldLCB0aGlzLnRyYW5zZm9ybSk7XG4gIH1cblxuICBjb252ZXJ0VG9WaWV3cG9ydFJlY3RhbmdsZShyZWN0KSB7XG4gICAgY29uc3QgdG9wTGVmdCA9IF91dGlsLlV0aWwuYXBwbHlUcmFuc2Zvcm0oW3JlY3RbMF0sIHJlY3RbMV1dLCB0aGlzLnRyYW5zZm9ybSk7XG5cbiAgICBjb25zdCBib3R0b21SaWdodCA9IF91dGlsLlV0aWwuYXBwbHlUcmFuc2Zvcm0oW3JlY3RbMl0sIHJlY3RbM11dLCB0aGlzLnRyYW5zZm9ybSk7XG5cbiAgICByZXR1cm4gW3RvcExlZnRbMF0sIHRvcExlZnRbMV0sIGJvdHRvbVJpZ2h0WzBdLCBib3R0b21SaWdodFsxXV07XG4gIH1cblxuICBjb252ZXJ0VG9QZGZQb2ludCh4LCB5KSB7XG4gICAgcmV0dXJuIF91dGlsLlV0aWwuYXBwbHlJbnZlcnNlVHJhbnNmb3JtKFt4LCB5XSwgdGhpcy50cmFuc2Zvcm0pO1xuICB9XG5cbn1cblxuZXhwb3J0cy5QYWdlVmlld3BvcnQgPSBQYWdlVmlld3BvcnQ7XG5cbmNsYXNzIFJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbiBleHRlbmRzIF91dGlsLkJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2csIHR5cGUpIHtcbiAgICBzdXBlcihtc2cpO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gIH1cblxufVxuXG5leHBvcnRzLlJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbiA9IFJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbjtcbmNvbnN0IExpbmtUYXJnZXQgPSB7XG4gIE5PTkU6IDAsXG4gIFNFTEY6IDEsXG4gIEJMQU5LOiAyLFxuICBQQVJFTlQ6IDMsXG4gIFRPUDogNFxufTtcbmV4cG9ydHMuTGlua1RhcmdldCA9IExpbmtUYXJnZXQ7XG5cbmZ1bmN0aW9uIGFkZExpbmtBdHRyaWJ1dGVzKGxpbmssIHtcbiAgdXJsLFxuICB0YXJnZXQsXG4gIHJlbCxcbiAgZW5hYmxlZCA9IHRydWVcbn0gPSB7fSkge1xuICAoMCwgX3V0aWwuYXNzZXJ0KSh1cmwgJiYgdHlwZW9mIHVybCA9PT0gXCJzdHJpbmdcIiwgJ2FkZExpbmtBdHRyaWJ1dGVzOiBBIHZhbGlkIFwidXJsXCIgcGFyYW1ldGVyIG11c3QgcHJvdmlkZWQuJyk7XG4gIGNvbnN0IHVybE51bGxSZW1vdmVkID0gKDAsIF91dGlsLnJlbW92ZU51bGxDaGFyYWN0ZXJzKSh1cmwpO1xuXG4gIGlmIChlbmFibGVkKSB7XG4gICAgbGluay5ocmVmID0gbGluay50aXRsZSA9IHVybE51bGxSZW1vdmVkO1xuICB9IGVsc2Uge1xuICAgIGxpbmsuaHJlZiA9IFwiXCI7XG4gICAgbGluay50aXRsZSA9IGBEaXNhYmxlZDogJHt1cmxOdWxsUmVtb3ZlZH1gO1xuXG4gICAgbGluay5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gIH1cblxuICBsZXQgdGFyZ2V0U3RyID0gXCJcIjtcblxuICBzd2l0Y2ggKHRhcmdldCkge1xuICAgIGNhc2UgTGlua1RhcmdldC5OT05FOlxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIExpbmtUYXJnZXQuU0VMRjpcbiAgICAgIHRhcmdldFN0ciA9IFwiX3NlbGZcIjtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBMaW5rVGFyZ2V0LkJMQU5LOlxuICAgICAgdGFyZ2V0U3RyID0gXCJfYmxhbmtcIjtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBMaW5rVGFyZ2V0LlBBUkVOVDpcbiAgICAgIHRhcmdldFN0ciA9IFwiX3BhcmVudFwiO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIExpbmtUYXJnZXQuVE9QOlxuICAgICAgdGFyZ2V0U3RyID0gXCJfdG9wXCI7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIGxpbmsudGFyZ2V0ID0gdGFyZ2V0U3RyO1xuICBsaW5rLnJlbCA9IHR5cGVvZiByZWwgPT09IFwic3RyaW5nXCIgPyByZWwgOiBERUZBVUxUX0xJTktfUkVMO1xufVxuXG5mdW5jdGlvbiBnZXRGaWxlbmFtZUZyb21VcmwodXJsKSB7XG4gIGNvbnN0IGFuY2hvciA9IHVybC5pbmRleE9mKFwiI1wiKTtcbiAgY29uc3QgcXVlcnkgPSB1cmwuaW5kZXhPZihcIj9cIik7XG4gIGNvbnN0IGVuZCA9IE1hdGgubWluKGFuY2hvciA+IDAgPyBhbmNob3IgOiB1cmwubGVuZ3RoLCBxdWVyeSA+IDAgPyBxdWVyeSA6IHVybC5sZW5ndGgpO1xuICByZXR1cm4gdXJsLnN1YnN0cmluZyh1cmwubGFzdEluZGV4T2YoXCIvXCIsIGVuZCkgKyAxLCBlbmQpO1xufVxuXG5jbGFzcyBTdGF0VGltZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnN0YXJ0ZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMudGltZXMgPSBbXTtcbiAgfVxuXG4gIHRpbWUobmFtZSkge1xuICAgIGlmIChuYW1lIGluIHRoaXMuc3RhcnRlZCkge1xuICAgICAgKDAsIF91dGlsLndhcm4pKGBUaW1lciBpcyBhbHJlYWR5IHJ1bm5pbmcgZm9yICR7bmFtZX1gKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXJ0ZWRbbmFtZV0gPSBEYXRlLm5vdygpO1xuICB9XG5cbiAgdGltZUVuZChuYW1lKSB7XG4gICAgaWYgKCEobmFtZSBpbiB0aGlzLnN0YXJ0ZWQpKSB7XG4gICAgICAoMCwgX3V0aWwud2FybikoYFRpbWVyIGhhcyBub3QgYmVlbiBzdGFydGVkIGZvciAke25hbWV9YCk7XG4gICAgfVxuXG4gICAgdGhpcy50aW1lcy5wdXNoKHtcbiAgICAgIG5hbWUsXG4gICAgICBzdGFydDogdGhpcy5zdGFydGVkW25hbWVdLFxuICAgICAgZW5kOiBEYXRlLm5vdygpXG4gICAgfSk7XG4gICAgZGVsZXRlIHRoaXMuc3RhcnRlZFtuYW1lXTtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIGNvbnN0IG91dEJ1ZiA9IFtdO1xuICAgIGxldCBsb25nZXN0ID0gMDtcblxuICAgIGZvciAoY29uc3QgdGltZSBvZiB0aGlzLnRpbWVzKSB7XG4gICAgICBjb25zdCBuYW1lID0gdGltZS5uYW1lO1xuXG4gICAgICBpZiAobmFtZS5sZW5ndGggPiBsb25nZXN0KSB7XG4gICAgICAgIGxvbmdlc3QgPSBuYW1lLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHRpbWUgb2YgdGhpcy50aW1lcykge1xuICAgICAgY29uc3QgZHVyYXRpb24gPSB0aW1lLmVuZCAtIHRpbWUuc3RhcnQ7XG4gICAgICBvdXRCdWYucHVzaChgJHt0aW1lLm5hbWUucGFkRW5kKGxvbmdlc3QpfSAke2R1cmF0aW9ufW1zXFxuYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dEJ1Zi5qb2luKFwiXCIpO1xuICB9XG5cbn1cblxuZXhwb3J0cy5TdGF0VGltZXIgPSBTdGF0VGltZXI7XG5cbmZ1bmN0aW9uIGlzRmV0Y2hTdXBwb3J0ZWQoKSB7XG4gIHJldHVybiB0eXBlb2YgZmV0Y2ggIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIFJlc3BvbnNlICE9PSBcInVuZGVmaW5lZFwiICYmIFwiYm9keVwiIGluIFJlc3BvbnNlLnByb3RvdHlwZSAmJiB0eXBlb2YgUmVhZGFibGVTdHJlYW0gIT09IFwidW5kZWZpbmVkXCI7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRGZXRjaFVybCh1cmwsIGJhc2VVcmwpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7XG4gICAgICBwcm90b2NvbFxuICAgIH0gPSBiYXNlVXJsID8gbmV3IFVSTCh1cmwsIGJhc2VVcmwpIDogbmV3IFVSTCh1cmwpO1xuICAgIHJldHVybiBwcm90b2NvbCA9PT0gXCJodHRwOlwiIHx8IHByb3RvY29sID09PSBcImh0dHBzOlwiO1xuICB9IGNhdGNoIChleCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsb2FkU2NyaXB0KHNyYykge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgc2NyaXB0LnNyYyA9IHNyYztcbiAgICBzY3JpcHQub25sb2FkID0gcmVzb2x2ZTtcblxuICAgIHNjcmlwdC5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcihgQ2Fubm90IGxvYWQgc2NyaXB0IGF0OiAke3NjcmlwdC5zcmN9YCkpO1xuICAgIH07XG5cbiAgICAoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkZXByZWNhdGVkKGRldGFpbHMpIHtcbiAgY29uc29sZS5sb2coXCJEZXByZWNhdGVkIEFQSSB1c2FnZTogXCIgKyBkZXRhaWxzKTtcbn1cblxubGV0IHBkZkRhdGVTdHJpbmdSZWdleDtcblxuY2xhc3MgUERGRGF0ZVN0cmluZyB7XG4gIHN0YXRpYyB0b0RhdGVPYmplY3QoaW5wdXQpIHtcbiAgICBpZiAoIWlucHV0IHx8ICEoMCwgX3V0aWwuaXNTdHJpbmcpKGlucHV0KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCFwZGZEYXRlU3RyaW5nUmVnZXgpIHtcbiAgICAgIHBkZkRhdGVTdHJpbmdSZWdleCA9IG5ldyBSZWdFeHAoXCJeRDpcIiArIFwiKFxcXFxkezR9KVwiICsgXCIoXFxcXGR7Mn0pP1wiICsgXCIoXFxcXGR7Mn0pP1wiICsgXCIoXFxcXGR7Mn0pP1wiICsgXCIoXFxcXGR7Mn0pP1wiICsgXCIoXFxcXGR7Mn0pP1wiICsgXCIoW1p8K3wtXSk/XCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIic/XCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIic/XCIpO1xuICAgIH1cblxuICAgIGNvbnN0IG1hdGNoZXMgPSBwZGZEYXRlU3RyaW5nUmVnZXguZXhlYyhpbnB1dCk7XG5cbiAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHllYXIgPSBwYXJzZUludChtYXRjaGVzWzFdLCAxMCk7XG4gICAgbGV0IG1vbnRoID0gcGFyc2VJbnQobWF0Y2hlc1syXSwgMTApO1xuICAgIG1vbnRoID0gbW9udGggPj0gMSAmJiBtb250aCA8PSAxMiA/IG1vbnRoIC0gMSA6IDA7XG4gICAgbGV0IGRheSA9IHBhcnNlSW50KG1hdGNoZXNbM10sIDEwKTtcbiAgICBkYXkgPSBkYXkgPj0gMSAmJiBkYXkgPD0gMzEgPyBkYXkgOiAxO1xuICAgIGxldCBob3VyID0gcGFyc2VJbnQobWF0Y2hlc1s0XSwgMTApO1xuICAgIGhvdXIgPSBob3VyID49IDAgJiYgaG91ciA8PSAyMyA/IGhvdXIgOiAwO1xuICAgIGxldCBtaW51dGUgPSBwYXJzZUludChtYXRjaGVzWzVdLCAxMCk7XG4gICAgbWludXRlID0gbWludXRlID49IDAgJiYgbWludXRlIDw9IDU5ID8gbWludXRlIDogMDtcbiAgICBsZXQgc2Vjb25kID0gcGFyc2VJbnQobWF0Y2hlc1s2XSwgMTApO1xuICAgIHNlY29uZCA9IHNlY29uZCA+PSAwICYmIHNlY29uZCA8PSA1OSA/IHNlY29uZCA6IDA7XG4gICAgY29uc3QgdW5pdmVyc2FsVGltZVJlbGF0aW9uID0gbWF0Y2hlc1s3XSB8fCBcIlpcIjtcbiAgICBsZXQgb2Zmc2V0SG91ciA9IHBhcnNlSW50KG1hdGNoZXNbOF0sIDEwKTtcbiAgICBvZmZzZXRIb3VyID0gb2Zmc2V0SG91ciA+PSAwICYmIG9mZnNldEhvdXIgPD0gMjMgPyBvZmZzZXRIb3VyIDogMDtcbiAgICBsZXQgb2Zmc2V0TWludXRlID0gcGFyc2VJbnQobWF0Y2hlc1s5XSwgMTApIHx8IDA7XG4gICAgb2Zmc2V0TWludXRlID0gb2Zmc2V0TWludXRlID49IDAgJiYgb2Zmc2V0TWludXRlIDw9IDU5ID8gb2Zmc2V0TWludXRlIDogMDtcblxuICAgIGlmICh1bml2ZXJzYWxUaW1lUmVsYXRpb24gPT09IFwiLVwiKSB7XG4gICAgICBob3VyICs9IG9mZnNldEhvdXI7XG4gICAgICBtaW51dGUgKz0gb2Zmc2V0TWludXRlO1xuICAgIH0gZWxzZSBpZiAodW5pdmVyc2FsVGltZVJlbGF0aW9uID09PSBcIitcIikge1xuICAgICAgaG91ciAtPSBvZmZzZXRIb3VyO1xuICAgICAgbWludXRlIC09IG9mZnNldE1pbnV0ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQpKTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuUERGRGF0ZVN0cmluZyA9IFBERkRhdGVTdHJpbmc7XG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5hcnJheUJ5dGVMZW5ndGggPSBhcnJheUJ5dGVMZW5ndGg7XG5leHBvcnRzLmFycmF5c1RvQnl0ZXMgPSBhcnJheXNUb0J5dGVzO1xuZXhwb3J0cy5hc3NlcnQgPSBhc3NlcnQ7XG5leHBvcnRzLmJ5dGVzVG9TdHJpbmcgPSBieXRlc1RvU3RyaW5nO1xuZXhwb3J0cy5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSA9IGNyZWF0ZVByb21pc2VDYXBhYmlsaXR5O1xuZXhwb3J0cy5lc2NhcGVTdHJpbmcgPSBlc2NhcGVTdHJpbmc7XG5leHBvcnRzLmdldE1vZGlmaWNhdGlvbkRhdGUgPSBnZXRNb2RpZmljYXRpb25EYXRlO1xuZXhwb3J0cy5nZXRWZXJib3NpdHlMZXZlbCA9IGdldFZlcmJvc2l0eUxldmVsO1xuZXhwb3J0cy5pbmZvID0gaW5mbztcbmV4cG9ydHMuaXNBcnJheUJ1ZmZlciA9IGlzQXJyYXlCdWZmZXI7XG5leHBvcnRzLmlzQXJyYXlFcXVhbCA9IGlzQXJyYXlFcXVhbDtcbmV4cG9ydHMuaXNCb29sID0gaXNCb29sO1xuZXhwb3J0cy5pc051bSA9IGlzTnVtO1xuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuZXhwb3J0cy5pc1NhbWVPcmlnaW4gPSBpc1NhbWVPcmlnaW47XG5leHBvcnRzLmNyZWF0ZVZhbGlkQWJzb2x1dGVVcmwgPSBjcmVhdGVWYWxpZEFic29sdXRlVXJsO1xuZXhwb3J0cy5yZW1vdmVOdWxsQ2hhcmFjdGVycyA9IHJlbW92ZU51bGxDaGFyYWN0ZXJzO1xuZXhwb3J0cy5zZXRWZXJib3NpdHlMZXZlbCA9IHNldFZlcmJvc2l0eUxldmVsO1xuZXhwb3J0cy5zaGFkb3cgPSBzaGFkb3c7XG5leHBvcnRzLnN0cmluZzMyID0gc3RyaW5nMzI7XG5leHBvcnRzLnN0cmluZ1RvQnl0ZXMgPSBzdHJpbmdUb0J5dGVzO1xuZXhwb3J0cy5zdHJpbmdUb1BERlN0cmluZyA9IHN0cmluZ1RvUERGU3RyaW5nO1xuZXhwb3J0cy5zdHJpbmdUb1VURjhTdHJpbmcgPSBzdHJpbmdUb1VURjhTdHJpbmc7XG5leHBvcnRzLnV0ZjhTdHJpbmdUb1N0cmluZyA9IHV0ZjhTdHJpbmdUb1N0cmluZztcbmV4cG9ydHMud2FybiA9IHdhcm47XG5leHBvcnRzLnVucmVhY2hhYmxlID0gdW5yZWFjaGFibGU7XG5leHBvcnRzLklzRXZhbFN1cHBvcnRlZENhY2hlZCA9IGV4cG9ydHMuSXNMaXR0bGVFbmRpYW5DYWNoZWQgPSBleHBvcnRzLmNyZWF0ZU9iamVjdFVSTCA9IGV4cG9ydHMuRm9ybWF0RXJyb3IgPSBleHBvcnRzLlV0aWwgPSBleHBvcnRzLlVua25vd25FcnJvckV4Y2VwdGlvbiA9IGV4cG9ydHMuVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uID0gZXhwb3J0cy5UZXh0UmVuZGVyaW5nTW9kZSA9IGV4cG9ydHMuU3RyZWFtVHlwZSA9IGV4cG9ydHMuUGVybWlzc2lvbkZsYWcgPSBleHBvcnRzLlBhc3N3b3JkUmVzcG9uc2VzID0gZXhwb3J0cy5QYXNzd29yZEV4Y2VwdGlvbiA9IGV4cG9ydHMuTWlzc2luZ1BERkV4Y2VwdGlvbiA9IGV4cG9ydHMuSW52YWxpZFBERkV4Y2VwdGlvbiA9IGV4cG9ydHMuQWJvcnRFeGNlcHRpb24gPSBleHBvcnRzLkNNYXBDb21wcmVzc2lvblR5cGUgPSBleHBvcnRzLkltYWdlS2luZCA9IGV4cG9ydHMuRm9udFR5cGUgPSBleHBvcnRzLkFubm90YXRpb25UeXBlID0gZXhwb3J0cy5Bbm5vdGF0aW9uU3RhdGVNb2RlbFR5cGUgPSBleHBvcnRzLkFubm90YXRpb25SZXZpZXdTdGF0ZSA9IGV4cG9ydHMuQW5ub3RhdGlvblJlcGx5VHlwZSA9IGV4cG9ydHMuQW5ub3RhdGlvbk1hcmtlZFN0YXRlID0gZXhwb3J0cy5Bbm5vdGF0aW9uRmxhZyA9IGV4cG9ydHMuQW5ub3RhdGlvbkZpZWxkRmxhZyA9IGV4cG9ydHMuQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZSA9IGV4cG9ydHMuVU5TVVBQT1JURURfRkVBVFVSRVMgPSBleHBvcnRzLlZlcmJvc2l0eUxldmVsID0gZXhwb3J0cy5PUFMgPSBleHBvcnRzLklERU5USVRZX01BVFJJWCA9IGV4cG9ydHMuRk9OVF9JREVOVElUWV9NQVRSSVggPSBleHBvcnRzLkJhc2VFeGNlcHRpb24gPSB2b2lkIDA7XG5cbl9fd19wZGZqc19yZXF1aXJlX18oMyk7XG5cbmNvbnN0IElERU5USVRZX01BVFJJWCA9IFsxLCAwLCAwLCAxLCAwLCAwXTtcbmV4cG9ydHMuSURFTlRJVFlfTUFUUklYID0gSURFTlRJVFlfTUFUUklYO1xuY29uc3QgRk9OVF9JREVOVElUWV9NQVRSSVggPSBbMC4wMDEsIDAsIDAsIDAuMDAxLCAwLCAwXTtcbmV4cG9ydHMuRk9OVF9JREVOVElUWV9NQVRSSVggPSBGT05UX0lERU5USVRZX01BVFJJWDtcbmNvbnN0IFBlcm1pc3Npb25GbGFnID0ge1xuICBQUklOVDogMHgwNCxcbiAgTU9ESUZZX0NPTlRFTlRTOiAweDA4LFxuICBDT1BZOiAweDEwLFxuICBNT0RJRllfQU5OT1RBVElPTlM6IDB4MjAsXG4gIEZJTExfSU5URVJBQ1RJVkVfRk9STVM6IDB4MTAwLFxuICBDT1BZX0ZPUl9BQ0NFU1NJQklMSVRZOiAweDIwMCxcbiAgQVNTRU1CTEU6IDB4NDAwLFxuICBQUklOVF9ISUdIX1FVQUxJVFk6IDB4ODAwXG59O1xuZXhwb3J0cy5QZXJtaXNzaW9uRmxhZyA9IFBlcm1pc3Npb25GbGFnO1xuY29uc3QgVGV4dFJlbmRlcmluZ01vZGUgPSB7XG4gIEZJTEw6IDAsXG4gIFNUUk9LRTogMSxcbiAgRklMTF9TVFJPS0U6IDIsXG4gIElOVklTSUJMRTogMyxcbiAgRklMTF9BRERfVE9fUEFUSDogNCxcbiAgU1RST0tFX0FERF9UT19QQVRIOiA1LFxuICBGSUxMX1NUUk9LRV9BRERfVE9fUEFUSDogNixcbiAgQUREX1RPX1BBVEg6IDcsXG4gIEZJTExfU1RST0tFX01BU0s6IDMsXG4gIEFERF9UT19QQVRIX0ZMQUc6IDRcbn07XG5leHBvcnRzLlRleHRSZW5kZXJpbmdNb2RlID0gVGV4dFJlbmRlcmluZ01vZGU7XG5jb25zdCBJbWFnZUtpbmQgPSB7XG4gIEdSQVlTQ0FMRV8xQlBQOiAxLFxuICBSR0JfMjRCUFA6IDIsXG4gIFJHQkFfMzJCUFA6IDNcbn07XG5leHBvcnRzLkltYWdlS2luZCA9IEltYWdlS2luZDtcbmNvbnN0IEFubm90YXRpb25UeXBlID0ge1xuICBURVhUOiAxLFxuICBMSU5LOiAyLFxuICBGUkVFVEVYVDogMyxcbiAgTElORTogNCxcbiAgU1FVQVJFOiA1LFxuICBDSVJDTEU6IDYsXG4gIFBPTFlHT046IDcsXG4gIFBPTFlMSU5FOiA4LFxuICBISUdITElHSFQ6IDksXG4gIFVOREVSTElORTogMTAsXG4gIFNRVUlHR0xZOiAxMSxcbiAgU1RSSUtFT1VUOiAxMixcbiAgU1RBTVA6IDEzLFxuICBDQVJFVDogMTQsXG4gIElOSzogMTUsXG4gIFBPUFVQOiAxNixcbiAgRklMRUFUVEFDSE1FTlQ6IDE3LFxuICBTT1VORDogMTgsXG4gIE1PVklFOiAxOSxcbiAgV0lER0VUOiAyMCxcbiAgU0NSRUVOOiAyMSxcbiAgUFJJTlRFUk1BUks6IDIyLFxuICBUUkFQTkVUOiAyMyxcbiAgV0FURVJNQVJLOiAyNCxcbiAgVEhSRUVEOiAyNSxcbiAgUkVEQUNUOiAyNlxufTtcbmV4cG9ydHMuQW5ub3RhdGlvblR5cGUgPSBBbm5vdGF0aW9uVHlwZTtcbmNvbnN0IEFubm90YXRpb25TdGF0ZU1vZGVsVHlwZSA9IHtcbiAgTUFSS0VEOiBcIk1hcmtlZFwiLFxuICBSRVZJRVc6IFwiUmV2aWV3XCJcbn07XG5leHBvcnRzLkFubm90YXRpb25TdGF0ZU1vZGVsVHlwZSA9IEFubm90YXRpb25TdGF0ZU1vZGVsVHlwZTtcbmNvbnN0IEFubm90YXRpb25NYXJrZWRTdGF0ZSA9IHtcbiAgTUFSS0VEOiBcIk1hcmtlZFwiLFxuICBVTk1BUktFRDogXCJVbm1hcmtlZFwiXG59O1xuZXhwb3J0cy5Bbm5vdGF0aW9uTWFya2VkU3RhdGUgPSBBbm5vdGF0aW9uTWFya2VkU3RhdGU7XG5jb25zdCBBbm5vdGF0aW9uUmV2aWV3U3RhdGUgPSB7XG4gIEFDQ0VQVEVEOiBcIkFjY2VwdGVkXCIsXG4gIFJFSkVDVEVEOiBcIlJlamVjdGVkXCIsXG4gIENBTkNFTExFRDogXCJDYW5jZWxsZWRcIixcbiAgQ09NUExFVEVEOiBcIkNvbXBsZXRlZFwiLFxuICBOT05FOiBcIk5vbmVcIlxufTtcbmV4cG9ydHMuQW5ub3RhdGlvblJldmlld1N0YXRlID0gQW5ub3RhdGlvblJldmlld1N0YXRlO1xuY29uc3QgQW5ub3RhdGlvblJlcGx5VHlwZSA9IHtcbiAgR1JPVVA6IFwiR3JvdXBcIixcbiAgUkVQTFk6IFwiUlwiXG59O1xuZXhwb3J0cy5Bbm5vdGF0aW9uUmVwbHlUeXBlID0gQW5ub3RhdGlvblJlcGx5VHlwZTtcbmNvbnN0IEFubm90YXRpb25GbGFnID0ge1xuICBJTlZJU0lCTEU6IDB4MDEsXG4gIEhJRERFTjogMHgwMixcbiAgUFJJTlQ6IDB4MDQsXG4gIE5PWk9PTTogMHgwOCxcbiAgTk9ST1RBVEU6IDB4MTAsXG4gIE5PVklFVzogMHgyMCxcbiAgUkVBRE9OTFk6IDB4NDAsXG4gIExPQ0tFRDogMHg4MCxcbiAgVE9HR0xFTk9WSUVXOiAweDEwMCxcbiAgTE9DS0VEQ09OVEVOVFM6IDB4MjAwXG59O1xuZXhwb3J0cy5Bbm5vdGF0aW9uRmxhZyA9IEFubm90YXRpb25GbGFnO1xuY29uc3QgQW5ub3RhdGlvbkZpZWxkRmxhZyA9IHtcbiAgUkVBRE9OTFk6IDB4MDAwMDAwMSxcbiAgUkVRVUlSRUQ6IDB4MDAwMDAwMixcbiAgTk9FWFBPUlQ6IDB4MDAwMDAwNCxcbiAgTVVMVElMSU5FOiAweDAwMDEwMDAsXG4gIFBBU1NXT1JEOiAweDAwMDIwMDAsXG4gIE5PVE9HR0xFVE9PRkY6IDB4MDAwNDAwMCxcbiAgUkFESU86IDB4MDAwODAwMCxcbiAgUFVTSEJVVFRPTjogMHgwMDEwMDAwLFxuICBDT01CTzogMHgwMDIwMDAwLFxuICBFRElUOiAweDAwNDAwMDAsXG4gIFNPUlQ6IDB4MDA4MDAwMCxcbiAgRklMRVNFTEVDVDogMHgwMTAwMDAwLFxuICBNVUxUSVNFTEVDVDogMHgwMjAwMDAwLFxuICBET05PVFNQRUxMQ0hFQ0s6IDB4MDQwMDAwMCxcbiAgRE9OT1RTQ1JPTEw6IDB4MDgwMDAwMCxcbiAgQ09NQjogMHgxMDAwMDAwLFxuICBSSUNIVEVYVDogMHgyMDAwMDAwLFxuICBSQURJT1NJTlVOSVNPTjogMHgyMDAwMDAwLFxuICBDT01NSVRPTlNFTENIQU5HRTogMHg0MDAwMDAwXG59O1xuZXhwb3J0cy5Bbm5vdGF0aW9uRmllbGRGbGFnID0gQW5ub3RhdGlvbkZpZWxkRmxhZztcbmNvbnN0IEFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUgPSB7XG4gIFNPTElEOiAxLFxuICBEQVNIRUQ6IDIsXG4gIEJFVkVMRUQ6IDMsXG4gIElOU0VUOiA0LFxuICBVTkRFUkxJTkU6IDVcbn07XG5leHBvcnRzLkFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUgPSBBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlO1xuY29uc3QgU3RyZWFtVHlwZSA9IHtcbiAgVU5LTk9XTjogXCJVTktOT1dOXCIsXG4gIEZMQVRFOiBcIkZMQVRFXCIsXG4gIExaVzogXCJMWldcIixcbiAgRENUOiBcIkRDVFwiLFxuICBKUFg6IFwiSlBYXCIsXG4gIEpCSUc6IFwiSkJJR1wiLFxuICBBODU6IFwiQTg1XCIsXG4gIEFIWDogXCJBSFhcIixcbiAgQ0NGOiBcIkNDRlwiLFxuICBSTFg6IFwiUkxYXCJcbn07XG5leHBvcnRzLlN0cmVhbVR5cGUgPSBTdHJlYW1UeXBlO1xuY29uc3QgRm9udFR5cGUgPSB7XG4gIFVOS05PV046IFwiVU5LTk9XTlwiLFxuICBUWVBFMTogXCJUWVBFMVwiLFxuICBUWVBFMUM6IFwiVFlQRTFDXCIsXG4gIENJREZPTlRUWVBFMDogXCJDSURGT05UVFlQRTBcIixcbiAgQ0lERk9OVFRZUEUwQzogXCJDSURGT05UVFlQRTBDXCIsXG4gIFRSVUVUWVBFOiBcIlRSVUVUWVBFXCIsXG4gIENJREZPTlRUWVBFMjogXCJDSURGT05UVFlQRTJcIixcbiAgVFlQRTM6IFwiVFlQRTNcIixcbiAgT1BFTlRZUEU6IFwiT1BFTlRZUEVcIixcbiAgVFlQRTA6IFwiVFlQRTBcIixcbiAgTU1UWVBFMTogXCJNTVRZUEUxXCJcbn07XG5leHBvcnRzLkZvbnRUeXBlID0gRm9udFR5cGU7XG5jb25zdCBWZXJib3NpdHlMZXZlbCA9IHtcbiAgRVJST1JTOiAwLFxuICBXQVJOSU5HUzogMSxcbiAgSU5GT1M6IDVcbn07XG5leHBvcnRzLlZlcmJvc2l0eUxldmVsID0gVmVyYm9zaXR5TGV2ZWw7XG5jb25zdCBDTWFwQ29tcHJlc3Npb25UeXBlID0ge1xuICBOT05FOiAwLFxuICBCSU5BUlk6IDEsXG4gIFNUUkVBTTogMlxufTtcbmV4cG9ydHMuQ01hcENvbXByZXNzaW9uVHlwZSA9IENNYXBDb21wcmVzc2lvblR5cGU7XG5jb25zdCBPUFMgPSB7XG4gIGRlcGVuZGVuY3k6IDEsXG4gIHNldExpbmVXaWR0aDogMixcbiAgc2V0TGluZUNhcDogMyxcbiAgc2V0TGluZUpvaW46IDQsXG4gIHNldE1pdGVyTGltaXQ6IDUsXG4gIHNldERhc2g6IDYsXG4gIHNldFJlbmRlcmluZ0ludGVudDogNyxcbiAgc2V0RmxhdG5lc3M6IDgsXG4gIHNldEdTdGF0ZTogOSxcbiAgc2F2ZTogMTAsXG4gIHJlc3RvcmU6IDExLFxuICB0cmFuc2Zvcm06IDEyLFxuICBtb3ZlVG86IDEzLFxuICBsaW5lVG86IDE0LFxuICBjdXJ2ZVRvOiAxNSxcbiAgY3VydmVUbzI6IDE2LFxuICBjdXJ2ZVRvMzogMTcsXG4gIGNsb3NlUGF0aDogMTgsXG4gIHJlY3RhbmdsZTogMTksXG4gIHN0cm9rZTogMjAsXG4gIGNsb3NlU3Ryb2tlOiAyMSxcbiAgZmlsbDogMjIsXG4gIGVvRmlsbDogMjMsXG4gIGZpbGxTdHJva2U6IDI0LFxuICBlb0ZpbGxTdHJva2U6IDI1LFxuICBjbG9zZUZpbGxTdHJva2U6IDI2LFxuICBjbG9zZUVPRmlsbFN0cm9rZTogMjcsXG4gIGVuZFBhdGg6IDI4LFxuICBjbGlwOiAyOSxcbiAgZW9DbGlwOiAzMCxcbiAgYmVnaW5UZXh0OiAzMSxcbiAgZW5kVGV4dDogMzIsXG4gIHNldENoYXJTcGFjaW5nOiAzMyxcbiAgc2V0V29yZFNwYWNpbmc6IDM0LFxuICBzZXRIU2NhbGU6IDM1LFxuICBzZXRMZWFkaW5nOiAzNixcbiAgc2V0Rm9udDogMzcsXG4gIHNldFRleHRSZW5kZXJpbmdNb2RlOiAzOCxcbiAgc2V0VGV4dFJpc2U6IDM5LFxuICBtb3ZlVGV4dDogNDAsXG4gIHNldExlYWRpbmdNb3ZlVGV4dDogNDEsXG4gIHNldFRleHRNYXRyaXg6IDQyLFxuICBuZXh0TGluZTogNDMsXG4gIHNob3dUZXh0OiA0NCxcbiAgc2hvd1NwYWNlZFRleHQ6IDQ1LFxuICBuZXh0TGluZVNob3dUZXh0OiA0NixcbiAgbmV4dExpbmVTZXRTcGFjaW5nU2hvd1RleHQ6IDQ3LFxuICBzZXRDaGFyV2lkdGg6IDQ4LFxuICBzZXRDaGFyV2lkdGhBbmRCb3VuZHM6IDQ5LFxuICBzZXRTdHJva2VDb2xvclNwYWNlOiA1MCxcbiAgc2V0RmlsbENvbG9yU3BhY2U6IDUxLFxuICBzZXRTdHJva2VDb2xvcjogNTIsXG4gIHNldFN0cm9rZUNvbG9yTjogNTMsXG4gIHNldEZpbGxDb2xvcjogNTQsXG4gIHNldEZpbGxDb2xvck46IDU1LFxuICBzZXRTdHJva2VHcmF5OiA1NixcbiAgc2V0RmlsbEdyYXk6IDU3LFxuICBzZXRTdHJva2VSR0JDb2xvcjogNTgsXG4gIHNldEZpbGxSR0JDb2xvcjogNTksXG4gIHNldFN0cm9rZUNNWUtDb2xvcjogNjAsXG4gIHNldEZpbGxDTVlLQ29sb3I6IDYxLFxuICBzaGFkaW5nRmlsbDogNjIsXG4gIGJlZ2luSW5saW5lSW1hZ2U6IDYzLFxuICBiZWdpbkltYWdlRGF0YTogNjQsXG4gIGVuZElubGluZUltYWdlOiA2NSxcbiAgcGFpbnRYT2JqZWN0OiA2NixcbiAgbWFya1BvaW50OiA2NyxcbiAgbWFya1BvaW50UHJvcHM6IDY4LFxuICBiZWdpbk1hcmtlZENvbnRlbnQ6IDY5LFxuICBiZWdpbk1hcmtlZENvbnRlbnRQcm9wczogNzAsXG4gIGVuZE1hcmtlZENvbnRlbnQ6IDcxLFxuICBiZWdpbkNvbXBhdDogNzIsXG4gIGVuZENvbXBhdDogNzMsXG4gIHBhaW50Rm9ybVhPYmplY3RCZWdpbjogNzQsXG4gIHBhaW50Rm9ybVhPYmplY3RFbmQ6IDc1LFxuICBiZWdpbkdyb3VwOiA3NixcbiAgZW5kR3JvdXA6IDc3LFxuICBiZWdpbkFubm90YXRpb25zOiA3OCxcbiAgZW5kQW5ub3RhdGlvbnM6IDc5LFxuICBiZWdpbkFubm90YXRpb246IDgwLFxuICBlbmRBbm5vdGF0aW9uOiA4MSxcbiAgcGFpbnRKcGVnWE9iamVjdDogODIsXG4gIHBhaW50SW1hZ2VNYXNrWE9iamVjdDogODMsXG4gIHBhaW50SW1hZ2VNYXNrWE9iamVjdEdyb3VwOiA4NCxcbiAgcGFpbnRJbWFnZVhPYmplY3Q6IDg1LFxuICBwYWludElubGluZUltYWdlWE9iamVjdDogODYsXG4gIHBhaW50SW5saW5lSW1hZ2VYT2JqZWN0R3JvdXA6IDg3LFxuICBwYWludEltYWdlWE9iamVjdFJlcGVhdDogODgsXG4gIHBhaW50SW1hZ2VNYXNrWE9iamVjdFJlcGVhdDogODksXG4gIHBhaW50U29saWRDb2xvckltYWdlTWFzazogOTAsXG4gIGNvbnN0cnVjdFBhdGg6IDkxXG59O1xuZXhwb3J0cy5PUFMgPSBPUFM7XG5jb25zdCBVTlNVUFBPUlRFRF9GRUFUVVJFUyA9IHtcbiAgdW5rbm93bjogXCJ1bmtub3duXCIsXG4gIGZvcm1zOiBcImZvcm1zXCIsXG4gIGphdmFTY3JpcHQ6IFwiamF2YVNjcmlwdFwiLFxuICBzbWFzazogXCJzbWFza1wiLFxuICBzaGFkaW5nUGF0dGVybjogXCJzaGFkaW5nUGF0dGVyblwiLFxuICBmb250OiBcImZvbnRcIixcbiAgZXJyb3JUaWxpbmdQYXR0ZXJuOiBcImVycm9yVGlsaW5nUGF0dGVyblwiLFxuICBlcnJvckV4dEdTdGF0ZTogXCJlcnJvckV4dEdTdGF0ZVwiLFxuICBlcnJvclhPYmplY3Q6IFwiZXJyb3JYT2JqZWN0XCIsXG4gIGVycm9yRm9udExvYWRUeXBlMzogXCJlcnJvckZvbnRMb2FkVHlwZTNcIixcbiAgZXJyb3JGb250U3RhdGU6IFwiZXJyb3JGb250U3RhdGVcIixcbiAgZXJyb3JGb250TWlzc2luZzogXCJlcnJvckZvbnRNaXNzaW5nXCIsXG4gIGVycm9yRm9udFRyYW5zbGF0ZTogXCJlcnJvckZvbnRUcmFuc2xhdGVcIixcbiAgZXJyb3JDb2xvclNwYWNlOiBcImVycm9yQ29sb3JTcGFjZVwiLFxuICBlcnJvck9wZXJhdG9yTGlzdDogXCJlcnJvck9wZXJhdG9yTGlzdFwiLFxuICBlcnJvckZvbnRUb1VuaWNvZGU6IFwiZXJyb3JGb250VG9Vbmljb2RlXCIsXG4gIGVycm9yRm9udExvYWROYXRpdmU6IFwiZXJyb3JGb250TG9hZE5hdGl2ZVwiLFxuICBlcnJvckZvbnRHZXRQYXRoOiBcImVycm9yRm9udEdldFBhdGhcIixcbiAgZXJyb3JNYXJrZWRDb250ZW50OiBcImVycm9yTWFya2VkQ29udGVudFwiXG59O1xuZXhwb3J0cy5VTlNVUFBPUlRFRF9GRUFUVVJFUyA9IFVOU1VQUE9SVEVEX0ZFQVRVUkVTO1xuY29uc3QgUGFzc3dvcmRSZXNwb25zZXMgPSB7XG4gIE5FRURfUEFTU1dPUkQ6IDEsXG4gIElOQ09SUkVDVF9QQVNTV09SRDogMlxufTtcbmV4cG9ydHMuUGFzc3dvcmRSZXNwb25zZXMgPSBQYXNzd29yZFJlc3BvbnNlcztcbmxldCB2ZXJib3NpdHkgPSBWZXJib3NpdHlMZXZlbC5XQVJOSU5HUztcblxuZnVuY3Rpb24gc2V0VmVyYm9zaXR5TGV2ZWwobGV2ZWwpIHtcbiAgaWYgKE51bWJlci5pc0ludGVnZXIobGV2ZWwpKSB7XG4gICAgdmVyYm9zaXR5ID0gbGV2ZWw7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VmVyYm9zaXR5TGV2ZWwoKSB7XG4gIHJldHVybiB2ZXJib3NpdHk7XG59XG5cbmZ1bmN0aW9uIGluZm8obXNnKSB7XG4gIGlmICh2ZXJib3NpdHkgPj0gVmVyYm9zaXR5TGV2ZWwuSU5GT1MpIHtcbiAgICBjb25zb2xlLmxvZyhgSW5mbzogJHttc2d9YCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgaWYgKHZlcmJvc2l0eSA+PSBWZXJib3NpdHlMZXZlbC5XQVJOSU5HUykge1xuICAgIGNvbnNvbGUubG9nKGBXYXJuaW5nOiAke21zZ31gKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bnJlYWNoYWJsZShtc2cpIHtcbiAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydChjb25kLCBtc2cpIHtcbiAgaWYgKCFjb25kKSB7XG4gICAgdW5yZWFjaGFibGUobXNnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1NhbWVPcmlnaW4oYmFzZVVybCwgb3RoZXJVcmwpIHtcbiAgbGV0IGJhc2U7XG5cbiAgdHJ5IHtcbiAgICBiYXNlID0gbmV3IFVSTChiYXNlVXJsKTtcblxuICAgIGlmICghYmFzZS5vcmlnaW4gfHwgYmFzZS5vcmlnaW4gPT09IFwibnVsbFwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3Qgb3RoZXIgPSBuZXcgVVJMKG90aGVyVXJsLCBiYXNlKTtcbiAgcmV0dXJuIGJhc2Uub3JpZ2luID09PSBvdGhlci5vcmlnaW47XG59XG5cbmZ1bmN0aW9uIF9pc1ZhbGlkUHJvdG9jb2wodXJsKSB7XG4gIGlmICghdXJsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3dpdGNoICh1cmwucHJvdG9jb2wpIHtcbiAgICBjYXNlIFwiaHR0cDpcIjpcbiAgICBjYXNlIFwiaHR0cHM6XCI6XG4gICAgY2FzZSBcImZ0cDpcIjpcbiAgICBjYXNlIFwibWFpbHRvOlwiOlxuICAgIGNhc2UgXCJ0ZWw6XCI6XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlVmFsaWRBYnNvbHV0ZVVybCh1cmwsIGJhc2VVcmwpIHtcbiAgaWYgKCF1cmwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgYWJzb2x1dGVVcmwgPSBiYXNlVXJsID8gbmV3IFVSTCh1cmwsIGJhc2VVcmwpIDogbmV3IFVSTCh1cmwpO1xuXG4gICAgaWYgKF9pc1ZhbGlkUHJvdG9jb2woYWJzb2x1dGVVcmwpKSB7XG4gICAgICByZXR1cm4gYWJzb2x1dGVVcmw7XG4gICAgfVxuICB9IGNhdGNoIChleCkge31cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gc2hhZG93KG9iaiwgcHJvcCwgdmFsdWUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwge1xuICAgIHZhbHVlLFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5jb25zdCBCYXNlRXhjZXB0aW9uID0gZnVuY3Rpb24gQmFzZUV4Y2VwdGlvbkNsb3N1cmUoKSB7XG4gIGZ1bmN0aW9uIEJhc2VFeGNlcHRpb24obWVzc2FnZSkge1xuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBCYXNlRXhjZXB0aW9uKSB7XG4gICAgICB1bnJlYWNoYWJsZShcIkNhbm5vdCBpbml0aWFsaXplIEJhc2VFeGNlcHRpb24uXCIpO1xuICAgIH1cblxuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG5cbiAgQmFzZUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbiAgQmFzZUV4Y2VwdGlvbi5jb25zdHJ1Y3RvciA9IEJhc2VFeGNlcHRpb247XG4gIHJldHVybiBCYXNlRXhjZXB0aW9uO1xufSgpO1xuXG5leHBvcnRzLkJhc2VFeGNlcHRpb24gPSBCYXNlRXhjZXB0aW9uO1xuXG5jbGFzcyBQYXNzd29yZEV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2csIGNvZGUpIHtcbiAgICBzdXBlcihtc2cpO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gIH1cblxufVxuXG5leHBvcnRzLlBhc3N3b3JkRXhjZXB0aW9uID0gUGFzc3dvcmRFeGNlcHRpb247XG5cbmNsYXNzIFVua25vd25FcnJvckV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2csIGRldGFpbHMpIHtcbiAgICBzdXBlcihtc2cpO1xuICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gIH1cblxufVxuXG5leHBvcnRzLlVua25vd25FcnJvckV4Y2VwdGlvbiA9IFVua25vd25FcnJvckV4Y2VwdGlvbjtcblxuY2xhc3MgSW52YWxpZFBERkV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge31cblxuZXhwb3J0cy5JbnZhbGlkUERGRXhjZXB0aW9uID0gSW52YWxpZFBERkV4Y2VwdGlvbjtcblxuY2xhc3MgTWlzc2luZ1BERkV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge31cblxuZXhwb3J0cy5NaXNzaW5nUERGRXhjZXB0aW9uID0gTWlzc2luZ1BERkV4Y2VwdGlvbjtcblxuY2xhc3MgVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uIGV4dGVuZHMgQmFzZUV4Y2VwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1zZywgc3RhdHVzKSB7XG4gICAgc3VwZXIobXNnKTtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgfVxuXG59XG5cbmV4cG9ydHMuVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uID0gVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uO1xuXG5jbGFzcyBGb3JtYXRFcnJvciBleHRlbmRzIEJhc2VFeGNlcHRpb24ge31cblxuZXhwb3J0cy5Gb3JtYXRFcnJvciA9IEZvcm1hdEVycm9yO1xuXG5jbGFzcyBBYm9ydEV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge31cblxuZXhwb3J0cy5BYm9ydEV4Y2VwdGlvbiA9IEFib3J0RXhjZXB0aW9uO1xuY29uc3QgTnVsbENoYXJhY3RlcnNSZWdFeHAgPSAvXFx4MDAvZztcblxuZnVuY3Rpb24gcmVtb3ZlTnVsbENoYXJhY3RlcnMoc3RyKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSBcInN0cmluZ1wiKSB7XG4gICAgd2FybihcIlRoZSBhcmd1bWVudCBmb3IgcmVtb3ZlTnVsbENoYXJhY3RlcnMgbXVzdCBiZSBhIHN0cmluZy5cIik7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIHJldHVybiBzdHIucmVwbGFjZShOdWxsQ2hhcmFjdGVyc1JlZ0V4cCwgXCJcIik7XG59XG5cbmZ1bmN0aW9uIGJ5dGVzVG9TdHJpbmcoYnl0ZXMpIHtcbiAgYXNzZXJ0KGJ5dGVzICE9PSBudWxsICYmIHR5cGVvZiBieXRlcyA9PT0gXCJvYmplY3RcIiAmJiBieXRlcy5sZW5ndGggIT09IHVuZGVmaW5lZCwgXCJJbnZhbGlkIGFyZ3VtZW50IGZvciBieXRlc1RvU3RyaW5nXCIpO1xuICBjb25zdCBsZW5ndGggPSBieXRlcy5sZW5ndGg7XG4gIGNvbnN0IE1BWF9BUkdVTUVOVF9DT1VOVCA9IDgxOTI7XG5cbiAgaWYgKGxlbmd0aCA8IE1BWF9BUkdVTUVOVF9DT1VOVCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJ5dGVzKTtcbiAgfVxuXG4gIGNvbnN0IHN0ckJ1ZiA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IE1BWF9BUkdVTUVOVF9DT1VOVCkge1xuICAgIGNvbnN0IGNodW5rRW5kID0gTWF0aC5taW4oaSArIE1BWF9BUkdVTUVOVF9DT1VOVCwgbGVuZ3RoKTtcbiAgICBjb25zdCBjaHVuayA9IGJ5dGVzLnN1YmFycmF5KGksIGNodW5rRW5kKTtcbiAgICBzdHJCdWYucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGNodW5rKSk7XG4gIH1cblxuICByZXR1cm4gc3RyQnVmLmpvaW4oXCJcIik7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ1RvQnl0ZXMoc3RyKSB7XG4gIGFzc2VydCh0eXBlb2Ygc3RyID09PSBcInN0cmluZ1wiLCBcIkludmFsaWQgYXJndW1lbnQgZm9yIHN0cmluZ1RvQnl0ZXNcIik7XG4gIGNvbnN0IGxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgYnl0ZXNbaV0gPSBzdHIuY2hhckNvZGVBdChpKSAmIDB4ZmY7XG4gIH1cblxuICByZXR1cm4gYnl0ZXM7XG59XG5cbmZ1bmN0aW9uIGFycmF5Qnl0ZUxlbmd0aChhcnIpIHtcbiAgaWYgKGFyci5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBhcnIubGVuZ3RoO1xuICB9XG5cbiAgYXNzZXJ0KGFyci5ieXRlTGVuZ3RoICE9PSB1bmRlZmluZWQsIFwiYXJyYXlCeXRlTGVuZ3RoIC0gaW52YWxpZCBhcmd1bWVudC5cIik7XG4gIHJldHVybiBhcnIuYnl0ZUxlbmd0aDtcbn1cblxuZnVuY3Rpb24gYXJyYXlzVG9CeXRlcyhhcnIpIHtcbiAgY29uc3QgbGVuZ3RoID0gYXJyLmxlbmd0aDtcblxuICBpZiAobGVuZ3RoID09PSAxICYmIGFyclswXSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4gYXJyWzBdO1xuICB9XG5cbiAgbGV0IHJlc3VsdExlbmd0aCA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdExlbmd0aCArPSBhcnJheUJ5dGVMZW5ndGgoYXJyW2ldKTtcbiAgfVxuXG4gIGxldCBwb3MgPSAwO1xuICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkocmVzdWx0TGVuZ3RoKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGl0ZW0gPSBhcnJbaV07XG5cbiAgICBpZiAoIShpdGVtIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpdGVtID0gc3RyaW5nVG9CeXRlcyhpdGVtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZW0gPSBuZXcgVWludDhBcnJheShpdGVtKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBpdGVtTGVuZ3RoID0gaXRlbS5ieXRlTGVuZ3RoO1xuICAgIGRhdGEuc2V0KGl0ZW0sIHBvcyk7XG4gICAgcG9zICs9IGl0ZW1MZW5ndGg7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gc3RyaW5nMzIodmFsdWUpIHtcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUodmFsdWUgPj4gMjQgJiAweGZmLCB2YWx1ZSA+PiAxNiAmIDB4ZmYsIHZhbHVlID4+IDggJiAweGZmLCB2YWx1ZSAmIDB4ZmYpO1xufVxuXG5mdW5jdGlvbiBpc0xpdHRsZUVuZGlhbigpIHtcbiAgY29uc3QgYnVmZmVyOCA9IG5ldyBVaW50OEFycmF5KDQpO1xuICBidWZmZXI4WzBdID0gMTtcbiAgY29uc3QgdmlldzMyID0gbmV3IFVpbnQzMkFycmF5KGJ1ZmZlcjguYnVmZmVyLCAwLCAxKTtcbiAgcmV0dXJuIHZpZXczMlswXSA9PT0gMTtcbn1cblxuY29uc3QgSXNMaXR0bGVFbmRpYW5DYWNoZWQgPSB7XG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwidmFsdWVcIiwgaXNMaXR0bGVFbmRpYW4oKSk7XG4gIH1cblxufTtcbmV4cG9ydHMuSXNMaXR0bGVFbmRpYW5DYWNoZWQgPSBJc0xpdHRsZUVuZGlhbkNhY2hlZDtcblxuZnVuY3Rpb24gaXNFdmFsU3VwcG9ydGVkKCkge1xuICB0cnkge1xuICAgIG5ldyBGdW5jdGlvbihcIlwiKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5jb25zdCBJc0V2YWxTdXBwb3J0ZWRDYWNoZWQgPSB7XG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwidmFsdWVcIiwgaXNFdmFsU3VwcG9ydGVkKCkpO1xuICB9XG5cbn07XG5leHBvcnRzLklzRXZhbFN1cHBvcnRlZENhY2hlZCA9IElzRXZhbFN1cHBvcnRlZENhY2hlZDtcbmNvbnN0IHJnYkJ1ZiA9IFtcInJnYihcIiwgMCwgXCIsXCIsIDAsIFwiLFwiLCAwLCBcIilcIl07XG5cbmNsYXNzIFV0aWwge1xuICBzdGF0aWMgbWFrZUNzc1JnYihyLCBnLCBiKSB7XG4gICAgcmdiQnVmWzFdID0gcjtcbiAgICByZ2JCdWZbM10gPSBnO1xuICAgIHJnYkJ1Zls1XSA9IGI7XG4gICAgcmV0dXJuIHJnYkJ1Zi5qb2luKFwiXCIpO1xuICB9XG5cbiAgc3RhdGljIHRyYW5zZm9ybShtMSwgbTIpIHtcbiAgICByZXR1cm4gW20xWzBdICogbTJbMF0gKyBtMVsyXSAqIG0yWzFdLCBtMVsxXSAqIG0yWzBdICsgbTFbM10gKiBtMlsxXSwgbTFbMF0gKiBtMlsyXSArIG0xWzJdICogbTJbM10sIG0xWzFdICogbTJbMl0gKyBtMVszXSAqIG0yWzNdLCBtMVswXSAqIG0yWzRdICsgbTFbMl0gKiBtMls1XSArIG0xWzRdLCBtMVsxXSAqIG0yWzRdICsgbTFbM10gKiBtMls1XSArIG0xWzVdXTtcbiAgfVxuXG4gIHN0YXRpYyBhcHBseVRyYW5zZm9ybShwLCBtKSB7XG4gICAgY29uc3QgeHQgPSBwWzBdICogbVswXSArIHBbMV0gKiBtWzJdICsgbVs0XTtcbiAgICBjb25zdCB5dCA9IHBbMF0gKiBtWzFdICsgcFsxXSAqIG1bM10gKyBtWzVdO1xuICAgIHJldHVybiBbeHQsIHl0XTtcbiAgfVxuXG4gIHN0YXRpYyBhcHBseUludmVyc2VUcmFuc2Zvcm0ocCwgbSkge1xuICAgIGNvbnN0IGQgPSBtWzBdICogbVszXSAtIG1bMV0gKiBtWzJdO1xuICAgIGNvbnN0IHh0ID0gKHBbMF0gKiBtWzNdIC0gcFsxXSAqIG1bMl0gKyBtWzJdICogbVs1XSAtIG1bNF0gKiBtWzNdKSAvIGQ7XG4gICAgY29uc3QgeXQgPSAoLXBbMF0gKiBtWzFdICsgcFsxXSAqIG1bMF0gKyBtWzRdICogbVsxXSAtIG1bNV0gKiBtWzBdKSAvIGQ7XG4gICAgcmV0dXJuIFt4dCwgeXRdO1xuICB9XG5cbiAgc3RhdGljIGdldEF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KHIsIG0pIHtcbiAgICBjb25zdCBwMSA9IFV0aWwuYXBwbHlUcmFuc2Zvcm0ociwgbSk7XG4gICAgY29uc3QgcDIgPSBVdGlsLmFwcGx5VHJhbnNmb3JtKHIuc2xpY2UoMiwgNCksIG0pO1xuICAgIGNvbnN0IHAzID0gVXRpbC5hcHBseVRyYW5zZm9ybShbclswXSwgclszXV0sIG0pO1xuICAgIGNvbnN0IHA0ID0gVXRpbC5hcHBseVRyYW5zZm9ybShbclsyXSwgclsxXV0sIG0pO1xuICAgIHJldHVybiBbTWF0aC5taW4ocDFbMF0sIHAyWzBdLCBwM1swXSwgcDRbMF0pLCBNYXRoLm1pbihwMVsxXSwgcDJbMV0sIHAzWzFdLCBwNFsxXSksIE1hdGgubWF4KHAxWzBdLCBwMlswXSwgcDNbMF0sIHA0WzBdKSwgTWF0aC5tYXgocDFbMV0sIHAyWzFdLCBwM1sxXSwgcDRbMV0pXTtcbiAgfVxuXG4gIHN0YXRpYyBpbnZlcnNlVHJhbnNmb3JtKG0pIHtcbiAgICBjb25zdCBkID0gbVswXSAqIG1bM10gLSBtWzFdICogbVsyXTtcbiAgICByZXR1cm4gW21bM10gLyBkLCAtbVsxXSAvIGQsIC1tWzJdIC8gZCwgbVswXSAvIGQsIChtWzJdICogbVs1XSAtIG1bNF0gKiBtWzNdKSAvIGQsIChtWzRdICogbVsxXSAtIG1bNV0gKiBtWzBdKSAvIGRdO1xuICB9XG5cbiAgc3RhdGljIGFwcGx5M2RUcmFuc2Zvcm0obSwgdikge1xuICAgIHJldHVybiBbbVswXSAqIHZbMF0gKyBtWzFdICogdlsxXSArIG1bMl0gKiB2WzJdLCBtWzNdICogdlswXSArIG1bNF0gKiB2WzFdICsgbVs1XSAqIHZbMl0sIG1bNl0gKiB2WzBdICsgbVs3XSAqIHZbMV0gKyBtWzhdICogdlsyXV07XG4gIH1cblxuICBzdGF0aWMgc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUobSkge1xuICAgIGNvbnN0IHRyYW5zcG9zZSA9IFttWzBdLCBtWzJdLCBtWzFdLCBtWzNdXTtcbiAgICBjb25zdCBhID0gbVswXSAqIHRyYW5zcG9zZVswXSArIG1bMV0gKiB0cmFuc3Bvc2VbMl07XG4gICAgY29uc3QgYiA9IG1bMF0gKiB0cmFuc3Bvc2VbMV0gKyBtWzFdICogdHJhbnNwb3NlWzNdO1xuICAgIGNvbnN0IGMgPSBtWzJdICogdHJhbnNwb3NlWzBdICsgbVszXSAqIHRyYW5zcG9zZVsyXTtcbiAgICBjb25zdCBkID0gbVsyXSAqIHRyYW5zcG9zZVsxXSArIG1bM10gKiB0cmFuc3Bvc2VbM107XG4gICAgY29uc3QgZmlyc3QgPSAoYSArIGQpIC8gMjtcbiAgICBjb25zdCBzZWNvbmQgPSBNYXRoLnNxcnQoKGEgKyBkKSAqIChhICsgZCkgLSA0ICogKGEgKiBkIC0gYyAqIGIpKSAvIDI7XG4gICAgY29uc3Qgc3ggPSBmaXJzdCArIHNlY29uZCB8fCAxO1xuICAgIGNvbnN0IHN5ID0gZmlyc3QgLSBzZWNvbmQgfHwgMTtcbiAgICByZXR1cm4gW01hdGguc3FydChzeCksIE1hdGguc3FydChzeSldO1xuICB9XG5cbiAgc3RhdGljIG5vcm1hbGl6ZVJlY3QocmVjdCkge1xuICAgIGNvbnN0IHIgPSByZWN0LnNsaWNlKDApO1xuXG4gICAgaWYgKHJlY3RbMF0gPiByZWN0WzJdKSB7XG4gICAgICByWzBdID0gcmVjdFsyXTtcbiAgICAgIHJbMl0gPSByZWN0WzBdO1xuICAgIH1cblxuICAgIGlmIChyZWN0WzFdID4gcmVjdFszXSkge1xuICAgICAgclsxXSA9IHJlY3RbM107XG4gICAgICByWzNdID0gcmVjdFsxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcjtcbiAgfVxuXG4gIHN0YXRpYyBpbnRlcnNlY3QocmVjdDEsIHJlY3QyKSB7XG4gICAgZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gICAgICByZXR1cm4gYSAtIGI7XG4gICAgfVxuXG4gICAgY29uc3Qgb3JkZXJlZFggPSBbcmVjdDFbMF0sIHJlY3QxWzJdLCByZWN0MlswXSwgcmVjdDJbMl1dLnNvcnQoY29tcGFyZSk7XG4gICAgY29uc3Qgb3JkZXJlZFkgPSBbcmVjdDFbMV0sIHJlY3QxWzNdLCByZWN0MlsxXSwgcmVjdDJbM11dLnNvcnQoY29tcGFyZSk7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgcmVjdDEgPSBVdGlsLm5vcm1hbGl6ZVJlY3QocmVjdDEpO1xuICAgIHJlY3QyID0gVXRpbC5ub3JtYWxpemVSZWN0KHJlY3QyKTtcblxuICAgIGlmIChvcmRlcmVkWFswXSA9PT0gcmVjdDFbMF0gJiYgb3JkZXJlZFhbMV0gPT09IHJlY3QyWzBdIHx8IG9yZGVyZWRYWzBdID09PSByZWN0MlswXSAmJiBvcmRlcmVkWFsxXSA9PT0gcmVjdDFbMF0pIHtcbiAgICAgIHJlc3VsdFswXSA9IG9yZGVyZWRYWzFdO1xuICAgICAgcmVzdWx0WzJdID0gb3JkZXJlZFhbMl07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChvcmRlcmVkWVswXSA9PT0gcmVjdDFbMV0gJiYgb3JkZXJlZFlbMV0gPT09IHJlY3QyWzFdIHx8IG9yZGVyZWRZWzBdID09PSByZWN0MlsxXSAmJiBvcmRlcmVkWVsxXSA9PT0gcmVjdDFbMV0pIHtcbiAgICAgIHJlc3VsdFsxXSA9IG9yZGVyZWRZWzFdO1xuICAgICAgcmVzdWx0WzNdID0gb3JkZXJlZFlbMl07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxufVxuXG5leHBvcnRzLlV0aWwgPSBVdGlsO1xuY29uc3QgUERGU3RyaW5nVHJhbnNsYXRlVGFibGUgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMHgyRDgsIDB4MkM3LCAweDJDNiwgMHgyRDksIDB4MkRELCAweDJEQiwgMHgyREEsIDB4MkRDLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAweDIwMjIsIDB4MjAyMCwgMHgyMDIxLCAweDIwMjYsIDB4MjAxNCwgMHgyMDEzLCAweDE5MiwgMHgyMDQ0LCAweDIwMzksIDB4MjAzQSwgMHgyMjEyLCAweDIwMzAsIDB4MjAxRSwgMHgyMDFDLCAweDIwMUQsIDB4MjAxOCwgMHgyMDE5LCAweDIwMUEsIDB4MjEyMiwgMHhGQjAxLCAweEZCMDIsIDB4MTQxLCAweDE1MiwgMHgxNjAsIDB4MTc4LCAweDE3RCwgMHgxMzEsIDB4MTQyLCAweDE1MywgMHgxNjEsIDB4MTdFLCAwLCAweDIwQUNdO1xuXG5mdW5jdGlvbiBzdHJpbmdUb1BERlN0cmluZyhzdHIpIHtcbiAgY29uc3QgbGVuZ3RoID0gc3RyLmxlbmd0aCxcbiAgICAgICAgc3RyQnVmID0gW107XG5cbiAgaWYgKHN0clswXSA9PT0gXCJcXHhGRVwiICYmIHN0clsxXSA9PT0gXCJcXHhGRlwiKSB7XG4gICAgZm9yIChsZXQgaSA9IDI7IGkgPCBsZW5ndGg7IGkgKz0gMikge1xuICAgICAgc3RyQnVmLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShzdHIuY2hhckNvZGVBdChpKSA8PCA4IHwgc3RyLmNoYXJDb2RlQXQoaSArIDEpKSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHN0clswXSA9PT0gXCJcXHhGRlwiICYmIHN0clsxXSA9PT0gXCJcXHhGRVwiKSB7XG4gICAgZm9yIChsZXQgaSA9IDI7IGkgPCBsZW5ndGg7IGkgKz0gMikge1xuICAgICAgc3RyQnVmLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShzdHIuY2hhckNvZGVBdChpICsgMSkgPDwgOCB8IHN0ci5jaGFyQ29kZUF0KGkpKSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGNvZGUgPSBQREZTdHJpbmdUcmFuc2xhdGVUYWJsZVtzdHIuY2hhckNvZGVBdChpKV07XG4gICAgICBzdHJCdWYucHVzaChjb2RlID8gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSA6IHN0ci5jaGFyQXQoaSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHJCdWYuam9pbihcIlwiKTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlU3RyaW5nKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbXFwoXFwpXFxcXF0pL2csIFwiXFxcXCQxXCIpO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdUb1VURjhTdHJpbmcoc3RyKSB7XG4gIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKHN0cikpO1xufVxuXG5mdW5jdGlvbiB1dGY4U3RyaW5nVG9TdHJpbmcoc3RyKSB7XG4gIHJldHVybiB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSk7XG59XG5cbmZ1bmN0aW9uIGlzQm9vbCh2KSB7XG4gIHJldHVybiB0eXBlb2YgdiA9PT0gXCJib29sZWFuXCI7XG59XG5cbmZ1bmN0aW9uIGlzTnVtKHYpIHtcbiAgcmV0dXJuIHR5cGVvZiB2ID09PSBcIm51bWJlclwiO1xufVxuXG5mdW5jdGlvbiBpc1N0cmluZyh2KSB7XG4gIHJldHVybiB0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIjtcbn1cblxuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2KSB7XG4gIHJldHVybiB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB2ICE9PSBudWxsICYmIHYuYnl0ZUxlbmd0aCAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBpc0FycmF5RXF1YWwoYXJyMSwgYXJyMikge1xuICBpZiAoYXJyMS5sZW5ndGggIT09IGFycjIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGFycjEuZXZlcnkoZnVuY3Rpb24gKGVsZW1lbnQsIGluZGV4KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQgPT09IGFycjJbaW5kZXhdO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0TW9kaWZpY2F0aW9uRGF0ZShkYXRlID0gbmV3IERhdGUoRGF0ZS5ub3coKSkpIHtcbiAgY29uc3QgYnVmZmVyID0gW2RhdGUuZ2V0VVRDRnVsbFllYXIoKS50b1N0cmluZygpLCAoZGF0ZS5nZXRVVENNb250aCgpICsgMSkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIiksIChkYXRlLmdldFVUQ0RhdGUoKSArIDEpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpLCBkYXRlLmdldFVUQ0hvdXJzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIiksIGRhdGUuZ2V0VVRDTWludXRlcygpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpLCBkYXRlLmdldFVUQ1NlY29uZHMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKV07XG4gIHJldHVybiBidWZmZXIuam9pbihcIlwiKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkoKSB7XG4gIGNvbnN0IGNhcGFiaWxpdHkgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBsZXQgaXNTZXR0bGVkID0gZmFsc2U7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjYXBhYmlsaXR5LCBcInNldHRsZWRcIiwge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBpc1NldHRsZWQ7XG4gICAgfVxuXG4gIH0pO1xuICBjYXBhYmlsaXR5LnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgY2FwYWJpbGl0eS5yZXNvbHZlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIGlzU2V0dGxlZCA9IHRydWU7XG4gICAgICByZXNvbHZlKGRhdGEpO1xuICAgIH07XG5cbiAgICBjYXBhYmlsaXR5LnJlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIGlzU2V0dGxlZCA9IHRydWU7XG4gICAgICByZWplY3QocmVhc29uKTtcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIGNhcGFiaWxpdHk7XG59XG5cbmNvbnN0IGNyZWF0ZU9iamVjdFVSTCA9IGZ1bmN0aW9uIGNyZWF0ZU9iamVjdFVSTENsb3N1cmUoKSB7XG4gIGNvbnN0IGRpZ2l0cyA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cIjtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdFVSTChkYXRhLCBjb250ZW50VHlwZSwgZm9yY2VEYXRhU2NoZW1hID0gZmFsc2UpIHtcbiAgICBpZiAoIWZvcmNlRGF0YVNjaGVtYSAmJiBVUkwuY3JlYXRlT2JqZWN0VVJMKSB7XG4gICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2RhdGFdLCB7XG4gICAgICAgIHR5cGU6IGNvbnRlbnRUeXBlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgIH1cblxuICAgIGxldCBidWZmZXIgPSBgZGF0YToke2NvbnRlbnRUeXBlfTtiYXNlNjQsYDtcblxuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGRhdGEubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMykge1xuICAgICAgY29uc3QgYjEgPSBkYXRhW2ldICYgMHhmZjtcbiAgICAgIGNvbnN0IGIyID0gZGF0YVtpICsgMV0gJiAweGZmO1xuICAgICAgY29uc3QgYjMgPSBkYXRhW2kgKyAyXSAmIDB4ZmY7XG4gICAgICBjb25zdCBkMSA9IGIxID4+IDIsXG4gICAgICAgICAgICBkMiA9IChiMSAmIDMpIDw8IDQgfCBiMiA+PiA0O1xuICAgICAgY29uc3QgZDMgPSBpICsgMSA8IGlpID8gKGIyICYgMHhmKSA8PCAyIHwgYjMgPj4gNiA6IDY0O1xuICAgICAgY29uc3QgZDQgPSBpICsgMiA8IGlpID8gYjMgJiAweDNmIDogNjQ7XG4gICAgICBidWZmZXIgKz0gZGlnaXRzW2QxXSArIGRpZ2l0c1tkMl0gKyBkaWdpdHNbZDNdICsgZGlnaXRzW2Q0XTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmZmVyO1xuICB9O1xufSgpO1xuXG5leHBvcnRzLmNyZWF0ZU9iamVjdFVSTCA9IGNyZWF0ZU9iamVjdFVSTDtcblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfaXNfbm9kZSA9IF9fd19wZGZqc19yZXF1aXJlX18oNCk7XG5cbjtcblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmlzTm9kZUpTID0gdm9pZCAwO1xuY29uc3QgaXNOb2RlSlMgPSB0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzICsgXCJcIiA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIgJiYgIXByb2Nlc3MudmVyc2lvbnMubncgJiYgIShwcm9jZXNzLnZlcnNpb25zLmVsZWN0cm9uICYmIHByb2Nlc3MudHlwZSAmJiBwcm9jZXNzLnR5cGUgIT09IFwiYnJvd3NlclwiKTtcbmV4cG9ydHMuaXNOb2RlSlMgPSBpc05vZGVKUztcblxuLyoqKi8gfSksXG4vKiA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmdldERvY3VtZW50ID0gZ2V0RG9jdW1lbnQ7XG5leHBvcnRzLnNldFBERk5ldHdvcmtTdHJlYW1GYWN0b3J5ID0gc2V0UERGTmV0d29ya1N0cmVhbUZhY3Rvcnk7XG5leHBvcnRzLmJ1aWxkID0gZXhwb3J0cy52ZXJzaW9uID0gZXhwb3J0cy5QREZQYWdlUHJveHkgPSBleHBvcnRzLlBERkRvY3VtZW50UHJveHkgPSBleHBvcnRzLlBERldvcmtlciA9IGV4cG9ydHMuUERGRGF0YVJhbmdlVHJhbnNwb3J0ID0gZXhwb3J0cy5Mb29wYmFja1BvcnQgPSB2b2lkIDA7XG5cbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMik7XG5cbnZhciBfZGlzcGxheV91dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG5cbnZhciBfZm9udF9sb2FkZXIgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDYpO1xuXG52YXIgX25vZGVfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDcpO1xuXG52YXIgX2Fubm90YXRpb25fc3RvcmFnZSA9IF9fd19wZGZqc19yZXF1aXJlX18oOCk7XG5cbnZhciBfYXBpX2NvbXBhdGliaWxpdHkgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDkpO1xuXG52YXIgX2NhbnZhcyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTApO1xuXG52YXIgX3dvcmtlcl9vcHRpb25zID0gX193X3BkZmpzX3JlcXVpcmVfXygxMik7XG5cbnZhciBfaXNfbm9kZSA9IF9fd19wZGZqc19yZXF1aXJlX18oNCk7XG5cbnZhciBfbWVzc2FnZV9oYW5kbGVyID0gX193X3BkZmpzX3JlcXVpcmVfXygxMyk7XG5cbnZhciBfbWV0YWRhdGEgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE0KTtcblxudmFyIF9vcHRpb25hbF9jb250ZW50X2NvbmZpZyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTYpO1xuXG52YXIgX3RyYW5zcG9ydF9zdHJlYW0gPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE3KTtcblxudmFyIF93ZWJnbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTgpO1xuXG5jb25zdCBERUZBVUxUX1JBTkdFX0NIVU5LX1NJWkUgPSA2NTUzNjtcbmNvbnN0IFJFTkRFUklOR19DQU5DRUxMRURfVElNRU9VVCA9IDEwMDtcbmNvbnN0IERlZmF1bHRDYW52YXNGYWN0b3J5ID0gX2lzX25vZGUuaXNOb2RlSlMgPyBfbm9kZV91dGlscy5Ob2RlQ2FudmFzRmFjdG9yeSA6IF9kaXNwbGF5X3V0aWxzLkRPTUNhbnZhc0ZhY3Rvcnk7XG5jb25zdCBEZWZhdWx0Q01hcFJlYWRlckZhY3RvcnkgPSBfaXNfbm9kZS5pc05vZGVKUyA/IF9ub2RlX3V0aWxzLk5vZGVDTWFwUmVhZGVyRmFjdG9yeSA6IF9kaXNwbGF5X3V0aWxzLkRPTUNNYXBSZWFkZXJGYWN0b3J5O1xubGV0IGNyZWF0ZVBERk5ldHdvcmtTdHJlYW07XG5cbmZ1bmN0aW9uIHNldFBERk5ldHdvcmtTdHJlYW1GYWN0b3J5KHBkZk5ldHdvcmtTdHJlYW1GYWN0b3J5KSB7XG4gIGNyZWF0ZVBERk5ldHdvcmtTdHJlYW0gPSBwZGZOZXR3b3JrU3RyZWFtRmFjdG9yeTtcbn1cblxuZnVuY3Rpb24gZ2V0RG9jdW1lbnQoc3JjKSB7XG4gIGNvbnN0IHRhc2sgPSBuZXcgUERGRG9jdW1lbnRMb2FkaW5nVGFzaygpO1xuICBsZXQgc291cmNlO1xuXG4gIGlmICh0eXBlb2Ygc3JjID09PSBcInN0cmluZ1wiKSB7XG4gICAgc291cmNlID0ge1xuICAgICAgdXJsOiBzcmNcbiAgICB9O1xuICB9IGVsc2UgaWYgKCgwLCBfdXRpbC5pc0FycmF5QnVmZmVyKShzcmMpKSB7XG4gICAgc291cmNlID0ge1xuICAgICAgZGF0YTogc3JjXG4gICAgfTtcbiAgfSBlbHNlIGlmIChzcmMgaW5zdGFuY2VvZiBQREZEYXRhUmFuZ2VUcmFuc3BvcnQpIHtcbiAgICBzb3VyY2UgPSB7XG4gICAgICByYW5nZTogc3JjXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIHNyYyAhPT0gXCJvYmplY3RcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwYXJhbWV0ZXIgaW4gZ2V0RG9jdW1lbnQsIFwiICsgXCJuZWVkIGVpdGhlciBVaW50OEFycmF5LCBzdHJpbmcgb3IgYSBwYXJhbWV0ZXIgb2JqZWN0XCIpO1xuICAgIH1cblxuICAgIGlmICghc3JjLnVybCAmJiAhc3JjLmRhdGEgJiYgIXNyYy5yYW5nZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwYXJhbWV0ZXIgb2JqZWN0OiBuZWVkIGVpdGhlciAuZGF0YSwgLnJhbmdlIG9yIC51cmxcIik7XG4gICAgfVxuXG4gICAgc291cmNlID0gc3JjO1xuICB9XG5cbiAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgbGV0IHJhbmdlVHJhbnNwb3J0ID0gbnVsbCxcbiAgICAgIHdvcmtlciA9IG51bGw7XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlKSB7XG4gICAgaWYgKGtleSA9PT0gXCJ1cmxcIiAmJiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBwYXJhbXNba2V5XSA9IG5ldyBVUkwoc291cmNlW2tleV0sIHdpbmRvdy5sb2NhdGlvbikuaHJlZjtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcInJhbmdlXCIpIHtcbiAgICAgIHJhbmdlVHJhbnNwb3J0ID0gc291cmNlW2tleV07XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJ3b3JrZXJcIikge1xuICAgICAgd29ya2VyID0gc291cmNlW2tleV07XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJkYXRhXCIgJiYgIShzb3VyY2Vba2V5XSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICBjb25zdCBwZGZCeXRlcyA9IHNvdXJjZVtrZXldO1xuXG4gICAgICBpZiAodHlwZW9mIHBkZkJ5dGVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHBhcmFtc1trZXldID0gKDAsIF91dGlsLnN0cmluZ1RvQnl0ZXMpKHBkZkJ5dGVzKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBkZkJ5dGVzID09PSBcIm9iamVjdFwiICYmIHBkZkJ5dGVzICE9PSBudWxsICYmICFpc05hTihwZGZCeXRlcy5sZW5ndGgpKSB7XG4gICAgICAgIHBhcmFtc1trZXldID0gbmV3IFVpbnQ4QXJyYXkocGRmQnl0ZXMpO1xuICAgICAgfSBlbHNlIGlmICgoMCwgX3V0aWwuaXNBcnJheUJ1ZmZlcikocGRmQnl0ZXMpKSB7XG4gICAgICAgIHBhcmFtc1trZXldID0gbmV3IFVpbnQ4QXJyYXkocGRmQnl0ZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBQREYgYmluYXJ5IGRhdGE6IGVpdGhlciB0eXBlZCBhcnJheSwgXCIgKyBcInN0cmluZyBvciBhcnJheS1saWtlIG9iamVjdCBpcyBleHBlY3RlZCBpbiB0aGUgXCIgKyBcImRhdGEgcHJvcGVydHkuXCIpO1xuICAgICAgfVxuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBwYXJhbXNba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG5cbiAgcGFyYW1zLnJhbmdlQ2h1bmtTaXplID0gcGFyYW1zLnJhbmdlQ2h1bmtTaXplIHx8IERFRkFVTFRfUkFOR0VfQ0hVTktfU0laRTtcbiAgcGFyYW1zLkNNYXBSZWFkZXJGYWN0b3J5ID0gcGFyYW1zLkNNYXBSZWFkZXJGYWN0b3J5IHx8IERlZmF1bHRDTWFwUmVhZGVyRmFjdG9yeTtcbiAgcGFyYW1zLmlnbm9yZUVycm9ycyA9IHBhcmFtcy5zdG9wQXRFcnJvcnMgIT09IHRydWU7XG4gIHBhcmFtcy5mb250RXh0cmFQcm9wZXJ0aWVzID0gcGFyYW1zLmZvbnRFeHRyYVByb3BlcnRpZXMgPT09IHRydWU7XG4gIHBhcmFtcy5wZGZCdWcgPSBwYXJhbXMucGRmQnVnID09PSB0cnVlO1xuXG4gIGlmICghTnVtYmVyLmlzSW50ZWdlcihwYXJhbXMubWF4SW1hZ2VTaXplKSkge1xuICAgIHBhcmFtcy5tYXhJbWFnZVNpemUgPSAtMTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcGFyYW1zLmlzRXZhbFN1cHBvcnRlZCAhPT0gXCJib29sZWFuXCIpIHtcbiAgICBwYXJhbXMuaXNFdmFsU3VwcG9ydGVkID0gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcGFyYW1zLmRpc2FibGVGb250RmFjZSAhPT0gXCJib29sZWFuXCIpIHtcbiAgICBwYXJhbXMuZGlzYWJsZUZvbnRGYWNlID0gX2FwaV9jb21wYXRpYmlsaXR5LmFwaUNvbXBhdGliaWxpdHlQYXJhbXMuZGlzYWJsZUZvbnRGYWNlIHx8IGZhbHNlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwYXJhbXMub3duZXJEb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHBhcmFtcy5vd25lckRvY3VtZW50ID0gZ2xvYmFsVGhpcy5kb2N1bWVudDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcGFyYW1zLmRpc2FibGVSYW5nZSAhPT0gXCJib29sZWFuXCIpIHtcbiAgICBwYXJhbXMuZGlzYWJsZVJhbmdlID0gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIHBhcmFtcy5kaXNhYmxlU3RyZWFtICE9PSBcImJvb2xlYW5cIikge1xuICAgIHBhcmFtcy5kaXNhYmxlU3RyZWFtID0gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIHBhcmFtcy5kaXNhYmxlQXV0b0ZldGNoICE9PSBcImJvb2xlYW5cIikge1xuICAgIHBhcmFtcy5kaXNhYmxlQXV0b0ZldGNoID0gZmFsc2U7XG4gIH1cblxuICAoMCwgX3V0aWwuc2V0VmVyYm9zaXR5TGV2ZWwpKHBhcmFtcy52ZXJib3NpdHkpO1xuXG4gIGlmICghd29ya2VyKSB7XG4gICAgY29uc3Qgd29ya2VyUGFyYW1zID0ge1xuICAgICAgdmVyYm9zaXR5OiBwYXJhbXMudmVyYm9zaXR5LFxuICAgICAgcG9ydDogX3dvcmtlcl9vcHRpb25zLkdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyUG9ydFxuICAgIH07XG4gICAgd29ya2VyID0gd29ya2VyUGFyYW1zLnBvcnQgPyBQREZXb3JrZXIuZnJvbVBvcnQod29ya2VyUGFyYW1zKSA6IG5ldyBQREZXb3JrZXIod29ya2VyUGFyYW1zKTtcbiAgICB0YXNrLl93b3JrZXIgPSB3b3JrZXI7XG4gIH1cblxuICBjb25zdCBkb2NJZCA9IHRhc2suZG9jSWQ7XG4gIHdvcmtlci5wcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIGlmICh0YXNrLmRlc3Ryb3llZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTG9hZGluZyBhYm9ydGVkXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IHdvcmtlcklkUHJvbWlzZSA9IF9mZXRjaERvY3VtZW50KHdvcmtlciwgcGFyYW1zLCByYW5nZVRyYW5zcG9ydCwgZG9jSWQpO1xuXG4gICAgY29uc3QgbmV0d29ya1N0cmVhbVByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgbGV0IG5ldHdvcmtTdHJlYW07XG5cbiAgICAgIGlmIChyYW5nZVRyYW5zcG9ydCkge1xuICAgICAgICBuZXR3b3JrU3RyZWFtID0gbmV3IF90cmFuc3BvcnRfc3RyZWFtLlBERkRhdGFUcmFuc3BvcnRTdHJlYW0oe1xuICAgICAgICAgIGxlbmd0aDogcGFyYW1zLmxlbmd0aCxcbiAgICAgICAgICBpbml0aWFsRGF0YTogcGFyYW1zLmluaXRpYWxEYXRhLFxuICAgICAgICAgIHByb2dyZXNzaXZlRG9uZTogcGFyYW1zLnByb2dyZXNzaXZlRG9uZSxcbiAgICAgICAgICBkaXNhYmxlUmFuZ2U6IHBhcmFtcy5kaXNhYmxlUmFuZ2UsXG4gICAgICAgICAgZGlzYWJsZVN0cmVhbTogcGFyYW1zLmRpc2FibGVTdHJlYW1cbiAgICAgICAgfSwgcmFuZ2VUcmFuc3BvcnQpO1xuICAgICAgfSBlbHNlIGlmICghcGFyYW1zLmRhdGEpIHtcbiAgICAgICAgbmV0d29ya1N0cmVhbSA9IGNyZWF0ZVBERk5ldHdvcmtTdHJlYW0oe1xuICAgICAgICAgIHVybDogcGFyYW1zLnVybCxcbiAgICAgICAgICBsZW5ndGg6IHBhcmFtcy5sZW5ndGgsXG4gICAgICAgICAgaHR0cEhlYWRlcnM6IHBhcmFtcy5odHRwSGVhZGVycyxcbiAgICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IHBhcmFtcy53aXRoQ3JlZGVudGlhbHMsXG4gICAgICAgICAgcmFuZ2VDaHVua1NpemU6IHBhcmFtcy5yYW5nZUNodW5rU2l6ZSxcbiAgICAgICAgICBkaXNhYmxlUmFuZ2U6IHBhcmFtcy5kaXNhYmxlUmFuZ2UsXG4gICAgICAgICAgZGlzYWJsZVN0cmVhbTogcGFyYW1zLmRpc2FibGVTdHJlYW1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJlc29sdmUobmV0d29ya1N0cmVhbSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFt3b3JrZXJJZFByb21pc2UsIG5ldHdvcmtTdHJlYW1Qcm9taXNlXSkudGhlbihmdW5jdGlvbiAoW3dvcmtlcklkLCBuZXR3b3JrU3RyZWFtXSkge1xuICAgICAgaWYgKHRhc2suZGVzdHJveWVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxvYWRpbmcgYWJvcnRlZFwiKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbWVzc2FnZUhhbmRsZXIgPSBuZXcgX21lc3NhZ2VfaGFuZGxlci5NZXNzYWdlSGFuZGxlcihkb2NJZCwgd29ya2VySWQsIHdvcmtlci5wb3J0KTtcbiAgICAgIG1lc3NhZ2VIYW5kbGVyLnBvc3RNZXNzYWdlVHJhbnNmZXJzID0gd29ya2VyLnBvc3RNZXNzYWdlVHJhbnNmZXJzO1xuICAgICAgY29uc3QgdHJhbnNwb3J0ID0gbmV3IFdvcmtlclRyYW5zcG9ydChtZXNzYWdlSGFuZGxlciwgdGFzaywgbmV0d29ya1N0cmVhbSwgcGFyYW1zKTtcbiAgICAgIHRhc2suX3RyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICAgIG1lc3NhZ2VIYW5kbGVyLnNlbmQoXCJSZWFkeVwiLCBudWxsKTtcbiAgICB9KTtcbiAgfSkuY2F0Y2godGFzay5fY2FwYWJpbGl0eS5yZWplY3QpO1xuICByZXR1cm4gdGFzaztcbn1cblxuZnVuY3Rpb24gX2ZldGNoRG9jdW1lbnQod29ya2VyLCBzb3VyY2UsIHBkZkRhdGFSYW5nZVRyYW5zcG9ydCwgZG9jSWQpIHtcbiAgaWYgKHdvcmtlci5kZXN0cm95ZWQpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiV29ya2VyIHdhcyBkZXN0cm95ZWRcIikpO1xuICB9XG5cbiAgaWYgKHBkZkRhdGFSYW5nZVRyYW5zcG9ydCkge1xuICAgIHNvdXJjZS5sZW5ndGggPSBwZGZEYXRhUmFuZ2VUcmFuc3BvcnQubGVuZ3RoO1xuICAgIHNvdXJjZS5pbml0aWFsRGF0YSA9IHBkZkRhdGFSYW5nZVRyYW5zcG9ydC5pbml0aWFsRGF0YTtcbiAgICBzb3VyY2UucHJvZ3Jlc3NpdmVEb25lID0gcGRmRGF0YVJhbmdlVHJhbnNwb3J0LnByb2dyZXNzaXZlRG9uZTtcbiAgfVxuXG4gIHJldHVybiB3b3JrZXIubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0RG9jUmVxdWVzdFwiLCB7XG4gICAgZG9jSWQsXG4gICAgYXBpVmVyc2lvbjogJzIuNi4zNDcnLFxuICAgIHNvdXJjZToge1xuICAgICAgZGF0YTogc291cmNlLmRhdGEsXG4gICAgICB1cmw6IHNvdXJjZS51cmwsXG4gICAgICBwYXNzd29yZDogc291cmNlLnBhc3N3b3JkLFxuICAgICAgZGlzYWJsZUF1dG9GZXRjaDogc291cmNlLmRpc2FibGVBdXRvRmV0Y2gsXG4gICAgICByYW5nZUNodW5rU2l6ZTogc291cmNlLnJhbmdlQ2h1bmtTaXplLFxuICAgICAgbGVuZ3RoOiBzb3VyY2UubGVuZ3RoXG4gICAgfSxcbiAgICBtYXhJbWFnZVNpemU6IHNvdXJjZS5tYXhJbWFnZVNpemUsXG4gICAgZGlzYWJsZUZvbnRGYWNlOiBzb3VyY2UuZGlzYWJsZUZvbnRGYWNlLFxuICAgIHBvc3RNZXNzYWdlVHJhbnNmZXJzOiB3b3JrZXIucG9zdE1lc3NhZ2VUcmFuc2ZlcnMsXG4gICAgZG9jQmFzZVVybDogc291cmNlLmRvY0Jhc2VVcmwsXG4gICAgaWdub3JlRXJyb3JzOiBzb3VyY2UuaWdub3JlRXJyb3JzLFxuICAgIGlzRXZhbFN1cHBvcnRlZDogc291cmNlLmlzRXZhbFN1cHBvcnRlZCxcbiAgICBmb250RXh0cmFQcm9wZXJ0aWVzOiBzb3VyY2UuZm9udEV4dHJhUHJvcGVydGllc1xuICB9KS50aGVuKGZ1bmN0aW9uICh3b3JrZXJJZCkge1xuICAgIGlmICh3b3JrZXIuZGVzdHJveWVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXb3JrZXIgd2FzIGRlc3Ryb3llZFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gd29ya2VySWQ7XG4gIH0pO1xufVxuXG5jb25zdCBQREZEb2N1bWVudExvYWRpbmdUYXNrID0gZnVuY3Rpb24gUERGRG9jdW1lbnRMb2FkaW5nVGFza0Nsb3N1cmUoKSB7XG4gIGxldCBuZXh0RG9jdW1lbnRJZCA9IDA7XG5cbiAgY2xhc3MgUERGRG9jdW1lbnRMb2FkaW5nVGFzayB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICB0aGlzLl9jYXBhYmlsaXR5ID0gKDAsIF91dGlsLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KSgpO1xuICAgICAgdGhpcy5fdHJhbnNwb3J0ID0gbnVsbDtcbiAgICAgIHRoaXMuX3dvcmtlciA9IG51bGw7XG4gICAgICB0aGlzLmRvY0lkID0gXCJkXCIgKyBuZXh0RG9jdW1lbnRJZCsrO1xuICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMub25QYXNzd29yZCA9IG51bGw7XG4gICAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgdGhpcy5vblVuc3VwcG9ydGVkRmVhdHVyZSA9IG51bGw7XG4gICAgfVxuXG4gICAgZ2V0IHByb21pc2UoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIH1cblxuICAgIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICBjb25zdCB0cmFuc3BvcnREZXN0cm95ZWQgPSAhdGhpcy5fdHJhbnNwb3J0ID8gUHJvbWlzZS5yZXNvbHZlKCkgOiB0aGlzLl90cmFuc3BvcnQuZGVzdHJveSgpO1xuICAgICAgcmV0dXJuIHRyYW5zcG9ydERlc3Ryb3llZC50aGVuKCgpID0+IHtcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0ID0gbnVsbDtcblxuICAgICAgICBpZiAodGhpcy5fd29ya2VyKSB7XG4gICAgICAgICAgdGhpcy5fd29ya2VyLmRlc3Ryb3koKTtcblxuICAgICAgICAgIHRoaXMuX3dvcmtlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIFBERkRvY3VtZW50TG9hZGluZ1Rhc2s7XG59KCk7XG5cbmNsYXNzIFBERkRhdGFSYW5nZVRyYW5zcG9ydCB7XG4gIGNvbnN0cnVjdG9yKGxlbmd0aCwgaW5pdGlhbERhdGEsIHByb2dyZXNzaXZlRG9uZSA9IGZhbHNlKSB7XG4gICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgdGhpcy5pbml0aWFsRGF0YSA9IGluaXRpYWxEYXRhO1xuICAgIHRoaXMucHJvZ3Jlc3NpdmVEb25lID0gcHJvZ3Jlc3NpdmVEb25lO1xuICAgIHRoaXMuX3JhbmdlTGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5fcHJvZ3Jlc3NMaXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLl9wcm9ncmVzc2l2ZVJlYWRMaXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLl9wcm9ncmVzc2l2ZURvbmVMaXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkgPSAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCk7XG4gIH1cblxuICBhZGRSYW5nZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5fcmFuZ2VMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gIH1cblxuICBhZGRQcm9ncmVzc0xpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5fcHJvZ3Jlc3NMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gIH1cblxuICBhZGRQcm9ncmVzc2l2ZVJlYWRMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIHRoaXMuX3Byb2dyZXNzaXZlUmVhZExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgfVxuXG4gIGFkZFByb2dyZXNzaXZlRG9uZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5fcHJvZ3Jlc3NpdmVEb25lTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICB9XG5cbiAgb25EYXRhUmFuZ2UoYmVnaW4sIGNodW5rKSB7XG4gICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLl9yYW5nZUxpc3RlbmVycykge1xuICAgICAgbGlzdGVuZXIoYmVnaW4sIGNodW5rKTtcbiAgICB9XG4gIH1cblxuICBvbkRhdGFQcm9ncmVzcyhsb2FkZWQsIHRvdGFsKSB7XG4gICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuX3Byb2dyZXNzTGlzdGVuZXJzKSB7XG4gICAgICAgIGxpc3RlbmVyKGxvYWRlZCwgdG90YWwpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgb25EYXRhUHJvZ3Jlc3NpdmVSZWFkKGNodW5rKSB7XG4gICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuX3Byb2dyZXNzaXZlUmVhZExpc3RlbmVycykge1xuICAgICAgICBsaXN0ZW5lcihjaHVuayk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBvbkRhdGFQcm9ncmVzc2l2ZURvbmUoKSB7XG4gICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuX3Byb2dyZXNzaXZlRG9uZUxpc3RlbmVycykge1xuICAgICAgICBsaXN0ZW5lcigpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdHJhbnNwb3J0UmVhZHkoKSB7XG4gICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgfVxuXG4gIHJlcXVlc3REYXRhUmFuZ2UoYmVnaW4sIGVuZCkge1xuICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJBYnN0cmFjdCBtZXRob2QgUERGRGF0YVJhbmdlVHJhbnNwb3J0LnJlcXVlc3REYXRhUmFuZ2VcIik7XG4gIH1cblxuICBhYm9ydCgpIHt9XG5cbn1cblxuZXhwb3J0cy5QREZEYXRhUmFuZ2VUcmFuc3BvcnQgPSBQREZEYXRhUmFuZ2VUcmFuc3BvcnQ7XG5cbmNsYXNzIFBERkRvY3VtZW50UHJveHkge1xuICBjb25zdHJ1Y3RvcihwZGZJbmZvLCB0cmFuc3BvcnQpIHtcbiAgICB0aGlzLl9wZGZJbmZvID0gcGRmSW5mbztcbiAgICB0aGlzLl90cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gIH1cblxuICBnZXQgYW5ub3RhdGlvblN0b3JhZ2UoKSB7XG4gICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwiYW5ub3RhdGlvblN0b3JhZ2VcIiwgbmV3IF9hbm5vdGF0aW9uX3N0b3JhZ2UuQW5ub3RhdGlvblN0b3JhZ2UoKSk7XG4gIH1cblxuICBnZXQgbnVtUGFnZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BkZkluZm8ubnVtUGFnZXM7XG4gIH1cblxuICBnZXQgZmluZ2VycHJpbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BkZkluZm8uZmluZ2VycHJpbnQ7XG4gIH1cblxuICBnZXRQYWdlKHBhZ2VOdW1iZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFBhZ2UocGFnZU51bWJlcik7XG4gIH1cblxuICBnZXRQYWdlSW5kZXgocmVmKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQYWdlSW5kZXgocmVmKTtcbiAgfVxuXG4gIGdldERlc3RpbmF0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldERlc3RpbmF0aW9ucygpO1xuICB9XG5cbiAgZ2V0RGVzdGluYXRpb24oaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldERlc3RpbmF0aW9uKGlkKTtcbiAgfVxuXG4gIGdldFBhZ2VMYWJlbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQYWdlTGFiZWxzKCk7XG4gIH1cblxuICBnZXRQYWdlTGF5b3V0KCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGFnZUxheW91dCgpO1xuICB9XG5cbiAgZ2V0UGFnZU1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQYWdlTW9kZSgpO1xuICB9XG5cbiAgZ2V0Vmlld2VyUHJlZmVyZW5jZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRWaWV3ZXJQcmVmZXJlbmNlcygpO1xuICB9XG5cbiAgZ2V0T3BlbkFjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldE9wZW5BY3Rpb24oKTtcbiAgfVxuXG4gIGdldEF0dGFjaG1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0QXR0YWNobWVudHMoKTtcbiAgfVxuXG4gIGdldEphdmFTY3JpcHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRKYXZhU2NyaXB0KCk7XG4gIH1cblxuICBnZXRPdXRsaW5lKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0T3V0bGluZSgpO1xuICB9XG5cbiAgZ2V0T3B0aW9uYWxDb250ZW50Q29uZmlnKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0T3B0aW9uYWxDb250ZW50Q29uZmlnKCk7XG4gIH1cblxuICBnZXRQZXJtaXNzaW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFBlcm1pc3Npb25zKCk7XG4gIH1cblxuICBnZXRNZXRhZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldE1ldGFkYXRhKCk7XG4gIH1cblxuICBnZXREYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0RGF0YSgpO1xuICB9XG5cbiAgZ2V0RG93bmxvYWRJbmZvKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZG93bmxvYWRJbmZvQ2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG5cbiAgZ2V0U3RhdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRTdGF0cygpO1xuICB9XG5cbiAgY2xlYW51cCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LnN0YXJ0Q2xlYW51cCgpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICByZXR1cm4gdGhpcy5sb2FkaW5nVGFzay5kZXN0cm95KCk7XG4gIH1cblxuICBnZXQgbG9hZGluZ1BhcmFtcygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmxvYWRpbmdQYXJhbXM7XG4gIH1cblxuICBnZXQgbG9hZGluZ1Rhc2soKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5sb2FkaW5nVGFzaztcbiAgfVxuXG4gIHNhdmVEb2N1bWVudChhbm5vdGF0aW9uU3RvcmFnZSkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuc2F2ZURvY3VtZW50KGFubm90YXRpb25TdG9yYWdlKTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuUERGRG9jdW1lbnRQcm94eSA9IFBERkRvY3VtZW50UHJveHk7XG5cbmNsYXNzIFBERlBhZ2VQcm94eSB7XG4gIGNvbnN0cnVjdG9yKHBhZ2VJbmRleCwgcGFnZUluZm8sIHRyYW5zcG9ydCwgb3duZXJEb2N1bWVudCwgcGRmQnVnID0gZmFsc2UpIHtcbiAgICB0aGlzLl9wYWdlSW5kZXggPSBwYWdlSW5kZXg7XG4gICAgdGhpcy5fcGFnZUluZm8gPSBwYWdlSW5mbztcbiAgICB0aGlzLl9vd25lckRvY3VtZW50ID0gb3duZXJEb2N1bWVudDtcbiAgICB0aGlzLl90cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgdGhpcy5fc3RhdHMgPSBwZGZCdWcgPyBuZXcgX2Rpc3BsYXlfdXRpbHMuU3RhdFRpbWVyKCkgOiBudWxsO1xuICAgIHRoaXMuX3BkZkJ1ZyA9IHBkZkJ1ZztcbiAgICB0aGlzLmNvbW1vbk9ianMgPSB0cmFuc3BvcnQuY29tbW9uT2JqcztcbiAgICB0aGlzLm9ianMgPSBuZXcgUERGT2JqZWN0cygpO1xuICAgIHRoaXMuY2xlYW51cEFmdGVyUmVuZGVyID0gZmFsc2U7XG4gICAgdGhpcy5wZW5kaW5nQ2xlYW51cCA9IGZhbHNlO1xuICAgIHRoaXMuX2ludGVudFN0YXRlcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICB9XG5cbiAgZ2V0IHBhZ2VOdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2VJbmRleCArIDE7XG4gIH1cblxuICBnZXQgcm90YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlSW5mby5yb3RhdGU7XG4gIH1cblxuICBnZXQgcmVmKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlSW5mby5yZWY7XG4gIH1cblxuICBnZXQgdXNlclVuaXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2VJbmZvLnVzZXJVbml0O1xuICB9XG5cbiAgZ2V0IHZpZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2VJbmZvLnZpZXc7XG4gIH1cblxuICBnZXRWaWV3cG9ydCh7XG4gICAgc2NhbGUsXG4gICAgcm90YXRpb24gPSB0aGlzLnJvdGF0ZSxcbiAgICBvZmZzZXRYID0gMCxcbiAgICBvZmZzZXRZID0gMCxcbiAgICBkb250RmxpcCA9IGZhbHNlXG4gIH0gPSB7fSkge1xuICAgIHJldHVybiBuZXcgX2Rpc3BsYXlfdXRpbHMuUGFnZVZpZXdwb3J0KHtcbiAgICAgIHZpZXdCb3g6IHRoaXMudmlldyxcbiAgICAgIHNjYWxlLFxuICAgICAgcm90YXRpb24sXG4gICAgICBvZmZzZXRYLFxuICAgICAgb2Zmc2V0WSxcbiAgICAgIGRvbnRGbGlwXG4gICAgfSk7XG4gIH1cblxuICBnZXRBbm5vdGF0aW9ucyh7XG4gICAgaW50ZW50ID0gbnVsbFxuICB9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuYW5ub3RhdGlvbnNQcm9taXNlIHx8IHRoaXMuYW5ub3RhdGlvbnNJbnRlbnQgIT09IGludGVudCkge1xuICAgICAgdGhpcy5hbm5vdGF0aW9uc1Byb21pc2UgPSB0aGlzLl90cmFuc3BvcnQuZ2V0QW5ub3RhdGlvbnModGhpcy5fcGFnZUluZGV4LCBpbnRlbnQpO1xuICAgICAgdGhpcy5hbm5vdGF0aW9uc0ludGVudCA9IGludGVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5hbm5vdGF0aW9uc1Byb21pc2U7XG4gIH1cblxuICByZW5kZXIoe1xuICAgIGNhbnZhc0NvbnRleHQsXG4gICAgdmlld3BvcnQsXG4gICAgaW50ZW50ID0gXCJkaXNwbGF5XCIsXG4gICAgZW5hYmxlV2ViR0wgPSBmYWxzZSxcbiAgICByZW5kZXJJbnRlcmFjdGl2ZUZvcm1zID0gZmFsc2UsXG4gICAgdHJhbnNmb3JtID0gbnVsbCxcbiAgICBpbWFnZUxheWVyID0gbnVsbCxcbiAgICBjYW52YXNGYWN0b3J5ID0gbnVsbCxcbiAgICBiYWNrZ3JvdW5kID0gbnVsbCxcbiAgICBhbm5vdGF0aW9uU3RvcmFnZSA9IG51bGwsXG4gICAgb3B0aW9uYWxDb250ZW50Q29uZmlnUHJvbWlzZSA9IG51bGxcbiAgfSkge1xuICAgIGlmICh0aGlzLl9zdGF0cykge1xuICAgICAgdGhpcy5fc3RhdHMudGltZShcIk92ZXJhbGxcIik7XG4gICAgfVxuXG4gICAgY29uc3QgcmVuZGVyaW5nSW50ZW50ID0gaW50ZW50ID09PSBcInByaW50XCIgPyBcInByaW50XCIgOiBcImRpc3BsYXlcIjtcbiAgICB0aGlzLnBlbmRpbmdDbGVhbnVwID0gZmFsc2U7XG5cbiAgICBpZiAoIW9wdGlvbmFsQ29udGVudENvbmZpZ1Byb21pc2UpIHtcbiAgICAgIG9wdGlvbmFsQ29udGVudENvbmZpZ1Byb21pc2UgPSB0aGlzLl90cmFuc3BvcnQuZ2V0T3B0aW9uYWxDb250ZW50Q29uZmlnKCk7XG4gICAgfVxuXG4gICAgbGV0IGludGVudFN0YXRlID0gdGhpcy5faW50ZW50U3RhdGVzLmdldChyZW5kZXJpbmdJbnRlbnQpO1xuXG4gICAgaWYgKCFpbnRlbnRTdGF0ZSkge1xuICAgICAgaW50ZW50U3RhdGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICB0aGlzLl9pbnRlbnRTdGF0ZXMuc2V0KHJlbmRlcmluZ0ludGVudCwgaW50ZW50U3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQoaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCk7XG4gICAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBjYW52YXNGYWN0b3J5SW5zdGFuY2UgPSBjYW52YXNGYWN0b3J5IHx8IG5ldyBEZWZhdWx0Q2FudmFzRmFjdG9yeSh7XG4gICAgICBvd25lckRvY3VtZW50OiB0aGlzLl9vd25lckRvY3VtZW50XG4gICAgfSk7XG4gICAgY29uc3Qgd2ViR0xDb250ZXh0ID0gbmV3IF93ZWJnbC5XZWJHTENvbnRleHQoe1xuICAgICAgZW5hYmxlOiBlbmFibGVXZWJHTFxuICAgIH0pO1xuXG4gICAgaWYgKCFpbnRlbnRTdGF0ZS5kaXNwbGF5UmVhZHlDYXBhYmlsaXR5KSB7XG4gICAgICBpbnRlbnRTdGF0ZS5kaXNwbGF5UmVhZHlDYXBhYmlsaXR5ID0gKDAsIF91dGlsLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KSgpO1xuICAgICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0ID0ge1xuICAgICAgICBmbkFycmF5OiBbXSxcbiAgICAgICAgYXJnc0FycmF5OiBbXSxcbiAgICAgICAgbGFzdENodW5rOiBmYWxzZVxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMuX3N0YXRzKSB7XG4gICAgICAgIHRoaXMuX3N0YXRzLnRpbWUoXCJQYWdlIFJlcXVlc3RcIik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3B1bXBPcGVyYXRvckxpc3Qoe1xuICAgICAgICBwYWdlSW5kZXg6IHRoaXMuX3BhZ2VJbmRleCxcbiAgICAgICAgaW50ZW50OiByZW5kZXJpbmdJbnRlbnQsXG4gICAgICAgIHJlbmRlckludGVyYWN0aXZlRm9ybXM6IHJlbmRlckludGVyYWN0aXZlRm9ybXMgPT09IHRydWUsXG4gICAgICAgIGFubm90YXRpb25TdG9yYWdlOiBhbm5vdGF0aW9uU3RvcmFnZSAmJiBhbm5vdGF0aW9uU3RvcmFnZS5nZXRBbGwoKSB8fCBudWxsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBjb21wbGV0ZSA9IGVycm9yID0+IHtcbiAgICAgIGNvbnN0IGkgPSBpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcy5pbmRleE9mKGludGVybmFsUmVuZGVyVGFzayk7XG5cbiAgICAgIGlmIChpID49IDApIHtcbiAgICAgICAgaW50ZW50U3RhdGUucmVuZGVyVGFza3Muc3BsaWNlKGksIDEpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jbGVhbnVwQWZ0ZXJSZW5kZXIgfHwgcmVuZGVyaW5nSW50ZW50ID09PSBcInByaW50XCIpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nQ2xlYW51cCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3RyeUNsZWFudXAoKTtcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGludGVybmFsUmVuZGVyVGFzay5jYXBhYmlsaXR5LnJlamVjdChlcnJvcik7XG5cbiAgICAgICAgdGhpcy5fYWJvcnRPcGVyYXRvckxpc3Qoe1xuICAgICAgICAgIGludGVudFN0YXRlLFxuICAgICAgICAgIHJlYXNvbjogZXJyb3JcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnRlcm5hbFJlbmRlclRhc2suY2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9zdGF0cykge1xuICAgICAgICB0aGlzLl9zdGF0cy50aW1lRW5kKFwiUmVuZGVyaW5nXCIpO1xuXG4gICAgICAgIHRoaXMuX3N0YXRzLnRpbWVFbmQoXCJPdmVyYWxsXCIpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBpbnRlcm5hbFJlbmRlclRhc2sgPSBuZXcgSW50ZXJuYWxSZW5kZXJUYXNrKHtcbiAgICAgIGNhbGxiYWNrOiBjb21wbGV0ZSxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBjYW52YXNDb250ZXh0LFxuICAgICAgICB2aWV3cG9ydCxcbiAgICAgICAgdHJhbnNmb3JtLFxuICAgICAgICBpbWFnZUxheWVyLFxuICAgICAgICBiYWNrZ3JvdW5kXG4gICAgICB9LFxuICAgICAgb2JqczogdGhpcy5vYmpzLFxuICAgICAgY29tbW9uT2JqczogdGhpcy5jb21tb25PYmpzLFxuICAgICAgb3BlcmF0b3JMaXN0OiBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QsXG4gICAgICBwYWdlSW5kZXg6IHRoaXMuX3BhZ2VJbmRleCxcbiAgICAgIGNhbnZhc0ZhY3Rvcnk6IGNhbnZhc0ZhY3RvcnlJbnN0YW5jZSxcbiAgICAgIHdlYkdMQ29udGV4dCxcbiAgICAgIHVzZVJlcXVlc3RBbmltYXRpb25GcmFtZTogcmVuZGVyaW5nSW50ZW50ICE9PSBcInByaW50XCIsXG4gICAgICBwZGZCdWc6IHRoaXMuX3BkZkJ1Z1xuICAgIH0pO1xuXG4gICAgaWYgKCFpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcykge1xuICAgICAgaW50ZW50U3RhdGUucmVuZGVyVGFza3MgPSBbXTtcbiAgICB9XG5cbiAgICBpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcy5wdXNoKGludGVybmFsUmVuZGVyVGFzayk7XG4gICAgY29uc3QgcmVuZGVyVGFzayA9IGludGVybmFsUmVuZGVyVGFzay50YXNrO1xuICAgIFByb21pc2UuYWxsKFtpbnRlbnRTdGF0ZS5kaXNwbGF5UmVhZHlDYXBhYmlsaXR5LnByb21pc2UsIG9wdGlvbmFsQ29udGVudENvbmZpZ1Byb21pc2VdKS50aGVuKChbdHJhbnNwYXJlbmN5LCBvcHRpb25hbENvbnRlbnRDb25maWddKSA9PiB7XG4gICAgICBpZiAodGhpcy5wZW5kaW5nQ2xlYW51cCkge1xuICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9zdGF0cykge1xuICAgICAgICB0aGlzLl9zdGF0cy50aW1lKFwiUmVuZGVyaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpbnRlcm5hbFJlbmRlclRhc2suaW5pdGlhbGl6ZUdyYXBoaWNzKHtcbiAgICAgICAgdHJhbnNwYXJlbmN5LFxuICAgICAgICBvcHRpb25hbENvbnRlbnRDb25maWdcbiAgICAgIH0pO1xuICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLm9wZXJhdG9yTGlzdENoYW5nZWQoKTtcbiAgICB9KS5jYXRjaChjb21wbGV0ZSk7XG4gICAgcmV0dXJuIHJlbmRlclRhc2s7XG4gIH1cblxuICBnZXRPcGVyYXRvckxpc3QoKSB7XG4gICAgZnVuY3Rpb24gb3BlcmF0b3JMaXN0Q2hhbmdlZCgpIHtcbiAgICAgIGlmIChpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QubGFzdENodW5rKSB7XG4gICAgICAgIGludGVudFN0YXRlLm9wTGlzdFJlYWRDYXBhYmlsaXR5LnJlc29sdmUoaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0KTtcbiAgICAgICAgY29uc3QgaSA9IGludGVudFN0YXRlLnJlbmRlclRhc2tzLmluZGV4T2Yob3BMaXN0VGFzayk7XG5cbiAgICAgICAgaWYgKGkgPj0gMCkge1xuICAgICAgICAgIGludGVudFN0YXRlLnJlbmRlclRhc2tzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHJlbmRlcmluZ0ludGVudCA9IFwib3BsaXN0XCI7XG5cbiAgICBsZXQgaW50ZW50U3RhdGUgPSB0aGlzLl9pbnRlbnRTdGF0ZXMuZ2V0KHJlbmRlcmluZ0ludGVudCk7XG5cbiAgICBpZiAoIWludGVudFN0YXRlKSB7XG4gICAgICBpbnRlbnRTdGF0ZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgIHRoaXMuX2ludGVudFN0YXRlcy5zZXQocmVuZGVyaW5nSW50ZW50LCBpbnRlbnRTdGF0ZSk7XG4gICAgfVxuXG4gICAgbGV0IG9wTGlzdFRhc2s7XG5cbiAgICBpZiAoIWludGVudFN0YXRlLm9wTGlzdFJlYWRDYXBhYmlsaXR5KSB7XG4gICAgICBvcExpc3RUYXNrID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIG9wTGlzdFRhc2sub3BlcmF0b3JMaXN0Q2hhbmdlZCA9IG9wZXJhdG9yTGlzdENoYW5nZWQ7XG4gICAgICBpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eSA9ICgwLCBfdXRpbC5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSkoKTtcbiAgICAgIGludGVudFN0YXRlLnJlbmRlclRhc2tzID0gW107XG4gICAgICBpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcy5wdXNoKG9wTGlzdFRhc2spO1xuICAgICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0ID0ge1xuICAgICAgICBmbkFycmF5OiBbXSxcbiAgICAgICAgYXJnc0FycmF5OiBbXSxcbiAgICAgICAgbGFzdENodW5rOiBmYWxzZVxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMuX3N0YXRzKSB7XG4gICAgICAgIHRoaXMuX3N0YXRzLnRpbWUoXCJQYWdlIFJlcXVlc3RcIik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3B1bXBPcGVyYXRvckxpc3Qoe1xuICAgICAgICBwYWdlSW5kZXg6IHRoaXMuX3BhZ2VJbmRleCxcbiAgICAgICAgaW50ZW50OiByZW5kZXJpbmdJbnRlbnRcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG5cbiAgc3RyZWFtVGV4dENvbnRlbnQoe1xuICAgIG5vcm1hbGl6ZVdoaXRlc3BhY2UgPSBmYWxzZSxcbiAgICBkaXNhYmxlQ29tYmluZVRleHRJdGVtcyA9IGZhbHNlXG4gIH0gPSB7fSkge1xuICAgIGNvbnN0IFRFWFRfQ09OVEVOVF9DSFVOS19TSVpFID0gMTAwO1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhTdHJlYW0oXCJHZXRUZXh0Q29udGVudFwiLCB7XG4gICAgICBwYWdlSW5kZXg6IHRoaXMuX3BhZ2VJbmRleCxcbiAgICAgIG5vcm1hbGl6ZVdoaXRlc3BhY2U6IG5vcm1hbGl6ZVdoaXRlc3BhY2UgPT09IHRydWUsXG4gICAgICBjb21iaW5lVGV4dEl0ZW1zOiBkaXNhYmxlQ29tYmluZVRleHRJdGVtcyAhPT0gdHJ1ZVxuICAgIH0sIHtcbiAgICAgIGhpZ2hXYXRlck1hcms6IFRFWFRfQ09OVEVOVF9DSFVOS19TSVpFLFxuXG4gICAgICBzaXplKHRleHRDb250ZW50KSB7XG4gICAgICAgIHJldHVybiB0ZXh0Q29udGVudC5pdGVtcy5sZW5ndGg7XG4gICAgICB9XG5cbiAgICB9KTtcbiAgfVxuXG4gIGdldFRleHRDb250ZW50KHBhcmFtcyA9IHt9KSB7XG4gICAgY29uc3QgcmVhZGFibGVTdHJlYW0gPSB0aGlzLnN0cmVhbVRleHRDb250ZW50KHBhcmFtcyk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGZ1bmN0aW9uIHB1bXAoKSB7XG4gICAgICAgIHJlYWRlci5yZWFkKCkudGhlbihmdW5jdGlvbiAoe1xuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGRvbmVcbiAgICAgICAgfSkge1xuICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICByZXNvbHZlKHRleHRDb250ZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBPYmplY3QuYXNzaWduKHRleHRDb250ZW50LnN0eWxlcywgdmFsdWUuc3R5bGVzKTtcbiAgICAgICAgICB0ZXh0Q29udGVudC5pdGVtcy5wdXNoKC4uLnZhbHVlLml0ZW1zKTtcbiAgICAgICAgICBwdW1wKCk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlYWRlciA9IHJlYWRhYmxlU3RyZWFtLmdldFJlYWRlcigpO1xuICAgICAgY29uc3QgdGV4dENvbnRlbnQgPSB7XG4gICAgICAgIGl0ZW1zOiBbXSxcbiAgICAgICAgc3R5bGVzOiBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgICB9O1xuICAgICAgcHVtcCgpO1xuICAgIH0pO1xuICB9XG5cbiAgX2Rlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIHRoaXMuX3RyYW5zcG9ydC5wYWdlQ2FjaGVbdGhpcy5fcGFnZUluZGV4XSA9IG51bGw7XG4gICAgY29uc3Qgd2FpdE9uID0gW107XG5cbiAgICBmb3IgKGNvbnN0IFtpbnRlbnQsIGludGVudFN0YXRlXSBvZiB0aGlzLl9pbnRlbnRTdGF0ZXMpIHtcbiAgICAgIHRoaXMuX2Fib3J0T3BlcmF0b3JMaXN0KHtcbiAgICAgICAgaW50ZW50U3RhdGUsXG4gICAgICAgIHJlYXNvbjogbmV3IEVycm9yKFwiUGFnZSB3YXMgZGVzdHJveWVkLlwiKSxcbiAgICAgICAgZm9yY2U6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaW50ZW50ID09PSBcIm9wbGlzdFwiKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGludGVybmFsUmVuZGVyVGFzayBvZiBpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcykge1xuICAgICAgICB3YWl0T24ucHVzaChpbnRlcm5hbFJlbmRlclRhc2suY29tcGxldGVkKTtcbiAgICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLmNhbmNlbCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMub2Jqcy5jbGVhcigpO1xuICAgIHRoaXMuYW5ub3RhdGlvbnNQcm9taXNlID0gbnVsbDtcbiAgICB0aGlzLnBlbmRpbmdDbGVhbnVwID0gZmFsc2U7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHdhaXRPbik7XG4gIH1cblxuICBjbGVhbnVwKHJlc2V0U3RhdHMgPSBmYWxzZSkge1xuICAgIHRoaXMucGVuZGluZ0NsZWFudXAgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzLl90cnlDbGVhbnVwKHJlc2V0U3RhdHMpO1xuICB9XG5cbiAgX3RyeUNsZWFudXAocmVzZXRTdGF0cyA9IGZhbHNlKSB7XG4gICAgaWYgKCF0aGlzLnBlbmRpbmdDbGVhbnVwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCB7XG4gICAgICByZW5kZXJUYXNrcyxcbiAgICAgIG9wZXJhdG9yTGlzdFxuICAgIH0gb2YgdGhpcy5faW50ZW50U3RhdGVzLnZhbHVlcygpKSB7XG4gICAgICBpZiAocmVuZGVyVGFza3MubGVuZ3RoICE9PSAwIHx8ICFvcGVyYXRvckxpc3QubGFzdENodW5rKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9pbnRlbnRTdGF0ZXMuY2xlYXIoKTtcblxuICAgIHRoaXMub2Jqcy5jbGVhcigpO1xuICAgIHRoaXMuYW5ub3RhdGlvbnNQcm9taXNlID0gbnVsbDtcblxuICAgIGlmIChyZXNldFN0YXRzICYmIHRoaXMuX3N0YXRzKSB7XG4gICAgICB0aGlzLl9zdGF0cyA9IG5ldyBfZGlzcGxheV91dGlscy5TdGF0VGltZXIoKTtcbiAgICB9XG5cbiAgICB0aGlzLnBlbmRpbmdDbGVhbnVwID0gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBfc3RhcnRSZW5kZXJQYWdlKHRyYW5zcGFyZW5jeSwgaW50ZW50KSB7XG4gICAgY29uc3QgaW50ZW50U3RhdGUgPSB0aGlzLl9pbnRlbnRTdGF0ZXMuZ2V0KGludGVudCk7XG5cbiAgICBpZiAoIWludGVudFN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3N0YXRzKSB7XG4gICAgICB0aGlzLl9zdGF0cy50aW1lRW5kKFwiUGFnZSBSZXF1ZXN0XCIpO1xuICAgIH1cblxuICAgIGlmIChpbnRlbnRTdGF0ZS5kaXNwbGF5UmVhZHlDYXBhYmlsaXR5KSB7XG4gICAgICBpbnRlbnRTdGF0ZS5kaXNwbGF5UmVhZHlDYXBhYmlsaXR5LnJlc29sdmUodHJhbnNwYXJlbmN5KTtcbiAgICB9XG4gIH1cblxuICBfcmVuZGVyUGFnZUNodW5rKG9wZXJhdG9yTGlzdENodW5rLCBpbnRlbnRTdGF0ZSkge1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IG9wZXJhdG9yTGlzdENodW5rLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdC5mbkFycmF5LnB1c2gob3BlcmF0b3JMaXN0Q2h1bmsuZm5BcnJheVtpXSk7XG4gICAgICBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QuYXJnc0FycmF5LnB1c2gob3BlcmF0b3JMaXN0Q2h1bmsuYXJnc0FycmF5W2ldKTtcbiAgICB9XG5cbiAgICBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QubGFzdENodW5rID0gb3BlcmF0b3JMaXN0Q2h1bmsubGFzdENodW5rO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgaW50ZW50U3RhdGUucmVuZGVyVGFza3NbaV0ub3BlcmF0b3JMaXN0Q2hhbmdlZCgpO1xuICAgIH1cblxuICAgIGlmIChvcGVyYXRvckxpc3RDaHVuay5sYXN0Q2h1bmspIHtcbiAgICAgIHRoaXMuX3RyeUNsZWFudXAoKTtcbiAgICB9XG4gIH1cblxuICBfcHVtcE9wZXJhdG9yTGlzdChhcmdzKSB7XG4gICAgKDAsIF91dGlsLmFzc2VydCkoYXJncy5pbnRlbnQsICdQREZQYWdlUHJveHkuX3B1bXBPcGVyYXRvckxpc3Q6IEV4cGVjdGVkIFwiaW50ZW50XCIgYXJndW1lbnQuJyk7XG5cbiAgICBjb25zdCByZWFkYWJsZVN0cmVhbSA9IHRoaXMuX3RyYW5zcG9ydC5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFN0cmVhbShcIkdldE9wZXJhdG9yTGlzdFwiLCBhcmdzKTtcblxuICAgIGNvbnN0IHJlYWRlciA9IHJlYWRhYmxlU3RyZWFtLmdldFJlYWRlcigpO1xuXG4gICAgY29uc3QgaW50ZW50U3RhdGUgPSB0aGlzLl9pbnRlbnRTdGF0ZXMuZ2V0KGFyZ3MuaW50ZW50KTtcblxuICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlciA9IHJlYWRlcjtcblxuICAgIGNvbnN0IHB1bXAgPSAoKSA9PiB7XG4gICAgICByZWFkZXIucmVhZCgpLnRoZW4oKHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGRvbmVcbiAgICAgIH0pID0+IHtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXIgPSBudWxsO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl90cmFuc3BvcnQuZGVzdHJveWVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcmVuZGVyUGFnZUNodW5rKHZhbHVlLCBpbnRlbnRTdGF0ZSk7XG5cbiAgICAgICAgcHVtcCgpO1xuICAgICAgfSwgcmVhc29uID0+IHtcbiAgICAgICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyID0gbnVsbDtcblxuICAgICAgICBpZiAodGhpcy5fdHJhbnNwb3J0LmRlc3Ryb3llZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QpIHtcbiAgICAgICAgICBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QubGFzdENodW5rID0gdHJ1ZTtcblxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW50ZW50U3RhdGUucmVuZGVyVGFza3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGludGVudFN0YXRlLnJlbmRlclRhc2tzW2ldLm9wZXJhdG9yTGlzdENoYW5nZWQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl90cnlDbGVhbnVwKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW50ZW50U3RhdGUuZGlzcGxheVJlYWR5Q2FwYWJpbGl0eSkge1xuICAgICAgICAgIGludGVudFN0YXRlLmRpc3BsYXlSZWFkeUNhcGFiaWxpdHkucmVqZWN0KHJlYXNvbik7XG4gICAgICAgIH0gZWxzZSBpZiAoaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkpIHtcbiAgICAgICAgICBpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eS5yZWplY3QocmVhc29uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyByZWFzb247XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBwdW1wKCk7XG4gIH1cblxuICBfYWJvcnRPcGVyYXRvckxpc3Qoe1xuICAgIGludGVudFN0YXRlLFxuICAgIHJlYXNvbixcbiAgICBmb3JjZSA9IGZhbHNlXG4gIH0pIHtcbiAgICAoMCwgX3V0aWwuYXNzZXJ0KShyZWFzb24gaW5zdGFuY2VvZiBFcnJvciB8fCB0eXBlb2YgcmVhc29uID09PSBcIm9iamVjdFwiICYmIHJlYXNvbiAhPT0gbnVsbCwgJ1BERlBhZ2VQcm94eS5fYWJvcnRPcGVyYXRvckxpc3Q6IEV4cGVjdGVkIFwicmVhc29uXCIgYXJndW1lbnQuJyk7XG5cbiAgICBpZiAoIWludGVudFN0YXRlLnN0cmVhbVJlYWRlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghZm9yY2UpIHtcbiAgICAgIGlmIChpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVhc29uIGluc3RhbmNlb2YgX2Rpc3BsYXlfdXRpbHMuUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uKSB7XG4gICAgICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlckNhbmNlbFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLl9hYm9ydE9wZXJhdG9yTGlzdCh7XG4gICAgICAgICAgICBpbnRlbnRTdGF0ZSxcbiAgICAgICAgICAgIHJlYXNvbixcbiAgICAgICAgICAgIGZvcmNlOiB0cnVlXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfSwgUkVOREVSSU5HX0NBTkNFTExFRF9USU1FT1VUKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlci5jYW5jZWwobmV3IF91dGlsLkFib3J0RXhjZXB0aW9uKHJlYXNvbiAmJiByZWFzb24ubWVzc2FnZSkpO1xuICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlciA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5fdHJhbnNwb3J0LmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgW2ludGVudCwgY3VySW50ZW50U3RhdGVdIG9mIHRoaXMuX2ludGVudFN0YXRlcykge1xuICAgICAgaWYgKGN1ckludGVudFN0YXRlID09PSBpbnRlbnRTdGF0ZSkge1xuICAgICAgICB0aGlzLl9pbnRlbnRTdGF0ZXMuZGVsZXRlKGludGVudCk7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jbGVhbnVwKCk7XG4gIH1cblxuICBnZXQgc3RhdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRzO1xuICB9XG5cbn1cblxuZXhwb3J0cy5QREZQYWdlUHJveHkgPSBQREZQYWdlUHJveHk7XG5cbmNsYXNzIExvb3BiYWNrUG9ydCB7XG4gIGNvbnN0cnVjdG9yKGRlZmVyID0gdHJ1ZSkge1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMuX2RlZmVyID0gZGVmZXI7XG4gICAgdGhpcy5fZGVmZXJyZWQgPSBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgfVxuXG4gIHBvc3RNZXNzYWdlKG9iaiwgdHJhbnNmZXJzKSB7XG4gICAgZnVuY3Rpb24gY2xvbmVWYWx1ZSh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjbG9uZWQuaGFzKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gY2xvbmVkLmdldCh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGxldCBidWZmZXIsIHJlc3VsdDtcblxuICAgICAgaWYgKChidWZmZXIgPSB2YWx1ZS5idWZmZXIpICYmICgwLCBfdXRpbC5pc0FycmF5QnVmZmVyKShidWZmZXIpKSB7XG4gICAgICAgIGNvbnN0IHRyYW5zZmVyYWJsZSA9IHRyYW5zZmVycyAmJiB0cmFuc2ZlcnMuaW5jbHVkZXMoYnVmZmVyKTtcblxuICAgICAgICBpZiAodHJhbnNmZXJhYmxlKSB7XG4gICAgICAgICAgcmVzdWx0ID0gbmV3IHZhbHVlLmNvbnN0cnVjdG9yKGJ1ZmZlciwgdmFsdWUuYnl0ZU9mZnNldCwgdmFsdWUuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ID0gbmV3IHZhbHVlLmNvbnN0cnVjdG9yKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNsb25lZC5zZXQodmFsdWUsIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdCA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gW10gOiB7fTtcbiAgICAgIGNsb25lZC5zZXQodmFsdWUsIHJlc3VsdCk7XG5cbiAgICAgIGZvciAoY29uc3QgaSBpbiB2YWx1ZSkge1xuICAgICAgICBsZXQgZGVzYyxcbiAgICAgICAgICAgIHAgPSB2YWx1ZTtcblxuICAgICAgICB3aGlsZSAoIShkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwLCBpKSkpIHtcbiAgICAgICAgICBwID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkZXNjLnZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGRlc2MudmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eSAmJiB2YWx1ZS5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMb29wYmFja1BvcnQucG9zdE1lc3NhZ2UgLSBjYW5ub3QgY2xvbmU6ICR7dmFsdWVbaV19YCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHRbaV0gPSBjbG9uZVZhbHVlKGRlc2MudmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fZGVmZXIpIHtcbiAgICAgIHRoaXMuX2xpc3RlbmVycy5mb3JFYWNoKGxpc3RlbmVyID0+IHtcbiAgICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCB7XG4gICAgICAgICAgZGF0YTogb2JqXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjbG9uZWQgPSBuZXcgV2Vha01hcCgpO1xuICAgIGNvbnN0IGUgPSB7XG4gICAgICBkYXRhOiBjbG9uZVZhbHVlKG9iailcbiAgICB9O1xuXG4gICAgdGhpcy5fZGVmZXJyZWQudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLl9saXN0ZW5lcnMuZm9yRWFjaChsaXN0ZW5lciA9PiB7XG4gICAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGFkZEV2ZW50TGlzdGVuZXIobmFtZSwgbGlzdGVuZXIpIHtcbiAgICB0aGlzLl9saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gIH1cblxuICByZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGxpc3RlbmVyKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuX2xpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcblxuICAgIHRoaXMuX2xpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gIH1cblxuICB0ZXJtaW5hdGUoKSB7XG4gICAgdGhpcy5fbGlzdGVuZXJzLmxlbmd0aCA9IDA7XG4gIH1cblxufVxuXG5leHBvcnRzLkxvb3BiYWNrUG9ydCA9IExvb3BiYWNrUG9ydDtcblxuY29uc3QgUERGV29ya2VyID0gZnVuY3Rpb24gUERGV29ya2VyQ2xvc3VyZSgpIHtcbiAgY29uc3QgcGRmV29ya2VyUG9ydHMgPSBuZXcgV2Vha01hcCgpO1xuICBsZXQgaXNXb3JrZXJEaXNhYmxlZCA9IGZhbHNlO1xuICBsZXQgZmFsbGJhY2tXb3JrZXJTcmM7XG4gIGxldCBuZXh0RmFrZVdvcmtlcklkID0gMDtcbiAgbGV0IGZha2VXb3JrZXJDYXBhYmlsaXR5O1xuXG4gIGlmIChfaXNfbm9kZS5pc05vZGVKUyAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgaXNXb3JrZXJEaXNhYmxlZCA9IHRydWU7XG4gICAgZmFsbGJhY2tXb3JrZXJTcmMgPSBcIi4vcGRmLndvcmtlci5qc1wiO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJvYmplY3RcIiAmJiBcImN1cnJlbnRTY3JpcHRcIiBpbiBkb2N1bWVudCkge1xuICAgIGNvbnN0IHBkZmpzRmlsZVBhdGggPSBkb2N1bWVudC5jdXJyZW50U2NyaXB0ICYmIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjO1xuXG4gICAgaWYgKHBkZmpzRmlsZVBhdGgpIHtcbiAgICAgIGZhbGxiYWNrV29ya2VyU3JjID0gcGRmanNGaWxlUGF0aC5yZXBsYWNlKC8oXFwuKD86bWluXFwuKT9qcykoXFw/LiopPyQvaSwgXCIud29ya2VyJDEkMlwiKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRXb3JrZXJTcmMoKSB7XG4gICAgaWYgKF93b3JrZXJfb3B0aW9ucy5HbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclNyYykge1xuICAgICAgcmV0dXJuIF93b3JrZXJfb3B0aW9ucy5HbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclNyYztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZhbGxiYWNrV29ya2VyU3JjICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBpZiAoIV9pc19ub2RlLmlzTm9kZUpTKSB7XG4gICAgICAgICgwLCBfZGlzcGxheV91dGlscy5kZXByZWNhdGVkKSgnTm8gXCJHbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclNyY1wiIHNwZWNpZmllZC4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbGxiYWNrV29ya2VyU3JjO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcignTm8gXCJHbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclNyY1wiIHNwZWNpZmllZC4nKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE1haW5UaHJlYWRXb3JrZXJNZXNzYWdlSGFuZGxlcigpIHtcbiAgICBsZXQgbWFpbldvcmtlck1lc3NhZ2VIYW5kbGVyO1xuXG4gICAgdHJ5IHtcbiAgICAgIG1haW5Xb3JrZXJNZXNzYWdlSGFuZGxlciA9IGdsb2JhbFRoaXMucGRmanNXb3JrZXIgJiYgZ2xvYmFsVGhpcy5wZGZqc1dvcmtlci5Xb3JrZXJNZXNzYWdlSGFuZGxlcjtcbiAgICB9IGNhdGNoIChleCkge31cblxuICAgIHJldHVybiBtYWluV29ya2VyTWVzc2FnZUhhbmRsZXIgfHwgbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldHVwRmFrZVdvcmtlckdsb2JhbCgpIHtcbiAgICBpZiAoZmFrZVdvcmtlckNhcGFiaWxpdHkpIHtcbiAgICAgIHJldHVybiBmYWtlV29ya2VyQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIH1cblxuICAgIGZha2VXb3JrZXJDYXBhYmlsaXR5ID0gKDAsIF91dGlsLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KSgpO1xuXG4gICAgY29uc3QgbG9hZGVyID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgbWFpbldvcmtlck1lc3NhZ2VIYW5kbGVyID0gZ2V0TWFpblRocmVhZFdvcmtlck1lc3NhZ2VIYW5kbGVyKCk7XG5cbiAgICAgIGlmIChtYWluV29ya2VyTWVzc2FnZUhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIG1haW5Xb3JrZXJNZXNzYWdlSGFuZGxlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKF9pc19ub2RlLmlzTm9kZUpTICYmIHR5cGVvZiByZXF1aXJlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3Qgd29ya2VyID0gZXZhbChcInJlcXVpcmVcIikoZ2V0V29ya2VyU3JjKCkpO1xuICAgICAgICByZXR1cm4gd29ya2VyLldvcmtlck1lc3NhZ2VIYW5kbGVyO1xuICAgICAgfVxuXG4gICAgICBhd2FpdCAoMCwgX2Rpc3BsYXlfdXRpbHMubG9hZFNjcmlwdCkoZ2V0V29ya2VyU3JjKCkpO1xuICAgICAgcmV0dXJuIHdpbmRvdy5wZGZqc1dvcmtlci5Xb3JrZXJNZXNzYWdlSGFuZGxlcjtcbiAgICB9O1xuXG4gICAgbG9hZGVyKCkudGhlbihmYWtlV29ya2VyQ2FwYWJpbGl0eS5yZXNvbHZlLCBmYWtlV29ya2VyQ2FwYWJpbGl0eS5yZWplY3QpO1xuICAgIHJldHVybiBmYWtlV29ya2VyQ2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ0ROV3JhcHBlcih1cmwpIHtcbiAgICBjb25zdCB3cmFwcGVyID0gXCJpbXBvcnRTY3JpcHRzKCdcIiArIHVybCArIFwiJyk7XCI7XG4gICAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW3dyYXBwZXJdKSk7XG4gIH1cblxuICBjbGFzcyBQREZXb3JrZXIge1xuICAgIGNvbnN0cnVjdG9yKHtcbiAgICAgIG5hbWUgPSBudWxsLFxuICAgICAgcG9ydCA9IG51bGwsXG4gICAgICB2ZXJib3NpdHkgPSAoMCwgX3V0aWwuZ2V0VmVyYm9zaXR5TGV2ZWwpKClcbiAgICB9ID0ge30pIHtcbiAgICAgIGlmIChwb3J0ICYmIHBkZldvcmtlclBvcnRzLmhhcyhwb3J0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdXNlIG1vcmUgdGhhbiBvbmUgUERGV29ya2VyIHBlciBwb3J0XCIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMucG9zdE1lc3NhZ2VUcmFuc2ZlcnMgPSB0cnVlO1xuICAgICAgdGhpcy52ZXJib3NpdHkgPSB2ZXJib3NpdHk7XG4gICAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkgPSAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCk7XG4gICAgICB0aGlzLl9wb3J0ID0gbnVsbDtcbiAgICAgIHRoaXMuX3dlYldvcmtlciA9IG51bGw7XG4gICAgICB0aGlzLl9tZXNzYWdlSGFuZGxlciA9IG51bGw7XG5cbiAgICAgIGlmIChwb3J0KSB7XG4gICAgICAgIHBkZldvcmtlclBvcnRzLnNldChwb3J0LCB0aGlzKTtcblxuICAgICAgICB0aGlzLl9pbml0aWFsaXplRnJvbVBvcnQocG9ydCk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pbml0aWFsaXplKCk7XG4gICAgfVxuXG4gICAgZ2V0IHByb21pc2UoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgfVxuXG4gICAgZ2V0IHBvcnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcG9ydDtcbiAgICB9XG5cbiAgICBnZXQgbWVzc2FnZUhhbmRsZXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWVzc2FnZUhhbmRsZXI7XG4gICAgfVxuXG4gICAgX2luaXRpYWxpemVGcm9tUG9ydChwb3J0KSB7XG4gICAgICB0aGlzLl9wb3J0ID0gcG9ydDtcbiAgICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyID0gbmV3IF9tZXNzYWdlX2hhbmRsZXIuTWVzc2FnZUhhbmRsZXIoXCJtYWluXCIsIFwid29ya2VyXCIsIHBvcnQpO1xuXG4gICAgICB0aGlzLl9tZXNzYWdlSGFuZGxlci5vbihcInJlYWR5XCIsIGZ1bmN0aW9uICgpIHt9KTtcblxuICAgICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB9XG5cbiAgICBfaW5pdGlhbGl6ZSgpIHtcbiAgICAgIGlmICh0eXBlb2YgV29ya2VyICE9PSBcInVuZGVmaW5lZFwiICYmICFpc1dvcmtlckRpc2FibGVkICYmICFnZXRNYWluVGhyZWFkV29ya2VyTWVzc2FnZUhhbmRsZXIoKSkge1xuICAgICAgICBsZXQgd29ya2VyU3JjID0gZ2V0V29ya2VyU3JjKCk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoISgwLCBfdXRpbC5pc1NhbWVPcmlnaW4pKHdpbmRvdy5sb2NhdGlvbi5ocmVmLCB3b3JrZXJTcmMpKSB7XG4gICAgICAgICAgICB3b3JrZXJTcmMgPSBjcmVhdGVDRE5XcmFwcGVyKG5ldyBVUkwod29ya2VyU3JjLCB3aW5kb3cubG9jYXRpb24pLmhyZWYpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyU3JjKTtcbiAgICAgICAgICBjb25zdCBtZXNzYWdlSGFuZGxlciA9IG5ldyBfbWVzc2FnZV9oYW5kbGVyLk1lc3NhZ2VIYW5kbGVyKFwibWFpblwiLCBcIndvcmtlclwiLCB3b3JrZXIpO1xuXG4gICAgICAgICAgY29uc3QgdGVybWluYXRlRWFybHkgPSAoKSA9PiB7XG4gICAgICAgICAgICB3b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uV29ya2VyRXJyb3IpO1xuICAgICAgICAgICAgbWVzc2FnZUhhbmRsZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgd29ya2VyLnRlcm1pbmF0ZSgpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnJlamVjdChuZXcgRXJyb3IoXCJXb3JrZXIgd2FzIGRlc3Ryb3llZFwiKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9zZXR1cEZha2VXb3JrZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY29uc3Qgb25Xb3JrZXJFcnJvciA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fd2ViV29ya2VyKSB7XG4gICAgICAgICAgICAgIHRlcm1pbmF0ZUVhcmx5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25Xb3JrZXJFcnJvcik7XG4gICAgICAgICAgbWVzc2FnZUhhbmRsZXIub24oXCJ0ZXN0XCIsIGRhdGEgPT4ge1xuICAgICAgICAgICAgd29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvbldvcmtlckVycm9yKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgIHRlcm1pbmF0ZUVhcmx5KCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgdGhpcy5fbWVzc2FnZUhhbmRsZXIgPSBtZXNzYWdlSGFuZGxlcjtcbiAgICAgICAgICAgICAgdGhpcy5fcG9ydCA9IHdvcmtlcjtcbiAgICAgICAgICAgICAgdGhpcy5fd2ViV29ya2VyID0gd29ya2VyO1xuXG4gICAgICAgICAgICAgIGlmICghZGF0YS5zdXBwb3J0VHJhbnNmZXJzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3N0TWVzc2FnZVRyYW5zZmVycyA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnJlc29sdmUoKTtcblxuICAgICAgICAgICAgICBtZXNzYWdlSGFuZGxlci5zZW5kKFwiY29uZmlndXJlXCIsIHtcbiAgICAgICAgICAgICAgICB2ZXJib3NpdHk6IHRoaXMudmVyYm9zaXR5XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fc2V0dXBGYWtlV29ya2VyKCk7XG5cbiAgICAgICAgICAgICAgbWVzc2FnZUhhbmRsZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgICB3b3JrZXIudGVybWluYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbWVzc2FnZUhhbmRsZXIub24oXCJyZWFkeVwiLCBkYXRhID0+IHtcbiAgICAgICAgICAgIHdvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25Xb3JrZXJFcnJvcik7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICB0ZXJtaW5hdGVFYXJseSgpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHNlbmRUZXN0KCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3NldHVwRmFrZVdvcmtlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY29uc3Qgc2VuZFRlc3QgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0ZXN0T2JqID0gbmV3IFVpbnQ4QXJyYXkoW3RoaXMucG9zdE1lc3NhZ2VUcmFuc2ZlcnMgPyAyNTUgOiAwXSk7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIG1lc3NhZ2VIYW5kbGVyLnNlbmQoXCJ0ZXN0XCIsIHRlc3RPYmosIFt0ZXN0T2JqLmJ1ZmZlcl0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgKDAsIF91dGlsLndhcm4pKFwiQ2Fubm90IHVzZSBwb3N0TWVzc2FnZSB0cmFuc2ZlcnMuXCIpO1xuICAgICAgICAgICAgICB0ZXN0T2JqWzBdID0gMDtcbiAgICAgICAgICAgICAgbWVzc2FnZUhhbmRsZXIuc2VuZChcInRlc3RcIiwgdGVzdE9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHNlbmRUZXN0KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgKDAsIF91dGlsLmluZm8pKFwiVGhlIHdvcmtlciBoYXMgYmVlbiBkaXNhYmxlZC5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2V0dXBGYWtlV29ya2VyKCk7XG4gICAgfVxuXG4gICAgX3NldHVwRmFrZVdvcmtlcigpIHtcbiAgICAgIGlmICghaXNXb3JrZXJEaXNhYmxlZCkge1xuICAgICAgICAoMCwgX3V0aWwud2FybikoXCJTZXR0aW5nIHVwIGZha2Ugd29ya2VyLlwiKTtcbiAgICAgICAgaXNXb3JrZXJEaXNhYmxlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHNldHVwRmFrZVdvcmtlckdsb2JhbCgpLnRoZW4oV29ya2VyTWVzc2FnZUhhbmRsZXIgPT4ge1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucmVqZWN0KG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkXCIpKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBvcnQgPSBuZXcgTG9vcGJhY2tQb3J0KCk7XG4gICAgICAgIHRoaXMuX3BvcnQgPSBwb3J0O1xuICAgICAgICBjb25zdCBpZCA9IFwiZmFrZVwiICsgbmV4dEZha2VXb3JrZXJJZCsrO1xuICAgICAgICBjb25zdCB3b3JrZXJIYW5kbGVyID0gbmV3IF9tZXNzYWdlX2hhbmRsZXIuTWVzc2FnZUhhbmRsZXIoaWQgKyBcIl93b3JrZXJcIiwgaWQsIHBvcnQpO1xuICAgICAgICBXb3JrZXJNZXNzYWdlSGFuZGxlci5zZXR1cCh3b3JrZXJIYW5kbGVyLCBwb3J0KTtcbiAgICAgICAgY29uc3QgbWVzc2FnZUhhbmRsZXIgPSBuZXcgX21lc3NhZ2VfaGFuZGxlci5NZXNzYWdlSGFuZGxlcihpZCwgaWQgKyBcIl93b3JrZXJcIiwgcG9ydCk7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyID0gbWVzc2FnZUhhbmRsZXI7XG5cbiAgICAgICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnJlc29sdmUoKTtcblxuICAgICAgICBtZXNzYWdlSGFuZGxlci5zZW5kKFwiY29uZmlndXJlXCIsIHtcbiAgICAgICAgICB2ZXJib3NpdHk6IHRoaXMudmVyYm9zaXR5XG4gICAgICAgIH0pO1xuICAgICAgfSkuY2F0Y2gocmVhc29uID0+IHtcbiAgICAgICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnJlamVjdChuZXcgRXJyb3IoYFNldHRpbmcgdXAgZmFrZSB3b3JrZXIgZmFpbGVkOiBcIiR7cmVhc29uLm1lc3NhZ2V9XCIuYCkpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcblxuICAgICAgaWYgKHRoaXMuX3dlYldvcmtlcikge1xuICAgICAgICB0aGlzLl93ZWJXb3JrZXIudGVybWluYXRlKCk7XG5cbiAgICAgICAgdGhpcy5fd2ViV29ya2VyID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcGRmV29ya2VyUG9ydHMuZGVsZXRlKHRoaXMuX3BvcnQpO1xuICAgICAgdGhpcy5fcG9ydCA9IG51bGw7XG5cbiAgICAgIGlmICh0aGlzLl9tZXNzYWdlSGFuZGxlcikge1xuICAgICAgICB0aGlzLl9tZXNzYWdlSGFuZGxlci5kZXN0cm95KCk7XG5cbiAgICAgICAgdGhpcy5fbWVzc2FnZUhhbmRsZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBmcm9tUG9ydChwYXJhbXMpIHtcbiAgICAgIGlmICghcGFyYW1zIHx8ICFwYXJhbXMucG9ydCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQREZXb3JrZXIuZnJvbVBvcnQgLSBpbnZhbGlkIG1ldGhvZCBzaWduYXR1cmUuXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGRmV29ya2VyUG9ydHMuaGFzKHBhcmFtcy5wb3J0KSkge1xuICAgICAgICByZXR1cm4gcGRmV29ya2VyUG9ydHMuZ2V0KHBhcmFtcy5wb3J0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBQREZXb3JrZXIocGFyYW1zKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0V29ya2VyU3JjKCkge1xuICAgICAgcmV0dXJuIGdldFdvcmtlclNyYygpO1xuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIFBERldvcmtlcjtcbn0oKTtcblxuZXhwb3J0cy5QREZXb3JrZXIgPSBQREZXb3JrZXI7XG5cbmNsYXNzIFdvcmtlclRyYW5zcG9ydCB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2VIYW5kbGVyLCBsb2FkaW5nVGFzaywgbmV0d29ya1N0cmVhbSwgcGFyYW1zKSB7XG4gICAgdGhpcy5tZXNzYWdlSGFuZGxlciA9IG1lc3NhZ2VIYW5kbGVyO1xuICAgIHRoaXMubG9hZGluZ1Rhc2sgPSBsb2FkaW5nVGFzaztcbiAgICB0aGlzLmNvbW1vbk9ianMgPSBuZXcgUERGT2JqZWN0cygpO1xuICAgIHRoaXMuZm9udExvYWRlciA9IG5ldyBfZm9udF9sb2FkZXIuRm9udExvYWRlcih7XG4gICAgICBkb2NJZDogbG9hZGluZ1Rhc2suZG9jSWQsXG4gICAgICBvblVuc3VwcG9ydGVkRmVhdHVyZTogdGhpcy5fb25VbnN1cHBvcnRlZEZlYXR1cmUuYmluZCh0aGlzKSxcbiAgICAgIG93bmVyRG9jdW1lbnQ6IHBhcmFtcy5vd25lckRvY3VtZW50XG4gICAgfSk7XG4gICAgdGhpcy5fcGFyYW1zID0gcGFyYW1zO1xuICAgIHRoaXMuQ01hcFJlYWRlckZhY3RvcnkgPSBuZXcgcGFyYW1zLkNNYXBSZWFkZXJGYWN0b3J5KHtcbiAgICAgIGJhc2VVcmw6IHBhcmFtcy5jTWFwVXJsLFxuICAgICAgaXNDb21wcmVzc2VkOiBwYXJhbXMuY01hcFBhY2tlZFxuICAgIH0pO1xuICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5kZXN0cm95Q2FwYWJpbGl0eSA9IG51bGw7XG4gICAgdGhpcy5fcGFzc3dvcmRDYXBhYmlsaXR5ID0gbnVsbDtcbiAgICB0aGlzLl9uZXR3b3JrU3RyZWFtID0gbmV0d29ya1N0cmVhbTtcbiAgICB0aGlzLl9mdWxsUmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9sYXN0UHJvZ3Jlc3MgPSBudWxsO1xuICAgIHRoaXMucGFnZUNhY2hlID0gW107XG4gICAgdGhpcy5wYWdlUHJvbWlzZXMgPSBbXTtcbiAgICB0aGlzLmRvd25sb2FkSW5mb0NhcGFiaWxpdHkgPSAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCk7XG4gICAgdGhpcy5zZXR1cE1lc3NhZ2VIYW5kbGVyKCk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5KSB7XG4gICAgICByZXR1cm4gdGhpcy5kZXN0cm95Q2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIH1cblxuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5ID0gKDAsIF91dGlsLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KSgpO1xuXG4gICAgaWYgKHRoaXMuX3Bhc3N3b3JkQ2FwYWJpbGl0eSkge1xuICAgICAgdGhpcy5fcGFzc3dvcmRDYXBhYmlsaXR5LnJlamVjdChuZXcgRXJyb3IoXCJXb3JrZXIgd2FzIGRlc3Ryb3llZCBkdXJpbmcgb25QYXNzd29yZCBjYWxsYmFja1wiKSk7XG4gICAgfVxuXG4gICAgY29uc3Qgd2FpdE9uID0gW107XG4gICAgdGhpcy5wYWdlQ2FjaGUuZm9yRWFjaChmdW5jdGlvbiAocGFnZSkge1xuICAgICAgaWYgKHBhZ2UpIHtcbiAgICAgICAgd2FpdE9uLnB1c2gocGFnZS5fZGVzdHJveSgpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnBhZ2VDYWNoZS5sZW5ndGggPSAwO1xuICAgIHRoaXMucGFnZVByb21pc2VzLmxlbmd0aCA9IDA7XG4gICAgY29uc3QgdGVybWluYXRlZCA9IHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiVGVybWluYXRlXCIsIG51bGwpO1xuICAgIHdhaXRPbi5wdXNoKHRlcm1pbmF0ZWQpO1xuICAgIFByb21pc2UuYWxsKHdhaXRPbikudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLmZvbnRMb2FkZXIuY2xlYXIoKTtcblxuICAgICAgaWYgKHRoaXMuX25ldHdvcmtTdHJlYW0pIHtcbiAgICAgICAgdGhpcy5fbmV0d29ya1N0cmVhbS5jYW5jZWxBbGxSZXF1ZXN0cyhuZXcgX3V0aWwuQWJvcnRFeGNlcHRpb24oXCJXb3JrZXIgd2FzIHRlcm1pbmF0ZWQuXCIpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubWVzc2FnZUhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlSGFuZGxlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMubWVzc2FnZUhhbmRsZXIgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB9LCB0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5LnJlamVjdCk7XG4gICAgcmV0dXJuIHRoaXMuZGVzdHJveUNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuXG4gIHNldHVwTWVzc2FnZUhhbmRsZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbWVzc2FnZUhhbmRsZXIsXG4gICAgICBsb2FkaW5nVGFza1xuICAgIH0gPSB0aGlzO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiR2V0UmVhZGVyXCIsIChkYXRhLCBzaW5rKSA9PiB7XG4gICAgICAoMCwgX3V0aWwuYXNzZXJ0KSh0aGlzLl9uZXR3b3JrU3RyZWFtLCBcIkdldFJlYWRlciAtIG5vIGBJUERGU3RyZWFtYCBpbnN0YW5jZSBhdmFpbGFibGUuXCIpO1xuICAgICAgdGhpcy5fZnVsbFJlYWRlciA9IHRoaXMuX25ldHdvcmtTdHJlYW0uZ2V0RnVsbFJlYWRlcigpO1xuXG4gICAgICB0aGlzLl9mdWxsUmVhZGVyLm9uUHJvZ3Jlc3MgPSBldnQgPT4ge1xuICAgICAgICB0aGlzLl9sYXN0UHJvZ3Jlc3MgPSB7XG4gICAgICAgICAgbG9hZGVkOiBldnQubG9hZGVkLFxuICAgICAgICAgIHRvdGFsOiBldnQudG90YWxcbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIHNpbmsub25QdWxsID0gKCkgPT4ge1xuICAgICAgICB0aGlzLl9mdWxsUmVhZGVyLnJlYWQoKS50aGVuKGZ1bmN0aW9uICh7XG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgZG9uZVxuICAgICAgICB9KSB7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHNpbmsuY2xvc2UoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAoMCwgX3V0aWwuYXNzZXJ0KSgoMCwgX3V0aWwuaXNBcnJheUJ1ZmZlcikodmFsdWUpLCBcIkdldFJlYWRlciAtIGV4cGVjdGVkIGFuIEFycmF5QnVmZmVyLlwiKTtcbiAgICAgICAgICBzaW5rLmVucXVldWUobmV3IFVpbnQ4QXJyYXkodmFsdWUpLCAxLCBbdmFsdWVdKTtcbiAgICAgICAgfSkuY2F0Y2gocmVhc29uID0+IHtcbiAgICAgICAgICBzaW5rLmVycm9yKHJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgc2luay5vbkNhbmNlbCA9IHJlYXNvbiA9PiB7XG4gICAgICAgIHRoaXMuX2Z1bGxSZWFkZXIuY2FuY2VsKHJlYXNvbik7XG5cbiAgICAgICAgc2luay5yZWFkeS5jYXRjaChyZWFkeVJlYXNvbiA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhyb3cgcmVhZHlSZWFzb247XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIlJlYWRlckhlYWRlcnNSZWFkeVwiLCBkYXRhID0+IHtcbiAgICAgIGNvbnN0IGhlYWRlcnNDYXBhYmlsaXR5ID0gKDAsIF91dGlsLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KSgpO1xuICAgICAgY29uc3QgZnVsbFJlYWRlciA9IHRoaXMuX2Z1bGxSZWFkZXI7XG4gICAgICBmdWxsUmVhZGVyLmhlYWRlcnNSZWFkeS50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKCFmdWxsUmVhZGVyLmlzU3RyZWFtaW5nU3VwcG9ydGVkIHx8ICFmdWxsUmVhZGVyLmlzUmFuZ2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICBpZiAodGhpcy5fbGFzdFByb2dyZXNzICYmIGxvYWRpbmdUYXNrLm9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIGxvYWRpbmdUYXNrLm9uUHJvZ3Jlc3ModGhpcy5fbGFzdFByb2dyZXNzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdWxsUmVhZGVyLm9uUHJvZ3Jlc3MgPSBldnQgPT4ge1xuICAgICAgICAgICAgaWYgKGxvYWRpbmdUYXNrLm9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgbG9hZGluZ1Rhc2sub25Qcm9ncmVzcyh7XG4gICAgICAgICAgICAgICAgbG9hZGVkOiBldnQubG9hZGVkLFxuICAgICAgICAgICAgICAgIHRvdGFsOiBldnQudG90YWxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhlYWRlcnNDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICAgIGlzU3RyZWFtaW5nU3VwcG9ydGVkOiBmdWxsUmVhZGVyLmlzU3RyZWFtaW5nU3VwcG9ydGVkLFxuICAgICAgICAgIGlzUmFuZ2VTdXBwb3J0ZWQ6IGZ1bGxSZWFkZXIuaXNSYW5nZVN1cHBvcnRlZCxcbiAgICAgICAgICBjb250ZW50TGVuZ3RoOiBmdWxsUmVhZGVyLmNvbnRlbnRMZW5ndGhcbiAgICAgICAgfSk7XG4gICAgICB9LCBoZWFkZXJzQ2FwYWJpbGl0eS5yZWplY3QpO1xuICAgICAgcmV0dXJuIGhlYWRlcnNDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJHZXRSYW5nZVJlYWRlclwiLCAoZGF0YSwgc2luaykgPT4ge1xuICAgICAgKDAsIF91dGlsLmFzc2VydCkodGhpcy5fbmV0d29ya1N0cmVhbSwgXCJHZXRSYW5nZVJlYWRlciAtIG5vIGBJUERGU3RyZWFtYCBpbnN0YW5jZSBhdmFpbGFibGUuXCIpO1xuXG4gICAgICBjb25zdCByYW5nZVJlYWRlciA9IHRoaXMuX25ldHdvcmtTdHJlYW0uZ2V0UmFuZ2VSZWFkZXIoZGF0YS5iZWdpbiwgZGF0YS5lbmQpO1xuXG4gICAgICBpZiAoIXJhbmdlUmVhZGVyKSB7XG4gICAgICAgIHNpbmsuY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzaW5rLm9uUHVsbCA9ICgpID0+IHtcbiAgICAgICAgcmFuZ2VSZWFkZXIucmVhZCgpLnRoZW4oZnVuY3Rpb24gKHtcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBkb25lXG4gICAgICAgIH0pIHtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgc2luay5jbG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgICgwLCBfdXRpbC5hc3NlcnQpKCgwLCBfdXRpbC5pc0FycmF5QnVmZmVyKSh2YWx1ZSksIFwiR2V0UmFuZ2VSZWFkZXIgLSBleHBlY3RlZCBhbiBBcnJheUJ1ZmZlci5cIik7XG4gICAgICAgICAgc2luay5lbnF1ZXVlKG5ldyBVaW50OEFycmF5KHZhbHVlKSwgMSwgW3ZhbHVlXSk7XG4gICAgICAgIH0pLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICAgICAgc2luay5lcnJvcihyZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIHNpbmsub25DYW5jZWwgPSByZWFzb24gPT4ge1xuICAgICAgICByYW5nZVJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICAgICAgc2luay5yZWFkeS5jYXRjaChyZWFkeVJlYXNvbiA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhyb3cgcmVhZHlSZWFzb247XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkdldERvY1wiLCAoe1xuICAgICAgcGRmSW5mb1xuICAgIH0pID0+IHtcbiAgICAgIHRoaXMuX251bVBhZ2VzID0gcGRmSW5mby5udW1QYWdlcztcblxuICAgICAgbG9hZGluZ1Rhc2suX2NhcGFiaWxpdHkucmVzb2x2ZShuZXcgUERGRG9jdW1lbnRQcm94eShwZGZJbmZvLCB0aGlzKSk7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJEb2NFeGNlcHRpb25cIiwgZnVuY3Rpb24gKGV4KSB7XG4gICAgICBsZXQgcmVhc29uO1xuXG4gICAgICBzd2l0Y2ggKGV4Lm5hbWUpIHtcbiAgICAgICAgY2FzZSBcIlBhc3N3b3JkRXhjZXB0aW9uXCI6XG4gICAgICAgICAgcmVhc29uID0gbmV3IF91dGlsLlBhc3N3b3JkRXhjZXB0aW9uKGV4Lm1lc3NhZ2UsIGV4LmNvZGUpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJJbnZhbGlkUERGRXhjZXB0aW9uXCI6XG4gICAgICAgICAgcmVhc29uID0gbmV3IF91dGlsLkludmFsaWRQREZFeGNlcHRpb24oZXgubWVzc2FnZSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcIk1pc3NpbmdQREZFeGNlcHRpb25cIjpcbiAgICAgICAgICByZWFzb24gPSBuZXcgX3V0aWwuTWlzc2luZ1BERkV4Y2VwdGlvbihleC5tZXNzYWdlKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwiVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uXCI6XG4gICAgICAgICAgcmVhc29uID0gbmV3IF91dGlsLlVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbihleC5tZXNzYWdlLCBleC5zdGF0dXMpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJVbmtub3duRXJyb3JFeGNlcHRpb25cIjpcbiAgICAgICAgICByZWFzb24gPSBuZXcgX3V0aWwuVW5rbm93bkVycm9yRXhjZXB0aW9uKGV4Lm1lc3NhZ2UsIGV4LmRldGFpbHMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoIShyZWFzb24gaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgY29uc3QgbXNnID0gXCJEb2NFeGNlcHRpb24gLSBleHBlY3RlZCBhIHZhbGlkIEVycm9yLlwiO1xuICAgICAgICAoMCwgX3V0aWwud2FybikobXNnKTtcbiAgICAgIH1cblxuICAgICAgbG9hZGluZ1Rhc2suX2NhcGFiaWxpdHkucmVqZWN0KHJlYXNvbik7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJQYXNzd29yZFJlcXVlc3RcIiwgZXhjZXB0aW9uID0+IHtcbiAgICAgIHRoaXMuX3Bhc3N3b3JkQ2FwYWJpbGl0eSA9ICgwLCBfdXRpbC5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSkoKTtcblxuICAgICAgaWYgKGxvYWRpbmdUYXNrLm9uUGFzc3dvcmQpIHtcbiAgICAgICAgY29uc3QgdXBkYXRlUGFzc3dvcmQgPSBwYXNzd29yZCA9PiB7XG4gICAgICAgICAgdGhpcy5fcGFzc3dvcmRDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICAgICAgcGFzc3dvcmRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGxvYWRpbmdUYXNrLm9uUGFzc3dvcmQodXBkYXRlUGFzc3dvcmQsIGV4Y2VwdGlvbi5jb2RlKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICB0aGlzLl9wYXNzd29yZENhcGFiaWxpdHkucmVqZWN0KGV4KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcGFzc3dvcmRDYXBhYmlsaXR5LnJlamVjdChuZXcgX3V0aWwuUGFzc3dvcmRFeGNlcHRpb24oZXhjZXB0aW9uLm1lc3NhZ2UsIGV4Y2VwdGlvbi5jb2RlKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9wYXNzd29yZENhcGFiaWxpdHkucHJvbWlzZTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkRhdGFMb2FkZWRcIiwgZGF0YSA9PiB7XG4gICAgICBpZiAobG9hZGluZ1Rhc2sub25Qcm9ncmVzcykge1xuICAgICAgICBsb2FkaW5nVGFzay5vblByb2dyZXNzKHtcbiAgICAgICAgICBsb2FkZWQ6IGRhdGEubGVuZ3RoLFxuICAgICAgICAgIHRvdGFsOiBkYXRhLmxlbmd0aFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kb3dubG9hZEluZm9DYXBhYmlsaXR5LnJlc29sdmUoZGF0YSk7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJTdGFydFJlbmRlclBhZ2VcIiwgZGF0YSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwYWdlID0gdGhpcy5wYWdlQ2FjaGVbZGF0YS5wYWdlSW5kZXhdO1xuXG4gICAgICBwYWdlLl9zdGFydFJlbmRlclBhZ2UoZGF0YS50cmFuc3BhcmVuY3ksIGRhdGEuaW50ZW50KTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcImNvbW1vbm9ialwiLCBkYXRhID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IFtpZCwgdHlwZSwgZXhwb3J0ZWREYXRhXSA9IGRhdGE7XG5cbiAgICAgIGlmICh0aGlzLmNvbW1vbk9ianMuaGFzKGlkKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwiRm9udFwiOlxuICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuX3BhcmFtcztcblxuICAgICAgICAgIGlmIChcImVycm9yXCIgaW4gZXhwb3J0ZWREYXRhKSB7XG4gICAgICAgICAgICBjb25zdCBleHBvcnRlZEVycm9yID0gZXhwb3J0ZWREYXRhLmVycm9yO1xuICAgICAgICAgICAgKDAsIF91dGlsLndhcm4pKGBFcnJvciBkdXJpbmcgZm9udCBsb2FkaW5nOiAke2V4cG9ydGVkRXJyb3J9YCk7XG4gICAgICAgICAgICB0aGlzLmNvbW1vbk9ianMucmVzb2x2ZShpZCwgZXhwb3J0ZWRFcnJvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgZm9udFJlZ2lzdHJ5ID0gbnVsbDtcblxuICAgICAgICAgIGlmIChwYXJhbXMucGRmQnVnICYmIGdsb2JhbFRoaXMuRm9udEluc3BlY3RvciAmJiBnbG9iYWxUaGlzLkZvbnRJbnNwZWN0b3IuZW5hYmxlZCkge1xuICAgICAgICAgICAgZm9udFJlZ2lzdHJ5ID0ge1xuICAgICAgICAgICAgICByZWdpc3RlckZvbnQoZm9udCwgdXJsKSB7XG4gICAgICAgICAgICAgICAgZ2xvYmFsVGhpcy5Gb250SW5zcGVjdG9yLmZvbnRBZGRlZChmb250LCB1cmwpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgZm9udCA9IG5ldyBfZm9udF9sb2FkZXIuRm9udEZhY2VPYmplY3QoZXhwb3J0ZWREYXRhLCB7XG4gICAgICAgICAgICBpc0V2YWxTdXBwb3J0ZWQ6IHBhcmFtcy5pc0V2YWxTdXBwb3J0ZWQsXG4gICAgICAgICAgICBkaXNhYmxlRm9udEZhY2U6IHBhcmFtcy5kaXNhYmxlRm9udEZhY2UsXG4gICAgICAgICAgICBpZ25vcmVFcnJvcnM6IHBhcmFtcy5pZ25vcmVFcnJvcnMsXG4gICAgICAgICAgICBvblVuc3VwcG9ydGVkRmVhdHVyZTogdGhpcy5fb25VbnN1cHBvcnRlZEZlYXR1cmUuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGZvbnRSZWdpc3RyeVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuZm9udExvYWRlci5iaW5kKGZvbnQpLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiRm9udEZhbGxiYWNrXCIsIHtcbiAgICAgICAgICAgICAgaWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFwYXJhbXMuZm9udEV4dHJhUHJvcGVydGllcyAmJiBmb250LmRhdGEpIHtcbiAgICAgICAgICAgICAgZm9udC5kYXRhID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jb21tb25PYmpzLnJlc29sdmUoaWQsIGZvbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJGb250UGF0aFwiOlxuICAgICAgICBjYXNlIFwiSW1hZ2VcIjpcbiAgICAgICAgICB0aGlzLmNvbW1vbk9ianMucmVzb2x2ZShpZCwgZXhwb3J0ZWREYXRhKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgR290IHVua25vd24gY29tbW9uIG9iamVjdCB0eXBlICR7dHlwZX1gKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIm9ialwiLCBkYXRhID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBbaWQsIHBhZ2VJbmRleCwgdHlwZSwgaW1hZ2VEYXRhXSA9IGRhdGE7XG4gICAgICBjb25zdCBwYWdlUHJveHkgPSB0aGlzLnBhZ2VDYWNoZVtwYWdlSW5kZXhdO1xuXG4gICAgICBpZiAocGFnZVByb3h5Lm9ianMuaGFzKGlkKSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcIkltYWdlXCI6XG4gICAgICAgICAgcGFnZVByb3h5Lm9ianMucmVzb2x2ZShpZCwgaW1hZ2VEYXRhKTtcbiAgICAgICAgICBjb25zdCBNQVhfSU1BR0VfU0laRV9UT19TVE9SRSA9IDgwMDAwMDA7XG5cbiAgICAgICAgICBpZiAoaW1hZ2VEYXRhICYmIFwiZGF0YVwiIGluIGltYWdlRGF0YSAmJiBpbWFnZURhdGEuZGF0YS5sZW5ndGggPiBNQVhfSU1BR0VfU0laRV9UT19TVE9SRSkge1xuICAgICAgICAgICAgcGFnZVByb3h5LmNsZWFudXBBZnRlclJlbmRlciA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEdvdCB1bmtub3duIG9iamVjdCB0eXBlICR7dHlwZX1gKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkRvY1Byb2dyZXNzXCIsIGRhdGEgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGxvYWRpbmdUYXNrLm9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgbG9hZGluZ1Rhc2sub25Qcm9ncmVzcyh7XG4gICAgICAgICAgbG9hZGVkOiBkYXRhLmxvYWRlZCxcbiAgICAgICAgICB0b3RhbDogZGF0YS50b3RhbFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIlVuc3VwcG9ydGVkRmVhdHVyZVwiLCB0aGlzLl9vblVuc3VwcG9ydGVkRmVhdHVyZS5iaW5kKHRoaXMpKTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkZldGNoQnVpbHRJbkNNYXBcIiwgKGRhdGEsIHNpbmspID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICBzaW5rLmVycm9yKG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkXCIpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQgZmV0Y2hlZCA9IGZhbHNlO1xuXG4gICAgICBzaW5rLm9uUHVsbCA9ICgpID0+IHtcbiAgICAgICAgaWYgKGZldGNoZWQpIHtcbiAgICAgICAgICBzaW5rLmNsb3NlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZmV0Y2hlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuQ01hcFJlYWRlckZhY3RvcnkuZmV0Y2goZGF0YSkudGhlbihmdW5jdGlvbiAoYnVpbHRJbkNNYXApIHtcbiAgICAgICAgICBzaW5rLmVucXVldWUoYnVpbHRJbkNNYXAsIDEsIFtidWlsdEluQ01hcC5jTWFwRGF0YS5idWZmZXJdKTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgIHNpbmsuZXJyb3IocmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgX29uVW5zdXBwb3J0ZWRGZWF0dXJlKHtcbiAgICBmZWF0dXJlSWRcbiAgfSkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxvYWRpbmdUYXNrLm9uVW5zdXBwb3J0ZWRGZWF0dXJlKSB7XG4gICAgICB0aGlzLmxvYWRpbmdUYXNrLm9uVW5zdXBwb3J0ZWRGZWF0dXJlKGZlYXR1cmVJZCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0RGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXREYXRhXCIsIG51bGwpO1xuICB9XG5cbiAgZ2V0UGFnZShwYWdlTnVtYmVyKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHBhZ2VOdW1iZXIpIHx8IHBhZ2VOdW1iZXIgPD0gMCB8fCBwYWdlTnVtYmVyID4gdGhpcy5fbnVtUGFnZXMpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJJbnZhbGlkIHBhZ2UgcmVxdWVzdFwiKSk7XG4gICAgfVxuXG4gICAgY29uc3QgcGFnZUluZGV4ID0gcGFnZU51bWJlciAtIDE7XG5cbiAgICBpZiAocGFnZUluZGV4IGluIHRoaXMucGFnZVByb21pc2VzKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYWdlUHJvbWlzZXNbcGFnZUluZGV4XTtcbiAgICB9XG5cbiAgICBjb25zdCBwcm9taXNlID0gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRQYWdlXCIsIHtcbiAgICAgIHBhZ2VJbmRleFxuICAgIH0pLnRoZW4ocGFnZUluZm8gPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zcG9ydCBkZXN0cm95ZWRcIik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhZ2UgPSBuZXcgUERGUGFnZVByb3h5KHBhZ2VJbmRleCwgcGFnZUluZm8sIHRoaXMsIHRoaXMuX3BhcmFtcy5vd25lckRvY3VtZW50LCB0aGlzLl9wYXJhbXMucGRmQnVnKTtcbiAgICAgIHRoaXMucGFnZUNhY2hlW3BhZ2VJbmRleF0gPSBwYWdlO1xuICAgICAgcmV0dXJuIHBhZ2U7XG4gICAgfSk7XG4gICAgdGhpcy5wYWdlUHJvbWlzZXNbcGFnZUluZGV4XSA9IHByb21pc2U7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBnZXRQYWdlSW5kZXgocmVmKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZUluZGV4XCIsIHtcbiAgICAgIHJlZlxuICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IocmVhc29uKSk7XG4gICAgfSk7XG4gIH1cblxuICBnZXRBbm5vdGF0aW9ucyhwYWdlSW5kZXgsIGludGVudCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldEFubm90YXRpb25zXCIsIHtcbiAgICAgIHBhZ2VJbmRleCxcbiAgICAgIGludGVudFxuICAgIH0pO1xuICB9XG5cbiAgc2F2ZURvY3VtZW50KGFubm90YXRpb25TdG9yYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiU2F2ZURvY3VtZW50XCIsIHtcbiAgICAgIG51bVBhZ2VzOiB0aGlzLl9udW1QYWdlcyxcbiAgICAgIGFubm90YXRpb25TdG9yYWdlOiBhbm5vdGF0aW9uU3RvcmFnZSAmJiBhbm5vdGF0aW9uU3RvcmFnZS5nZXRBbGwoKSB8fCBudWxsLFxuICAgICAgZmlsZW5hbWU6IHRoaXMuX2Z1bGxSZWFkZXIgPyB0aGlzLl9mdWxsUmVhZGVyLmZpbGVuYW1lIDogbnVsbFxuICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgaWYgKGFubm90YXRpb25TdG9yYWdlKSB7XG4gICAgICAgIGFubm90YXRpb25TdG9yYWdlLnJlc2V0TW9kaWZpZWQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGdldERlc3RpbmF0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXREZXN0aW5hdGlvbnNcIiwgbnVsbCk7XG4gIH1cblxuICBnZXREZXN0aW5hdGlvbihpZCkge1xuICAgIGlmICh0eXBlb2YgaWQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJJbnZhbGlkIGRlc3RpbmF0aW9uIHJlcXVlc3QuXCIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXREZXN0aW5hdGlvblwiLCB7XG4gICAgICBpZFxuICAgIH0pO1xuICB9XG5cbiAgZ2V0UGFnZUxhYmVscygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRQYWdlTGFiZWxzXCIsIG51bGwpO1xuICB9XG5cbiAgZ2V0UGFnZUxheW91dCgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRQYWdlTGF5b3V0XCIsIG51bGwpO1xuICB9XG5cbiAgZ2V0UGFnZU1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZU1vZGVcIiwgbnVsbCk7XG4gIH1cblxuICBnZXRWaWV3ZXJQcmVmZXJlbmNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRWaWV3ZXJQcmVmZXJlbmNlc1wiLCBudWxsKTtcbiAgfVxuXG4gIGdldE9wZW5BY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0T3BlbkFjdGlvblwiLCBudWxsKTtcbiAgfVxuXG4gIGdldEF0dGFjaG1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldEF0dGFjaG1lbnRzXCIsIG51bGwpO1xuICB9XG5cbiAgZ2V0SmF2YVNjcmlwdCgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRKYXZhU2NyaXB0XCIsIG51bGwpO1xuICB9XG5cbiAgZ2V0T3V0bGluZSgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRPdXRsaW5lXCIsIG51bGwpO1xuICB9XG5cbiAgZ2V0T3B0aW9uYWxDb250ZW50Q29uZmlnKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldE9wdGlvbmFsQ29udGVudENvbmZpZ1wiLCBudWxsKS50aGVuKHJlc3VsdHMgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBfb3B0aW9uYWxfY29udGVudF9jb25maWcuT3B0aW9uYWxDb250ZW50Q29uZmlnKHJlc3VsdHMpO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0UGVybWlzc2lvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGVybWlzc2lvbnNcIiwgbnVsbCk7XG4gIH1cblxuICBnZXRNZXRhZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRNZXRhZGF0YVwiLCBudWxsKS50aGVuKHJlc3VsdHMgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5mbzogcmVzdWx0c1swXSxcbiAgICAgICAgbWV0YWRhdGE6IHJlc3VsdHNbMV0gPyBuZXcgX21ldGFkYXRhLk1ldGFkYXRhKHJlc3VsdHNbMV0pIDogbnVsbCxcbiAgICAgICAgY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWU6IHRoaXMuX2Z1bGxSZWFkZXIgPyB0aGlzLl9mdWxsUmVhZGVyLmZpbGVuYW1lIDogbnVsbFxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldFN0YXRzKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFN0YXRzXCIsIG51bGwpO1xuICB9XG5cbiAgc3RhcnRDbGVhbnVwKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkNsZWFudXBcIiwgbnVsbCkudGhlbigoKSA9PiB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSB0aGlzLnBhZ2VDYWNoZS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBhZ2UgPSB0aGlzLnBhZ2VDYWNoZVtpXTtcblxuICAgICAgICBpZiAocGFnZSkge1xuICAgICAgICAgIGNvbnN0IGNsZWFudXBTdWNjZXNzZnVsID0gcGFnZS5jbGVhbnVwKCk7XG5cbiAgICAgICAgICBpZiAoIWNsZWFudXBTdWNjZXNzZnVsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHN0YXJ0Q2xlYW51cDogUGFnZSAke2kgKyAxfSBpcyBjdXJyZW50bHkgcmVuZGVyaW5nLmApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbW1vbk9ianMuY2xlYXIoKTtcbiAgICAgIHRoaXMuZm9udExvYWRlci5jbGVhcigpO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0IGxvYWRpbmdQYXJhbXMoKSB7XG4gICAgY29uc3QgcGFyYW1zID0gdGhpcy5fcGFyYW1zO1xuICAgIHJldHVybiAoMCwgX3V0aWwuc2hhZG93KSh0aGlzLCBcImxvYWRpbmdQYXJhbXNcIiwge1xuICAgICAgZGlzYWJsZUF1dG9GZXRjaDogcGFyYW1zLmRpc2FibGVBdXRvRmV0Y2gsXG4gICAgICBkaXNhYmxlRm9udEZhY2U6IHBhcmFtcy5kaXNhYmxlRm9udEZhY2VcbiAgICB9KTtcbiAgfVxuXG59XG5cbmNsYXNzIFBERk9iamVjdHMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9vYmpzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuXG4gIF9lbnN1cmVPYmoob2JqSWQpIHtcbiAgICBpZiAodGhpcy5fb2Jqc1tvYmpJZF0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9vYmpzW29iaklkXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fb2Jqc1tvYmpJZF0gPSB7XG4gICAgICBjYXBhYmlsaXR5OiAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCksXG4gICAgICBkYXRhOiBudWxsLFxuICAgICAgcmVzb2x2ZWQ6IGZhbHNlXG4gICAgfTtcbiAgfVxuXG4gIGdldChvYmpJZCwgY2FsbGJhY2sgPSBudWxsKSB7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLl9lbnN1cmVPYmoob2JqSWQpLmNhcGFiaWxpdHkucHJvbWlzZS50aGVuKGNhbGxiYWNrKTtcblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3Qgb2JqID0gdGhpcy5fb2Jqc1tvYmpJZF07XG5cbiAgICBpZiAoIW9iaiB8fCAhb2JqLnJlc29sdmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlcXVlc3Rpbmcgb2JqZWN0IHRoYXQgaXNuJ3QgcmVzb2x2ZWQgeWV0ICR7b2JqSWR9LmApO1xuICAgIH1cblxuICAgIHJldHVybiBvYmouZGF0YTtcbiAgfVxuXG4gIGhhcyhvYmpJZCkge1xuICAgIGNvbnN0IG9iaiA9IHRoaXMuX29ianNbb2JqSWRdO1xuICAgIHJldHVybiBvYmogPyBvYmoucmVzb2x2ZWQgOiBmYWxzZTtcbiAgfVxuXG4gIHJlc29sdmUob2JqSWQsIGRhdGEpIHtcbiAgICBjb25zdCBvYmogPSB0aGlzLl9lbnN1cmVPYmoob2JqSWQpO1xuXG4gICAgb2JqLnJlc29sdmVkID0gdHJ1ZTtcbiAgICBvYmouZGF0YSA9IGRhdGE7XG4gICAgb2JqLmNhcGFiaWxpdHkucmVzb2x2ZShkYXRhKTtcbiAgfVxuXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuX29ianMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG5cbn1cblxuY2xhc3MgUmVuZGVyVGFzayB7XG4gIGNvbnN0cnVjdG9yKGludGVybmFsUmVuZGVyVGFzaykge1xuICAgIHRoaXMuX2ludGVybmFsUmVuZGVyVGFzayA9IGludGVybmFsUmVuZGVyVGFzaztcbiAgICB0aGlzLm9uQ29udGludWUgPSBudWxsO1xuICB9XG5cbiAgZ2V0IHByb21pc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ludGVybmFsUmVuZGVyVGFzay5jYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cblxuICBjYW5jZWwoKSB7XG4gICAgdGhpcy5faW50ZXJuYWxSZW5kZXJUYXNrLmNhbmNlbCgpO1xuICB9XG5cbn1cblxuY29uc3QgSW50ZXJuYWxSZW5kZXJUYXNrID0gZnVuY3Rpb24gSW50ZXJuYWxSZW5kZXJUYXNrQ2xvc3VyZSgpIHtcbiAgY29uc3QgY2FudmFzSW5SZW5kZXJpbmcgPSBuZXcgV2Vha1NldCgpO1xuXG4gIGNsYXNzIEludGVybmFsUmVuZGVyVGFzayB7XG4gICAgY29uc3RydWN0b3Ioe1xuICAgICAgY2FsbGJhY2ssXG4gICAgICBwYXJhbXMsXG4gICAgICBvYmpzLFxuICAgICAgY29tbW9uT2JqcyxcbiAgICAgIG9wZXJhdG9yTGlzdCxcbiAgICAgIHBhZ2VJbmRleCxcbiAgICAgIGNhbnZhc0ZhY3RvcnksXG4gICAgICB3ZWJHTENvbnRleHQsXG4gICAgICB1c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmYWxzZSxcbiAgICAgIHBkZkJ1ZyA9IGZhbHNlXG4gICAgfSkge1xuICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgICB0aGlzLm9ianMgPSBvYmpzO1xuICAgICAgdGhpcy5jb21tb25PYmpzID0gY29tbW9uT2JqcztcbiAgICAgIHRoaXMub3BlcmF0b3JMaXN0SWR4ID0gbnVsbDtcbiAgICAgIHRoaXMub3BlcmF0b3JMaXN0ID0gb3BlcmF0b3JMaXN0O1xuICAgICAgdGhpcy5fcGFnZUluZGV4ID0gcGFnZUluZGV4O1xuICAgICAgdGhpcy5jYW52YXNGYWN0b3J5ID0gY2FudmFzRmFjdG9yeTtcbiAgICAgIHRoaXMud2ViR0xDb250ZXh0ID0gd2ViR0xDb250ZXh0O1xuICAgICAgdGhpcy5fcGRmQnVnID0gcGRmQnVnO1xuICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLmdyYXBoaWNzUmVhZHlDYWxsYmFjayA9IG51bGw7XG4gICAgICB0aGlzLmdyYXBoaWNzUmVhZHkgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3VzZVJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHVzZVJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gdHJ1ZSAmJiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xuICAgICAgdGhpcy5jYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuY2FwYWJpbGl0eSA9ICgwLCBfdXRpbC5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSkoKTtcbiAgICAgIHRoaXMudGFzayA9IG5ldyBSZW5kZXJUYXNrKHRoaXMpO1xuICAgICAgdGhpcy5fY29udGludWVCb3VuZCA9IHRoaXMuX2NvbnRpbnVlLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9zY2hlZHVsZU5leHRCb3VuZCA9IHRoaXMuX3NjaGVkdWxlTmV4dC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fbmV4dEJvdW5kID0gdGhpcy5fbmV4dC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fY2FudmFzID0gcGFyYW1zLmNhbnZhc0NvbnRleHQuY2FudmFzO1xuICAgIH1cblxuICAgIGdldCBjb21wbGV0ZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYXBhYmlsaXR5LnByb21pc2UuY2F0Y2goZnVuY3Rpb24gKCkge30pO1xuICAgIH1cblxuICAgIGluaXRpYWxpemVHcmFwaGljcyh7XG4gICAgICB0cmFuc3BhcmVuY3kgPSBmYWxzZSxcbiAgICAgIG9wdGlvbmFsQ29udGVudENvbmZpZ1xuICAgIH0pIHtcbiAgICAgIGlmICh0aGlzLmNhbmNlbGxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9jYW52YXMpIHtcbiAgICAgICAgaWYgKGNhbnZhc0luUmVuZGVyaW5nLmhhcyh0aGlzLl9jYW52YXMpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHVzZSB0aGUgc2FtZSBjYW52YXMgZHVyaW5nIG11bHRpcGxlIHJlbmRlcigpIG9wZXJhdGlvbnMuIFwiICsgXCJVc2UgZGlmZmVyZW50IGNhbnZhcyBvciBlbnN1cmUgcHJldmlvdXMgb3BlcmF0aW9ucyB3ZXJlIFwiICsgXCJjYW5jZWxsZWQgb3IgY29tcGxldGVkLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbnZhc0luUmVuZGVyaW5nLmFkZCh0aGlzLl9jYW52YXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fcGRmQnVnICYmIGdsb2JhbFRoaXMuU3RlcHBlck1hbmFnZXIgJiYgZ2xvYmFsVGhpcy5TdGVwcGVyTWFuYWdlci5lbmFibGVkKSB7XG4gICAgICAgIHRoaXMuc3RlcHBlciA9IGdsb2JhbFRoaXMuU3RlcHBlck1hbmFnZXIuY3JlYXRlKHRoaXMuX3BhZ2VJbmRleCk7XG4gICAgICAgIHRoaXMuc3RlcHBlci5pbml0KHRoaXMub3BlcmF0b3JMaXN0KTtcbiAgICAgICAgdGhpcy5zdGVwcGVyLm5leHRCcmVha1BvaW50ID0gdGhpcy5zdGVwcGVyLmdldE5leHRCcmVha1BvaW50KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2FudmFzQ29udGV4dCxcbiAgICAgICAgdmlld3BvcnQsXG4gICAgICAgIHRyYW5zZm9ybSxcbiAgICAgICAgaW1hZ2VMYXllcixcbiAgICAgICAgYmFja2dyb3VuZFxuICAgICAgfSA9IHRoaXMucGFyYW1zO1xuICAgICAgdGhpcy5nZnggPSBuZXcgX2NhbnZhcy5DYW52YXNHcmFwaGljcyhjYW52YXNDb250ZXh0LCB0aGlzLmNvbW1vbk9ianMsIHRoaXMub2JqcywgdGhpcy5jYW52YXNGYWN0b3J5LCB0aGlzLndlYkdMQ29udGV4dCwgaW1hZ2VMYXllciwgb3B0aW9uYWxDb250ZW50Q29uZmlnKTtcbiAgICAgIHRoaXMuZ2Z4LmJlZ2luRHJhd2luZyh7XG4gICAgICAgIHRyYW5zZm9ybSxcbiAgICAgICAgdmlld3BvcnQsXG4gICAgICAgIHRyYW5zcGFyZW5jeSxcbiAgICAgICAgYmFja2dyb3VuZFxuICAgICAgfSk7XG4gICAgICB0aGlzLm9wZXJhdG9yTGlzdElkeCA9IDA7XG4gICAgICB0aGlzLmdyYXBoaWNzUmVhZHkgPSB0cnVlO1xuXG4gICAgICBpZiAodGhpcy5ncmFwaGljc1JlYWR5Q2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5ncmFwaGljc1JlYWR5Q2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjYW5jZWwoZXJyb3IgPSBudWxsKSB7XG4gICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuY2FuY2VsbGVkID0gdHJ1ZTtcblxuICAgICAgaWYgKHRoaXMuZ2Z4KSB7XG4gICAgICAgIHRoaXMuZ2Z4LmVuZERyYXdpbmcoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2NhbnZhcykge1xuICAgICAgICBjYW52YXNJblJlbmRlcmluZy5kZWxldGUodGhpcy5fY2FudmFzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jYWxsYmFjayhlcnJvciB8fCBuZXcgX2Rpc3BsYXlfdXRpbHMuUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uKGBSZW5kZXJpbmcgY2FuY2VsbGVkLCBwYWdlICR7dGhpcy5fcGFnZUluZGV4ICsgMX1gLCBcImNhbnZhc1wiKSk7XG4gICAgfVxuXG4gICAgb3BlcmF0b3JMaXN0Q2hhbmdlZCgpIHtcbiAgICAgIGlmICghdGhpcy5ncmFwaGljc1JlYWR5KSB7XG4gICAgICAgIGlmICghdGhpcy5ncmFwaGljc1JlYWR5Q2FsbGJhY2spIHtcbiAgICAgICAgICB0aGlzLmdyYXBoaWNzUmVhZHlDYWxsYmFjayA9IHRoaXMuX2NvbnRpbnVlQm91bmQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnN0ZXBwZXIpIHtcbiAgICAgICAgdGhpcy5zdGVwcGVyLnVwZGF0ZU9wZXJhdG9yTGlzdCh0aGlzLm9wZXJhdG9yTGlzdCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnJ1bm5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jb250aW51ZSgpO1xuICAgIH1cblxuICAgIF9jb250aW51ZSgpIHtcbiAgICAgIHRoaXMucnVubmluZyA9IHRydWU7XG5cbiAgICAgIGlmICh0aGlzLmNhbmNlbGxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnRhc2sub25Db250aW51ZSkge1xuICAgICAgICB0aGlzLnRhc2sub25Db250aW51ZSh0aGlzLl9zY2hlZHVsZU5leHRCb3VuZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zY2hlZHVsZU5leHQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfc2NoZWR1bGVOZXh0KCkge1xuICAgICAgaWYgKHRoaXMuX3VzZVJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICB0aGlzLl9uZXh0Qm91bmQoKS5jYXRjaCh0aGlzLmNhbmNlbC5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKHRoaXMuX25leHRCb3VuZCkuY2F0Y2godGhpcy5jYW5jZWwuYmluZCh0aGlzKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgX25leHQoKSB7XG4gICAgICBpZiAodGhpcy5jYW5jZWxsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm9wZXJhdG9yTGlzdElkeCA9IHRoaXMuZ2Z4LmV4ZWN1dGVPcGVyYXRvckxpc3QodGhpcy5vcGVyYXRvckxpc3QsIHRoaXMub3BlcmF0b3JMaXN0SWR4LCB0aGlzLl9jb250aW51ZUJvdW5kLCB0aGlzLnN0ZXBwZXIpO1xuXG4gICAgICBpZiAodGhpcy5vcGVyYXRvckxpc3RJZHggPT09IHRoaXMub3BlcmF0b3JMaXN0LmFyZ3NBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHRoaXMub3BlcmF0b3JMaXN0Lmxhc3RDaHVuaykge1xuICAgICAgICAgIHRoaXMuZ2Z4LmVuZERyYXdpbmcoKTtcblxuICAgICAgICAgIGlmICh0aGlzLl9jYW52YXMpIHtcbiAgICAgICAgICAgIGNhbnZhc0luUmVuZGVyaW5nLmRlbGV0ZSh0aGlzLl9jYW52YXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIEludGVybmFsUmVuZGVyVGFzaztcbn0oKTtcblxuY29uc3QgdmVyc2lvbiA9ICcyLjYuMzQ3JztcbmV4cG9ydHMudmVyc2lvbiA9IHZlcnNpb247XG5jb25zdCBidWlsZCA9ICczYmU5YzY1Zic7XG5leHBvcnRzLmJ1aWxkID0gYnVpbGQ7XG5cbi8qKiovIH0pLFxuLyogNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5Gb250TG9hZGVyID0gZXhwb3J0cy5Gb250RmFjZU9iamVjdCA9IHZvaWQgMDtcblxudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygyKTtcblxuY2xhc3MgQmFzZUZvbnRMb2FkZXIge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgZG9jSWQsXG4gICAgb25VbnN1cHBvcnRlZEZlYXR1cmUsXG4gICAgb3duZXJEb2N1bWVudCA9IGdsb2JhbFRoaXMuZG9jdW1lbnRcbiAgfSkge1xuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBCYXNlRm9udExvYWRlcikge1xuICAgICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkNhbm5vdCBpbml0aWFsaXplIEJhc2VGb250TG9hZGVyLlwiKTtcbiAgICB9XG5cbiAgICB0aGlzLmRvY0lkID0gZG9jSWQ7XG4gICAgdGhpcy5fb25VbnN1cHBvcnRlZEZlYXR1cmUgPSBvblVuc3VwcG9ydGVkRmVhdHVyZTtcbiAgICB0aGlzLl9kb2N1bWVudCA9IG93bmVyRG9jdW1lbnQ7XG4gICAgdGhpcy5uYXRpdmVGb250RmFjZXMgPSBbXTtcbiAgICB0aGlzLnN0eWxlRWxlbWVudCA9IG51bGw7XG4gIH1cblxuICBhZGROYXRpdmVGb250RmFjZShuYXRpdmVGb250RmFjZSkge1xuICAgIHRoaXMubmF0aXZlRm9udEZhY2VzLnB1c2gobmF0aXZlRm9udEZhY2UpO1xuXG4gICAgdGhpcy5fZG9jdW1lbnQuZm9udHMuYWRkKG5hdGl2ZUZvbnRGYWNlKTtcbiAgfVxuXG4gIGluc2VydFJ1bGUocnVsZSkge1xuICAgIGxldCBzdHlsZUVsZW1lbnQgPSB0aGlzLnN0eWxlRWxlbWVudDtcblxuICAgIGlmICghc3R5bGVFbGVtZW50KSB7XG4gICAgICBzdHlsZUVsZW1lbnQgPSB0aGlzLnN0eWxlRWxlbWVudCA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICAgIHN0eWxlRWxlbWVudC5pZCA9IGBQREZKU19GT05UX1NUWUxFX1RBR18ke3RoaXMuZG9jSWR9YDtcblxuICAgICAgdGhpcy5fZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXS5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xuICAgIH1cblxuICAgIGNvbnN0IHN0eWxlU2hlZXQgPSBzdHlsZUVsZW1lbnQuc2hlZXQ7XG4gICAgc3R5bGVTaGVldC5pbnNlcnRSdWxlKHJ1bGUsIHN0eWxlU2hlZXQuY3NzUnVsZXMubGVuZ3RoKTtcbiAgfVxuXG4gIGNsZWFyKCkge1xuICAgIHRoaXMubmF0aXZlRm9udEZhY2VzLmZvckVhY2gobmF0aXZlRm9udEZhY2UgPT4ge1xuICAgICAgdGhpcy5fZG9jdW1lbnQuZm9udHMuZGVsZXRlKG5hdGl2ZUZvbnRGYWNlKTtcbiAgICB9KTtcbiAgICB0aGlzLm5hdGl2ZUZvbnRGYWNlcy5sZW5ndGggPSAwO1xuXG4gICAgaWYgKHRoaXMuc3R5bGVFbGVtZW50KSB7XG4gICAgICB0aGlzLnN0eWxlRWxlbWVudC5yZW1vdmUoKTtcbiAgICAgIHRoaXMuc3R5bGVFbGVtZW50ID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBhc3luYyBiaW5kKGZvbnQpIHtcbiAgICBpZiAoZm9udC5hdHRhY2hlZCB8fCBmb250Lm1pc3NpbmdGaWxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9udC5hdHRhY2hlZCA9IHRydWU7XG5cbiAgICBpZiAodGhpcy5pc0ZvbnRMb2FkaW5nQVBJU3VwcG9ydGVkKSB7XG4gICAgICBjb25zdCBuYXRpdmVGb250RmFjZSA9IGZvbnQuY3JlYXRlTmF0aXZlRm9udEZhY2UoKTtcblxuICAgICAgaWYgKG5hdGl2ZUZvbnRGYWNlKSB7XG4gICAgICAgIHRoaXMuYWRkTmF0aXZlRm9udEZhY2UobmF0aXZlRm9udEZhY2UpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgbmF0aXZlRm9udEZhY2UubG9hZGVkO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIHRoaXMuX29uVW5zdXBwb3J0ZWRGZWF0dXJlKHtcbiAgICAgICAgICAgIGZlYXR1cmVJZDogX3V0aWwuVU5TVVBQT1JURURfRkVBVFVSRVMuZXJyb3JGb250TG9hZE5hdGl2ZVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgKDAsIF91dGlsLndhcm4pKGBGYWlsZWQgdG8gbG9hZCBmb250ICcke25hdGl2ZUZvbnRGYWNlLmZhbWlseX0nOiAnJHtleH0nLmApO1xuICAgICAgICAgIGZvbnQuZGlzYWJsZUZvbnRGYWNlID0gdHJ1ZTtcbiAgICAgICAgICB0aHJvdyBleDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcnVsZSA9IGZvbnQuY3JlYXRlRm9udEZhY2VSdWxlKCk7XG5cbiAgICBpZiAocnVsZSkge1xuICAgICAgdGhpcy5pbnNlcnRSdWxlKHJ1bGUpO1xuXG4gICAgICBpZiAodGhpcy5pc1N5bmNGb250TG9hZGluZ1N1cHBvcnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5fcXVldWVMb2FkaW5nQ2FsbGJhY2socmVzb2x2ZSk7XG5cbiAgICAgICAgdGhpcy5fcHJlcGFyZUZvbnRMb2FkRXZlbnQoW3J1bGVdLCBbZm9udF0sIHJlcXVlc3QpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgX3F1ZXVlTG9hZGluZ0NhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkFic3RyYWN0IG1ldGhvZCBgX3F1ZXVlTG9hZGluZ0NhbGxiYWNrYC5cIik7XG4gIH1cblxuICBnZXQgaXNGb250TG9hZGluZ0FQSVN1cHBvcnRlZCgpIHtcbiAgICBjb25zdCBzdXBwb3J0ZWQgPSB0eXBlb2YgdGhpcy5fZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgISF0aGlzLl9kb2N1bWVudC5mb250cztcbiAgICByZXR1cm4gKDAsIF91dGlsLnNoYWRvdykodGhpcywgXCJpc0ZvbnRMb2FkaW5nQVBJU3VwcG9ydGVkXCIsIHN1cHBvcnRlZCk7XG4gIH1cblxuICBnZXQgaXNTeW5jRm9udExvYWRpbmdTdXBwb3J0ZWQoKSB7XG4gICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkFic3RyYWN0IG1ldGhvZCBgaXNTeW5jRm9udExvYWRpbmdTdXBwb3J0ZWRgLlwiKTtcbiAgfVxuXG4gIGdldCBfbG9hZFRlc3RGb250KCkge1xuICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJBYnN0cmFjdCBtZXRob2QgYF9sb2FkVGVzdEZvbnRgLlwiKTtcbiAgfVxuXG4gIF9wcmVwYXJlRm9udExvYWRFdmVudChydWxlcywgZm9udHNUb0xvYWQsIHJlcXVlc3QpIHtcbiAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiQWJzdHJhY3QgbWV0aG9kIGBfcHJlcGFyZUZvbnRMb2FkRXZlbnRgLlwiKTtcbiAgfVxuXG59XG5cbmxldCBGb250TG9hZGVyO1xuZXhwb3J0cy5Gb250TG9hZGVyID0gRm9udExvYWRlcjtcbntcbiAgZXhwb3J0cy5Gb250TG9hZGVyID0gRm9udExvYWRlciA9IGNsYXNzIEdlbmVyaWNGb250TG9hZGVyIGV4dGVuZHMgQmFzZUZvbnRMb2FkZXIge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgICAgc3VwZXIocGFyYW1zKTtcbiAgICAgIHRoaXMubG9hZGluZ0NvbnRleHQgPSB7XG4gICAgICAgIHJlcXVlc3RzOiBbXSxcbiAgICAgICAgbmV4dFJlcXVlc3RJZDogMFxuICAgICAgfTtcbiAgICAgIHRoaXMubG9hZFRlc3RGb250SWQgPSAwO1xuICAgIH1cblxuICAgIGdldCBpc1N5bmNGb250TG9hZGluZ1N1cHBvcnRlZCgpIHtcbiAgICAgIGxldCBzdXBwb3J0ZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgc3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG0gPSAvTW96aWxsYVxcLzUuMC4qP3J2OihcXGQrKS4qPyBHZWNrby8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuICAgICAgICBpZiAobSAmJiBtWzFdID49IDE0KSB7XG4gICAgICAgICAgc3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gKDAsIF91dGlsLnNoYWRvdykodGhpcywgXCJpc1N5bmNGb250TG9hZGluZ1N1cHBvcnRlZFwiLCBzdXBwb3J0ZWQpO1xuICAgIH1cblxuICAgIF9xdWV1ZUxvYWRpbmdDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgZnVuY3Rpb24gY29tcGxldGVSZXF1ZXN0KCkge1xuICAgICAgICAoMCwgX3V0aWwuYXNzZXJ0KSghcmVxdWVzdC5kb25lLCBcImNvbXBsZXRlUmVxdWVzdCgpIGNhbm5vdCBiZSBjYWxsZWQgdHdpY2UuXCIpO1xuICAgICAgICByZXF1ZXN0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgIHdoaWxlIChjb250ZXh0LnJlcXVlc3RzLmxlbmd0aCA+IDAgJiYgY29udGV4dC5yZXF1ZXN0c1swXS5kb25lKSB7XG4gICAgICAgICAgY29uc3Qgb3RoZXJSZXF1ZXN0ID0gY29udGV4dC5yZXF1ZXN0cy5zaGlmdCgpO1xuICAgICAgICAgIHNldFRpbWVvdXQob3RoZXJSZXF1ZXN0LmNhbGxiYWNrLCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5sb2FkaW5nQ29udGV4dDtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgIGlkOiBgcGRmanMtZm9udC1sb2FkaW5nLSR7Y29udGV4dC5uZXh0UmVxdWVzdElkKyt9YCxcbiAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgIGNvbXBsZXRlOiBjb21wbGV0ZVJlcXVlc3QsXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICB9O1xuICAgICAgY29udGV4dC5yZXF1ZXN0cy5wdXNoKHJlcXVlc3QpO1xuICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfVxuXG4gICAgZ2V0IF9sb2FkVGVzdEZvbnQoKSB7XG4gICAgICBjb25zdCBnZXRMb2FkVGVzdEZvbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhdG9iKFwiVDFSVVR3QUxBSUFBQXdBd1EwWkdJREh0Wmc0QUFBT1lBQUFBZ1VaR1ZFMWxrelp3QUFBRUhBQUFBQnhIUkVWR0FCUUFcIiArIFwiRlFBQUJEZ0FBQUFlVDFNdk1sWU5Zd2tBQUFFZ0FBQUFZR050WVhBQkRRTFVBQUFDTkFBQUFVSm9aV0ZrL3hWRkRRQUFcIiArIFwiQUx3QUFBQTJhR2hsWVFka0Erb0FBQUQwQUFBQUpHaHRkSGdENkFBQUFBQUVXQUFBQUFadFlYaHdBQUpRQUFBQUFSZ0FcIiArIFwiQUFBR2JtRnRaVmptZEg0QUFBR0FBQUFBc1hCdmMzVC9oZ0F6QUFBRGVBQUFBQ0FBQVFBQUFBRUFBTFpSRnNSZkR6ejFcIiArIFwiQUFzRDZBQUFBQURPQk9UTEFBQUFBTTRLSER3QUFBQUFBK2dESVFBQUFBZ0FBZ0FBQUFBQUFBQUJBQUFESVFBQUFGb0RcIiArIFwiNkFBQUFBQUQ2QUFCQUFBQUFBQUFBQUFBQUFBQUFBQUFBUUFBVUFBQUFnQUFBQVFENkFIMEFBVUFBQUtLQXJ3QUFBQ01cIiArIFwiQW9vQ3ZBQUFBZUFBTVFFQ0FBQUNBQVlKQUFBQUFBQUFBQUFBQVFBQUFBQUFBQUFBQUFBQUFGQm1SV1FBd0FBdUFDNERcIiArIFwiSVA4NEFGb0RJUUFBQUFBQUFRQUFBQUFBQUFBQUFDQUFJQUFCQUFBQURnQ3VBQUVBQUFBQUFBQUFBUUFBQUFFQUFBQUFcIiArIFwiQUFFQUFRQUFBQUVBQUFBQUFBSUFBUUFBQUFFQUFBQUFBQU1BQVFBQUFBRUFBQUFBQUFRQUFRQUFBQUVBQUFBQUFBVUFcIiArIFwiQVFBQUFBRUFBQUFBQUFZQUFRQUFBQU1BQVFRSkFBQUFBZ0FCQUFNQUFRUUpBQUVBQWdBQkFBTUFBUVFKQUFJQUFnQUJcIiArIFwiQUFNQUFRUUpBQU1BQWdBQkFBTUFBUVFKQUFRQUFnQUJBQU1BQVFRSkFBVUFBZ0FCQUFNQUFRUUpBQVlBQWdBQldBQllcIiArIFwiQUFBQUFBQUFBd0FBQUFNQUFBQWNBQUVBQUFBQUFEd0FBd0FCQUFBQUhBQUVBQ0FBQUFBRUFBUUFBUUFBQUM3Ly93QUFcIiArIFwiQUM3Ly8vL1RBQUVBQUFBQUFBQUJCZ0FBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFcIiArIFwiQUFBQUFBQUFBQUFBQUFBQUFBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFcIiArIFwiQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFcIiArIFwiQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFcIiArIFwiQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFcIiArIFwiQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBTUFBQUFBQUFEL2d3QXlBQUFBQVFBQUFBQUFBQUFBQUFBQUFBQUFcIiArIFwiQUFBQkFBUUVBQUVCQVFKWUFBRUJBU0g0RHdENEd3SEVBdmdjQS9nWEJJd01BWXVMK256NXRRWGtENWozQ0JMbkVRQUNcIiArIFwiQVFFQklWaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZQUFBQkFRQUFEd0FDQVFFRUUvdDNcIiArIFwiRG92NmZBSDZmQVQrZlBwOCtud0hEb3NNQ3ZtMUN2bTFEQXo2ZkJRQUFBQUFBQUFCQUFBQUFNbUpiekVBQUFBQXpnVGpcIiArIFwiRlFBQUFBRE9CT1FwQUFFQUFBQUFBQUFBREFBVUFBUUFBQUFCQUFBQUFnQUJBQUFBQUFBQUFBQUQ2QUFBQUFBQUFBPT1cIik7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gKDAsIF91dGlsLnNoYWRvdykodGhpcywgXCJfbG9hZFRlc3RGb250XCIsIGdldExvYWRUZXN0Rm9udCgpKTtcbiAgICB9XG5cbiAgICBfcHJlcGFyZUZvbnRMb2FkRXZlbnQocnVsZXMsIGZvbnRzLCByZXF1ZXN0KSB7XG4gICAgICBmdW5jdGlvbiBpbnQzMihkYXRhLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIGRhdGEuY2hhckNvZGVBdChvZmZzZXQpIDw8IDI0IHwgZGF0YS5jaGFyQ29kZUF0KG9mZnNldCArIDEpIDw8IDE2IHwgZGF0YS5jaGFyQ29kZUF0KG9mZnNldCArIDIpIDw8IDggfCBkYXRhLmNoYXJDb2RlQXQob2Zmc2V0ICsgMykgJiAweGZmO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzcGxpY2VTdHJpbmcocywgb2Zmc2V0LCByZW1vdmUsIGluc2VydCkge1xuICAgICAgICBjb25zdCBjaHVuazEgPSBzLnN1YnN0cmluZygwLCBvZmZzZXQpO1xuICAgICAgICBjb25zdCBjaHVuazIgPSBzLnN1YnN0cmluZyhvZmZzZXQgKyByZW1vdmUpO1xuICAgICAgICByZXR1cm4gY2h1bmsxICsgaW5zZXJ0ICsgY2h1bmsyO1xuICAgICAgfVxuXG4gICAgICBsZXQgaSwgaWk7XG5cbiAgICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG5cbiAgICAgIGNhbnZhcy53aWR0aCA9IDE7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gMTtcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICBsZXQgY2FsbGVkID0gMDtcblxuICAgICAgZnVuY3Rpb24gaXNGb250UmVhZHkobmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGVkKys7XG5cbiAgICAgICAgaWYgKGNhbGxlZCA+IDMwKSB7XG4gICAgICAgICAgKDAsIF91dGlsLndhcm4pKFwiTG9hZCB0ZXN0IGZvbnQgbmV2ZXIgbG9hZGVkLlwiKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5mb250ID0gXCIzMHB4IFwiICsgbmFtZTtcbiAgICAgICAgY3R4LmZpbGxUZXh0KFwiLlwiLCAwLCAyMCk7XG4gICAgICAgIGNvbnN0IGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSk7XG5cbiAgICAgICAgaWYgKGltYWdlRGF0YS5kYXRhWzNdID4gMCkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0VGltZW91dChpc0ZvbnRSZWFkeS5iaW5kKG51bGwsIG5hbWUsIGNhbGxiYWNrKSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxvYWRUZXN0Rm9udElkID0gYGx0JHtEYXRlLm5vdygpfSR7dGhpcy5sb2FkVGVzdEZvbnRJZCsrfWA7XG4gICAgICBsZXQgZGF0YSA9IHRoaXMuX2xvYWRUZXN0Rm9udDtcbiAgICAgIGNvbnN0IENPTU1FTlRfT0ZGU0VUID0gOTc2O1xuICAgICAgZGF0YSA9IHNwbGljZVN0cmluZyhkYXRhLCBDT01NRU5UX09GRlNFVCwgbG9hZFRlc3RGb250SWQubGVuZ3RoLCBsb2FkVGVzdEZvbnRJZCk7XG4gICAgICBjb25zdCBDRkZfQ0hFQ0tTVU1fT0ZGU0VUID0gMTY7XG4gICAgICBjb25zdCBYWFhYX1ZBTFVFID0gMHg1ODU4NTg1ODtcbiAgICAgIGxldCBjaGVja3N1bSA9IGludDMyKGRhdGEsIENGRl9DSEVDS1NVTV9PRkZTRVQpO1xuXG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IGxvYWRUZXN0Rm9udElkLmxlbmd0aCAtIDM7IGkgPCBpaTsgaSArPSA0KSB7XG4gICAgICAgIGNoZWNrc3VtID0gY2hlY2tzdW0gLSBYWFhYX1ZBTFVFICsgaW50MzIobG9hZFRlc3RGb250SWQsIGkpIHwgMDtcbiAgICAgIH1cblxuICAgICAgaWYgKGkgPCBsb2FkVGVzdEZvbnRJZC5sZW5ndGgpIHtcbiAgICAgICAgY2hlY2tzdW0gPSBjaGVja3N1bSAtIFhYWFhfVkFMVUUgKyBpbnQzMihsb2FkVGVzdEZvbnRJZCArIFwiWFhYXCIsIGkpIHwgMDtcbiAgICAgIH1cblxuICAgICAgZGF0YSA9IHNwbGljZVN0cmluZyhkYXRhLCBDRkZfQ0hFQ0tTVU1fT0ZGU0VULCA0LCAoMCwgX3V0aWwuc3RyaW5nMzIpKGNoZWNrc3VtKSk7XG4gICAgICBjb25zdCB1cmwgPSBgdXJsKGRhdGE6Zm9udC9vcGVudHlwZTtiYXNlNjQsJHtidG9hKGRhdGEpfSk7YDtcbiAgICAgIGNvbnN0IHJ1bGUgPSBgQGZvbnQtZmFjZSB7Zm9udC1mYW1pbHk6XCIke2xvYWRUZXN0Rm9udElkfVwiO3NyYzoke3VybH19YDtcbiAgICAgIHRoaXMuaW5zZXJ0UnVsZShydWxlKTtcbiAgICAgIGNvbnN0IG5hbWVzID0gW107XG5cbiAgICAgIGZvciAoaSA9IDAsIGlpID0gZm9udHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBuYW1lcy5wdXNoKGZvbnRzW2ldLmxvYWRlZE5hbWUpO1xuICAgICAgfVxuXG4gICAgICBuYW1lcy5wdXNoKGxvYWRUZXN0Rm9udElkKTtcblxuICAgICAgY29uc3QgZGl2ID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblxuICAgICAgZGl2LnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgICAgZGl2LnN0eWxlLndpZHRoID0gZGl2LnN0eWxlLmhlaWdodCA9IFwiMTBweFwiO1xuICAgICAgZGl2LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgZGl2LnN0eWxlLnRvcCA9IGRpdi5zdHlsZS5sZWZ0ID0gXCIwcHhcIjtcblxuICAgICAgZm9yIChpID0gMCwgaWkgPSBuYW1lcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGNvbnN0IHNwYW4gPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcblxuICAgICAgICBzcGFuLnRleHRDb250ZW50ID0gXCJIaVwiO1xuICAgICAgICBzcGFuLnN0eWxlLmZvbnRGYW1pbHkgPSBuYW1lc1tpXTtcbiAgICAgICAgZGl2LmFwcGVuZENoaWxkKHNwYW4pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XG5cbiAgICAgIGlzRm9udFJlYWR5KGxvYWRUZXN0Rm9udElkLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2RvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZGl2KTtcblxuICAgICAgICByZXF1ZXN0LmNvbXBsZXRlKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgfTtcbn1cblxuY2xhc3MgRm9udEZhY2VPYmplY3Qge1xuICBjb25zdHJ1Y3Rvcih0cmFuc2xhdGVkRGF0YSwge1xuICAgIGlzRXZhbFN1cHBvcnRlZCA9IHRydWUsXG4gICAgZGlzYWJsZUZvbnRGYWNlID0gZmFsc2UsXG4gICAgaWdub3JlRXJyb3JzID0gZmFsc2UsXG4gICAgb25VbnN1cHBvcnRlZEZlYXR1cmUgPSBudWxsLFxuICAgIGZvbnRSZWdpc3RyeSA9IG51bGxcbiAgfSkge1xuICAgIHRoaXMuY29tcGlsZWRHbHlwaHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgZm9yIChjb25zdCBpIGluIHRyYW5zbGF0ZWREYXRhKSB7XG4gICAgICB0aGlzW2ldID0gdHJhbnNsYXRlZERhdGFbaV07XG4gICAgfVxuXG4gICAgdGhpcy5pc0V2YWxTdXBwb3J0ZWQgPSBpc0V2YWxTdXBwb3J0ZWQgIT09IGZhbHNlO1xuICAgIHRoaXMuZGlzYWJsZUZvbnRGYWNlID0gZGlzYWJsZUZvbnRGYWNlID09PSB0cnVlO1xuICAgIHRoaXMuaWdub3JlRXJyb3JzID0gaWdub3JlRXJyb3JzID09PSB0cnVlO1xuICAgIHRoaXMuX29uVW5zdXBwb3J0ZWRGZWF0dXJlID0gb25VbnN1cHBvcnRlZEZlYXR1cmU7XG4gICAgdGhpcy5mb250UmVnaXN0cnkgPSBmb250UmVnaXN0cnk7XG4gIH1cblxuICBjcmVhdGVOYXRpdmVGb250RmFjZSgpIHtcbiAgICBpZiAoIXRoaXMuZGF0YSB8fCB0aGlzLmRpc2FibGVGb250RmFjZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgbmF0aXZlRm9udEZhY2UgPSBuZXcgRm9udEZhY2UodGhpcy5sb2FkZWROYW1lLCB0aGlzLmRhdGEsIHt9KTtcblxuICAgIGlmICh0aGlzLmZvbnRSZWdpc3RyeSkge1xuICAgICAgdGhpcy5mb250UmVnaXN0cnkucmVnaXN0ZXJGb250KHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiBuYXRpdmVGb250RmFjZTtcbiAgfVxuXG4gIGNyZWF0ZUZvbnRGYWNlUnVsZSgpIHtcbiAgICBpZiAoIXRoaXMuZGF0YSB8fCB0aGlzLmRpc2FibGVGb250RmFjZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgZGF0YSA9ICgwLCBfdXRpbC5ieXRlc1RvU3RyaW5nKShuZXcgVWludDhBcnJheSh0aGlzLmRhdGEpKTtcbiAgICBjb25zdCB1cmwgPSBgdXJsKGRhdGE6JHt0aGlzLm1pbWV0eXBlfTtiYXNlNjQsJHtidG9hKGRhdGEpfSk7YDtcbiAgICBjb25zdCBydWxlID0gYEBmb250LWZhY2Uge2ZvbnQtZmFtaWx5OlwiJHt0aGlzLmxvYWRlZE5hbWV9XCI7c3JjOiR7dXJsfX1gO1xuXG4gICAgaWYgKHRoaXMuZm9udFJlZ2lzdHJ5KSB7XG4gICAgICB0aGlzLmZvbnRSZWdpc3RyeS5yZWdpc3RlckZvbnQodGhpcywgdXJsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcnVsZTtcbiAgfVxuXG4gIGdldFBhdGhHZW5lcmF0b3Iob2JqcywgY2hhcmFjdGVyKSB7XG4gICAgaWYgKHRoaXMuY29tcGlsZWRHbHlwaHNbY2hhcmFjdGVyXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21waWxlZEdseXBoc1tjaGFyYWN0ZXJdO1xuICAgIH1cblxuICAgIGxldCBjbWRzLCBjdXJyZW50O1xuXG4gICAgdHJ5IHtcbiAgICAgIGNtZHMgPSBvYmpzLmdldCh0aGlzLmxvYWRlZE5hbWUgKyBcIl9wYXRoX1wiICsgY2hhcmFjdGVyKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgaWYgKCF0aGlzLmlnbm9yZUVycm9ycykge1xuICAgICAgICB0aHJvdyBleDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX29uVW5zdXBwb3J0ZWRGZWF0dXJlKSB7XG4gICAgICAgIHRoaXMuX29uVW5zdXBwb3J0ZWRGZWF0dXJlKHtcbiAgICAgICAgICBmZWF0dXJlSWQ6IF91dGlsLlVOU1VQUE9SVEVEX0ZFQVRVUkVTLmVycm9yRm9udEdldFBhdGhcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgICgwLCBfdXRpbC53YXJuKShgZ2V0UGF0aEdlbmVyYXRvciAtIGlnbm9yaW5nIGNoYXJhY3RlcjogXCIke2V4fVwiLmApO1xuICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZWRHbHlwaHNbY2hhcmFjdGVyXSA9IGZ1bmN0aW9uIChjLCBzaXplKSB7fTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0V2YWxTdXBwb3J0ZWQgJiYgX3V0aWwuSXNFdmFsU3VwcG9ydGVkQ2FjaGVkLnZhbHVlKSB7XG4gICAgICBsZXQgYXJncyxcbiAgICAgICAgICBqcyA9IFwiXCI7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGNtZHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBjdXJyZW50ID0gY21kc1tpXTtcblxuICAgICAgICBpZiAoY3VycmVudC5hcmdzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBhcmdzID0gY3VycmVudC5hcmdzLmpvaW4oXCIsXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFyZ3MgPSBcIlwiO1xuICAgICAgICB9XG5cbiAgICAgICAganMgKz0gXCJjLlwiICsgY3VycmVudC5jbWQgKyBcIihcIiArIGFyZ3MgKyBcIik7XFxuXCI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVkR2x5cGhzW2NoYXJhY3Rlcl0gPSBuZXcgRnVuY3Rpb24oXCJjXCIsIFwic2l6ZVwiLCBqcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY29tcGlsZWRHbHlwaHNbY2hhcmFjdGVyXSA9IGZ1bmN0aW9uIChjLCBzaXplKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBjbWRzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgY3VycmVudCA9IGNtZHNbaV07XG5cbiAgICAgICAgaWYgKGN1cnJlbnQuY21kID09PSBcInNjYWxlXCIpIHtcbiAgICAgICAgICBjdXJyZW50LmFyZ3MgPSBbc2l6ZSwgLXNpemVdO1xuICAgICAgICB9XG5cbiAgICAgICAgY1tjdXJyZW50LmNtZF0uYXBwbHkoYywgY3VycmVudC5hcmdzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbn1cblxuZXhwb3J0cy5Gb250RmFjZU9iamVjdCA9IEZvbnRGYWNlT2JqZWN0O1xuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuTm9kZUNNYXBSZWFkZXJGYWN0b3J5ID0gZXhwb3J0cy5Ob2RlQ2FudmFzRmFjdG9yeSA9IHZvaWQgMDtcblxudmFyIF9kaXNwbGF5X3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcblxudmFyIF9pc19ub2RlID0gX193X3BkZmpzX3JlcXVpcmVfXyg0KTtcblxudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygyKTtcblxubGV0IE5vZGVDYW52YXNGYWN0b3J5ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiTm90IGltcGxlbWVudGVkOiBOb2RlQ2FudmFzRmFjdG9yeVwiKTtcbiAgfVxuXG59O1xuZXhwb3J0cy5Ob2RlQ2FudmFzRmFjdG9yeSA9IE5vZGVDYW52YXNGYWN0b3J5O1xubGV0IE5vZGVDTWFwUmVhZGVyRmFjdG9yeSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIk5vdCBpbXBsZW1lbnRlZDogTm9kZUNNYXBSZWFkZXJGYWN0b3J5XCIpO1xuICB9XG5cbn07XG5leHBvcnRzLk5vZGVDTWFwUmVhZGVyRmFjdG9yeSA9IE5vZGVDTWFwUmVhZGVyRmFjdG9yeTtcblxuaWYgKF9pc19ub2RlLmlzTm9kZUpTKSB7XG4gIGV4cG9ydHMuTm9kZUNhbnZhc0ZhY3RvcnkgPSBOb2RlQ2FudmFzRmFjdG9yeSA9IGNsYXNzIGV4dGVuZHMgX2Rpc3BsYXlfdXRpbHMuQmFzZUNhbnZhc0ZhY3Rvcnkge1xuICAgIGNyZWF0ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICBpZiAod2lkdGggPD0gMCB8fCBoZWlnaHQgPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNhbnZhcyBzaXplXCIpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBDYW52YXMgPSByZXF1aXJlKFwiY2FudmFzXCIpO1xuXG4gICAgICBjb25zdCBjYW52YXMgPSBDYW52YXMuY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2FudmFzLFxuICAgICAgICBjb250ZXh0OiBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpXG4gICAgICB9O1xuICAgIH1cblxuICB9O1xuICBleHBvcnRzLk5vZGVDTWFwUmVhZGVyRmFjdG9yeSA9IE5vZGVDTWFwUmVhZGVyRmFjdG9yeSA9IGNsYXNzIGV4dGVuZHMgX2Rpc3BsYXlfdXRpbHMuQmFzZUNNYXBSZWFkZXJGYWN0b3J5IHtcbiAgICBfZmV0Y2hEYXRhKHVybCwgY29tcHJlc3Npb25UeXBlKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcblxuICAgICAgICBmcy5yZWFkRmlsZSh1cmwsIChlcnJvciwgZGF0YSkgPT4ge1xuICAgICAgICAgIGlmIChlcnJvciB8fCAhZGF0YSkge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihlcnJvcikpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgY01hcERhdGE6IG5ldyBVaW50OEFycmF5KGRhdGEpLFxuICAgICAgICAgICAgY29tcHJlc3Npb25UeXBlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gIH07XG59XG5cbi8qKiovIH0pLFxuLyogOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5Bbm5vdGF0aW9uU3RvcmFnZSA9IHZvaWQgMDtcblxuY2xhc3MgQW5ub3RhdGlvblN0b3JhZ2Uge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9zdG9yYWdlID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX21vZGlmaWVkID0gZmFsc2U7XG4gICAgdGhpcy5vblNldE1vZGlmaWVkID0gbnVsbDtcbiAgICB0aGlzLm9uUmVzZXRNb2RpZmllZCA9IG51bGw7XG4gIH1cblxuICBnZXRPckNyZWF0ZVZhbHVlKGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX3N0b3JhZ2UuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdG9yYWdlLmdldChrZXkpO1xuICAgIH1cblxuICAgIHRoaXMuX3N0b3JhZ2Uuc2V0KGtleSwgZGVmYXVsdFZhbHVlKTtcblxuICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gIH1cblxuICBzZXRWYWx1ZShrZXksIHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX3N0b3JhZ2UuZ2V0KGtleSkgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl9zZXRNb2RpZmllZCgpO1xuICAgIH1cblxuICAgIHRoaXMuX3N0b3JhZ2Uuc2V0KGtleSwgdmFsdWUpO1xuICB9XG5cbiAgZ2V0QWxsKCkge1xuICAgIGlmICh0aGlzLl9zdG9yYWdlLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXModGhpcy5fc3RvcmFnZSk7XG4gIH1cblxuICBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RvcmFnZS5zaXplO1xuICB9XG5cbiAgX3NldE1vZGlmaWVkKCkge1xuICAgIGlmICghdGhpcy5fbW9kaWZpZWQpIHtcbiAgICAgIHRoaXMuX21vZGlmaWVkID0gdHJ1ZTtcblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9uU2V0TW9kaWZpZWQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLm9uU2V0TW9kaWZpZWQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXNldE1vZGlmaWVkKCkge1xuICAgIGlmICh0aGlzLl9tb2RpZmllZCkge1xuICAgICAgdGhpcy5fbW9kaWZpZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9uUmVzZXRNb2RpZmllZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMub25SZXNldE1vZGlmaWVkKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn1cblxuZXhwb3J0cy5Bbm5vdGF0aW9uU3RvcmFnZSA9IEFubm90YXRpb25TdG9yYWdlO1xuXG4vKioqLyB9KSxcbi8qIDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuYXBpQ29tcGF0aWJpbGl0eVBhcmFtcyA9IHZvaWQgMDtcblxudmFyIF9pc19ub2RlID0gX193X3BkZmpzX3JlcXVpcmVfXyg0KTtcblxuY29uc3QgY29tcGF0aWJpbGl0eVBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG57XG4gIChmdW5jdGlvbiBjaGVja0ZvbnRGYWNlKCkge1xuICAgIGlmIChfaXNfbm9kZS5pc05vZGVKUykge1xuICAgICAgY29tcGF0aWJpbGl0eVBhcmFtcy5kaXNhYmxlRm9udEZhY2UgPSB0cnVlO1xuICAgIH1cbiAgfSkoKTtcbn1cbmNvbnN0IGFwaUNvbXBhdGliaWxpdHlQYXJhbXMgPSBPYmplY3QuZnJlZXplKGNvbXBhdGliaWxpdHlQYXJhbXMpO1xuZXhwb3J0cy5hcGlDb21wYXRpYmlsaXR5UGFyYW1zID0gYXBpQ29tcGF0aWJpbGl0eVBhcmFtcztcblxuLyoqKi8gfSksXG4vKiAxMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5DYW52YXNHcmFwaGljcyA9IHZvaWQgMDtcblxudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygyKTtcblxudmFyIF9wYXR0ZXJuX2hlbHBlciA9IF9fd19wZGZqc19yZXF1aXJlX18oMTEpO1xuXG52YXIgTUlOX0ZPTlRfU0laRSA9IDE2O1xudmFyIE1BWF9GT05UX1NJWkUgPSAxMDA7XG52YXIgTUFYX0dST1VQX1NJWkUgPSA0MDk2O1xudmFyIE1JTl9XSURUSF9GQUNUT1IgPSAwLjY1O1xudmFyIENPTVBJTEVfVFlQRTNfR0xZUEhTID0gdHJ1ZTtcbnZhciBNQVhfU0laRV9UT19DT01QSUxFID0gMTAwMDtcbnZhciBGVUxMX0NIVU5LX0hFSUdIVCA9IDE2O1xuXG5mdW5jdGlvbiBhZGRDb250ZXh0Q3VycmVudFRyYW5zZm9ybShjdHgpIHtcbiAgaWYgKCFjdHgubW96Q3VycmVudFRyYW5zZm9ybSkge1xuICAgIGN0eC5fb3JpZ2luYWxTYXZlID0gY3R4LnNhdmU7XG4gICAgY3R4Ll9vcmlnaW5hbFJlc3RvcmUgPSBjdHgucmVzdG9yZTtcbiAgICBjdHguX29yaWdpbmFsUm90YXRlID0gY3R4LnJvdGF0ZTtcbiAgICBjdHguX29yaWdpbmFsU2NhbGUgPSBjdHguc2NhbGU7XG4gICAgY3R4Ll9vcmlnaW5hbFRyYW5zbGF0ZSA9IGN0eC50cmFuc2xhdGU7XG4gICAgY3R4Ll9vcmlnaW5hbFRyYW5zZm9ybSA9IGN0eC50cmFuc2Zvcm07XG4gICAgY3R4Ll9vcmlnaW5hbFNldFRyYW5zZm9ybSA9IGN0eC5zZXRUcmFuc2Zvcm07XG4gICAgY3R4Ll90cmFuc2Zvcm1NYXRyaXggPSBjdHguX3RyYW5zZm9ybU1hdHJpeCB8fCBbMSwgMCwgMCwgMSwgMCwgMF07XG4gICAgY3R4Ll90cmFuc2Zvcm1TdGFjayA9IFtdO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIFwibW96Q3VycmVudFRyYW5zZm9ybVwiLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldEN1cnJlbnRUcmFuc2Zvcm0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc2Zvcm1NYXRyaXg7XG4gICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwgXCJtb3pDdXJyZW50VHJhbnNmb3JtSW52ZXJzZVwiLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKCkge1xuICAgICAgICB2YXIgbSA9IHRoaXMuX3RyYW5zZm9ybU1hdHJpeDtcbiAgICAgICAgdmFyIGEgPSBtWzBdLFxuICAgICAgICAgICAgYiA9IG1bMV0sXG4gICAgICAgICAgICBjID0gbVsyXSxcbiAgICAgICAgICAgIGQgPSBtWzNdLFxuICAgICAgICAgICAgZSA9IG1bNF0sXG4gICAgICAgICAgICBmID0gbVs1XTtcbiAgICAgICAgdmFyIGFkX2JjID0gYSAqIGQgLSBiICogYztcbiAgICAgICAgdmFyIGJjX2FkID0gYiAqIGMgLSBhICogZDtcbiAgICAgICAgcmV0dXJuIFtkIC8gYWRfYmMsIGIgLyBiY19hZCwgYyAvIGJjX2FkLCBhIC8gYWRfYmMsIChkICogZSAtIGMgKiBmKSAvIGJjX2FkLCAoYiAqIGUgLSBhICogZikgLyBhZF9iY107XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjdHguc2F2ZSA9IGZ1bmN0aW9uIGN0eFNhdmUoKSB7XG4gICAgICB2YXIgb2xkID0gdGhpcy5fdHJhbnNmb3JtTWF0cml4O1xuXG4gICAgICB0aGlzLl90cmFuc2Zvcm1TdGFjay5wdXNoKG9sZCk7XG5cbiAgICAgIHRoaXMuX3RyYW5zZm9ybU1hdHJpeCA9IG9sZC5zbGljZSgwLCA2KTtcblxuICAgICAgdGhpcy5fb3JpZ2luYWxTYXZlKCk7XG4gICAgfTtcblxuICAgIGN0eC5yZXN0b3JlID0gZnVuY3Rpb24gY3R4UmVzdG9yZSgpIHtcbiAgICAgIHZhciBwcmV2ID0gdGhpcy5fdHJhbnNmb3JtU3RhY2sucG9wKCk7XG5cbiAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybU1hdHJpeCA9IHByZXY7XG5cbiAgICAgICAgdGhpcy5fb3JpZ2luYWxSZXN0b3JlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGN0eC50cmFuc2xhdGUgPSBmdW5jdGlvbiBjdHhUcmFuc2xhdGUoeCwgeSkge1xuICAgICAgdmFyIG0gPSB0aGlzLl90cmFuc2Zvcm1NYXRyaXg7XG4gICAgICBtWzRdID0gbVswXSAqIHggKyBtWzJdICogeSArIG1bNF07XG4gICAgICBtWzVdID0gbVsxXSAqIHggKyBtWzNdICogeSArIG1bNV07XG5cbiAgICAgIHRoaXMuX29yaWdpbmFsVHJhbnNsYXRlKHgsIHkpO1xuICAgIH07XG5cbiAgICBjdHguc2NhbGUgPSBmdW5jdGlvbiBjdHhTY2FsZSh4LCB5KSB7XG4gICAgICB2YXIgbSA9IHRoaXMuX3RyYW5zZm9ybU1hdHJpeDtcbiAgICAgIG1bMF0gPSBtWzBdICogeDtcbiAgICAgIG1bMV0gPSBtWzFdICogeDtcbiAgICAgIG1bMl0gPSBtWzJdICogeTtcbiAgICAgIG1bM10gPSBtWzNdICogeTtcblxuICAgICAgdGhpcy5fb3JpZ2luYWxTY2FsZSh4LCB5KTtcbiAgICB9O1xuXG4gICAgY3R4LnRyYW5zZm9ybSA9IGZ1bmN0aW9uIGN0eFRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgICB2YXIgbSA9IHRoaXMuX3RyYW5zZm9ybU1hdHJpeDtcbiAgICAgIHRoaXMuX3RyYW5zZm9ybU1hdHJpeCA9IFttWzBdICogYSArIG1bMl0gKiBiLCBtWzFdICogYSArIG1bM10gKiBiLCBtWzBdICogYyArIG1bMl0gKiBkLCBtWzFdICogYyArIG1bM10gKiBkLCBtWzBdICogZSArIG1bMl0gKiBmICsgbVs0XSwgbVsxXSAqIGUgKyBtWzNdICogZiArIG1bNV1dO1xuXG4gICAgICBjdHguX29yaWdpbmFsVHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpO1xuICAgIH07XG5cbiAgICBjdHguc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gY3R4U2V0VHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICAgIHRoaXMuX3RyYW5zZm9ybU1hdHJpeCA9IFthLCBiLCBjLCBkLCBlLCBmXTtcblxuICAgICAgY3R4Ll9vcmlnaW5hbFNldFRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKTtcbiAgICB9O1xuXG4gICAgY3R4LnJvdGF0ZSA9IGZ1bmN0aW9uIGN0eFJvdGF0ZShhbmdsZSkge1xuICAgICAgdmFyIGNvc1ZhbHVlID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgdmFyIHNpblZhbHVlID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgdmFyIG0gPSB0aGlzLl90cmFuc2Zvcm1NYXRyaXg7XG4gICAgICB0aGlzLl90cmFuc2Zvcm1NYXRyaXggPSBbbVswXSAqIGNvc1ZhbHVlICsgbVsyXSAqIHNpblZhbHVlLCBtWzFdICogY29zVmFsdWUgKyBtWzNdICogc2luVmFsdWUsIG1bMF0gKiAtc2luVmFsdWUgKyBtWzJdICogY29zVmFsdWUsIG1bMV0gKiAtc2luVmFsdWUgKyBtWzNdICogY29zVmFsdWUsIG1bNF0sIG1bNV1dO1xuXG4gICAgICB0aGlzLl9vcmlnaW5hbFJvdGF0ZShhbmdsZSk7XG4gICAgfTtcbiAgfVxufVxuXG52YXIgQ2FjaGVkQ2FudmFzZXMgPSBmdW5jdGlvbiBDYWNoZWRDYW52YXNlc0Nsb3N1cmUoKSB7XG4gIGZ1bmN0aW9uIENhY2hlZENhbnZhc2VzKGNhbnZhc0ZhY3RvcnkpIHtcbiAgICB0aGlzLmNhbnZhc0ZhY3RvcnkgPSBjYW52YXNGYWN0b3J5O1xuICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG5cbiAgQ2FjaGVkQ2FudmFzZXMucHJvdG90eXBlID0ge1xuICAgIGdldENhbnZhczogZnVuY3Rpb24gQ2FjaGVkQ2FudmFzZXNfZ2V0Q2FudmFzKGlkLCB3aWR0aCwgaGVpZ2h0LCB0cmFja1RyYW5zZm9ybSkge1xuICAgICAgdmFyIGNhbnZhc0VudHJ5O1xuXG4gICAgICBpZiAodGhpcy5jYWNoZVtpZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjYW52YXNFbnRyeSA9IHRoaXMuY2FjaGVbaWRdO1xuICAgICAgICB0aGlzLmNhbnZhc0ZhY3RvcnkucmVzZXQoY2FudmFzRW50cnksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBjYW52YXNFbnRyeS5jb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbnZhc0VudHJ5ID0gdGhpcy5jYW52YXNGYWN0b3J5LmNyZWF0ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5jYWNoZVtpZF0gPSBjYW52YXNFbnRyeTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRyYWNrVHJhbnNmb3JtKSB7XG4gICAgICAgIGFkZENvbnRleHRDdXJyZW50VHJhbnNmb3JtKGNhbnZhc0VudHJ5LmNvbnRleHQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2FudmFzRW50cnk7XG4gICAgfSxcblxuICAgIGNsZWFyKCkge1xuICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5jYWNoZSkge1xuICAgICAgICB2YXIgY2FudmFzRW50cnkgPSB0aGlzLmNhY2hlW2lkXTtcbiAgICAgICAgdGhpcy5jYW52YXNGYWN0b3J5LmRlc3Ryb3koY2FudmFzRW50cnkpO1xuICAgICAgICBkZWxldGUgdGhpcy5jYWNoZVtpZF07XG4gICAgICB9XG4gICAgfVxuXG4gIH07XG4gIHJldHVybiBDYWNoZWRDYW52YXNlcztcbn0oKTtcblxuZnVuY3Rpb24gY29tcGlsZVR5cGUzR2x5cGgoaW1nRGF0YSkge1xuICB2YXIgUE9JTlRfVE9fUFJPQ0VTU19MSU1JVCA9IDEwMDA7XG4gIHZhciB3aWR0aCA9IGltZ0RhdGEud2lkdGgsXG4gICAgICBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodDtcbiAgdmFyIGksXG4gICAgICBqLFxuICAgICAgajAsXG4gICAgICB3aWR0aDEgPSB3aWR0aCArIDE7XG4gIHZhciBwb2ludHMgPSBuZXcgVWludDhBcnJheSh3aWR0aDEgKiAoaGVpZ2h0ICsgMSkpO1xuICB2YXIgUE9JTlRfVFlQRVMgPSBuZXcgVWludDhBcnJheShbMCwgMiwgNCwgMCwgMSwgMCwgNSwgNCwgOCwgMTAsIDAsIDgsIDAsIDIsIDEsIDBdKTtcbiAgdmFyIGxpbmVTaXplID0gd2lkdGggKyA3ICYgfjcsXG4gICAgICBkYXRhMCA9IGltZ0RhdGEuZGF0YTtcbiAgdmFyIGRhdGEgPSBuZXcgVWludDhBcnJheShsaW5lU2l6ZSAqIGhlaWdodCksXG4gICAgICBwb3MgPSAwLFxuICAgICAgaWk7XG5cbiAgZm9yIChpID0gMCwgaWkgPSBkYXRhMC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgdmFyIG1hc2sgPSAxMjgsXG4gICAgICAgIGVsZW0gPSBkYXRhMFtpXTtcblxuICAgIHdoaWxlIChtYXNrID4gMCkge1xuICAgICAgZGF0YVtwb3MrK10gPSBlbGVtICYgbWFzayA/IDAgOiAyNTU7XG4gICAgICBtYXNrID4+PSAxO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb3VudCA9IDA7XG4gIHBvcyA9IDA7XG5cbiAgaWYgKGRhdGFbcG9zXSAhPT0gMCkge1xuICAgIHBvaW50c1swXSA9IDE7XG4gICAgKytjb3VudDtcbiAgfVxuXG4gIGZvciAoaiA9IDE7IGogPCB3aWR0aDsgaisrKSB7XG4gICAgaWYgKGRhdGFbcG9zXSAhPT0gZGF0YVtwb3MgKyAxXSkge1xuICAgICAgcG9pbnRzW2pdID0gZGF0YVtwb3NdID8gMiA6IDE7XG4gICAgICArK2NvdW50O1xuICAgIH1cblxuICAgIHBvcysrO1xuICB9XG5cbiAgaWYgKGRhdGFbcG9zXSAhPT0gMCkge1xuICAgIHBvaW50c1tqXSA9IDI7XG4gICAgKytjb3VudDtcbiAgfVxuXG4gIGZvciAoaSA9IDE7IGkgPCBoZWlnaHQ7IGkrKykge1xuICAgIHBvcyA9IGkgKiBsaW5lU2l6ZTtcbiAgICBqMCA9IGkgKiB3aWR0aDE7XG5cbiAgICBpZiAoZGF0YVtwb3MgLSBsaW5lU2l6ZV0gIT09IGRhdGFbcG9zXSkge1xuICAgICAgcG9pbnRzW2owXSA9IGRhdGFbcG9zXSA/IDEgOiA4O1xuICAgICAgKytjb3VudDtcbiAgICB9XG5cbiAgICB2YXIgc3VtID0gKGRhdGFbcG9zXSA/IDQgOiAwKSArIChkYXRhW3BvcyAtIGxpbmVTaXplXSA/IDggOiAwKTtcblxuICAgIGZvciAoaiA9IDE7IGogPCB3aWR0aDsgaisrKSB7XG4gICAgICBzdW0gPSAoc3VtID4+IDIpICsgKGRhdGFbcG9zICsgMV0gPyA0IDogMCkgKyAoZGF0YVtwb3MgLSBsaW5lU2l6ZSArIDFdID8gOCA6IDApO1xuXG4gICAgICBpZiAoUE9JTlRfVFlQRVNbc3VtXSkge1xuICAgICAgICBwb2ludHNbajAgKyBqXSA9IFBPSU5UX1RZUEVTW3N1bV07XG4gICAgICAgICsrY291bnQ7XG4gICAgICB9XG5cbiAgICAgIHBvcysrO1xuICAgIH1cblxuICAgIGlmIChkYXRhW3BvcyAtIGxpbmVTaXplXSAhPT0gZGF0YVtwb3NdKSB7XG4gICAgICBwb2ludHNbajAgKyBqXSA9IGRhdGFbcG9zXSA/IDIgOiA0O1xuICAgICAgKytjb3VudDtcbiAgICB9XG5cbiAgICBpZiAoY291bnQgPiBQT0lOVF9UT19QUk9DRVNTX0xJTUlUKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBwb3MgPSBsaW5lU2l6ZSAqIChoZWlnaHQgLSAxKTtcbiAgajAgPSBpICogd2lkdGgxO1xuXG4gIGlmIChkYXRhW3Bvc10gIT09IDApIHtcbiAgICBwb2ludHNbajBdID0gODtcbiAgICArK2NvdW50O1xuICB9XG5cbiAgZm9yIChqID0gMTsgaiA8IHdpZHRoOyBqKyspIHtcbiAgICBpZiAoZGF0YVtwb3NdICE9PSBkYXRhW3BvcyArIDFdKSB7XG4gICAgICBwb2ludHNbajAgKyBqXSA9IGRhdGFbcG9zXSA/IDQgOiA4O1xuICAgICAgKytjb3VudDtcbiAgICB9XG5cbiAgICBwb3MrKztcbiAgfVxuXG4gIGlmIChkYXRhW3Bvc10gIT09IDApIHtcbiAgICBwb2ludHNbajAgKyBqXSA9IDQ7XG4gICAgKytjb3VudDtcbiAgfVxuXG4gIGlmIChjb3VudCA+IFBPSU5UX1RPX1BST0NFU1NfTElNSVQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBzdGVwcyA9IG5ldyBJbnQzMkFycmF5KFswLCB3aWR0aDEsIC0xLCAwLCAtd2lkdGgxLCAwLCAwLCAwLCAxXSk7XG4gIHZhciBvdXRsaW5lcyA9IFtdO1xuXG4gIGZvciAoaSA9IDA7IGNvdW50ICYmIGkgPD0gaGVpZ2h0OyBpKyspIHtcbiAgICB2YXIgcCA9IGkgKiB3aWR0aDE7XG4gICAgdmFyIGVuZCA9IHAgKyB3aWR0aDtcblxuICAgIHdoaWxlIChwIDwgZW5kICYmICFwb2ludHNbcF0pIHtcbiAgICAgIHArKztcbiAgICB9XG5cbiAgICBpZiAocCA9PT0gZW5kKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgY29vcmRzID0gW3AgJSB3aWR0aDEsIGldO1xuICAgIHZhciB0eXBlID0gcG9pbnRzW3BdLFxuICAgICAgICBwMCA9IHAsXG4gICAgICAgIHBwO1xuXG4gICAgZG8ge1xuICAgICAgdmFyIHN0ZXAgPSBzdGVwc1t0eXBlXTtcblxuICAgICAgZG8ge1xuICAgICAgICBwICs9IHN0ZXA7XG4gICAgICB9IHdoaWxlICghcG9pbnRzW3BdKTtcblxuICAgICAgcHAgPSBwb2ludHNbcF07XG5cbiAgICAgIGlmIChwcCAhPT0gNSAmJiBwcCAhPT0gMTApIHtcbiAgICAgICAgdHlwZSA9IHBwO1xuICAgICAgICBwb2ludHNbcF0gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZSA9IHBwICYgMHgzMyAqIHR5cGUgPj4gNDtcbiAgICAgICAgcG9pbnRzW3BdICY9IHR5cGUgPj4gMiB8IHR5cGUgPDwgMjtcbiAgICAgIH1cblxuICAgICAgY29vcmRzLnB1c2gocCAlIHdpZHRoMSk7XG4gICAgICBjb29yZHMucHVzaChwIC8gd2lkdGgxIHwgMCk7XG5cbiAgICAgIGlmICghcG9pbnRzW3BdKSB7XG4gICAgICAgIC0tY291bnQ7XG4gICAgICB9XG4gICAgfSB3aGlsZSAocDAgIT09IHApO1xuXG4gICAgb3V0bGluZXMucHVzaChjb29yZHMpO1xuICAgIC0taTtcbiAgfVxuXG4gIHZhciBkcmF3T3V0bGluZSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgYy5zYXZlKCk7XG4gICAgYy5zY2FsZSgxIC8gd2lkdGgsIC0xIC8gaGVpZ2h0KTtcbiAgICBjLnRyYW5zbGF0ZSgwLCAtaGVpZ2h0KTtcbiAgICBjLmJlZ2luUGF0aCgpO1xuXG4gICAgZm9yIChsZXQgayA9IDAsIGtrID0gb3V0bGluZXMubGVuZ3RoOyBrIDwga2s7IGsrKykge1xuICAgICAgdmFyIG8gPSBvdXRsaW5lc1trXTtcbiAgICAgIGMubW92ZVRvKG9bMF0sIG9bMV0pO1xuXG4gICAgICBmb3IgKGxldCBsID0gMiwgbGwgPSBvLmxlbmd0aDsgbCA8IGxsOyBsICs9IDIpIHtcbiAgICAgICAgYy5saW5lVG8ob1tsXSwgb1tsICsgMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGMuZmlsbCgpO1xuICAgIGMuYmVnaW5QYXRoKCk7XG4gICAgYy5yZXN0b3JlKCk7XG4gIH07XG5cbiAgcmV0dXJuIGRyYXdPdXRsaW5lO1xufVxuXG52YXIgQ2FudmFzRXh0cmFTdGF0ZSA9IGZ1bmN0aW9uIENhbnZhc0V4dHJhU3RhdGVDbG9zdXJlKCkge1xuICBmdW5jdGlvbiBDYW52YXNFeHRyYVN0YXRlKCkge1xuICAgIHRoaXMuYWxwaGFJc1NoYXBlID0gZmFsc2U7XG4gICAgdGhpcy5mb250U2l6ZSA9IDA7XG4gICAgdGhpcy5mb250U2l6ZVNjYWxlID0gMTtcbiAgICB0aGlzLnRleHRNYXRyaXggPSBfdXRpbC5JREVOVElUWV9NQVRSSVg7XG4gICAgdGhpcy50ZXh0TWF0cml4U2NhbGUgPSAxO1xuICAgIHRoaXMuZm9udE1hdHJpeCA9IF91dGlsLkZPTlRfSURFTlRJVFlfTUFUUklYO1xuICAgIHRoaXMubGVhZGluZyA9IDA7XG4gICAgdGhpcy54ID0gMDtcbiAgICB0aGlzLnkgPSAwO1xuICAgIHRoaXMubGluZVggPSAwO1xuICAgIHRoaXMubGluZVkgPSAwO1xuICAgIHRoaXMuY2hhclNwYWNpbmcgPSAwO1xuICAgIHRoaXMud29yZFNwYWNpbmcgPSAwO1xuICAgIHRoaXMudGV4dEhTY2FsZSA9IDE7XG4gICAgdGhpcy50ZXh0UmVuZGVyaW5nTW9kZSA9IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkZJTEw7XG4gICAgdGhpcy50ZXh0UmlzZSA9IDA7XG4gICAgdGhpcy5maWxsQ29sb3IgPSBcIiMwMDAwMDBcIjtcbiAgICB0aGlzLnN0cm9rZUNvbG9yID0gXCIjMDAwMDAwXCI7XG4gICAgdGhpcy5wYXR0ZXJuRmlsbCA9IGZhbHNlO1xuICAgIHRoaXMuZmlsbEFscGhhID0gMTtcbiAgICB0aGlzLnN0cm9rZUFscGhhID0gMTtcbiAgICB0aGlzLmxpbmVXaWR0aCA9IDE7XG4gICAgdGhpcy5hY3RpdmVTTWFzayA9IG51bGw7XG4gICAgdGhpcy5yZXN1bWVTTWFza0N0eCA9IG51bGw7XG4gICAgdGhpcy50cmFuc2Zlck1hcHMgPSBudWxsO1xuICB9XG5cbiAgQ2FudmFzRXh0cmFTdGF0ZS5wcm90b3R5cGUgPSB7XG4gICAgY2xvbmU6IGZ1bmN0aW9uIENhbnZhc0V4dHJhU3RhdGVfY2xvbmUoKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZSh0aGlzKTtcbiAgICB9LFxuICAgIHNldEN1cnJlbnRQb2ludDogZnVuY3Rpb24gQ2FudmFzRXh0cmFTdGF0ZV9zZXRDdXJyZW50UG9pbnQoeCwgeSkge1xuICAgICAgdGhpcy54ID0geDtcbiAgICAgIHRoaXMueSA9IHk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gQ2FudmFzRXh0cmFTdGF0ZTtcbn0oKTtcblxudmFyIENhbnZhc0dyYXBoaWNzID0gZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3NDbG9zdXJlKCkge1xuICB2YXIgRVhFQ1VUSU9OX1RJTUUgPSAxNTtcbiAgdmFyIEVYRUNVVElPTl9TVEVQUyA9IDEwO1xuXG4gIGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzKGNhbnZhc0N0eCwgY29tbW9uT2Jqcywgb2JqcywgY2FudmFzRmFjdG9yeSwgd2ViR0xDb250ZXh0LCBpbWFnZUxheWVyLCBvcHRpb25hbENvbnRlbnRDb25maWcpIHtcbiAgICB0aGlzLmN0eCA9IGNhbnZhc0N0eDtcbiAgICB0aGlzLmN1cnJlbnQgPSBuZXcgQ2FudmFzRXh0cmFTdGF0ZSgpO1xuICAgIHRoaXMuc3RhdGVTdGFjayA9IFtdO1xuICAgIHRoaXMucGVuZGluZ0NsaXAgPSBudWxsO1xuICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IGZhbHNlO1xuICAgIHRoaXMucmVzID0gbnVsbDtcbiAgICB0aGlzLnhvYmpzID0gbnVsbDtcbiAgICB0aGlzLmNvbW1vbk9ianMgPSBjb21tb25PYmpzO1xuICAgIHRoaXMub2JqcyA9IG9ianM7XG4gICAgdGhpcy5jYW52YXNGYWN0b3J5ID0gY2FudmFzRmFjdG9yeTtcbiAgICB0aGlzLndlYkdMQ29udGV4dCA9IHdlYkdMQ29udGV4dDtcbiAgICB0aGlzLmltYWdlTGF5ZXIgPSBpbWFnZUxheWVyO1xuICAgIHRoaXMuZ3JvdXBTdGFjayA9IFtdO1xuICAgIHRoaXMucHJvY2Vzc2luZ1R5cGUzID0gbnVsbDtcbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm0gPSBudWxsO1xuICAgIHRoaXMuYmFzZVRyYW5zZm9ybVN0YWNrID0gW107XG4gICAgdGhpcy5ncm91cExldmVsID0gMDtcbiAgICB0aGlzLnNtYXNrU3RhY2sgPSBbXTtcbiAgICB0aGlzLnNtYXNrQ291bnRlciA9IDA7XG4gICAgdGhpcy50ZW1wU01hc2sgPSBudWxsO1xuICAgIHRoaXMuY29udGVudFZpc2libGUgPSB0cnVlO1xuICAgIHRoaXMubWFya2VkQ29udGVudFN0YWNrID0gW107XG4gICAgdGhpcy5vcHRpb25hbENvbnRlbnRDb25maWcgPSBvcHRpb25hbENvbnRlbnRDb25maWc7XG4gICAgdGhpcy5jYWNoZWRDYW52YXNlcyA9IG5ldyBDYWNoZWRDYW52YXNlcyh0aGlzLmNhbnZhc0ZhY3RvcnkpO1xuXG4gICAgaWYgKGNhbnZhc0N0eCkge1xuICAgICAgYWRkQ29udGV4dEN1cnJlbnRUcmFuc2Zvcm0oY2FudmFzQ3R4KTtcbiAgICB9XG5cbiAgICB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoID0gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1dEJpbmFyeUltYWdlRGF0YShjdHgsIGltZ0RhdGEsIHRyYW5zZmVyTWFwcyA9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIEltYWdlRGF0YSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpbWdEYXRhIGluc3RhbmNlb2YgSW1hZ2VEYXRhKSB7XG4gICAgICBjdHgucHV0SW1hZ2VEYXRhKGltZ0RhdGEsIDAsIDApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodCxcbiAgICAgICAgd2lkdGggPSBpbWdEYXRhLndpZHRoO1xuICAgIHZhciBwYXJ0aWFsQ2h1bmtIZWlnaHQgPSBoZWlnaHQgJSBGVUxMX0NIVU5LX0hFSUdIVDtcbiAgICB2YXIgZnVsbENodW5rcyA9IChoZWlnaHQgLSBwYXJ0aWFsQ2h1bmtIZWlnaHQpIC8gRlVMTF9DSFVOS19IRUlHSFQ7XG4gICAgdmFyIHRvdGFsQ2h1bmtzID0gcGFydGlhbENodW5rSGVpZ2h0ID09PSAwID8gZnVsbENodW5rcyA6IGZ1bGxDaHVua3MgKyAxO1xuICAgIHZhciBjaHVua0ltZ0RhdGEgPSBjdHguY3JlYXRlSW1hZ2VEYXRhKHdpZHRoLCBGVUxMX0NIVU5LX0hFSUdIVCk7XG4gICAgdmFyIHNyY1BvcyA9IDAsXG4gICAgICAgIGRlc3RQb3M7XG4gICAgdmFyIHNyYyA9IGltZ0RhdGEuZGF0YTtcbiAgICB2YXIgZGVzdCA9IGNodW5rSW1nRGF0YS5kYXRhO1xuICAgIHZhciBpLCBqLCB0aGlzQ2h1bmtIZWlnaHQsIGVsZW1zSW5UaGlzQ2h1bms7XG4gICAgbGV0IHRyYW5zZmVyTWFwUmVkLCB0cmFuc2Zlck1hcEdyZWVuLCB0cmFuc2Zlck1hcEJsdWUsIHRyYW5zZmVyTWFwR3JheTtcblxuICAgIGlmICh0cmFuc2Zlck1hcHMpIHtcbiAgICAgIHN3aXRjaCAodHJhbnNmZXJNYXBzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdHJhbnNmZXJNYXBSZWQgPSB0cmFuc2Zlck1hcHNbMF07XG4gICAgICAgICAgdHJhbnNmZXJNYXBHcmVlbiA9IHRyYW5zZmVyTWFwc1swXTtcbiAgICAgICAgICB0cmFuc2Zlck1hcEJsdWUgPSB0cmFuc2Zlck1hcHNbMF07XG4gICAgICAgICAgdHJhbnNmZXJNYXBHcmF5ID0gdHJhbnNmZXJNYXBzWzBdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICB0cmFuc2Zlck1hcFJlZCA9IHRyYW5zZmVyTWFwc1swXTtcbiAgICAgICAgICB0cmFuc2Zlck1hcEdyZWVuID0gdHJhbnNmZXJNYXBzWzFdO1xuICAgICAgICAgIHRyYW5zZmVyTWFwQmx1ZSA9IHRyYW5zZmVyTWFwc1syXTtcbiAgICAgICAgICB0cmFuc2Zlck1hcEdyYXkgPSB0cmFuc2Zlck1hcHNbM107XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGltZ0RhdGEua2luZCA9PT0gX3V0aWwuSW1hZ2VLaW5kLkdSQVlTQ0FMRV8xQlBQKSB7XG4gICAgICB2YXIgc3JjTGVuZ3RoID0gc3JjLmJ5dGVMZW5ndGg7XG4gICAgICB2YXIgZGVzdDMyID0gbmV3IFVpbnQzMkFycmF5KGRlc3QuYnVmZmVyLCAwLCBkZXN0LmJ5dGVMZW5ndGggPj4gMik7XG4gICAgICB2YXIgZGVzdDMyRGF0YUxlbmd0aCA9IGRlc3QzMi5sZW5ndGg7XG4gICAgICB2YXIgZnVsbFNyY0RpZmYgPSB3aWR0aCArIDcgPj4gMztcbiAgICAgIHZhciB3aGl0ZSA9IDB4ZmZmZmZmZmY7XG4gICAgICB2YXIgYmxhY2sgPSBfdXRpbC5Jc0xpdHRsZUVuZGlhbkNhY2hlZC52YWx1ZSA/IDB4ZmYwMDAwMDAgOiAweDAwMDAwMGZmO1xuXG4gICAgICBpZiAodHJhbnNmZXJNYXBHcmF5KSB7XG4gICAgICAgIGlmICh0cmFuc2Zlck1hcEdyYXlbMF0gPT09IDB4ZmYgJiYgdHJhbnNmZXJNYXBHcmF5WzB4ZmZdID09PSAwKSB7XG4gICAgICAgICAgW3doaXRlLCBibGFja10gPSBbYmxhY2ssIHdoaXRlXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdG90YWxDaHVua3M7IGkrKykge1xuICAgICAgICB0aGlzQ2h1bmtIZWlnaHQgPSBpIDwgZnVsbENodW5rcyA/IEZVTExfQ0hVTktfSEVJR0hUIDogcGFydGlhbENodW5rSGVpZ2h0O1xuICAgICAgICBkZXN0UG9zID0gMDtcblxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgdGhpc0NodW5rSGVpZ2h0OyBqKyspIHtcbiAgICAgICAgICB2YXIgc3JjRGlmZiA9IHNyY0xlbmd0aCAtIHNyY1BvcztcbiAgICAgICAgICBsZXQgayA9IDA7XG4gICAgICAgICAgdmFyIGtFbmQgPSBzcmNEaWZmID4gZnVsbFNyY0RpZmYgPyB3aWR0aCA6IHNyY0RpZmYgKiA4IC0gNztcbiAgICAgICAgICB2YXIga0VuZFVucm9sbGVkID0ga0VuZCAmIH43O1xuICAgICAgICAgIHZhciBtYXNrID0gMDtcbiAgICAgICAgICB2YXIgc3JjQnl0ZSA9IDA7XG5cbiAgICAgICAgICBmb3IgKDsgayA8IGtFbmRVbnJvbGxlZDsgayArPSA4KSB7XG4gICAgICAgICAgICBzcmNCeXRlID0gc3JjW3NyY1BvcysrXTtcbiAgICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIDEyOCA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiA2NCA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiAzMiA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiAxNiA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiA4ID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIDQgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgMiA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiAxID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKDsgayA8IGtFbmQ7IGsrKykge1xuICAgICAgICAgICAgaWYgKG1hc2sgPT09IDApIHtcbiAgICAgICAgICAgICAgc3JjQnl0ZSA9IHNyY1tzcmNQb3MrK107XG4gICAgICAgICAgICAgIG1hc2sgPSAxMjg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIG1hc2sgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgICAgbWFzayA+Pj0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoZGVzdFBvcyA8IGRlc3QzMkRhdGFMZW5ndGgpIHtcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjdHgucHV0SW1hZ2VEYXRhKGNodW5rSW1nRGF0YSwgMCwgaSAqIEZVTExfQ0hVTktfSEVJR0hUKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGltZ0RhdGEua2luZCA9PT0gX3V0aWwuSW1hZ2VLaW5kLlJHQkFfMzJCUFApIHtcbiAgICAgIGNvbnN0IGhhc1RyYW5zZmVyTWFwcyA9ICEhKHRyYW5zZmVyTWFwUmVkIHx8IHRyYW5zZmVyTWFwR3JlZW4gfHwgdHJhbnNmZXJNYXBCbHVlKTtcbiAgICAgIGogPSAwO1xuICAgICAgZWxlbXNJblRoaXNDaHVuayA9IHdpZHRoICogRlVMTF9DSFVOS19IRUlHSFQgKiA0O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZnVsbENodW5rczsgaSsrKSB7XG4gICAgICAgIGRlc3Quc2V0KHNyYy5zdWJhcnJheShzcmNQb3MsIHNyY1BvcyArIGVsZW1zSW5UaGlzQ2h1bmspKTtcbiAgICAgICAgc3JjUG9zICs9IGVsZW1zSW5UaGlzQ2h1bms7XG5cbiAgICAgICAgaWYgKGhhc1RyYW5zZmVyTWFwcykge1xuICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgZWxlbXNJblRoaXNDaHVuazsgayArPSA0KSB7XG4gICAgICAgICAgICBpZiAodHJhbnNmZXJNYXBSZWQpIHtcbiAgICAgICAgICAgICAgZGVzdFtrICsgMF0gPSB0cmFuc2Zlck1hcFJlZFtkZXN0W2sgKyAwXV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0cmFuc2Zlck1hcEdyZWVuKSB7XG4gICAgICAgICAgICAgIGRlc3RbayArIDFdID0gdHJhbnNmZXJNYXBHcmVlbltkZXN0W2sgKyAxXV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0cmFuc2Zlck1hcEJsdWUpIHtcbiAgICAgICAgICAgICAgZGVzdFtrICsgMl0gPSB0cmFuc2Zlck1hcEJsdWVbZGVzdFtrICsgMl1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5wdXRJbWFnZURhdGEoY2h1bmtJbWdEYXRhLCAwLCBqKTtcbiAgICAgICAgaiArPSBGVUxMX0NIVU5LX0hFSUdIVDtcbiAgICAgIH1cblxuICAgICAgaWYgKGkgPCB0b3RhbENodW5rcykge1xuICAgICAgICBlbGVtc0luVGhpc0NodW5rID0gd2lkdGggKiBwYXJ0aWFsQ2h1bmtIZWlnaHQgKiA0O1xuICAgICAgICBkZXN0LnNldChzcmMuc3ViYXJyYXkoc3JjUG9zLCBzcmNQb3MgKyBlbGVtc0luVGhpc0NodW5rKSk7XG5cbiAgICAgICAgaWYgKGhhc1RyYW5zZmVyTWFwcykge1xuICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgZWxlbXNJblRoaXNDaHVuazsgayArPSA0KSB7XG4gICAgICAgICAgICBpZiAodHJhbnNmZXJNYXBSZWQpIHtcbiAgICAgICAgICAgICAgZGVzdFtrICsgMF0gPSB0cmFuc2Zlck1hcFJlZFtkZXN0W2sgKyAwXV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0cmFuc2Zlck1hcEdyZWVuKSB7XG4gICAgICAgICAgICAgIGRlc3RbayArIDFdID0gdHJhbnNmZXJNYXBHcmVlbltkZXN0W2sgKyAxXV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0cmFuc2Zlck1hcEJsdWUpIHtcbiAgICAgICAgICAgICAgZGVzdFtrICsgMl0gPSB0cmFuc2Zlck1hcEJsdWVbZGVzdFtrICsgMl1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5wdXRJbWFnZURhdGEoY2h1bmtJbWdEYXRhLCAwLCBqKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGltZ0RhdGEua2luZCA9PT0gX3V0aWwuSW1hZ2VLaW5kLlJHQl8yNEJQUCkge1xuICAgICAgY29uc3QgaGFzVHJhbnNmZXJNYXBzID0gISEodHJhbnNmZXJNYXBSZWQgfHwgdHJhbnNmZXJNYXBHcmVlbiB8fCB0cmFuc2Zlck1hcEJsdWUpO1xuICAgICAgdGhpc0NodW5rSGVpZ2h0ID0gRlVMTF9DSFVOS19IRUlHSFQ7XG4gICAgICBlbGVtc0luVGhpc0NodW5rID0gd2lkdGggKiB0aGlzQ2h1bmtIZWlnaHQ7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0b3RhbENodW5rczsgaSsrKSB7XG4gICAgICAgIGlmIChpID49IGZ1bGxDaHVua3MpIHtcbiAgICAgICAgICB0aGlzQ2h1bmtIZWlnaHQgPSBwYXJ0aWFsQ2h1bmtIZWlnaHQ7XG4gICAgICAgICAgZWxlbXNJblRoaXNDaHVuayA9IHdpZHRoICogdGhpc0NodW5rSGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgZGVzdFBvcyA9IDA7XG5cbiAgICAgICAgZm9yIChqID0gZWxlbXNJblRoaXNDaHVuazsgai0tOykge1xuICAgICAgICAgIGRlc3RbZGVzdFBvcysrXSA9IHNyY1tzcmNQb3MrK107XG4gICAgICAgICAgZGVzdFtkZXN0UG9zKytdID0gc3JjW3NyY1BvcysrXTtcbiAgICAgICAgICBkZXN0W2Rlc3RQb3MrK10gPSBzcmNbc3JjUG9zKytdO1xuICAgICAgICAgIGRlc3RbZGVzdFBvcysrXSA9IDI1NTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNUcmFuc2Zlck1hcHMpIHtcbiAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGRlc3RQb3M7IGsgKz0gNCkge1xuICAgICAgICAgICAgaWYgKHRyYW5zZmVyTWFwUmVkKSB7XG4gICAgICAgICAgICAgIGRlc3RbayArIDBdID0gdHJhbnNmZXJNYXBSZWRbZGVzdFtrICsgMF1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHJhbnNmZXJNYXBHcmVlbikge1xuICAgICAgICAgICAgICBkZXN0W2sgKyAxXSA9IHRyYW5zZmVyTWFwR3JlZW5bZGVzdFtrICsgMV1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHJhbnNmZXJNYXBCbHVlKSB7XG4gICAgICAgICAgICAgIGRlc3RbayArIDJdID0gdHJhbnNmZXJNYXBCbHVlW2Rlc3RbayArIDJdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjdHgucHV0SW1hZ2VEYXRhKGNodW5rSW1nRGF0YSwgMCwgaSAqIEZVTExfQ0hVTktfSEVJR0hUKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBiYWQgaW1hZ2Uga2luZDogJHtpbWdEYXRhLmtpbmR9YCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHV0QmluYXJ5SW1hZ2VNYXNrKGN0eCwgaW1nRGF0YSkge1xuICAgIHZhciBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodCxcbiAgICAgICAgd2lkdGggPSBpbWdEYXRhLndpZHRoO1xuICAgIHZhciBwYXJ0aWFsQ2h1bmtIZWlnaHQgPSBoZWlnaHQgJSBGVUxMX0NIVU5LX0hFSUdIVDtcbiAgICB2YXIgZnVsbENodW5rcyA9IChoZWlnaHQgLSBwYXJ0aWFsQ2h1bmtIZWlnaHQpIC8gRlVMTF9DSFVOS19IRUlHSFQ7XG4gICAgdmFyIHRvdGFsQ2h1bmtzID0gcGFydGlhbENodW5rSGVpZ2h0ID09PSAwID8gZnVsbENodW5rcyA6IGZ1bGxDaHVua3MgKyAxO1xuICAgIHZhciBjaHVua0ltZ0RhdGEgPSBjdHguY3JlYXRlSW1hZ2VEYXRhKHdpZHRoLCBGVUxMX0NIVU5LX0hFSUdIVCk7XG4gICAgdmFyIHNyY1BvcyA9IDA7XG4gICAgdmFyIHNyYyA9IGltZ0RhdGEuZGF0YTtcbiAgICB2YXIgZGVzdCA9IGNodW5rSW1nRGF0YS5kYXRhO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b3RhbENodW5rczsgaSsrKSB7XG4gICAgICB2YXIgdGhpc0NodW5rSGVpZ2h0ID0gaSA8IGZ1bGxDaHVua3MgPyBGVUxMX0NIVU5LX0hFSUdIVCA6IHBhcnRpYWxDaHVua0hlaWdodDtcbiAgICAgIHZhciBkZXN0UG9zID0gMztcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzQ2h1bmtIZWlnaHQ7IGorKykge1xuICAgICAgICB2YXIgbWFzayA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB3aWR0aDsgaysrKSB7XG4gICAgICAgICAgaWYgKCFtYXNrKSB7XG4gICAgICAgICAgICB2YXIgZWxlbSA9IHNyY1tzcmNQb3MrK107XG4gICAgICAgICAgICBtYXNrID0gMTI4O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlc3RbZGVzdFBvc10gPSBlbGVtICYgbWFzayA/IDAgOiAyNTU7XG4gICAgICAgICAgZGVzdFBvcyArPSA0O1xuICAgICAgICAgIG1hc2sgPj49IDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY3R4LnB1dEltYWdlRGF0YShjaHVua0ltZ0RhdGEsIDAsIGkgKiBGVUxMX0NIVU5LX0hFSUdIVCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29weUN0eFN0YXRlKHNvdXJjZUN0eCwgZGVzdEN0eCkge1xuICAgIHZhciBwcm9wZXJ0aWVzID0gW1wic3Ryb2tlU3R5bGVcIiwgXCJmaWxsU3R5bGVcIiwgXCJmaWxsUnVsZVwiLCBcImdsb2JhbEFscGhhXCIsIFwibGluZVdpZHRoXCIsIFwibGluZUNhcFwiLCBcImxpbmVKb2luXCIsIFwibWl0ZXJMaW1pdFwiLCBcImdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvblwiLCBcImZvbnRcIl07XG5cbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBwcm9wZXJ0aWVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIHZhciBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbaV07XG5cbiAgICAgIGlmIChzb3VyY2VDdHhbcHJvcGVydHldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVzdEN0eFtwcm9wZXJ0eV0gPSBzb3VyY2VDdHhbcHJvcGVydHldO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzb3VyY2VDdHguc2V0TGluZURhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgZGVzdEN0eC5zZXRMaW5lRGFzaChzb3VyY2VDdHguZ2V0TGluZURhc2goKSk7XG4gICAgICBkZXN0Q3R4LmxpbmVEYXNoT2Zmc2V0ID0gc291cmNlQ3R4LmxpbmVEYXNoT2Zmc2V0O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0Q3R4VG9EZWZhdWx0KGN0eCkge1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IFwiIzAwMDAwMFwiO1xuICAgIGN0eC5maWxsU3R5bGUgPSBcIiMwMDAwMDBcIjtcbiAgICBjdHguZmlsbFJ1bGUgPSBcIm5vbnplcm9cIjtcbiAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgIGN0eC5saW5lQ2FwID0gXCJidXR0XCI7XG4gICAgY3R4LmxpbmVKb2luID0gXCJtaXRlclwiO1xuICAgIGN0eC5taXRlckxpbWl0ID0gMTA7XG4gICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwic291cmNlLW92ZXJcIjtcbiAgICBjdHguZm9udCA9IFwiMTBweCBzYW5zLXNlcmlmXCI7XG5cbiAgICBpZiAoY3R4LnNldExpbmVEYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaChbXSk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgPSAwO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBvc2VTTWFza0JhY2tkcm9wKGJ5dGVzLCByMCwgZzAsIGIwKSB7XG4gICAgdmFyIGxlbmd0aCA9IGJ5dGVzLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAzOyBpIDwgbGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgIHZhciBhbHBoYSA9IGJ5dGVzW2ldO1xuXG4gICAgICBpZiAoYWxwaGEgPT09IDApIHtcbiAgICAgICAgYnl0ZXNbaSAtIDNdID0gcjA7XG4gICAgICAgIGJ5dGVzW2kgLSAyXSA9IGcwO1xuICAgICAgICBieXRlc1tpIC0gMV0gPSBiMDtcbiAgICAgIH0gZWxzZSBpZiAoYWxwaGEgPCAyNTUpIHtcbiAgICAgICAgdmFyIGFscGhhXyA9IDI1NSAtIGFscGhhO1xuICAgICAgICBieXRlc1tpIC0gM10gPSBieXRlc1tpIC0gM10gKiBhbHBoYSArIHIwICogYWxwaGFfID4+IDg7XG4gICAgICAgIGJ5dGVzW2kgLSAyXSA9IGJ5dGVzW2kgLSAyXSAqIGFscGhhICsgZzAgKiBhbHBoYV8gPj4gODtcbiAgICAgICAgYnl0ZXNbaSAtIDFdID0gYnl0ZXNbaSAtIDFdICogYWxwaGEgKyBiMCAqIGFscGhhXyA+PiA4O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBvc2VTTWFza0FscGhhKG1hc2tEYXRhLCBsYXllckRhdGEsIHRyYW5zZmVyTWFwKSB7XG4gICAgdmFyIGxlbmd0aCA9IG1hc2tEYXRhLmxlbmd0aDtcbiAgICB2YXIgc2NhbGUgPSAxIC8gMjU1O1xuXG4gICAgZm9yICh2YXIgaSA9IDM7IGkgPCBsZW5ndGg7IGkgKz0gNCkge1xuICAgICAgdmFyIGFscGhhID0gdHJhbnNmZXJNYXAgPyB0cmFuc2Zlck1hcFttYXNrRGF0YVtpXV0gOiBtYXNrRGF0YVtpXTtcbiAgICAgIGxheWVyRGF0YVtpXSA9IGxheWVyRGF0YVtpXSAqIGFscGhhICogc2NhbGUgfCAwO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBvc2VTTWFza0x1bWlub3NpdHkobWFza0RhdGEsIGxheWVyRGF0YSwgdHJhbnNmZXJNYXApIHtcbiAgICB2YXIgbGVuZ3RoID0gbWFza0RhdGEubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDM7IGkgPCBsZW5ndGg7IGkgKz0gNCkge1xuICAgICAgdmFyIHkgPSBtYXNrRGF0YVtpIC0gM10gKiA3NyArIG1hc2tEYXRhW2kgLSAyXSAqIDE1MiArIG1hc2tEYXRhW2kgLSAxXSAqIDI4O1xuICAgICAgbGF5ZXJEYXRhW2ldID0gdHJhbnNmZXJNYXAgPyBsYXllckRhdGFbaV0gKiB0cmFuc2Zlck1hcFt5ID4+IDhdID4+IDggOiBsYXllckRhdGFbaV0gKiB5ID4+IDE2O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbmVyaWNDb21wb3NlU01hc2sobWFza0N0eCwgbGF5ZXJDdHgsIHdpZHRoLCBoZWlnaHQsIHN1YnR5cGUsIGJhY2tkcm9wLCB0cmFuc2Zlck1hcCkge1xuICAgIHZhciBoYXNCYWNrZHJvcCA9ICEhYmFja2Ryb3A7XG4gICAgdmFyIHIwID0gaGFzQmFja2Ryb3AgPyBiYWNrZHJvcFswXSA6IDA7XG4gICAgdmFyIGcwID0gaGFzQmFja2Ryb3AgPyBiYWNrZHJvcFsxXSA6IDA7XG4gICAgdmFyIGIwID0gaGFzQmFja2Ryb3AgPyBiYWNrZHJvcFsyXSA6IDA7XG4gICAgdmFyIGNvbXBvc2VGbjtcblxuICAgIGlmIChzdWJ0eXBlID09PSBcIkx1bWlub3NpdHlcIikge1xuICAgICAgY29tcG9zZUZuID0gY29tcG9zZVNNYXNrTHVtaW5vc2l0eTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcG9zZUZuID0gY29tcG9zZVNNYXNrQWxwaGE7XG4gICAgfVxuXG4gICAgdmFyIFBJWEVMU19UT19QUk9DRVNTID0gMTA0ODU3NjtcbiAgICB2YXIgY2h1bmtTaXplID0gTWF0aC5taW4oaGVpZ2h0LCBNYXRoLmNlaWwoUElYRUxTX1RPX1BST0NFU1MgLyB3aWR0aCkpO1xuXG4gICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgaGVpZ2h0OyByb3cgKz0gY2h1bmtTaXplKSB7XG4gICAgICB2YXIgY2h1bmtIZWlnaHQgPSBNYXRoLm1pbihjaHVua1NpemUsIGhlaWdodCAtIHJvdyk7XG4gICAgICB2YXIgbWFza0RhdGEgPSBtYXNrQ3R4LmdldEltYWdlRGF0YSgwLCByb3csIHdpZHRoLCBjaHVua0hlaWdodCk7XG4gICAgICB2YXIgbGF5ZXJEYXRhID0gbGF5ZXJDdHguZ2V0SW1hZ2VEYXRhKDAsIHJvdywgd2lkdGgsIGNodW5rSGVpZ2h0KTtcblxuICAgICAgaWYgKGhhc0JhY2tkcm9wKSB7XG4gICAgICAgIGNvbXBvc2VTTWFza0JhY2tkcm9wKG1hc2tEYXRhLmRhdGEsIHIwLCBnMCwgYjApO1xuICAgICAgfVxuXG4gICAgICBjb21wb3NlRm4obWFza0RhdGEuZGF0YSwgbGF5ZXJEYXRhLmRhdGEsIHRyYW5zZmVyTWFwKTtcbiAgICAgIG1hc2tDdHgucHV0SW1hZ2VEYXRhKGxheWVyRGF0YSwgMCwgcm93KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21wb3NlU01hc2soY3R4LCBzbWFzaywgbGF5ZXJDdHgsIHdlYkdMQ29udGV4dCkge1xuICAgIHZhciBtYXNrID0gc21hc2suY2FudmFzO1xuICAgIHZhciBtYXNrQ3R4ID0gc21hc2suY29udGV4dDtcbiAgICBjdHguc2V0VHJhbnNmb3JtKHNtYXNrLnNjYWxlWCwgMCwgMCwgc21hc2suc2NhbGVZLCBzbWFzay5vZmZzZXRYLCBzbWFzay5vZmZzZXRZKTtcbiAgICB2YXIgYmFja2Ryb3AgPSBzbWFzay5iYWNrZHJvcCB8fCBudWxsO1xuXG4gICAgaWYgKCFzbWFzay50cmFuc2Zlck1hcCAmJiB3ZWJHTENvbnRleHQuaXNFbmFibGVkKSB7XG4gICAgICBjb25zdCBjb21wb3NlZCA9IHdlYkdMQ29udGV4dC5jb21wb3NlU01hc2soe1xuICAgICAgICBsYXllcjogbGF5ZXJDdHguY2FudmFzLFxuICAgICAgICBtYXNrLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgc3VidHlwZTogc21hc2suc3VidHlwZSxcbiAgICAgICAgICBiYWNrZHJvcFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICBjdHguZHJhd0ltYWdlKGNvbXBvc2VkLCBzbWFzay5vZmZzZXRYLCBzbWFzay5vZmZzZXRZKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBnZW5lcmljQ29tcG9zZVNNYXNrKG1hc2tDdHgsIGxheWVyQ3R4LCBtYXNrLndpZHRoLCBtYXNrLmhlaWdodCwgc21hc2suc3VidHlwZSwgYmFja2Ryb3AsIHNtYXNrLnRyYW5zZmVyTWFwKTtcbiAgICBjdHguZHJhd0ltYWdlKG1hc2ssIDAsIDApO1xuICB9XG5cbiAgdmFyIExJTkVfQ0FQX1NUWUxFUyA9IFtcImJ1dHRcIiwgXCJyb3VuZFwiLCBcInNxdWFyZVwiXTtcbiAgdmFyIExJTkVfSk9JTl9TVFlMRVMgPSBbXCJtaXRlclwiLCBcInJvdW5kXCIsIFwiYmV2ZWxcIl07XG4gIHZhciBOT1JNQUxfQ0xJUCA9IHt9O1xuICB2YXIgRU9fQ0xJUCA9IHt9O1xuICBDYW52YXNHcmFwaGljcy5wcm90b3R5cGUgPSB7XG4gICAgYmVnaW5EcmF3aW5nKHtcbiAgICAgIHRyYW5zZm9ybSxcbiAgICAgIHZpZXdwb3J0LFxuICAgICAgdHJhbnNwYXJlbmN5ID0gZmFsc2UsXG4gICAgICBiYWNrZ3JvdW5kID0gbnVsbFxuICAgIH0pIHtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMuY3R4LmNhbnZhcy53aWR0aDtcbiAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0O1xuICAgICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgICAgdGhpcy5jdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZCB8fCBcInJnYigyNTUsIDI1NSwgMjU1KVwiO1xuICAgICAgdGhpcy5jdHguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG5cbiAgICAgIGlmICh0cmFuc3BhcmVuY3kpIHtcbiAgICAgICAgdmFyIHRyYW5zcGFyZW50Q2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJ0cmFuc3BhcmVudFwiLCB3aWR0aCwgaGVpZ2h0LCB0cnVlKTtcbiAgICAgICAgdGhpcy5jb21wb3NpdGVDdHggPSB0aGlzLmN0eDtcbiAgICAgICAgdGhpcy50cmFuc3BhcmVudENhbnZhcyA9IHRyYW5zcGFyZW50Q2FudmFzLmNhbnZhcztcbiAgICAgICAgdGhpcy5jdHggPSB0cmFuc3BhcmVudENhbnZhcy5jb250ZXh0O1xuICAgICAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgICAgIHRoaXMuY3R4LnRyYW5zZm9ybS5hcHBseSh0aGlzLmN0eCwgdGhpcy5jb21wb3NpdGVDdHgubW96Q3VycmVudFRyYW5zZm9ybSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICAgIHJlc2V0Q3R4VG9EZWZhdWx0KHRoaXMuY3R4KTtcblxuICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICB0aGlzLmN0eC50cmFuc2Zvcm0uYXBwbHkodGhpcy5jdHgsIHRyYW5zZm9ybSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY3R4LnRyYW5zZm9ybS5hcHBseSh0aGlzLmN0eCwgdmlld3BvcnQudHJhbnNmb3JtKTtcbiAgICAgIHRoaXMuYmFzZVRyYW5zZm9ybSA9IHRoaXMuY3R4Lm1vekN1cnJlbnRUcmFuc2Zvcm0uc2xpY2UoKTtcblxuICAgICAgaWYgKHRoaXMuaW1hZ2VMYXllcikge1xuICAgICAgICB0aGlzLmltYWdlTGF5ZXIuYmVnaW5MYXlvdXQoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZXhlY3V0ZU9wZXJhdG9yTGlzdDogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3NfZXhlY3V0ZU9wZXJhdG9yTGlzdChvcGVyYXRvckxpc3QsIGV4ZWN1dGlvblN0YXJ0SWR4LCBjb250aW51ZUNhbGxiYWNrLCBzdGVwcGVyKSB7XG4gICAgICB2YXIgYXJnc0FycmF5ID0gb3BlcmF0b3JMaXN0LmFyZ3NBcnJheTtcbiAgICAgIHZhciBmbkFycmF5ID0gb3BlcmF0b3JMaXN0LmZuQXJyYXk7XG4gICAgICB2YXIgaSA9IGV4ZWN1dGlvblN0YXJ0SWR4IHx8IDA7XG4gICAgICB2YXIgYXJnc0FycmF5TGVuID0gYXJnc0FycmF5Lmxlbmd0aDtcblxuICAgICAgaWYgKGFyZ3NBcnJheUxlbiA9PT0gaSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNodW5rT3BlcmF0aW9ucyA9IGFyZ3NBcnJheUxlbiAtIGkgPiBFWEVDVVRJT05fU1RFUFMgJiYgdHlwZW9mIGNvbnRpbnVlQ2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgIHZhciBlbmRUaW1lID0gY2h1bmtPcGVyYXRpb25zID8gRGF0ZS5ub3coKSArIEVYRUNVVElPTl9USU1FIDogMDtcbiAgICAgIHZhciBzdGVwcyA9IDA7XG4gICAgICB2YXIgY29tbW9uT2JqcyA9IHRoaXMuY29tbW9uT2JqcztcbiAgICAgIHZhciBvYmpzID0gdGhpcy5vYmpzO1xuICAgICAgdmFyIGZuSWQ7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmIChzdGVwcGVyICE9PSB1bmRlZmluZWQgJiYgaSA9PT0gc3RlcHBlci5uZXh0QnJlYWtQb2ludCkge1xuICAgICAgICAgIHN0ZXBwZXIuYnJlYWtJdChpLCBjb250aW51ZUNhbGxiYWNrKTtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuSWQgPSBmbkFycmF5W2ldO1xuXG4gICAgICAgIGlmIChmbklkICE9PSBfdXRpbC5PUFMuZGVwZW5kZW5jeSkge1xuICAgICAgICAgIHRoaXNbZm5JZF0uYXBwbHkodGhpcywgYXJnc0FycmF5W2ldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGRlcE9iaklkIG9mIGFyZ3NBcnJheVtpXSkge1xuICAgICAgICAgICAgY29uc3Qgb2Jqc1Bvb2wgPSBkZXBPYmpJZC5zdGFydHNXaXRoKFwiZ19cIikgPyBjb21tb25PYmpzIDogb2JqcztcblxuICAgICAgICAgICAgaWYgKCFvYmpzUG9vbC5oYXMoZGVwT2JqSWQpKSB7XG4gICAgICAgICAgICAgIG9ianNQb29sLmdldChkZXBPYmpJZCwgY29udGludWVDYWxsYmFjayk7XG4gICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGkrKztcblxuICAgICAgICBpZiAoaSA9PT0gYXJnc0FycmF5TGVuKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2h1bmtPcGVyYXRpb25zICYmICsrc3RlcHMgPiBFWEVDVVRJT05fU1RFUFMpIHtcbiAgICAgICAgICBpZiAoRGF0ZS5ub3coKSA+IGVuZFRpbWUpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlQ2FsbGJhY2soKTtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN0ZXBzID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZW5kRHJhd2luZzogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3NfZW5kRHJhd2luZygpIHtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2sgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5lbmRTTWFza0dyb3VwKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcblxuICAgICAgaWYgKHRoaXMudHJhbnNwYXJlbnRDYW52YXMpIHtcbiAgICAgICAgdGhpcy5jdHggPSB0aGlzLmNvbXBvc2l0ZUN0eDtcbiAgICAgICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICAgIHRoaXMuY3R4LmRyYXdJbWFnZSh0aGlzLnRyYW5zcGFyZW50Q2FudmFzLCAwLCAwKTtcbiAgICAgICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICAgICAgICB0aGlzLnRyYW5zcGFyZW50Q2FudmFzID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jYWNoZWRDYW52YXNlcy5jbGVhcigpO1xuICAgICAgdGhpcy53ZWJHTENvbnRleHQuY2xlYXIoKTtcblxuICAgICAgaWYgKHRoaXMuaW1hZ2VMYXllcikge1xuICAgICAgICB0aGlzLmltYWdlTGF5ZXIuZW5kTGF5b3V0KCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXRMaW5lV2lkdGg6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX3NldExpbmVXaWR0aCh3aWR0aCkge1xuICAgICAgdGhpcy5jdXJyZW50LmxpbmVXaWR0aCA9IHdpZHRoO1xuICAgICAgdGhpcy5jdHgubGluZVdpZHRoID0gd2lkdGg7XG4gICAgfSxcbiAgICBzZXRMaW5lQ2FwOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19zZXRMaW5lQ2FwKHN0eWxlKSB7XG4gICAgICB0aGlzLmN0eC5saW5lQ2FwID0gTElORV9DQVBfU1RZTEVTW3N0eWxlXTtcbiAgICB9LFxuICAgIHNldExpbmVKb2luOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19zZXRMaW5lSm9pbihzdHlsZSkge1xuICAgICAgdGhpcy5jdHgubGluZUpvaW4gPSBMSU5FX0pPSU5fU1RZTEVTW3N0eWxlXTtcbiAgICB9LFxuICAgIHNldE1pdGVyTGltaXQ6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX3NldE1pdGVyTGltaXQobGltaXQpIHtcbiAgICAgIHRoaXMuY3R4Lm1pdGVyTGltaXQgPSBsaW1pdDtcbiAgICB9LFxuICAgIHNldERhc2g6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX3NldERhc2goZGFzaEFycmF5LCBkYXNoUGhhc2UpIHtcbiAgICAgIHZhciBjdHggPSB0aGlzLmN0eDtcblxuICAgICAgaWYgKGN0eC5zZXRMaW5lRGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGN0eC5zZXRMaW5lRGFzaChkYXNoQXJyYXkpO1xuICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBkYXNoUGhhc2U7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHNldFJlbmRlcmluZ0ludGVudChpbnRlbnQpIHt9LFxuXG4gICAgc2V0RmxhdG5lc3MoZmxhdG5lc3MpIHt9LFxuXG4gICAgc2V0R1N0YXRlOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19zZXRHU3RhdGUoc3RhdGVzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBzdGF0ZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICB2YXIgc3RhdGUgPSBzdGF0ZXNbaV07XG4gICAgICAgIHZhciBrZXkgPSBzdGF0ZVswXTtcbiAgICAgICAgdmFyIHZhbHVlID0gc3RhdGVbMV07XG5cbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICBjYXNlIFwiTFdcIjpcbiAgICAgICAgICAgIHRoaXMuc2V0TGluZVdpZHRoKHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcIkxDXCI6XG4gICAgICAgICAgICB0aGlzLnNldExpbmVDYXAodmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiTEpcIjpcbiAgICAgICAgICAgIHRoaXMuc2V0TGluZUpvaW4odmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiTUxcIjpcbiAgICAgICAgICAgIHRoaXMuc2V0TWl0ZXJMaW1pdCh2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJEXCI6XG4gICAgICAgICAgICB0aGlzLnNldERhc2godmFsdWVbMF0sIHZhbHVlWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcIlJJXCI6XG4gICAgICAgICAgICB0aGlzLnNldFJlbmRlcmluZ0ludGVudCh2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJGTFwiOlxuICAgICAgICAgICAgdGhpcy5zZXRGbGF0bmVzcyh2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJGb250XCI6XG4gICAgICAgICAgICB0aGlzLnNldEZvbnQodmFsdWVbMF0sIHZhbHVlWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcIkNBXCI6XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQuc3Ryb2tlQWxwaGEgPSBzdGF0ZVsxXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcImNhXCI6XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQuZmlsbEFscGhhID0gc3RhdGVbMV07XG4gICAgICAgICAgICB0aGlzLmN0eC5nbG9iYWxBbHBoYSA9IHN0YXRlWzFdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiQk1cIjpcbiAgICAgICAgICAgIHRoaXMuY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiU01hc2tcIjpcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2spIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGVTdGFjay5sZW5ndGggPiAwICYmIHRoaXMuc3RhdGVTdGFja1t0aGlzLnN0YXRlU3RhY2subGVuZ3RoIC0gMV0uYWN0aXZlU01hc2sgPT09IHRoaXMuY3VycmVudC5hY3RpdmVTTWFzaykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3VzcGVuZFNNYXNrR3JvdXAoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZFNNYXNrR3JvdXAoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2sgPSB2YWx1ZSA/IHRoaXMudGVtcFNNYXNrIDogbnVsbDtcblxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudC5hY3RpdmVTTWFzaykge1xuICAgICAgICAgICAgICB0aGlzLmJlZ2luU01hc2tHcm91cCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnRlbXBTTWFzayA9IG51bGw7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJUUlwiOlxuICAgICAgICAgICAgdGhpcy5jdXJyZW50LnRyYW5zZmVyTWFwcyA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBiZWdpblNNYXNrR3JvdXA6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX2JlZ2luU01hc2tHcm91cCgpIHtcbiAgICAgIHZhciBhY3RpdmVTTWFzayA9IHRoaXMuY3VycmVudC5hY3RpdmVTTWFzaztcbiAgICAgIHZhciBkcmF3bldpZHRoID0gYWN0aXZlU01hc2suY2FudmFzLndpZHRoO1xuICAgICAgdmFyIGRyYXduSGVpZ2h0ID0gYWN0aXZlU01hc2suY2FudmFzLmhlaWdodDtcbiAgICAgIHZhciBjYWNoZUlkID0gXCJzbWFza0dyb3VwQXRcIiArIHRoaXMuZ3JvdXBMZXZlbDtcbiAgICAgIHZhciBzY3JhdGNoQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoY2FjaGVJZCwgZHJhd25XaWR0aCwgZHJhd25IZWlnaHQsIHRydWUpO1xuICAgICAgdmFyIGN1cnJlbnRDdHggPSB0aGlzLmN0eDtcbiAgICAgIHZhciBjdXJyZW50VHJhbnNmb3JtID0gY3VycmVudEN0eC5tb3pDdXJyZW50VHJhbnNmb3JtO1xuICAgICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgICAgdmFyIGdyb3VwQ3R4ID0gc2NyYXRjaENhbnZhcy5jb250ZXh0O1xuICAgICAgZ3JvdXBDdHguc2NhbGUoMSAvIGFjdGl2ZVNNYXNrLnNjYWxlWCwgMSAvIGFjdGl2ZVNNYXNrLnNjYWxlWSk7XG4gICAgICBncm91cEN0eC50cmFuc2xhdGUoLWFjdGl2ZVNNYXNrLm9mZnNldFgsIC1hY3RpdmVTTWFzay5vZmZzZXRZKTtcbiAgICAgIGdyb3VwQ3R4LnRyYW5zZm9ybS5hcHBseShncm91cEN0eCwgY3VycmVudFRyYW5zZm9ybSk7XG4gICAgICBhY3RpdmVTTWFzay5zdGFydFRyYW5zZm9ybUludmVyc2UgPSBncm91cEN0eC5tb3pDdXJyZW50VHJhbnNmb3JtSW52ZXJzZTtcbiAgICAgIGNvcHlDdHhTdGF0ZShjdXJyZW50Q3R4LCBncm91cEN0eCk7XG4gICAgICB0aGlzLmN0eCA9IGdyb3VwQ3R4O1xuICAgICAgdGhpcy5zZXRHU3RhdGUoW1tcIkJNXCIsIFwic291cmNlLW92ZXJcIl0sIFtcImNhXCIsIDFdLCBbXCJDQVwiLCAxXV0pO1xuICAgICAgdGhpcy5ncm91cFN0YWNrLnB1c2goY3VycmVudEN0eCk7XG4gICAgICB0aGlzLmdyb3VwTGV2ZWwrKztcbiAgICB9LFxuICAgIHN1c3BlbmRTTWFza0dyb3VwOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19lbmRTTWFza0dyb3VwKCkge1xuICAgICAgdmFyIGdyb3VwQ3R4ID0gdGhpcy5jdHg7XG4gICAgICB0aGlzLmdyb3VwTGV2ZWwtLTtcbiAgICAgIHRoaXMuY3R4ID0gdGhpcy5ncm91cFN0YWNrLnBvcCgpO1xuICAgICAgY29tcG9zZVNNYXNrKHRoaXMuY3R4LCB0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2ssIGdyb3VwQ3R4LCB0aGlzLndlYkdMQ29udGV4dCk7XG4gICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgICBjb3B5Q3R4U3RhdGUoZ3JvdXBDdHgsIHRoaXMuY3R4KTtcbiAgICAgIHRoaXMuY3VycmVudC5yZXN1bWVTTWFza0N0eCA9IGdyb3VwQ3R4O1xuXG4gICAgICB2YXIgZGVsdGFUcmFuc2Zvcm0gPSBfdXRpbC5VdGlsLnRyYW5zZm9ybSh0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2suc3RhcnRUcmFuc2Zvcm1JbnZlcnNlLCBncm91cEN0eC5tb3pDdXJyZW50VHJhbnNmb3JtKTtcblxuICAgICAgdGhpcy5jdHgudHJhbnNmb3JtLmFwcGx5KHRoaXMuY3R4LCBkZWx0YVRyYW5zZm9ybSk7XG4gICAgICBncm91cEN0eC5zYXZlKCk7XG4gICAgICBncm91cEN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICBncm91cEN0eC5jbGVhclJlY3QoMCwgMCwgZ3JvdXBDdHguY2FudmFzLndpZHRoLCBncm91cEN0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICAgIGdyb3VwQ3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuICAgIHJlc3VtZVNNYXNrR3JvdXA6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX2VuZFNNYXNrR3JvdXAoKSB7XG4gICAgICB2YXIgZ3JvdXBDdHggPSB0aGlzLmN1cnJlbnQucmVzdW1lU01hc2tDdHg7XG4gICAgICB2YXIgY3VycmVudEN0eCA9IHRoaXMuY3R4O1xuICAgICAgdGhpcy5jdHggPSBncm91cEN0eDtcbiAgICAgIHRoaXMuZ3JvdXBTdGFjay5wdXNoKGN1cnJlbnRDdHgpO1xuICAgICAgdGhpcy5ncm91cExldmVsKys7XG4gICAgfSxcbiAgICBlbmRTTWFza0dyb3VwOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19lbmRTTWFza0dyb3VwKCkge1xuICAgICAgdmFyIGdyb3VwQ3R4ID0gdGhpcy5jdHg7XG4gICAgICB0aGlzLmdyb3VwTGV2ZWwtLTtcbiAgICAgIHRoaXMuY3R4ID0gdGhpcy5ncm91cFN0YWNrLnBvcCgpO1xuICAgICAgY29tcG9zZVNNYXNrKHRoaXMuY3R4LCB0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2ssIGdyb3VwQ3R4LCB0aGlzLndlYkdMQ29udGV4dCk7XG4gICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICBjb3B5Q3R4U3RhdGUoZ3JvdXBDdHgsIHRoaXMuY3R4KTtcblxuICAgICAgdmFyIGRlbHRhVHJhbnNmb3JtID0gX3V0aWwuVXRpbC50cmFuc2Zvcm0odGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrLnN0YXJ0VHJhbnNmb3JtSW52ZXJzZSwgZ3JvdXBDdHgubW96Q3VycmVudFRyYW5zZm9ybSk7XG5cbiAgICAgIHRoaXMuY3R4LnRyYW5zZm9ybS5hcHBseSh0aGlzLmN0eCwgZGVsdGFUcmFuc2Zvcm0pO1xuICAgIH0sXG4gICAgc2F2ZTogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3Nfc2F2ZSgpIHtcbiAgICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICAgIHZhciBvbGQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICB0aGlzLnN0YXRlU3RhY2sucHVzaChvbGQpO1xuICAgICAgdGhpcy5jdXJyZW50ID0gb2xkLmNsb25lKCk7XG4gICAgICB0aGlzLmN1cnJlbnQucmVzdW1lU01hc2tDdHggPSBudWxsO1xuICAgIH0sXG4gICAgcmVzdG9yZTogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3NfcmVzdG9yZSgpIHtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnQucmVzdW1lU01hc2tDdHgpIHtcbiAgICAgICAgdGhpcy5yZXN1bWVTTWFza0dyb3VwKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2sgIT09IG51bGwgJiYgKHRoaXMuc3RhdGVTdGFjay5sZW5ndGggPT09IDAgfHwgdGhpcy5zdGF0ZVN0YWNrW3RoaXMuc3RhdGVTdGFjay5sZW5ndGggLSAxXS5hY3RpdmVTTWFzayAhPT0gdGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrKSkge1xuICAgICAgICB0aGlzLmVuZFNNYXNrR3JvdXAoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc3RhdGVTdGFjay5sZW5ndGggIT09IDApIHtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy5zdGF0ZVN0YWNrLnBvcCgpO1xuICAgICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICAgIHRoaXMucGVuZGluZ0NsaXAgPSBudWxsO1xuICAgICAgICB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoID0gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRyYW5zZm9ybTogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3NfdHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICAgIHRoaXMuY3R4LnRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKTtcbiAgICAgIHRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGggPSBudWxsO1xuICAgIH0sXG4gICAgY29uc3RydWN0UGF0aDogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3NfY29uc3RydWN0UGF0aChvcHMsIGFyZ3MpIHtcbiAgICAgIHZhciBjdHggPSB0aGlzLmN0eDtcbiAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgICAgdmFyIHggPSBjdXJyZW50LngsXG4gICAgICAgICAgeSA9IGN1cnJlbnQueTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSAwLCBpaSA9IG9wcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIHN3aXRjaCAob3BzW2ldIHwgMCkge1xuICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnJlY3RhbmdsZTpcbiAgICAgICAgICAgIHggPSBhcmdzW2orK107XG4gICAgICAgICAgICB5ID0gYXJnc1tqKytdO1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gYXJnc1tqKytdO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IGFyZ3NbaisrXTtcblxuICAgICAgICAgICAgaWYgKHdpZHRoID09PSAwICYmIGN0eC5saW5lV2lkdGggPCB0aGlzLmdldFNpbmdsZVBpeGVsV2lkdGgoKSkge1xuICAgICAgICAgICAgICB3aWR0aCA9IHRoaXMuZ2V0U2luZ2xlUGl4ZWxXaWR0aCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaGVpZ2h0ID09PSAwICYmIGN0eC5saW5lV2lkdGggPCB0aGlzLmdldFNpbmdsZVBpeGVsV2lkdGgoKSkge1xuICAgICAgICAgICAgICBoZWlnaHQgPSB0aGlzLmdldFNpbmdsZVBpeGVsV2lkdGgoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHh3ID0geCArIHdpZHRoO1xuICAgICAgICAgICAgdmFyIHloID0geSArIGhlaWdodDtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHh3LCB5KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeHcsIHloKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeWgpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBfdXRpbC5PUFMubW92ZVRvOlxuICAgICAgICAgICAgeCA9IGFyZ3NbaisrXTtcbiAgICAgICAgICAgIHkgPSBhcmdzW2orK107XG4gICAgICAgICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5saW5lVG86XG4gICAgICAgICAgICB4ID0gYXJnc1tqKytdO1xuICAgICAgICAgICAgeSA9IGFyZ3NbaisrXTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLmN1cnZlVG86XG4gICAgICAgICAgICB4ID0gYXJnc1tqICsgNF07XG4gICAgICAgICAgICB5ID0gYXJnc1tqICsgNV07XG4gICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhhcmdzW2pdLCBhcmdzW2ogKyAxXSwgYXJnc1tqICsgMl0sIGFyZ3NbaiArIDNdLCB4LCB5KTtcbiAgICAgICAgICAgIGogKz0gNjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBfdXRpbC5PUFMuY3VydmVUbzI6XG4gICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyh4LCB5LCBhcmdzW2pdLCBhcmdzW2ogKyAxXSwgYXJnc1tqICsgMl0sIGFyZ3NbaiArIDNdKTtcbiAgICAgICAgICAgIHggPSBhcmdzW2ogKyAyXTtcbiAgICAgICAgICAgIHkgPSBhcmdzW2ogKyAzXTtcbiAgICAgICAgICAgIGogKz0gNDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBfdXRpbC5PUFMuY3VydmVUbzM6XG4gICAgICAgICAgICB4ID0gYXJnc1tqICsgMl07XG4gICAgICAgICAgICB5ID0gYXJnc1tqICsgM107XG4gICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhhcmdzW2pdLCBhcmdzW2ogKyAxXSwgeCwgeSwgeCwgeSk7XG4gICAgICAgICAgICBqICs9IDQ7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLmNsb3NlUGF0aDpcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnQuc2V0Q3VycmVudFBvaW50KHgsIHkpO1xuICAgIH0sXG4gICAgY2xvc2VQYXRoOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19jbG9zZVBhdGgoKSB7XG4gICAgICB0aGlzLmN0eC5jbG9zZVBhdGgoKTtcbiAgICB9LFxuICAgIHN0cm9rZTogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3Nfc3Ryb2tlKGNvbnN1bWVQYXRoKSB7XG4gICAgICBjb25zdW1lUGF0aCA9IHR5cGVvZiBjb25zdW1lUGF0aCAhPT0gXCJ1bmRlZmluZWRcIiA/IGNvbnN1bWVQYXRoIDogdHJ1ZTtcbiAgICAgIHZhciBjdHggPSB0aGlzLmN0eDtcbiAgICAgIHZhciBzdHJva2VDb2xvciA9IHRoaXMuY3VycmVudC5zdHJva2VDb2xvcjtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuY3VycmVudC5zdHJva2VBbHBoYTtcblxuICAgICAgaWYgKHRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgICAgaWYgKHN0cm9rZUNvbG9yICYmIHN0cm9rZUNvbG9yLmhhc093blByb3BlcnR5KFwidHlwZVwiKSAmJiBzdHJva2VDb2xvci50eXBlID09PSBcIlBhdHRlcm5cIikge1xuICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gY3R4Lm1vekN1cnJlbnRUcmFuc2Zvcm07XG5cbiAgICAgICAgICBjb25zdCBzY2FsZSA9IF91dGlsLlV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUodHJhbnNmb3JtKVswXTtcblxuICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZUNvbG9yLmdldFBhdHRlcm4oY3R4LCB0aGlzKTtcbiAgICAgICAgICBjdHgubGluZVdpZHRoID0gTWF0aC5tYXgodGhpcy5nZXRTaW5nbGVQaXhlbFdpZHRoKCkgKiBNSU5fV0lEVEhfRkFDVE9SLCB0aGlzLmN1cnJlbnQubGluZVdpZHRoICogc2NhbGUpO1xuICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBNYXRoLm1heCh0aGlzLmdldFNpbmdsZVBpeGVsV2lkdGgoKSAqIE1JTl9XSURUSF9GQUNUT1IsIHRoaXMuY3VycmVudC5saW5lV2lkdGgpO1xuICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY29uc3VtZVBhdGgpIHtcbiAgICAgICAgdGhpcy5jb25zdW1lUGF0aCgpO1xuICAgICAgfVxuXG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLmN1cnJlbnQuZmlsbEFscGhhO1xuICAgIH0sXG4gICAgY2xvc2VTdHJva2U6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX2Nsb3NlU3Ryb2tlKCkge1xuICAgICAgdGhpcy5jbG9zZVBhdGgoKTtcbiAgICAgIHRoaXMuc3Ryb2tlKCk7XG4gICAgfSxcbiAgICBmaWxsOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19maWxsKGNvbnN1bWVQYXRoKSB7XG4gICAgICBjb25zdW1lUGF0aCA9IHR5cGVvZiBjb25zdW1lUGF0aCAhPT0gXCJ1bmRlZmluZWRcIiA/IGNvbnN1bWVQYXRoIDogdHJ1ZTtcbiAgICAgIHZhciBjdHggPSB0aGlzLmN0eDtcbiAgICAgIHZhciBmaWxsQ29sb3IgPSB0aGlzLmN1cnJlbnQuZmlsbENvbG9yO1xuICAgICAgdmFyIGlzUGF0dGVybkZpbGwgPSB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGw7XG4gICAgICB2YXIgbmVlZFJlc3RvcmUgPSBmYWxzZTtcblxuICAgICAgaWYgKGlzUGF0dGVybkZpbGwpIHtcbiAgICAgICAgY3R4LnNhdmUoKTtcblxuICAgICAgICBpZiAodGhpcy5iYXNlVHJhbnNmb3JtKSB7XG4gICAgICAgICAgY3R4LnNldFRyYW5zZm9ybS5hcHBseShjdHgsIHRoaXMuYmFzZVRyYW5zZm9ybSk7XG4gICAgICAgIH1cblxuICAgICAgICBjdHguZmlsbFN0eWxlID0gZmlsbENvbG9yLmdldFBhdHRlcm4oY3R4LCB0aGlzKTtcbiAgICAgICAgbmVlZFJlc3RvcmUgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nRU9GaWxsKSB7XG4gICAgICAgICAgY3R4LmZpbGwoXCJldmVub2RkXCIpO1xuICAgICAgICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG5lZWRSZXN0b3JlKSB7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb25zdW1lUGF0aCkge1xuICAgICAgICB0aGlzLmNvbnN1bWVQYXRoKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBlb0ZpbGw6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX2VvRmlsbCgpIHtcbiAgICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IHRydWU7XG4gICAgICB0aGlzLmZpbGwoKTtcbiAgICB9LFxuICAgIGZpbGxTdHJva2U6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX2ZpbGxTdHJva2UoKSB7XG4gICAgICB0aGlzLmZpbGwoZmFsc2UpO1xuICAgICAgdGhpcy5zdHJva2UoZmFsc2UpO1xuICAgICAgdGhpcy5jb25zdW1lUGF0aCgpO1xuICAgIH0sXG4gICAgZW9GaWxsU3Ryb2tlOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19lb0ZpbGxTdHJva2UoKSB7XG4gICAgICB0aGlzLnBlbmRpbmdFT0ZpbGwgPSB0cnVlO1xuICAgICAgdGhpcy5maWxsU3Ryb2tlKCk7XG4gICAgfSxcbiAgICBjbG9zZUZpbGxTdHJva2U6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX2Nsb3NlRmlsbFN0cm9rZSgpIHtcbiAgICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gICAgICB0aGlzLmZpbGxTdHJva2UoKTtcbiAgICB9LFxuICAgIGNsb3NlRU9GaWxsU3Ryb2tlOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19jbG9zZUVPRmlsbFN0cm9rZSgpIHtcbiAgICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IHRydWU7XG4gICAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICAgICAgdGhpcy5maWxsU3Ryb2tlKCk7XG4gICAgfSxcbiAgICBlbmRQYXRoOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19lbmRQYXRoKCkge1xuICAgICAgdGhpcy5jb25zdW1lUGF0aCgpO1xuICAgIH0sXG4gICAgY2xpcDogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3NfY2xpcCgpIHtcbiAgICAgIHRoaXMucGVuZGluZ0NsaXAgPSBOT1JNQUxfQ0xJUDtcbiAgICB9LFxuICAgIGVvQ2xpcDogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3NfZW9DbGlwKCkge1xuICAgICAgdGhpcy5wZW5kaW5nQ2xpcCA9IEVPX0NMSVA7XG4gICAgfSxcbiAgICBiZWdpblRleHQ6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX2JlZ2luVGV4dCgpIHtcbiAgICAgIHRoaXMuY3VycmVudC50ZXh0TWF0cml4ID0gX3V0aWwuSURFTlRJVFlfTUFUUklYO1xuICAgICAgdGhpcy5jdXJyZW50LnRleHRNYXRyaXhTY2FsZSA9IDE7XG4gICAgICB0aGlzLmN1cnJlbnQueCA9IHRoaXMuY3VycmVudC5saW5lWCA9IDA7XG4gICAgICB0aGlzLmN1cnJlbnQueSA9IHRoaXMuY3VycmVudC5saW5lWSA9IDA7XG4gICAgfSxcbiAgICBlbmRUZXh0OiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19lbmRUZXh0KCkge1xuICAgICAgdmFyIHBhdGhzID0gdGhpcy5wZW5kaW5nVGV4dFBhdGhzO1xuICAgICAgdmFyIGN0eCA9IHRoaXMuY3R4O1xuXG4gICAgICBpZiAocGF0aHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcGF0aCA9IHBhdGhzW2ldO1xuICAgICAgICBjdHguc2V0VHJhbnNmb3JtLmFwcGx5KGN0eCwgcGF0aC50cmFuc2Zvcm0pO1xuICAgICAgICBjdHgudHJhbnNsYXRlKHBhdGgueCwgcGF0aC55KTtcbiAgICAgICAgcGF0aC5hZGRUb1BhdGgoY3R4LCBwYXRoLmZvbnRTaXplKTtcbiAgICAgIH1cblxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIGN0eC5jbGlwKCk7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBkZWxldGUgdGhpcy5wZW5kaW5nVGV4dFBhdGhzO1xuICAgIH0sXG4gICAgc2V0Q2hhclNwYWNpbmc6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX3NldENoYXJTcGFjaW5nKHNwYWNpbmcpIHtcbiAgICAgIHRoaXMuY3VycmVudC5jaGFyU3BhY2luZyA9IHNwYWNpbmc7XG4gICAgfSxcbiAgICBzZXRXb3JkU3BhY2luZzogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3Nfc2V0V29yZFNwYWNpbmcoc3BhY2luZykge1xuICAgICAgdGhpcy5jdXJyZW50LndvcmRTcGFjaW5nID0gc3BhY2luZztcbiAgICB9LFxuICAgIHNldEhTY2FsZTogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3Nfc2V0SFNjYWxlKHNjYWxlKSB7XG4gICAgICB0aGlzLmN1cnJlbnQudGV4dEhTY2FsZSA9IHNjYWxlIC8gMTAwO1xuICAgIH0sXG4gICAgc2V0TGVhZGluZzogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3Nfc2V0TGVhZGluZyhsZWFkaW5nKSB7XG4gICAgICB0aGlzLmN1cnJlbnQubGVhZGluZyA9IC1sZWFkaW5nO1xuICAgIH0sXG4gICAgc2V0Rm9udDogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3Nfc2V0Rm9udChmb250UmVmTmFtZSwgc2l6ZSkge1xuICAgICAgdmFyIGZvbnRPYmogPSB0aGlzLmNvbW1vbk9ianMuZ2V0KGZvbnRSZWZOYW1lKTtcbiAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuXG4gICAgICBpZiAoIWZvbnRPYmopIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBmaW5kIGZvbnQgZm9yICR7Zm9udFJlZk5hbWV9YCk7XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnQuZm9udE1hdHJpeCA9IGZvbnRPYmouZm9udE1hdHJpeCA/IGZvbnRPYmouZm9udE1hdHJpeCA6IF91dGlsLkZPTlRfSURFTlRJVFlfTUFUUklYO1xuXG4gICAgICBpZiAoY3VycmVudC5mb250TWF0cml4WzBdID09PSAwIHx8IGN1cnJlbnQuZm9udE1hdHJpeFszXSA9PT0gMCkge1xuICAgICAgICAoMCwgX3V0aWwud2FybikoXCJJbnZhbGlkIGZvbnQgbWF0cml4IGZvciBmb250IFwiICsgZm9udFJlZk5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2l6ZSA8IDApIHtcbiAgICAgICAgc2l6ZSA9IC1zaXplO1xuICAgICAgICBjdXJyZW50LmZvbnREaXJlY3Rpb24gPSAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnQuZm9udERpcmVjdGlvbiA9IDE7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY3VycmVudC5mb250ID0gZm9udE9iajtcbiAgICAgIHRoaXMuY3VycmVudC5mb250U2l6ZSA9IHNpemU7XG5cbiAgICAgIGlmIChmb250T2JqLmlzVHlwZTNGb250KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG5hbWUgPSBmb250T2JqLmxvYWRlZE5hbWUgfHwgXCJzYW5zLXNlcmlmXCI7XG4gICAgICBsZXQgYm9sZCA9IFwibm9ybWFsXCI7XG5cbiAgICAgIGlmIChmb250T2JqLmJsYWNrKSB7XG4gICAgICAgIGJvbGQgPSBcIjkwMFwiO1xuICAgICAgfSBlbHNlIGlmIChmb250T2JqLmJvbGQpIHtcbiAgICAgICAgYm9sZCA9IFwiYm9sZFwiO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXRhbGljID0gZm9udE9iai5pdGFsaWMgPyBcIml0YWxpY1wiIDogXCJub3JtYWxcIjtcbiAgICAgIHZhciB0eXBlZmFjZSA9IGBcIiR7bmFtZX1cIiwgJHtmb250T2JqLmZhbGxiYWNrTmFtZX1gO1xuICAgICAgbGV0IGJyb3dzZXJGb250U2l6ZSA9IHNpemU7XG5cbiAgICAgIGlmIChzaXplIDwgTUlOX0ZPTlRfU0laRSkge1xuICAgICAgICBicm93c2VyRm9udFNpemUgPSBNSU5fRk9OVF9TSVpFO1xuICAgICAgfSBlbHNlIGlmIChzaXplID4gTUFYX0ZPTlRfU0laRSkge1xuICAgICAgICBicm93c2VyRm9udFNpemUgPSBNQVhfRk9OVF9TSVpFO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmN1cnJlbnQuZm9udFNpemVTY2FsZSA9IHNpemUgLyBicm93c2VyRm9udFNpemU7XG4gICAgICB0aGlzLmN0eC5mb250ID0gYCR7aXRhbGljfSAke2JvbGR9ICR7YnJvd3NlckZvbnRTaXplfXB4ICR7dHlwZWZhY2V9YDtcbiAgICB9LFxuICAgIHNldFRleHRSZW5kZXJpbmdNb2RlOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19zZXRUZXh0UmVuZGVyaW5nTW9kZShtb2RlKSB7XG4gICAgICB0aGlzLmN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGUgPSBtb2RlO1xuICAgIH0sXG4gICAgc2V0VGV4dFJpc2U6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX3NldFRleHRSaXNlKHJpc2UpIHtcbiAgICAgIHRoaXMuY3VycmVudC50ZXh0UmlzZSA9IHJpc2U7XG4gICAgfSxcbiAgICBtb3ZlVGV4dDogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3NfbW92ZVRleHQoeCwgeSkge1xuICAgICAgdGhpcy5jdXJyZW50LnggPSB0aGlzLmN1cnJlbnQubGluZVggKz0geDtcbiAgICAgIHRoaXMuY3VycmVudC55ID0gdGhpcy5jdXJyZW50LmxpbmVZICs9IHk7XG4gICAgfSxcbiAgICBzZXRMZWFkaW5nTW92ZVRleHQ6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX3NldExlYWRpbmdNb3ZlVGV4dCh4LCB5KSB7XG4gICAgICB0aGlzLnNldExlYWRpbmcoLXkpO1xuICAgICAgdGhpcy5tb3ZlVGV4dCh4LCB5KTtcbiAgICB9LFxuICAgIHNldFRleHRNYXRyaXg6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX3NldFRleHRNYXRyaXgoYSwgYiwgYywgZCwgZSwgZikge1xuICAgICAgdGhpcy5jdXJyZW50LnRleHRNYXRyaXggPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICB0aGlzLmN1cnJlbnQudGV4dE1hdHJpeFNjYWxlID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpO1xuICAgICAgdGhpcy5jdXJyZW50LnggPSB0aGlzLmN1cnJlbnQubGluZVggPSAwO1xuICAgICAgdGhpcy5jdXJyZW50LnkgPSB0aGlzLmN1cnJlbnQubGluZVkgPSAwO1xuICAgIH0sXG4gICAgbmV4dExpbmU6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX25leHRMaW5lKCkge1xuICAgICAgdGhpcy5tb3ZlVGV4dCgwLCB0aGlzLmN1cnJlbnQubGVhZGluZyk7XG4gICAgfSxcblxuICAgIHBhaW50Q2hhcihjaGFyYWN0ZXIsIHgsIHksIHBhdHRlcm5UcmFuc2Zvcm0pIHtcbiAgICAgIHZhciBjdHggPSB0aGlzLmN0eDtcbiAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgICAgdmFyIGZvbnQgPSBjdXJyZW50LmZvbnQ7XG4gICAgICB2YXIgdGV4dFJlbmRlcmluZ01vZGUgPSBjdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlO1xuICAgICAgdmFyIGZvbnRTaXplID0gY3VycmVudC5mb250U2l6ZSAvIGN1cnJlbnQuZm9udFNpemVTY2FsZTtcbiAgICAgIHZhciBmaWxsU3Ryb2tlTW9kZSA9IHRleHRSZW5kZXJpbmdNb2RlICYgX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0VfTUFTSztcbiAgICAgIHZhciBpc0FkZFRvUGF0aFNldCA9ICEhKHRleHRSZW5kZXJpbmdNb2RlICYgX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuQUREX1RPX1BBVEhfRkxBRyk7XG4gICAgICBjb25zdCBwYXR0ZXJuRmlsbCA9IGN1cnJlbnQucGF0dGVybkZpbGwgJiYgIWZvbnQubWlzc2luZ0ZpbGU7XG4gICAgICB2YXIgYWRkVG9QYXRoO1xuXG4gICAgICBpZiAoZm9udC5kaXNhYmxlRm9udEZhY2UgfHwgaXNBZGRUb1BhdGhTZXQgfHwgcGF0dGVybkZpbGwpIHtcbiAgICAgICAgYWRkVG9QYXRoID0gZm9udC5nZXRQYXRoR2VuZXJhdG9yKHRoaXMuY29tbW9uT2JqcywgY2hhcmFjdGVyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZvbnQuZGlzYWJsZUZvbnRGYWNlIHx8IHBhdHRlcm5GaWxsKSB7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoeCwgeSk7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgYWRkVG9QYXRoKGN0eCwgZm9udFNpemUpO1xuXG4gICAgICAgIGlmIChwYXR0ZXJuVHJhbnNmb3JtKSB7XG4gICAgICAgICAgY3R4LnNldFRyYW5zZm9ybS5hcHBseShjdHgsIHBhdHRlcm5UcmFuc2Zvcm0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZpbGxTdHJva2VNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMIHx8IGZpbGxTdHJva2VNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRSkge1xuICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLlNUUk9LRSB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0UpIHtcbiAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZpbGxTdHJva2VNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMIHx8IGZpbGxTdHJva2VNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRSkge1xuICAgICAgICAgIGN0eC5maWxsVGV4dChjaGFyYWN0ZXIsIHgsIHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZpbGxTdHJva2VNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5TVFJPS0UgfHwgZmlsbFN0cm9rZU1vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFKSB7XG4gICAgICAgICAgY3R4LnN0cm9rZVRleHQoY2hhcmFjdGVyLCB4LCB5KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBZGRUb1BhdGhTZXQpIHtcbiAgICAgICAgdmFyIHBhdGhzID0gdGhpcy5wZW5kaW5nVGV4dFBhdGhzIHx8ICh0aGlzLnBlbmRpbmdUZXh0UGF0aHMgPSBbXSk7XG4gICAgICAgIHBhdGhzLnB1c2goe1xuICAgICAgICAgIHRyYW5zZm9ybTogY3R4Lm1vekN1cnJlbnRUcmFuc2Zvcm0sXG4gICAgICAgICAgeCxcbiAgICAgICAgICB5LFxuICAgICAgICAgIGZvbnRTaXplLFxuICAgICAgICAgIGFkZFRvUGF0aFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0IGlzRm9udFN1YnBpeGVsQUFFbmFibGVkKCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb250ZXh0OiBjdHhcbiAgICAgIH0gPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcImlzRm9udFN1YnBpeGVsQUFFbmFibGVkXCIsIDEwLCAxMCk7XG4gICAgICBjdHguc2NhbGUoMS41LCAxKTtcbiAgICAgIGN0eC5maWxsVGV4dChcIklcIiwgMCwgMTApO1xuICAgICAgdmFyIGRhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDEwLCAxMCkuZGF0YTtcbiAgICAgIHZhciBlbmFibGVkID0gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIGkgPSAzOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICBpZiAoZGF0YVtpXSA+IDAgJiYgZGF0YVtpXSA8IDI1NSkge1xuICAgICAgICAgIGVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoMCwgX3V0aWwuc2hhZG93KSh0aGlzLCBcImlzRm9udFN1YnBpeGVsQUFFbmFibGVkXCIsIGVuYWJsZWQpO1xuICAgIH0sXG5cbiAgICBzaG93VGV4dDogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3Nfc2hvd1RleHQoZ2x5cGhzKSB7XG4gICAgICB2YXIgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICAgIHZhciBmb250ID0gY3VycmVudC5mb250O1xuXG4gICAgICBpZiAoZm9udC5pc1R5cGUzRm9udCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaG93VHlwZTNUZXh0KGdseXBocyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBmb250U2l6ZSA9IGN1cnJlbnQuZm9udFNpemU7XG5cbiAgICAgIGlmIChmb250U2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3R4ID0gdGhpcy5jdHg7XG4gICAgICB2YXIgZm9udFNpemVTY2FsZSA9IGN1cnJlbnQuZm9udFNpemVTY2FsZTtcbiAgICAgIHZhciBjaGFyU3BhY2luZyA9IGN1cnJlbnQuY2hhclNwYWNpbmc7XG4gICAgICB2YXIgd29yZFNwYWNpbmcgPSBjdXJyZW50LndvcmRTcGFjaW5nO1xuICAgICAgdmFyIGZvbnREaXJlY3Rpb24gPSBjdXJyZW50LmZvbnREaXJlY3Rpb247XG4gICAgICB2YXIgdGV4dEhTY2FsZSA9IGN1cnJlbnQudGV4dEhTY2FsZSAqIGZvbnREaXJlY3Rpb247XG4gICAgICB2YXIgZ2x5cGhzTGVuZ3RoID0gZ2x5cGhzLmxlbmd0aDtcbiAgICAgIHZhciB2ZXJ0aWNhbCA9IGZvbnQudmVydGljYWw7XG4gICAgICB2YXIgc3BhY2luZ0RpciA9IHZlcnRpY2FsID8gMSA6IC0xO1xuICAgICAgdmFyIGRlZmF1bHRWTWV0cmljcyA9IGZvbnQuZGVmYXVsdFZNZXRyaWNzO1xuICAgICAgdmFyIHdpZHRoQWR2YW5jZVNjYWxlID0gZm9udFNpemUgKiBjdXJyZW50LmZvbnRNYXRyaXhbMF07XG4gICAgICB2YXIgc2ltcGxlRmlsbFRleHQgPSBjdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMICYmICFmb250LmRpc2FibGVGb250RmFjZSAmJiAhY3VycmVudC5wYXR0ZXJuRmlsbDtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBsZXQgcGF0dGVyblRyYW5zZm9ybTtcblxuICAgICAgaWYgKGN1cnJlbnQucGF0dGVybkZpbGwpIHtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IGN1cnJlbnQuZmlsbENvbG9yLmdldFBhdHRlcm4oY3R4LCB0aGlzKTtcbiAgICAgICAgcGF0dGVyblRyYW5zZm9ybSA9IGN0eC5tb3pDdXJyZW50VHJhbnNmb3JtO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gcGF0dGVybjtcbiAgICAgIH1cblxuICAgICAgY3R4LnRyYW5zZm9ybS5hcHBseShjdHgsIGN1cnJlbnQudGV4dE1hdHJpeCk7XG4gICAgICBjdHgudHJhbnNsYXRlKGN1cnJlbnQueCwgY3VycmVudC55ICsgY3VycmVudC50ZXh0UmlzZSk7XG5cbiAgICAgIGlmIChmb250RGlyZWN0aW9uID4gMCkge1xuICAgICAgICBjdHguc2NhbGUodGV4dEhTY2FsZSwgLTEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LnNjYWxlKHRleHRIU2NhbGUsIDEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGluZVdpZHRoID0gY3VycmVudC5saW5lV2lkdGg7XG4gICAgICB2YXIgc2NhbGUgPSBjdXJyZW50LnRleHRNYXRyaXhTY2FsZTtcblxuICAgICAgaWYgKHNjYWxlID09PSAwIHx8IGxpbmVXaWR0aCA9PT0gMCkge1xuICAgICAgICB2YXIgZmlsbFN0cm9rZU1vZGUgPSBjdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlICYgX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0VfTUFTSztcblxuICAgICAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLlNUUk9LRSB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0UpIHtcbiAgICAgICAgICB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoID0gbnVsbDtcbiAgICAgICAgICBsaW5lV2lkdGggPSB0aGlzLmdldFNpbmdsZVBpeGVsV2lkdGgoKSAqIE1JTl9XSURUSF9GQUNUT1I7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpbmVXaWR0aCAvPSBzY2FsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZvbnRTaXplU2NhbGUgIT09IDEuMCkge1xuICAgICAgICBjdHguc2NhbGUoZm9udFNpemVTY2FsZSwgZm9udFNpemVTY2FsZSk7XG4gICAgICAgIGxpbmVXaWR0aCAvPSBmb250U2l6ZVNjYWxlO1xuICAgICAgfVxuXG4gICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgdmFyIHggPSAwLFxuICAgICAgICAgIGk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBnbHlwaHNMZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgZ2x5cGggPSBnbHlwaHNbaV07XG5cbiAgICAgICAgaWYgKCgwLCBfdXRpbC5pc051bSkoZ2x5cGgpKSB7XG4gICAgICAgICAgeCArPSBzcGFjaW5nRGlyICogZ2x5cGggKiBmb250U2l6ZSAvIDEwMDA7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdG9yZU5lZWRlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgc3BhY2luZyA9IChnbHlwaC5pc1NwYWNlID8gd29yZFNwYWNpbmcgOiAwKSArIGNoYXJTcGFjaW5nO1xuICAgICAgICB2YXIgY2hhcmFjdGVyID0gZ2x5cGguZm9udENoYXI7XG4gICAgICAgIHZhciBhY2NlbnQgPSBnbHlwaC5hY2NlbnQ7XG4gICAgICAgIHZhciBzY2FsZWRYLCBzY2FsZWRZLCBzY2FsZWRBY2NlbnRYLCBzY2FsZWRBY2NlbnRZO1xuICAgICAgICB2YXIgd2lkdGggPSBnbHlwaC53aWR0aDtcblxuICAgICAgICBpZiAodmVydGljYWwpIHtcbiAgICAgICAgICB2YXIgdm1ldHJpYywgdngsIHZ5O1xuICAgICAgICAgIHZtZXRyaWMgPSBnbHlwaC52bWV0cmljIHx8IGRlZmF1bHRWTWV0cmljcztcbiAgICAgICAgICB2eCA9IGdseXBoLnZtZXRyaWMgPyB2bWV0cmljWzFdIDogd2lkdGggKiAwLjU7XG4gICAgICAgICAgdnggPSAtdnggKiB3aWR0aEFkdmFuY2VTY2FsZTtcbiAgICAgICAgICB2eSA9IHZtZXRyaWNbMl0gKiB3aWR0aEFkdmFuY2VTY2FsZTtcbiAgICAgICAgICB3aWR0aCA9IHZtZXRyaWMgPyAtdm1ldHJpY1swXSA6IHdpZHRoO1xuICAgICAgICAgIHNjYWxlZFggPSB2eCAvIGZvbnRTaXplU2NhbGU7XG4gICAgICAgICAgc2NhbGVkWSA9ICh4ICsgdnkpIC8gZm9udFNpemVTY2FsZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzY2FsZWRYID0geCAvIGZvbnRTaXplU2NhbGU7XG4gICAgICAgICAgc2NhbGVkWSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm9udC5yZW1lYXN1cmUgJiYgd2lkdGggPiAwKSB7XG4gICAgICAgICAgdmFyIG1lYXN1cmVkV2lkdGggPSBjdHgubWVhc3VyZVRleHQoY2hhcmFjdGVyKS53aWR0aCAqIDEwMDAgLyBmb250U2l6ZSAqIGZvbnRTaXplU2NhbGU7XG5cbiAgICAgICAgICBpZiAod2lkdGggPCBtZWFzdXJlZFdpZHRoICYmIHRoaXMuaXNGb250U3VicGl4ZWxBQUVuYWJsZWQpIHtcbiAgICAgICAgICAgIHZhciBjaGFyYWN0ZXJTY2FsZVggPSB3aWR0aCAvIG1lYXN1cmVkV2lkdGg7XG4gICAgICAgICAgICByZXN0b3JlTmVlZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHguc2NhbGUoY2hhcmFjdGVyU2NhbGVYLCAxKTtcbiAgICAgICAgICAgIHNjYWxlZFggLz0gY2hhcmFjdGVyU2NhbGVYO1xuICAgICAgICAgIH0gZWxzZSBpZiAod2lkdGggIT09IG1lYXN1cmVkV2lkdGgpIHtcbiAgICAgICAgICAgIHNjYWxlZFggKz0gKHdpZHRoIC0gbWVhc3VyZWRXaWR0aCkgLyAyMDAwICogZm9udFNpemUgLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRWaXNpYmxlICYmIChnbHlwaC5pc0luRm9udCB8fCBmb250Lm1pc3NpbmdGaWxlKSkge1xuICAgICAgICAgIGlmIChzaW1wbGVGaWxsVGV4dCAmJiAhYWNjZW50KSB7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQoY2hhcmFjdGVyLCBzY2FsZWRYLCBzY2FsZWRZKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wYWludENoYXIoY2hhcmFjdGVyLCBzY2FsZWRYLCBzY2FsZWRZLCBwYXR0ZXJuVHJhbnNmb3JtKTtcblxuICAgICAgICAgICAgaWYgKGFjY2VudCkge1xuICAgICAgICAgICAgICBzY2FsZWRBY2NlbnRYID0gc2NhbGVkWCArIGZvbnRTaXplICogYWNjZW50Lm9mZnNldC54IC8gZm9udFNpemVTY2FsZTtcbiAgICAgICAgICAgICAgc2NhbGVkQWNjZW50WSA9IHNjYWxlZFkgLSBmb250U2l6ZSAqIGFjY2VudC5vZmZzZXQueSAvIGZvbnRTaXplU2NhbGU7XG4gICAgICAgICAgICAgIHRoaXMucGFpbnRDaGFyKGFjY2VudC5mb250Q2hhciwgc2NhbGVkQWNjZW50WCwgc2NhbGVkQWNjZW50WSwgcGF0dGVyblRyYW5zZm9ybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoYXJXaWR0aDtcblxuICAgICAgICBpZiAodmVydGljYWwpIHtcbiAgICAgICAgICBjaGFyV2lkdGggPSB3aWR0aCAqIHdpZHRoQWR2YW5jZVNjYWxlIC0gc3BhY2luZyAqIGZvbnREaXJlY3Rpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hhcldpZHRoID0gd2lkdGggKiB3aWR0aEFkdmFuY2VTY2FsZSArIHNwYWNpbmcgKiBmb250RGlyZWN0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgeCArPSBjaGFyV2lkdGg7XG5cbiAgICAgICAgaWYgKHJlc3RvcmVOZWVkZWQpIHtcbiAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgICBjdXJyZW50LnkgLT0geDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnQueCArPSB4ICogdGV4dEhTY2FsZTtcbiAgICAgIH1cblxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuICAgIHNob3dUeXBlM1RleHQ6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX3Nob3dUeXBlM1RleHQoZ2x5cGhzKSB7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5jdHg7XG4gICAgICB2YXIgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICAgIHZhciBmb250ID0gY3VycmVudC5mb250O1xuICAgICAgdmFyIGZvbnRTaXplID0gY3VycmVudC5mb250U2l6ZTtcbiAgICAgIHZhciBmb250RGlyZWN0aW9uID0gY3VycmVudC5mb250RGlyZWN0aW9uO1xuICAgICAgdmFyIHNwYWNpbmdEaXIgPSBmb250LnZlcnRpY2FsID8gMSA6IC0xO1xuICAgICAgdmFyIGNoYXJTcGFjaW5nID0gY3VycmVudC5jaGFyU3BhY2luZztcbiAgICAgIHZhciB3b3JkU3BhY2luZyA9IGN1cnJlbnQud29yZFNwYWNpbmc7XG4gICAgICB2YXIgdGV4dEhTY2FsZSA9IGN1cnJlbnQudGV4dEhTY2FsZSAqIGZvbnREaXJlY3Rpb247XG4gICAgICB2YXIgZm9udE1hdHJpeCA9IGN1cnJlbnQuZm9udE1hdHJpeCB8fCBfdXRpbC5GT05UX0lERU5USVRZX01BVFJJWDtcbiAgICAgIHZhciBnbHlwaHNMZW5ndGggPSBnbHlwaHMubGVuZ3RoO1xuICAgICAgdmFyIGlzVGV4dEludmlzaWJsZSA9IGN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLklOVklTSUJMRTtcbiAgICAgIHZhciBpLCBnbHlwaCwgd2lkdGgsIHNwYWNpbmdMZW5ndGg7XG5cbiAgICAgIGlmIChpc1RleHRJbnZpc2libGUgfHwgZm9udFNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoID0gbnVsbDtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNmb3JtLmFwcGx5KGN0eCwgY3VycmVudC50ZXh0TWF0cml4KTtcbiAgICAgIGN0eC50cmFuc2xhdGUoY3VycmVudC54LCBjdXJyZW50LnkpO1xuICAgICAgY3R4LnNjYWxlKHRleHRIU2NhbGUsIGZvbnREaXJlY3Rpb24pO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZ2x5cGhzTGVuZ3RoOyArK2kpIHtcbiAgICAgICAgZ2x5cGggPSBnbHlwaHNbaV07XG5cbiAgICAgICAgaWYgKCgwLCBfdXRpbC5pc051bSkoZ2x5cGgpKSB7XG4gICAgICAgICAgc3BhY2luZ0xlbmd0aCA9IHNwYWNpbmdEaXIgKiBnbHlwaCAqIGZvbnRTaXplIC8gMTAwMDtcbiAgICAgICAgICB0aGlzLmN0eC50cmFuc2xhdGUoc3BhY2luZ0xlbmd0aCwgMCk7XG4gICAgICAgICAgY3VycmVudC54ICs9IHNwYWNpbmdMZW5ndGggKiB0ZXh0SFNjYWxlO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNwYWNpbmcgPSAoZ2x5cGguaXNTcGFjZSA/IHdvcmRTcGFjaW5nIDogMCkgKyBjaGFyU3BhY2luZztcbiAgICAgICAgdmFyIG9wZXJhdG9yTGlzdCA9IGZvbnQuY2hhclByb2NPcGVyYXRvckxpc3RbZ2x5cGgub3BlcmF0b3JMaXN0SWRdO1xuXG4gICAgICAgIGlmICghb3BlcmF0b3JMaXN0KSB7XG4gICAgICAgICAgKDAsIF91dGlsLndhcm4pKGBUeXBlMyBjaGFyYWN0ZXIgXCIke2dseXBoLm9wZXJhdG9yTGlzdElkfVwiIGlzIG5vdCBhdmFpbGFibGUuYCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgICAgIHRoaXMucHJvY2Vzc2luZ1R5cGUzID0gZ2x5cGg7XG4gICAgICAgICAgdGhpcy5zYXZlKCk7XG4gICAgICAgICAgY3R4LnNjYWxlKGZvbnRTaXplLCBmb250U2l6ZSk7XG4gICAgICAgICAgY3R4LnRyYW5zZm9ybS5hcHBseShjdHgsIGZvbnRNYXRyaXgpO1xuICAgICAgICAgIHRoaXMuZXhlY3V0ZU9wZXJhdG9yTGlzdChvcGVyYXRvckxpc3QpO1xuICAgICAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRyYW5zZm9ybWVkID0gX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShbZ2x5cGgud2lkdGgsIDBdLCBmb250TWF0cml4KTtcblxuICAgICAgICB3aWR0aCA9IHRyYW5zZm9ybWVkWzBdICogZm9udFNpemUgKyBzcGFjaW5nO1xuICAgICAgICBjdHgudHJhbnNsYXRlKHdpZHRoLCAwKTtcbiAgICAgICAgY3VycmVudC54ICs9IHdpZHRoICogdGV4dEhTY2FsZTtcbiAgICAgIH1cblxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIHRoaXMucHJvY2Vzc2luZ1R5cGUzID0gbnVsbDtcbiAgICB9LFxuICAgIHNldENoYXJXaWR0aDogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3Nfc2V0Q2hhcldpZHRoKHhXaWR0aCwgeVdpZHRoKSB7fSxcbiAgICBzZXRDaGFyV2lkdGhBbmRCb3VuZHM6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX3NldENoYXJXaWR0aEFuZEJvdW5kcyh4V2lkdGgsIHlXaWR0aCwgbGx4LCBsbHksIHVyeCwgdXJ5KSB7XG4gICAgICB0aGlzLmN0eC5yZWN0KGxseCwgbGx5LCB1cnggLSBsbHgsIHVyeSAtIGxseSk7XG4gICAgICB0aGlzLmNsaXAoKTtcbiAgICAgIHRoaXMuZW5kUGF0aCgpO1xuICAgIH0sXG4gICAgZ2V0Q29sb3JOX1BhdHRlcm46IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX2dldENvbG9yTl9QYXR0ZXJuKElSKSB7XG4gICAgICB2YXIgcGF0dGVybjtcblxuICAgICAgaWYgKElSWzBdID09PSBcIlRpbGluZ1BhdHRlcm5cIikge1xuICAgICAgICB2YXIgY29sb3IgPSBJUlsxXTtcbiAgICAgICAgdmFyIGJhc2VUcmFuc2Zvcm0gPSB0aGlzLmJhc2VUcmFuc2Zvcm0gfHwgdGhpcy5jdHgubW96Q3VycmVudFRyYW5zZm9ybS5zbGljZSgpO1xuICAgICAgICB2YXIgY2FudmFzR3JhcGhpY3NGYWN0b3J5ID0ge1xuICAgICAgICAgIGNyZWF0ZUNhbnZhc0dyYXBoaWNzOiBjdHggPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDYW52YXNHcmFwaGljcyhjdHgsIHRoaXMuY29tbW9uT2JqcywgdGhpcy5vYmpzLCB0aGlzLmNhbnZhc0ZhY3RvcnksIHRoaXMud2ViR0xDb250ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHBhdHRlcm4gPSBuZXcgX3BhdHRlcm5faGVscGVyLlRpbGluZ1BhdHRlcm4oSVIsIGNvbG9yLCB0aGlzLmN0eCwgY2FudmFzR3JhcGhpY3NGYWN0b3J5LCBiYXNlVHJhbnNmb3JtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdHRlcm4gPSAoMCwgX3BhdHRlcm5faGVscGVyLmdldFNoYWRpbmdQYXR0ZXJuRnJvbUlSKShJUik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXR0ZXJuO1xuICAgIH0sXG4gICAgc2V0U3Ryb2tlQ29sb3JOOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19zZXRTdHJva2VDb2xvck4oKSB7XG4gICAgICB0aGlzLmN1cnJlbnQuc3Ryb2tlQ29sb3IgPSB0aGlzLmdldENvbG9yTl9QYXR0ZXJuKGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBzZXRGaWxsQ29sb3JOOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19zZXRGaWxsQ29sb3JOKCkge1xuICAgICAgdGhpcy5jdXJyZW50LmZpbGxDb2xvciA9IHRoaXMuZ2V0Q29sb3JOX1BhdHRlcm4oYXJndW1lbnRzKTtcbiAgICAgIHRoaXMuY3VycmVudC5wYXR0ZXJuRmlsbCA9IHRydWU7XG4gICAgfSxcbiAgICBzZXRTdHJva2VSR0JDb2xvcjogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3Nfc2V0U3Ryb2tlUkdCQ29sb3IociwgZywgYikge1xuICAgICAgdmFyIGNvbG9yID0gX3V0aWwuVXRpbC5tYWtlQ3NzUmdiKHIsIGcsIGIpO1xuXG4gICAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgICAgdGhpcy5jdXJyZW50LnN0cm9rZUNvbG9yID0gY29sb3I7XG4gICAgfSxcbiAgICBzZXRGaWxsUkdCQ29sb3I6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX3NldEZpbGxSR0JDb2xvcihyLCBnLCBiKSB7XG4gICAgICB2YXIgY29sb3IgPSBfdXRpbC5VdGlsLm1ha2VDc3NSZ2IociwgZywgYik7XG5cbiAgICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgdGhpcy5jdXJyZW50LmZpbGxDb2xvciA9IGNvbG9yO1xuICAgICAgdGhpcy5jdXJyZW50LnBhdHRlcm5GaWxsID0gZmFsc2U7XG4gICAgfSxcbiAgICBzaGFkaW5nRmlsbDogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3Nfc2hhZGluZ0ZpbGwocGF0dGVybklSKSB7XG4gICAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3R4ID0gdGhpcy5jdHg7XG4gICAgICB0aGlzLnNhdmUoKTtcbiAgICAgIHZhciBwYXR0ZXJuID0gKDAsIF9wYXR0ZXJuX2hlbHBlci5nZXRTaGFkaW5nUGF0dGVybkZyb21JUikocGF0dGVybklSKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBwYXR0ZXJuLmdldFBhdHRlcm4oY3R4LCB0aGlzLCB0cnVlKTtcbiAgICAgIHZhciBpbnYgPSBjdHgubW96Q3VycmVudFRyYW5zZm9ybUludmVyc2U7XG5cbiAgICAgIGlmIChpbnYpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IGN0eC5jYW52YXM7XG4gICAgICAgIHZhciB3aWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XG5cbiAgICAgICAgdmFyIGJsID0gX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShbMCwgMF0sIGludik7XG5cbiAgICAgICAgdmFyIGJyID0gX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShbMCwgaGVpZ2h0XSwgaW52KTtcblxuICAgICAgICB2YXIgdWwgPSBfdXRpbC5VdGlsLmFwcGx5VHJhbnNmb3JtKFt3aWR0aCwgMF0sIGludik7XG5cbiAgICAgICAgdmFyIHVyID0gX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShbd2lkdGgsIGhlaWdodF0sIGludik7XG5cbiAgICAgICAgdmFyIHgwID0gTWF0aC5taW4oYmxbMF0sIGJyWzBdLCB1bFswXSwgdXJbMF0pO1xuICAgICAgICB2YXIgeTAgPSBNYXRoLm1pbihibFsxXSwgYnJbMV0sIHVsWzFdLCB1clsxXSk7XG4gICAgICAgIHZhciB4MSA9IE1hdGgubWF4KGJsWzBdLCBiclswXSwgdWxbMF0sIHVyWzBdKTtcbiAgICAgICAgdmFyIHkxID0gTWF0aC5tYXgoYmxbMV0sIGJyWzFdLCB1bFsxXSwgdXJbMV0pO1xuICAgICAgICB0aGlzLmN0eC5maWxsUmVjdCh4MCwgeTAsIHgxIC0geDAsIHkxIC0geTApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jdHguZmlsbFJlY3QoLTFlMTAsIC0xZTEwLCAyZTEwLCAyZTEwKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgfSxcbiAgICBiZWdpbklubGluZUltYWdlOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19iZWdpbklubGluZUltYWdlKCkge1xuICAgICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIlNob3VsZCBub3QgY2FsbCBiZWdpbklubGluZUltYWdlXCIpO1xuICAgIH0sXG4gICAgYmVnaW5JbWFnZURhdGE6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX2JlZ2luSW1hZ2VEYXRhKCkge1xuICAgICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIlNob3VsZCBub3QgY2FsbCBiZWdpbkltYWdlRGF0YVwiKTtcbiAgICB9LFxuICAgIHBhaW50Rm9ybVhPYmplY3RCZWdpbjogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3NfcGFpbnRGb3JtWE9iamVjdEJlZ2luKG1hdHJpeCwgYmJveCkge1xuICAgICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zYXZlKCk7XG4gICAgICB0aGlzLmJhc2VUcmFuc2Zvcm1TdGFjay5wdXNoKHRoaXMuYmFzZVRyYW5zZm9ybSk7XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG1hdHJpeCkgJiYgbWF0cml4Lmxlbmd0aCA9PT0gNikge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybS5hcHBseSh0aGlzLCBtYXRyaXgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJhc2VUcmFuc2Zvcm0gPSB0aGlzLmN0eC5tb3pDdXJyZW50VHJhbnNmb3JtO1xuXG4gICAgICBpZiAoYmJveCkge1xuICAgICAgICB2YXIgd2lkdGggPSBiYm94WzJdIC0gYmJveFswXTtcbiAgICAgICAgdmFyIGhlaWdodCA9IGJib3hbM10gLSBiYm94WzFdO1xuICAgICAgICB0aGlzLmN0eC5yZWN0KGJib3hbMF0sIGJib3hbMV0sIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLmNsaXAoKTtcbiAgICAgICAgdGhpcy5lbmRQYXRoKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBwYWludEZvcm1YT2JqZWN0RW5kOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19wYWludEZvcm1YT2JqZWN0RW5kKCkge1xuICAgICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgICB0aGlzLmJhc2VUcmFuc2Zvcm0gPSB0aGlzLmJhc2VUcmFuc2Zvcm1TdGFjay5wb3AoKTtcbiAgICB9LFxuICAgIGJlZ2luR3JvdXA6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX2JlZ2luR3JvdXAoZ3JvdXApIHtcbiAgICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2F2ZSgpO1xuICAgICAgdmFyIGN1cnJlbnRDdHggPSB0aGlzLmN0eDtcblxuICAgICAgaWYgKCFncm91cC5pc29sYXRlZCkge1xuICAgICAgICAoMCwgX3V0aWwuaW5mbykoXCJUT0RPOiBTdXBwb3J0IG5vbi1pc29sYXRlZCBncm91cHMuXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ3JvdXAua25vY2tvdXQpIHtcbiAgICAgICAgKDAsIF91dGlsLndhcm4pKFwiS25vY2tvdXQgZ3JvdXBzIG5vdCBzdXBwb3J0ZWQuXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3VycmVudFRyYW5zZm9ybSA9IGN1cnJlbnRDdHgubW96Q3VycmVudFRyYW5zZm9ybTtcblxuICAgICAgaWYgKGdyb3VwLm1hdHJpeCkge1xuICAgICAgICBjdXJyZW50Q3R4LnRyYW5zZm9ybS5hcHBseShjdXJyZW50Q3R4LCBncm91cC5tYXRyaXgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWdyb3VwLmJib3gpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQm91bmRpbmcgYm94IGlzIHJlcXVpcmVkLlwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGJvdW5kcyA9IF91dGlsLlV0aWwuZ2V0QXhpYWxBbGlnbmVkQm91bmRpbmdCb3goZ3JvdXAuYmJveCwgY3VycmVudEN0eC5tb3pDdXJyZW50VHJhbnNmb3JtKTtcblxuICAgICAgdmFyIGNhbnZhc0JvdW5kcyA9IFswLCAwLCBjdXJyZW50Q3R4LmNhbnZhcy53aWR0aCwgY3VycmVudEN0eC5jYW52YXMuaGVpZ2h0XTtcbiAgICAgIGJvdW5kcyA9IF91dGlsLlV0aWwuaW50ZXJzZWN0KGJvdW5kcywgY2FudmFzQm91bmRzKSB8fCBbMCwgMCwgMCwgMF07XG4gICAgICB2YXIgb2Zmc2V0WCA9IE1hdGguZmxvb3IoYm91bmRzWzBdKTtcbiAgICAgIHZhciBvZmZzZXRZID0gTWF0aC5mbG9vcihib3VuZHNbMV0pO1xuICAgICAgdmFyIGRyYXduV2lkdGggPSBNYXRoLm1heChNYXRoLmNlaWwoYm91bmRzWzJdKSAtIG9mZnNldFgsIDEpO1xuICAgICAgdmFyIGRyYXduSGVpZ2h0ID0gTWF0aC5tYXgoTWF0aC5jZWlsKGJvdW5kc1szXSkgLSBvZmZzZXRZLCAxKTtcbiAgICAgIHZhciBzY2FsZVggPSAxLFxuICAgICAgICAgIHNjYWxlWSA9IDE7XG5cbiAgICAgIGlmIChkcmF3bldpZHRoID4gTUFYX0dST1VQX1NJWkUpIHtcbiAgICAgICAgc2NhbGVYID0gZHJhd25XaWR0aCAvIE1BWF9HUk9VUF9TSVpFO1xuICAgICAgICBkcmF3bldpZHRoID0gTUFYX0dST1VQX1NJWkU7XG4gICAgICB9XG5cbiAgICAgIGlmIChkcmF3bkhlaWdodCA+IE1BWF9HUk9VUF9TSVpFKSB7XG4gICAgICAgIHNjYWxlWSA9IGRyYXduSGVpZ2h0IC8gTUFYX0dST1VQX1NJWkU7XG4gICAgICAgIGRyYXduSGVpZ2h0ID0gTUFYX0dST1VQX1NJWkU7XG4gICAgICB9XG5cbiAgICAgIHZhciBjYWNoZUlkID0gXCJncm91cEF0XCIgKyB0aGlzLmdyb3VwTGV2ZWw7XG5cbiAgICAgIGlmIChncm91cC5zbWFzaykge1xuICAgICAgICBjYWNoZUlkICs9IFwiX3NtYXNrX1wiICsgdGhpcy5zbWFza0NvdW50ZXIrKyAlIDI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzY3JhdGNoQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoY2FjaGVJZCwgZHJhd25XaWR0aCwgZHJhd25IZWlnaHQsIHRydWUpO1xuICAgICAgdmFyIGdyb3VwQ3R4ID0gc2NyYXRjaENhbnZhcy5jb250ZXh0O1xuICAgICAgZ3JvdXBDdHguc2NhbGUoMSAvIHNjYWxlWCwgMSAvIHNjYWxlWSk7XG4gICAgICBncm91cEN0eC50cmFuc2xhdGUoLW9mZnNldFgsIC1vZmZzZXRZKTtcbiAgICAgIGdyb3VwQ3R4LnRyYW5zZm9ybS5hcHBseShncm91cEN0eCwgY3VycmVudFRyYW5zZm9ybSk7XG5cbiAgICAgIGlmIChncm91cC5zbWFzaykge1xuICAgICAgICB0aGlzLnNtYXNrU3RhY2sucHVzaCh7XG4gICAgICAgICAgY2FudmFzOiBzY3JhdGNoQ2FudmFzLmNhbnZhcyxcbiAgICAgICAgICBjb250ZXh0OiBncm91cEN0eCxcbiAgICAgICAgICBvZmZzZXRYLFxuICAgICAgICAgIG9mZnNldFksXG4gICAgICAgICAgc2NhbGVYLFxuICAgICAgICAgIHNjYWxlWSxcbiAgICAgICAgICBzdWJ0eXBlOiBncm91cC5zbWFzay5zdWJ0eXBlLFxuICAgICAgICAgIGJhY2tkcm9wOiBncm91cC5zbWFzay5iYWNrZHJvcCxcbiAgICAgICAgICB0cmFuc2Zlck1hcDogZ3JvdXAuc21hc2sudHJhbnNmZXJNYXAgfHwgbnVsbCxcbiAgICAgICAgICBzdGFydFRyYW5zZm9ybUludmVyc2U6IG51bGxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50Q3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgY3VycmVudEN0eC50cmFuc2xhdGUob2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICAgICAgIGN1cnJlbnRDdHguc2NhbGUoc2NhbGVYLCBzY2FsZVkpO1xuICAgICAgfVxuXG4gICAgICBjb3B5Q3R4U3RhdGUoY3VycmVudEN0eCwgZ3JvdXBDdHgpO1xuICAgICAgdGhpcy5jdHggPSBncm91cEN0eDtcbiAgICAgIHRoaXMuc2V0R1N0YXRlKFtbXCJCTVwiLCBcInNvdXJjZS1vdmVyXCJdLCBbXCJjYVwiLCAxXSwgW1wiQ0FcIiwgMV1dKTtcbiAgICAgIHRoaXMuZ3JvdXBTdGFjay5wdXNoKGN1cnJlbnRDdHgpO1xuICAgICAgdGhpcy5ncm91cExldmVsKys7XG4gICAgICB0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2sgPSBudWxsO1xuICAgIH0sXG4gICAgZW5kR3JvdXA6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX2VuZEdyb3VwKGdyb3VwKSB7XG4gICAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmdyb3VwTGV2ZWwtLTtcbiAgICAgIHZhciBncm91cEN0eCA9IHRoaXMuY3R4O1xuICAgICAgdGhpcy5jdHggPSB0aGlzLmdyb3VwU3RhY2sucG9wKCk7XG5cbiAgICAgIGlmICh0aGlzLmN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY3R4Lm1vekltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ3JvdXAuc21hc2spIHtcbiAgICAgICAgdGhpcy50ZW1wU01hc2sgPSB0aGlzLnNtYXNrU3RhY2sucG9wKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmN0eC5kcmF3SW1hZ2UoZ3JvdXBDdHguY2FudmFzLCAwLCAwKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgfSxcbiAgICBiZWdpbkFubm90YXRpb25zOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19iZWdpbkFubm90YXRpb25zKCkge1xuICAgICAgdGhpcy5zYXZlKCk7XG5cbiAgICAgIGlmICh0aGlzLmJhc2VUcmFuc2Zvcm0pIHtcbiAgICAgICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtLmFwcGx5KHRoaXMuY3R4LCB0aGlzLmJhc2VUcmFuc2Zvcm0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgZW5kQW5ub3RhdGlvbnM6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX2VuZEFubm90YXRpb25zKCkge1xuICAgICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgfSxcbiAgICBiZWdpbkFubm90YXRpb246IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX2JlZ2luQW5ub3RhdGlvbihyZWN0LCB0cmFuc2Zvcm0sIG1hdHJpeCkge1xuICAgICAgdGhpcy5zYXZlKCk7XG4gICAgICByZXNldEN0eFRvRGVmYXVsdCh0aGlzLmN0eCk7XG4gICAgICB0aGlzLmN1cnJlbnQgPSBuZXcgQ2FudmFzRXh0cmFTdGF0ZSgpO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyZWN0KSAmJiByZWN0Lmxlbmd0aCA9PT0gNCkge1xuICAgICAgICB2YXIgd2lkdGggPSByZWN0WzJdIC0gcmVjdFswXTtcbiAgICAgICAgdmFyIGhlaWdodCA9IHJlY3RbM10gLSByZWN0WzFdO1xuICAgICAgICB0aGlzLmN0eC5yZWN0KHJlY3RbMF0sIHJlY3RbMV0sIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLmNsaXAoKTtcbiAgICAgICAgdGhpcy5lbmRQYXRoKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudHJhbnNmb3JtLmFwcGx5KHRoaXMsIHRyYW5zZm9ybSk7XG4gICAgICB0aGlzLnRyYW5zZm9ybS5hcHBseSh0aGlzLCBtYXRyaXgpO1xuICAgIH0sXG4gICAgZW5kQW5ub3RhdGlvbjogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3NfZW5kQW5ub3RhdGlvbigpIHtcbiAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgIH0sXG4gICAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0OiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19wYWludEltYWdlTWFza1hPYmplY3QoaW1nKSB7XG4gICAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3R4ID0gdGhpcy5jdHg7XG4gICAgICB2YXIgd2lkdGggPSBpbWcud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gaW1nLmhlaWdodDtcbiAgICAgIHZhciBmaWxsQ29sb3IgPSB0aGlzLmN1cnJlbnQuZmlsbENvbG9yO1xuICAgICAgdmFyIGlzUGF0dGVybkZpbGwgPSB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGw7XG4gICAgICB2YXIgZ2x5cGggPSB0aGlzLnByb2Nlc3NpbmdUeXBlMztcblxuICAgICAgaWYgKENPTVBJTEVfVFlQRTNfR0xZUEhTICYmIGdseXBoICYmIGdseXBoLmNvbXBpbGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHdpZHRoIDw9IE1BWF9TSVpFX1RPX0NPTVBJTEUgJiYgaGVpZ2h0IDw9IE1BWF9TSVpFX1RPX0NPTVBJTEUpIHtcbiAgICAgICAgICBnbHlwaC5jb21waWxlZCA9IGNvbXBpbGVUeXBlM0dseXBoKHtcbiAgICAgICAgICAgIGRhdGE6IGltZy5kYXRhLFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnbHlwaC5jb21waWxlZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGdseXBoICYmIGdseXBoLmNvbXBpbGVkKSB7XG4gICAgICAgIGdseXBoLmNvbXBpbGVkKGN0eCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG1hc2tDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcIm1hc2tDYW52YXNcIiwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB2YXIgbWFza0N0eCA9IG1hc2tDYW52YXMuY29udGV4dDtcbiAgICAgIG1hc2tDdHguc2F2ZSgpO1xuICAgICAgcHV0QmluYXJ5SW1hZ2VNYXNrKG1hc2tDdHgsIGltZyk7XG4gICAgICBtYXNrQ3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwic291cmNlLWluXCI7XG4gICAgICBtYXNrQ3R4LmZpbGxTdHlsZSA9IGlzUGF0dGVybkZpbGwgPyBmaWxsQ29sb3IuZ2V0UGF0dGVybihtYXNrQ3R4LCB0aGlzKSA6IGZpbGxDb2xvcjtcbiAgICAgIG1hc2tDdHguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBtYXNrQ3R4LnJlc3RvcmUoKTtcbiAgICAgIHRoaXMucGFpbnRJbmxpbmVJbWFnZVhPYmplY3QobWFza0NhbnZhcy5jYW52YXMpO1xuICAgIH0sXG5cbiAgICBwYWludEltYWdlTWFza1hPYmplY3RSZXBlYXQoaW1nRGF0YSwgc2NhbGVYLCBza2V3WCA9IDAsIHNrZXdZID0gMCwgc2NhbGVZLCBwb3NpdGlvbnMpIHtcbiAgICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB3aWR0aCA9IGltZ0RhdGEud2lkdGg7XG4gICAgICB2YXIgaGVpZ2h0ID0gaW1nRGF0YS5oZWlnaHQ7XG4gICAgICB2YXIgZmlsbENvbG9yID0gdGhpcy5jdXJyZW50LmZpbGxDb2xvcjtcbiAgICAgIHZhciBpc1BhdHRlcm5GaWxsID0gdGhpcy5jdXJyZW50LnBhdHRlcm5GaWxsO1xuICAgICAgdmFyIG1hc2tDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcIm1hc2tDYW52YXNcIiwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB2YXIgbWFza0N0eCA9IG1hc2tDYW52YXMuY29udGV4dDtcbiAgICAgIG1hc2tDdHguc2F2ZSgpO1xuICAgICAgcHV0QmluYXJ5SW1hZ2VNYXNrKG1hc2tDdHgsIGltZ0RhdGEpO1xuICAgICAgbWFza0N0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcInNvdXJjZS1pblwiO1xuICAgICAgbWFza0N0eC5maWxsU3R5bGUgPSBpc1BhdHRlcm5GaWxsID8gZmlsbENvbG9yLmdldFBhdHRlcm4obWFza0N0eCwgdGhpcykgOiBmaWxsQ29sb3I7XG4gICAgICBtYXNrQ3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgbWFza0N0eC5yZXN0b3JlKCk7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5jdHg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC50cmFuc2Zvcm0oc2NhbGVYLCBza2V3WCwgc2tld1ksIHNjYWxlWSwgcG9zaXRpb25zW2ldLCBwb3NpdGlvbnNbaSArIDFdKTtcbiAgICAgICAgY3R4LnNjYWxlKDEsIC0xKTtcbiAgICAgICAgY3R4LmRyYXdJbWFnZShtYXNrQ2FudmFzLmNhbnZhcywgMCwgMCwgd2lkdGgsIGhlaWdodCwgMCwgLTEsIDEsIDEpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBwYWludEltYWdlTWFza1hPYmplY3RHcm91cDogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3NfcGFpbnRJbWFnZU1hc2tYT2JqZWN0R3JvdXAoaW1hZ2VzKSB7XG4gICAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3R4ID0gdGhpcy5jdHg7XG4gICAgICB2YXIgZmlsbENvbG9yID0gdGhpcy5jdXJyZW50LmZpbGxDb2xvcjtcbiAgICAgIHZhciBpc1BhdHRlcm5GaWxsID0gdGhpcy5jdXJyZW50LnBhdHRlcm5GaWxsO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBpbWFnZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICB2YXIgaW1hZ2UgPSBpbWFnZXNbaV07XG4gICAgICAgIHZhciB3aWR0aCA9IGltYWdlLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgICAgICB2YXIgbWFza0NhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwibWFza0NhbnZhc1wiLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdmFyIG1hc2tDdHggPSBtYXNrQ2FudmFzLmNvbnRleHQ7XG4gICAgICAgIG1hc2tDdHguc2F2ZSgpO1xuICAgICAgICBwdXRCaW5hcnlJbWFnZU1hc2sobWFza0N0eCwgaW1hZ2UpO1xuICAgICAgICBtYXNrQ3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwic291cmNlLWluXCI7XG4gICAgICAgIG1hc2tDdHguZmlsbFN0eWxlID0gaXNQYXR0ZXJuRmlsbCA/IGZpbGxDb2xvci5nZXRQYXR0ZXJuKG1hc2tDdHgsIHRoaXMpIDogZmlsbENvbG9yO1xuICAgICAgICBtYXNrQ3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBtYXNrQ3R4LnJlc3RvcmUoKTtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LnRyYW5zZm9ybS5hcHBseShjdHgsIGltYWdlLnRyYW5zZm9ybSk7XG4gICAgICAgIGN0eC5zY2FsZSgxLCAtMSk7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UobWFza0NhbnZhcy5jYW52YXMsIDAsIDAsIHdpZHRoLCBoZWlnaHQsIDAsIC0xLCAxLCAxKTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHBhaW50SW1hZ2VYT2JqZWN0OiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19wYWludEltYWdlWE9iamVjdChvYmpJZCkge1xuICAgICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaW1nRGF0YSA9IG9iaklkLnN0YXJ0c1dpdGgoXCJnX1wiKSA/IHRoaXMuY29tbW9uT2Jqcy5nZXQob2JqSWQpIDogdGhpcy5vYmpzLmdldChvYmpJZCk7XG5cbiAgICAgIGlmICghaW1nRGF0YSkge1xuICAgICAgICAoMCwgX3V0aWwud2FybikoXCJEZXBlbmRlbnQgaW1hZ2UgaXNuJ3QgcmVhZHkgeWV0XCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMucGFpbnRJbmxpbmVJbWFnZVhPYmplY3QoaW1nRGF0YSk7XG4gICAgfSxcbiAgICBwYWludEltYWdlWE9iamVjdFJlcGVhdDogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3NfcGFpbnRJbWFnZVhPYmplY3RSZXBlYXQob2JqSWQsIHNjYWxlWCwgc2NhbGVZLCBwb3NpdGlvbnMpIHtcbiAgICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGltZ0RhdGEgPSBvYmpJZC5zdGFydHNXaXRoKFwiZ19cIikgPyB0aGlzLmNvbW1vbk9ianMuZ2V0KG9iaklkKSA6IHRoaXMub2Jqcy5nZXQob2JqSWQpO1xuXG4gICAgICBpZiAoIWltZ0RhdGEpIHtcbiAgICAgICAgKDAsIF91dGlsLndhcm4pKFwiRGVwZW5kZW50IGltYWdlIGlzbid0IHJlYWR5IHlldFwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgd2lkdGggPSBpbWdEYXRhLndpZHRoO1xuICAgICAgdmFyIGhlaWdodCA9IGltZ0RhdGEuaGVpZ2h0O1xuICAgICAgdmFyIG1hcCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgICBtYXAucHVzaCh7XG4gICAgICAgICAgdHJhbnNmb3JtOiBbc2NhbGVYLCAwLCAwLCBzY2FsZVksIHBvc2l0aW9uc1tpXSwgcG9zaXRpb25zW2kgKyAxXV0sXG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwLFxuICAgICAgICAgIHc6IHdpZHRoLFxuICAgICAgICAgIGg6IGhlaWdodFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wYWludElubGluZUltYWdlWE9iamVjdEdyb3VwKGltZ0RhdGEsIG1hcCk7XG4gICAgfSxcbiAgICBwYWludElubGluZUltYWdlWE9iamVjdDogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3NfcGFpbnRJbmxpbmVJbWFnZVhPYmplY3QoaW1nRGF0YSkge1xuICAgICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHdpZHRoID0gaW1nRGF0YS53aWR0aDtcbiAgICAgIHZhciBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodDtcbiAgICAgIHZhciBjdHggPSB0aGlzLmN0eDtcbiAgICAgIHRoaXMuc2F2ZSgpO1xuICAgICAgY3R4LnNjYWxlKDEgLyB3aWR0aCwgLTEgLyBoZWlnaHQpO1xuICAgICAgdmFyIGN1cnJlbnRUcmFuc2Zvcm0gPSBjdHgubW96Q3VycmVudFRyYW5zZm9ybUludmVyc2U7XG4gICAgICB2YXIgYSA9IGN1cnJlbnRUcmFuc2Zvcm1bMF0sXG4gICAgICAgICAgYiA9IGN1cnJlbnRUcmFuc2Zvcm1bMV07XG4gICAgICB2YXIgd2lkdGhTY2FsZSA9IE1hdGgubWF4KE1hdGguc3FydChhICogYSArIGIgKiBiKSwgMSk7XG4gICAgICB2YXIgYyA9IGN1cnJlbnRUcmFuc2Zvcm1bMl0sXG4gICAgICAgICAgZCA9IGN1cnJlbnRUcmFuc2Zvcm1bM107XG4gICAgICB2YXIgaGVpZ2h0U2NhbGUgPSBNYXRoLm1heChNYXRoLnNxcnQoYyAqIGMgKyBkICogZCksIDEpO1xuICAgICAgdmFyIGltZ1RvUGFpbnQsIHRtcENhbnZhcztcblxuICAgICAgaWYgKHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gXCJmdW5jdGlvblwiICYmIGltZ0RhdGEgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCAhaW1nRGF0YS5kYXRhKSB7XG4gICAgICAgIGltZ1RvUGFpbnQgPSBpbWdEYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG1wQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJpbmxpbmVJbWFnZVwiLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdmFyIHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgICAgICBwdXRCaW5hcnlJbWFnZURhdGEodG1wQ3R4LCBpbWdEYXRhLCB0aGlzLmN1cnJlbnQudHJhbnNmZXJNYXBzKTtcbiAgICAgICAgaW1nVG9QYWludCA9IHRtcENhbnZhcy5jYW52YXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBwYWludFdpZHRoID0gd2lkdGgsXG4gICAgICAgICAgcGFpbnRIZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB2YXIgdG1wQ2FudmFzSWQgPSBcInByZXNjYWxlMVwiO1xuXG4gICAgICB3aGlsZSAod2lkdGhTY2FsZSA+IDIgJiYgcGFpbnRXaWR0aCA+IDEgfHwgaGVpZ2h0U2NhbGUgPiAyICYmIHBhaW50SGVpZ2h0ID4gMSkge1xuICAgICAgICB2YXIgbmV3V2lkdGggPSBwYWludFdpZHRoLFxuICAgICAgICAgICAgbmV3SGVpZ2h0ID0gcGFpbnRIZWlnaHQ7XG5cbiAgICAgICAgaWYgKHdpZHRoU2NhbGUgPiAyICYmIHBhaW50V2lkdGggPiAxKSB7XG4gICAgICAgICAgbmV3V2lkdGggPSBNYXRoLmNlaWwocGFpbnRXaWR0aCAvIDIpO1xuICAgICAgICAgIHdpZHRoU2NhbGUgLz0gcGFpbnRXaWR0aCAvIG5ld1dpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhlaWdodFNjYWxlID4gMiAmJiBwYWludEhlaWdodCA+IDEpIHtcbiAgICAgICAgICBuZXdIZWlnaHQgPSBNYXRoLmNlaWwocGFpbnRIZWlnaHQgLyAyKTtcbiAgICAgICAgICBoZWlnaHRTY2FsZSAvPSBwYWludEhlaWdodCAvIG5ld0hlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRtcENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKHRtcENhbnZhc0lkLCBuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICAgICAgdG1wQ3R4ID0gdG1wQ2FudmFzLmNvbnRleHQ7XG4gICAgICAgIHRtcEN0eC5jbGVhclJlY3QoMCwgMCwgbmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgICAgIHRtcEN0eC5kcmF3SW1hZ2UoaW1nVG9QYWludCwgMCwgMCwgcGFpbnRXaWR0aCwgcGFpbnRIZWlnaHQsIDAsIDAsIG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xuICAgICAgICBpbWdUb1BhaW50ID0gdG1wQ2FudmFzLmNhbnZhcztcbiAgICAgICAgcGFpbnRXaWR0aCA9IG5ld1dpZHRoO1xuICAgICAgICBwYWludEhlaWdodCA9IG5ld0hlaWdodDtcbiAgICAgICAgdG1wQ2FudmFzSWQgPSB0bXBDYW52YXNJZCA9PT0gXCJwcmVzY2FsZTFcIiA/IFwicHJlc2NhbGUyXCIgOiBcInByZXNjYWxlMVwiO1xuICAgICAgfVxuXG4gICAgICBjdHguZHJhd0ltYWdlKGltZ1RvUGFpbnQsIDAsIDAsIHBhaW50V2lkdGgsIHBhaW50SGVpZ2h0LCAwLCAtaGVpZ2h0LCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgaWYgKHRoaXMuaW1hZ2VMYXllcikge1xuICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLmdldENhbnZhc1Bvc2l0aW9uKDAsIC1oZWlnaHQpO1xuICAgICAgICB0aGlzLmltYWdlTGF5ZXIuYXBwZW5kSW1hZ2Uoe1xuICAgICAgICAgIGltZ0RhdGEsXG4gICAgICAgICAgbGVmdDogcG9zaXRpb25bMF0sXG4gICAgICAgICAgdG9wOiBwb3NpdGlvblsxXSxcbiAgICAgICAgICB3aWR0aDogd2lkdGggLyBjdXJyZW50VHJhbnNmb3JtWzBdLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0IC8gY3VycmVudFRyYW5zZm9ybVszXVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgfSxcbiAgICBwYWludElubGluZUltYWdlWE9iamVjdEdyb3VwOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19wYWludElubGluZUltYWdlWE9iamVjdEdyb3VwKGltZ0RhdGEsIG1hcCkge1xuICAgICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGN0eCA9IHRoaXMuY3R4O1xuICAgICAgdmFyIHcgPSBpbWdEYXRhLndpZHRoO1xuICAgICAgdmFyIGggPSBpbWdEYXRhLmhlaWdodDtcbiAgICAgIHZhciB0bXBDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcImlubGluZUltYWdlXCIsIHcsIGgpO1xuICAgICAgdmFyIHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgICAgcHV0QmluYXJ5SW1hZ2VEYXRhKHRtcEN0eCwgaW1nRGF0YSwgdGhpcy5jdXJyZW50LnRyYW5zZmVyTWFwcyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IG1hcC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IG1hcFtpXTtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LnRyYW5zZm9ybS5hcHBseShjdHgsIGVudHJ5LnRyYW5zZm9ybSk7XG4gICAgICAgIGN0eC5zY2FsZSgxLCAtMSk7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UodG1wQ2FudmFzLmNhbnZhcywgZW50cnkueCwgZW50cnkueSwgZW50cnkudywgZW50cnkuaCwgMCwgLTEsIDEsIDEpO1xuXG4gICAgICAgIGlmICh0aGlzLmltYWdlTGF5ZXIpIHtcbiAgICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLmdldENhbnZhc1Bvc2l0aW9uKGVudHJ5LngsIGVudHJ5LnkpO1xuICAgICAgICAgIHRoaXMuaW1hZ2VMYXllci5hcHBlbmRJbWFnZSh7XG4gICAgICAgICAgICBpbWdEYXRhLFxuICAgICAgICAgICAgbGVmdDogcG9zaXRpb25bMF0sXG4gICAgICAgICAgICB0b3A6IHBvc2l0aW9uWzFdLFxuICAgICAgICAgICAgd2lkdGg6IHcsXG4gICAgICAgICAgICBoZWlnaHQ6IGhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBwYWludFNvbGlkQ29sb3JJbWFnZU1hc2s6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX3BhaW50U29saWRDb2xvckltYWdlTWFzaygpIHtcbiAgICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY3R4LmZpbGxSZWN0KDAsIDAsIDEsIDEpO1xuICAgIH0sXG4gICAgbWFya1BvaW50OiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19tYXJrUG9pbnQodGFnKSB7fSxcbiAgICBtYXJrUG9pbnRQcm9wczogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3NfbWFya1BvaW50UHJvcHModGFnLCBwcm9wZXJ0aWVzKSB7fSxcbiAgICBiZWdpbk1hcmtlZENvbnRlbnQ6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX2JlZ2luTWFya2VkQ29udGVudCh0YWcpIHtcbiAgICAgIHRoaXMubWFya2VkQ29udGVudFN0YWNrLnB1c2goe1xuICAgICAgICB2aXNpYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGJlZ2luTWFya2VkQ29udGVudFByb3BzOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19iZWdpbk1hcmtlZENvbnRlbnRQcm9wcyh0YWcsIHByb3BlcnRpZXMpIHtcbiAgICAgIGlmICh0YWcgPT09IFwiT0NcIikge1xuICAgICAgICB0aGlzLm1hcmtlZENvbnRlbnRTdGFjay5wdXNoKHtcbiAgICAgICAgICB2aXNpYmxlOiB0aGlzLm9wdGlvbmFsQ29udGVudENvbmZpZy5pc1Zpc2libGUocHJvcGVydGllcylcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm1hcmtlZENvbnRlbnRTdGFjay5wdXNoKHtcbiAgICAgICAgICB2aXNpYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbnRlbnRWaXNpYmxlID0gdGhpcy5pc0NvbnRlbnRWaXNpYmxlKCk7XG4gICAgfSxcbiAgICBlbmRNYXJrZWRDb250ZW50OiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19lbmRNYXJrZWRDb250ZW50KCkge1xuICAgICAgdGhpcy5tYXJrZWRDb250ZW50U3RhY2sucG9wKCk7XG4gICAgICB0aGlzLmNvbnRlbnRWaXNpYmxlID0gdGhpcy5pc0NvbnRlbnRWaXNpYmxlKCk7XG4gICAgfSxcbiAgICBiZWdpbkNvbXBhdDogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3NfYmVnaW5Db21wYXQoKSB7fSxcbiAgICBlbmRDb21wYXQ6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX2VuZENvbXBhdCgpIHt9LFxuICAgIGNvbnN1bWVQYXRoOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19jb25zdW1lUGF0aCgpIHtcbiAgICAgIHZhciBjdHggPSB0aGlzLmN0eDtcblxuICAgICAgaWYgKHRoaXMucGVuZGluZ0NsaXApIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0NsaXAgPT09IEVPX0NMSVApIHtcbiAgICAgICAgICBjdHguY2xpcChcImV2ZW5vZGRcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3R4LmNsaXAoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucGVuZGluZ0NsaXAgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgfSxcblxuICAgIGdldFNpbmdsZVBpeGVsV2lkdGgoc2NhbGUpIHtcbiAgICAgIGlmICh0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoID09PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGludmVyc2UgPSB0aGlzLmN0eC5tb3pDdXJyZW50VHJhbnNmb3JtSW52ZXJzZTtcbiAgICAgICAgdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCA9IE1hdGguc3FydChNYXRoLm1heChpbnZlcnNlWzBdICogaW52ZXJzZVswXSArIGludmVyc2VbMV0gKiBpbnZlcnNlWzFdLCBpbnZlcnNlWzJdICogaW52ZXJzZVsyXSArIGludmVyc2VbM10gKiBpbnZlcnNlWzNdKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoO1xuICAgIH0sXG5cbiAgICBnZXRDYW52YXNQb3NpdGlvbjogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3NfZ2V0Q2FudmFzUG9zaXRpb24oeCwgeSkge1xuICAgICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMuY3R4Lm1vekN1cnJlbnRUcmFuc2Zvcm07XG4gICAgICByZXR1cm4gW3RyYW5zZm9ybVswXSAqIHggKyB0cmFuc2Zvcm1bMl0gKiB5ICsgdHJhbnNmb3JtWzRdLCB0cmFuc2Zvcm1bMV0gKiB4ICsgdHJhbnNmb3JtWzNdICogeSArIHRyYW5zZm9ybVs1XV07XG4gICAgfSxcbiAgICBpc0NvbnRlbnRWaXNpYmxlOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19pc0NvbnRlbnRWaXNpYmxlKCkge1xuICAgICAgZm9yIChsZXQgaSA9IHRoaXMubWFya2VkQ29udGVudFN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmICghdGhpcy5tYXJrZWRDb250ZW50U3RhY2tbaV0udmlzaWJsZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgZm9yICh2YXIgb3AgaW4gX3V0aWwuT1BTKSB7XG4gICAgQ2FudmFzR3JhcGhpY3MucHJvdG90eXBlW191dGlsLk9QU1tvcF1dID0gQ2FudmFzR3JhcGhpY3MucHJvdG90eXBlW29wXTtcbiAgfVxuXG4gIHJldHVybiBDYW52YXNHcmFwaGljcztcbn0oKTtcblxuZXhwb3J0cy5DYW52YXNHcmFwaGljcyA9IENhbnZhc0dyYXBoaWNzO1xuXG4vKioqLyB9KSxcbi8qIDExICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmdldFNoYWRpbmdQYXR0ZXJuRnJvbUlSID0gZ2V0U2hhZGluZ1BhdHRlcm5Gcm9tSVI7XG5leHBvcnRzLlRpbGluZ1BhdHRlcm4gPSB2b2lkIDA7XG5cbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMik7XG5cbnZhciBTaGFkaW5nSVJzID0ge307XG5cbmZ1bmN0aW9uIGFwcGx5Qm91bmRpbmdCb3goY3R4LCBiYm94KSB7XG4gIGlmICghYmJveCB8fCB0eXBlb2YgUGF0aDJEID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgd2lkdGggPSBiYm94WzJdIC0gYmJveFswXTtcbiAgY29uc3QgaGVpZ2h0ID0gYmJveFszXSAtIGJib3hbMV07XG4gIGNvbnN0IHJlZ2lvbiA9IG5ldyBQYXRoMkQoKTtcbiAgcmVnaW9uLnJlY3QoYmJveFswXSwgYmJveFsxXSwgd2lkdGgsIGhlaWdodCk7XG4gIGN0eC5jbGlwKHJlZ2lvbik7XG59XG5cblNoYWRpbmdJUnMuUmFkaWFsQXhpYWwgPSB7XG4gIGZyb21JUjogZnVuY3Rpb24gUmFkaWFsQXhpYWxfZnJvbUlSKHJhdykge1xuICAgIHZhciB0eXBlID0gcmF3WzFdO1xuICAgIHZhciBiYm94ID0gcmF3WzJdO1xuICAgIHZhciBjb2xvclN0b3BzID0gcmF3WzNdO1xuICAgIHZhciBwMCA9IHJhd1s0XTtcbiAgICB2YXIgcDEgPSByYXdbNV07XG4gICAgdmFyIHIwID0gcmF3WzZdO1xuICAgIHZhciByMSA9IHJhd1s3XTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJQYXR0ZXJuXCIsXG4gICAgICBnZXRQYXR0ZXJuOiBmdW5jdGlvbiBSYWRpYWxBeGlhbF9nZXRQYXR0ZXJuKGN0eCkge1xuICAgICAgICBhcHBseUJvdW5kaW5nQm94KGN0eCwgYmJveCk7XG4gICAgICAgIHZhciBncmFkO1xuXG4gICAgICAgIGlmICh0eXBlID09PSBcImF4aWFsXCIpIHtcbiAgICAgICAgICBncmFkID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KHAwWzBdLCBwMFsxXSwgcDFbMF0sIHAxWzFdKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcInJhZGlhbFwiKSB7XG4gICAgICAgICAgZ3JhZCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudChwMFswXSwgcDBbMV0sIHIwLCBwMVswXSwgcDFbMV0sIHIxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGNvbG9yU3RvcHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgIHZhciBjID0gY29sb3JTdG9wc1tpXTtcbiAgICAgICAgICBncmFkLmFkZENvbG9yU3RvcChjWzBdLCBjWzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBncmFkO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5cbnZhciBjcmVhdGVNZXNoQ2FudmFzID0gZnVuY3Rpb24gY3JlYXRlTWVzaENhbnZhc0Nsb3N1cmUoKSB7XG4gIGZ1bmN0aW9uIGRyYXdUcmlhbmdsZShkYXRhLCBjb250ZXh0LCBwMSwgcDIsIHAzLCBjMSwgYzIsIGMzKSB7XG4gICAgdmFyIGNvb3JkcyA9IGNvbnRleHQuY29vcmRzLFxuICAgICAgICBjb2xvcnMgPSBjb250ZXh0LmNvbG9ycztcbiAgICB2YXIgYnl0ZXMgPSBkYXRhLmRhdGEsXG4gICAgICAgIHJvd1NpemUgPSBkYXRhLndpZHRoICogNDtcbiAgICB2YXIgdG1wO1xuXG4gICAgaWYgKGNvb3Jkc1twMSArIDFdID4gY29vcmRzW3AyICsgMV0pIHtcbiAgICAgIHRtcCA9IHAxO1xuICAgICAgcDEgPSBwMjtcbiAgICAgIHAyID0gdG1wO1xuICAgICAgdG1wID0gYzE7XG4gICAgICBjMSA9IGMyO1xuICAgICAgYzIgPSB0bXA7XG4gICAgfVxuXG4gICAgaWYgKGNvb3Jkc1twMiArIDFdID4gY29vcmRzW3AzICsgMV0pIHtcbiAgICAgIHRtcCA9IHAyO1xuICAgICAgcDIgPSBwMztcbiAgICAgIHAzID0gdG1wO1xuICAgICAgdG1wID0gYzI7XG4gICAgICBjMiA9IGMzO1xuICAgICAgYzMgPSB0bXA7XG4gICAgfVxuXG4gICAgaWYgKGNvb3Jkc1twMSArIDFdID4gY29vcmRzW3AyICsgMV0pIHtcbiAgICAgIHRtcCA9IHAxO1xuICAgICAgcDEgPSBwMjtcbiAgICAgIHAyID0gdG1wO1xuICAgICAgdG1wID0gYzE7XG4gICAgICBjMSA9IGMyO1xuICAgICAgYzIgPSB0bXA7XG4gICAgfVxuXG4gICAgdmFyIHgxID0gKGNvb3Jkc1twMV0gKyBjb250ZXh0Lm9mZnNldFgpICogY29udGV4dC5zY2FsZVg7XG4gICAgdmFyIHkxID0gKGNvb3Jkc1twMSArIDFdICsgY29udGV4dC5vZmZzZXRZKSAqIGNvbnRleHQuc2NhbGVZO1xuICAgIHZhciB4MiA9IChjb29yZHNbcDJdICsgY29udGV4dC5vZmZzZXRYKSAqIGNvbnRleHQuc2NhbGVYO1xuICAgIHZhciB5MiA9IChjb29yZHNbcDIgKyAxXSArIGNvbnRleHQub2Zmc2V0WSkgKiBjb250ZXh0LnNjYWxlWTtcbiAgICB2YXIgeDMgPSAoY29vcmRzW3AzXSArIGNvbnRleHQub2Zmc2V0WCkgKiBjb250ZXh0LnNjYWxlWDtcbiAgICB2YXIgeTMgPSAoY29vcmRzW3AzICsgMV0gKyBjb250ZXh0Lm9mZnNldFkpICogY29udGV4dC5zY2FsZVk7XG5cbiAgICBpZiAoeTEgPj0geTMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYzFyID0gY29sb3JzW2MxXSxcbiAgICAgICAgYzFnID0gY29sb3JzW2MxICsgMV0sXG4gICAgICAgIGMxYiA9IGNvbG9yc1tjMSArIDJdO1xuICAgIHZhciBjMnIgPSBjb2xvcnNbYzJdLFxuICAgICAgICBjMmcgPSBjb2xvcnNbYzIgKyAxXSxcbiAgICAgICAgYzJiID0gY29sb3JzW2MyICsgMl07XG4gICAgdmFyIGMzciA9IGNvbG9yc1tjM10sXG4gICAgICAgIGMzZyA9IGNvbG9yc1tjMyArIDFdLFxuICAgICAgICBjM2IgPSBjb2xvcnNbYzMgKyAyXTtcbiAgICB2YXIgbWluWSA9IE1hdGgucm91bmQoeTEpLFxuICAgICAgICBtYXhZID0gTWF0aC5yb3VuZCh5Myk7XG4gICAgdmFyIHhhLCBjYXIsIGNhZywgY2FiO1xuICAgIHZhciB4YiwgY2JyLCBjYmcsIGNiYjtcblxuICAgIGZvciAodmFyIHkgPSBtaW5ZOyB5IDw9IG1heFk7IHkrKykge1xuICAgICAgaWYgKHkgPCB5Mikge1xuICAgICAgICBsZXQgaztcblxuICAgICAgICBpZiAoeSA8IHkxKSB7XG4gICAgICAgICAgayA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoeTEgPT09IHkyKSB7XG4gICAgICAgICAgayA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgayA9ICh5MSAtIHkpIC8gKHkxIC0geTIpO1xuICAgICAgICB9XG5cbiAgICAgICAgeGEgPSB4MSAtICh4MSAtIHgyKSAqIGs7XG4gICAgICAgIGNhciA9IGMxciAtIChjMXIgLSBjMnIpICogaztcbiAgICAgICAgY2FnID0gYzFnIC0gKGMxZyAtIGMyZykgKiBrO1xuICAgICAgICBjYWIgPSBjMWIgLSAoYzFiIC0gYzJiKSAqIGs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgaztcblxuICAgICAgICBpZiAoeSA+IHkzKSB7XG4gICAgICAgICAgayA9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAoeTIgPT09IHkzKSB7XG4gICAgICAgICAgayA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgayA9ICh5MiAtIHkpIC8gKHkyIC0geTMpO1xuICAgICAgICB9XG5cbiAgICAgICAgeGEgPSB4MiAtICh4MiAtIHgzKSAqIGs7XG4gICAgICAgIGNhciA9IGMyciAtIChjMnIgLSBjM3IpICogaztcbiAgICAgICAgY2FnID0gYzJnIC0gKGMyZyAtIGMzZykgKiBrO1xuICAgICAgICBjYWIgPSBjMmIgLSAoYzJiIC0gYzNiKSAqIGs7XG4gICAgICB9XG5cbiAgICAgIGxldCBrO1xuXG4gICAgICBpZiAoeSA8IHkxKSB7XG4gICAgICAgIGsgPSAwO1xuICAgICAgfSBlbHNlIGlmICh5ID4geTMpIHtcbiAgICAgICAgayA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrID0gKHkxIC0geSkgLyAoeTEgLSB5Myk7XG4gICAgICB9XG5cbiAgICAgIHhiID0geDEgLSAoeDEgLSB4MykgKiBrO1xuICAgICAgY2JyID0gYzFyIC0gKGMxciAtIGMzcikgKiBrO1xuICAgICAgY2JnID0gYzFnIC0gKGMxZyAtIGMzZykgKiBrO1xuICAgICAgY2JiID0gYzFiIC0gKGMxYiAtIGMzYikgKiBrO1xuICAgICAgdmFyIHgxXyA9IE1hdGgucm91bmQoTWF0aC5taW4oeGEsIHhiKSk7XG4gICAgICB2YXIgeDJfID0gTWF0aC5yb3VuZChNYXRoLm1heCh4YSwgeGIpKTtcbiAgICAgIHZhciBqID0gcm93U2l6ZSAqIHkgKyB4MV8gKiA0O1xuXG4gICAgICBmb3IgKHZhciB4ID0geDFfOyB4IDw9IHgyXzsgeCsrKSB7XG4gICAgICAgIGsgPSAoeGEgLSB4KSAvICh4YSAtIHhiKTtcblxuICAgICAgICBpZiAoayA8IDApIHtcbiAgICAgICAgICBrID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChrID4gMSkge1xuICAgICAgICAgIGsgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgYnl0ZXNbaisrXSA9IGNhciAtIChjYXIgLSBjYnIpICogayB8IDA7XG4gICAgICAgIGJ5dGVzW2orK10gPSBjYWcgLSAoY2FnIC0gY2JnKSAqIGsgfCAwO1xuICAgICAgICBieXRlc1tqKytdID0gY2FiIC0gKGNhYiAtIGNiYikgKiBrIHwgMDtcbiAgICAgICAgYnl0ZXNbaisrXSA9IDI1NTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkcmF3RmlndXJlKGRhdGEsIGZpZ3VyZSwgY29udGV4dCkge1xuICAgIHZhciBwcyA9IGZpZ3VyZS5jb29yZHM7XG4gICAgdmFyIGNzID0gZmlndXJlLmNvbG9ycztcbiAgICB2YXIgaSwgaWk7XG5cbiAgICBzd2l0Y2ggKGZpZ3VyZS50eXBlKSB7XG4gICAgICBjYXNlIFwibGF0dGljZVwiOlxuICAgICAgICB2YXIgdmVydGljZXNQZXJSb3cgPSBmaWd1cmUudmVydGljZXNQZXJSb3c7XG4gICAgICAgIHZhciByb3dzID0gTWF0aC5mbG9vcihwcy5sZW5ndGggLyB2ZXJ0aWNlc1BlclJvdykgLSAxO1xuICAgICAgICB2YXIgY29scyA9IHZlcnRpY2VzUGVyUm93IC0gMTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcm93czsgaSsrKSB7XG4gICAgICAgICAgdmFyIHEgPSBpICogdmVydGljZXNQZXJSb3c7XG5cbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbHM7IGorKywgcSsrKSB7XG4gICAgICAgICAgICBkcmF3VHJpYW5nbGUoZGF0YSwgY29udGV4dCwgcHNbcV0sIHBzW3EgKyAxXSwgcHNbcSArIHZlcnRpY2VzUGVyUm93XSwgY3NbcV0sIGNzW3EgKyAxXSwgY3NbcSArIHZlcnRpY2VzUGVyUm93XSk7XG4gICAgICAgICAgICBkcmF3VHJpYW5nbGUoZGF0YSwgY29udGV4dCwgcHNbcSArIHZlcnRpY2VzUGVyUm93ICsgMV0sIHBzW3EgKyAxXSwgcHNbcSArIHZlcnRpY2VzUGVyUm93XSwgY3NbcSArIHZlcnRpY2VzUGVyUm93ICsgMV0sIGNzW3EgKyAxXSwgY3NbcSArIHZlcnRpY2VzUGVyUm93XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJ0cmlhbmdsZXNcIjpcbiAgICAgICAgZm9yIChpID0gMCwgaWkgPSBwcy5sZW5ndGg7IGkgPCBpaTsgaSArPSAzKSB7XG4gICAgICAgICAgZHJhd1RyaWFuZ2xlKGRhdGEsIGNvbnRleHQsIHBzW2ldLCBwc1tpICsgMV0sIHBzW2kgKyAyXSwgY3NbaV0sIGNzW2kgKyAxXSwgY3NbaSArIDJdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGZpZ3VyZVwiKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVNZXNoQ2FudmFzKGJvdW5kcywgY29tYmluZXNTY2FsZSwgY29vcmRzLCBjb2xvcnMsIGZpZ3VyZXMsIGJhY2tncm91bmRDb2xvciwgY2FjaGVkQ2FudmFzZXMsIHdlYkdMQ29udGV4dCkge1xuICAgIHZhciBFWFBFQ1RFRF9TQ0FMRSA9IDEuMTtcbiAgICB2YXIgTUFYX1BBVFRFUk5fU0laRSA9IDMwMDA7XG4gICAgdmFyIEJPUkRFUl9TSVpFID0gMjtcbiAgICB2YXIgb2Zmc2V0WCA9IE1hdGguZmxvb3IoYm91bmRzWzBdKTtcbiAgICB2YXIgb2Zmc2V0WSA9IE1hdGguZmxvb3IoYm91bmRzWzFdKTtcbiAgICB2YXIgYm91bmRzV2lkdGggPSBNYXRoLmNlaWwoYm91bmRzWzJdKSAtIG9mZnNldFg7XG4gICAgdmFyIGJvdW5kc0hlaWdodCA9IE1hdGguY2VpbChib3VuZHNbM10pIC0gb2Zmc2V0WTtcbiAgICB2YXIgd2lkdGggPSBNYXRoLm1pbihNYXRoLmNlaWwoTWF0aC5hYnMoYm91bmRzV2lkdGggKiBjb21iaW5lc1NjYWxlWzBdICogRVhQRUNURURfU0NBTEUpKSwgTUFYX1BBVFRFUk5fU0laRSk7XG4gICAgdmFyIGhlaWdodCA9IE1hdGgubWluKE1hdGguY2VpbChNYXRoLmFicyhib3VuZHNIZWlnaHQgKiBjb21iaW5lc1NjYWxlWzFdICogRVhQRUNURURfU0NBTEUpKSwgTUFYX1BBVFRFUk5fU0laRSk7XG4gICAgdmFyIHNjYWxlWCA9IGJvdW5kc1dpZHRoIC8gd2lkdGg7XG4gICAgdmFyIHNjYWxlWSA9IGJvdW5kc0hlaWdodCAvIGhlaWdodDtcbiAgICB2YXIgY29udGV4dCA9IHtcbiAgICAgIGNvb3JkcyxcbiAgICAgIGNvbG9ycyxcbiAgICAgIG9mZnNldFg6IC1vZmZzZXRYLFxuICAgICAgb2Zmc2V0WTogLW9mZnNldFksXG4gICAgICBzY2FsZVg6IDEgLyBzY2FsZVgsXG4gICAgICBzY2FsZVk6IDEgLyBzY2FsZVlcbiAgICB9O1xuICAgIHZhciBwYWRkZWRXaWR0aCA9IHdpZHRoICsgQk9SREVSX1NJWkUgKiAyO1xuICAgIHZhciBwYWRkZWRIZWlnaHQgPSBoZWlnaHQgKyBCT1JERVJfU0laRSAqIDI7XG4gICAgdmFyIGNhbnZhcywgdG1wQ2FudmFzLCBpLCBpaTtcblxuICAgIGlmICh3ZWJHTENvbnRleHQuaXNFbmFibGVkKSB7XG4gICAgICBjYW52YXMgPSB3ZWJHTENvbnRleHQuZHJhd0ZpZ3VyZXMoe1xuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgIGZpZ3VyZXMsXG4gICAgICAgIGNvbnRleHRcbiAgICAgIH0pO1xuICAgICAgdG1wQ2FudmFzID0gY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwibWVzaFwiLCBwYWRkZWRXaWR0aCwgcGFkZGVkSGVpZ2h0LCBmYWxzZSk7XG4gICAgICB0bXBDYW52YXMuY29udGV4dC5kcmF3SW1hZ2UoY2FudmFzLCBCT1JERVJfU0laRSwgQk9SREVSX1NJWkUpO1xuICAgICAgY2FudmFzID0gdG1wQ2FudmFzLmNhbnZhcztcbiAgICB9IGVsc2Uge1xuICAgICAgdG1wQ2FudmFzID0gY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwibWVzaFwiLCBwYWRkZWRXaWR0aCwgcGFkZGVkSGVpZ2h0LCBmYWxzZSk7XG4gICAgICB2YXIgdG1wQ3R4ID0gdG1wQ2FudmFzLmNvbnRleHQ7XG4gICAgICB2YXIgZGF0YSA9IHRtcEN0eC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIGhlaWdodCk7XG5cbiAgICAgIGlmIChiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgdmFyIGJ5dGVzID0gZGF0YS5kYXRhO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGlpID0gYnl0ZXMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gNCkge1xuICAgICAgICAgIGJ5dGVzW2ldID0gYmFja2dyb3VuZENvbG9yWzBdO1xuICAgICAgICAgIGJ5dGVzW2kgKyAxXSA9IGJhY2tncm91bmRDb2xvclsxXTtcbiAgICAgICAgICBieXRlc1tpICsgMl0gPSBiYWNrZ3JvdW5kQ29sb3JbMl07XG4gICAgICAgICAgYnl0ZXNbaSArIDNdID0gMjU1O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBmaWd1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRyYXdGaWd1cmUoZGF0YSwgZmlndXJlc1tpXSwgY29udGV4dCk7XG4gICAgICB9XG5cbiAgICAgIHRtcEN0eC5wdXRJbWFnZURhdGEoZGF0YSwgQk9SREVSX1NJWkUsIEJPUkRFUl9TSVpFKTtcbiAgICAgIGNhbnZhcyA9IHRtcENhbnZhcy5jYW52YXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbnZhcyxcbiAgICAgIG9mZnNldFg6IG9mZnNldFggLSBCT1JERVJfU0laRSAqIHNjYWxlWCxcbiAgICAgIG9mZnNldFk6IG9mZnNldFkgLSBCT1JERVJfU0laRSAqIHNjYWxlWSxcbiAgICAgIHNjYWxlWCxcbiAgICAgIHNjYWxlWVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gY3JlYXRlTWVzaENhbnZhcztcbn0oKTtcblxuU2hhZGluZ0lScy5NZXNoID0ge1xuICBmcm9tSVI6IGZ1bmN0aW9uIE1lc2hfZnJvbUlSKHJhdykge1xuICAgIHZhciBjb29yZHMgPSByYXdbMl07XG4gICAgdmFyIGNvbG9ycyA9IHJhd1szXTtcbiAgICB2YXIgZmlndXJlcyA9IHJhd1s0XTtcbiAgICB2YXIgYm91bmRzID0gcmF3WzVdO1xuICAgIHZhciBtYXRyaXggPSByYXdbNl07XG4gICAgdmFyIGJib3ggPSByYXdbN107XG4gICAgdmFyIGJhY2tncm91bmQgPSByYXdbOF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiUGF0dGVyblwiLFxuICAgICAgZ2V0UGF0dGVybjogZnVuY3Rpb24gTWVzaF9nZXRQYXR0ZXJuKGN0eCwgb3duZXIsIHNoYWRpbmdGaWxsKSB7XG4gICAgICAgIGFwcGx5Qm91bmRpbmdCb3goY3R4LCBiYm94KTtcbiAgICAgICAgdmFyIHNjYWxlO1xuXG4gICAgICAgIGlmIChzaGFkaW5nRmlsbCkge1xuICAgICAgICAgIHNjYWxlID0gX3V0aWwuVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZShjdHgubW96Q3VycmVudFRyYW5zZm9ybSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2NhbGUgPSBfdXRpbC5VdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKG93bmVyLmJhc2VUcmFuc2Zvcm0pO1xuXG4gICAgICAgICAgaWYgKG1hdHJpeCkge1xuICAgICAgICAgICAgdmFyIG1hdHJpeFNjYWxlID0gX3V0aWwuVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZShtYXRyaXgpO1xuXG4gICAgICAgICAgICBzY2FsZSA9IFtzY2FsZVswXSAqIG1hdHJpeFNjYWxlWzBdLCBzY2FsZVsxXSAqIG1hdHJpeFNjYWxlWzFdXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGVtcG9yYXJ5UGF0dGVybkNhbnZhcyA9IGNyZWF0ZU1lc2hDYW52YXMoYm91bmRzLCBzY2FsZSwgY29vcmRzLCBjb2xvcnMsIGZpZ3VyZXMsIHNoYWRpbmdGaWxsID8gbnVsbCA6IGJhY2tncm91bmQsIG93bmVyLmNhY2hlZENhbnZhc2VzLCBvd25lci53ZWJHTENvbnRleHQpO1xuXG4gICAgICAgIGlmICghc2hhZGluZ0ZpbGwpIHtcbiAgICAgICAgICBjdHguc2V0VHJhbnNmb3JtLmFwcGx5KGN0eCwgb3duZXIuYmFzZVRyYW5zZm9ybSk7XG5cbiAgICAgICAgICBpZiAobWF0cml4KSB7XG4gICAgICAgICAgICBjdHgudHJhbnNmb3JtLmFwcGx5KGN0eCwgbWF0cml4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjdHgudHJhbnNsYXRlKHRlbXBvcmFyeVBhdHRlcm5DYW52YXMub2Zmc2V0WCwgdGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5vZmZzZXRZKTtcbiAgICAgICAgY3R4LnNjYWxlKHRlbXBvcmFyeVBhdHRlcm5DYW52YXMuc2NhbGVYLCB0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLnNjYWxlWSk7XG4gICAgICAgIHJldHVybiBjdHguY3JlYXRlUGF0dGVybih0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLmNhbnZhcywgXCJuby1yZXBlYXRcIik7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcblNoYWRpbmdJUnMuRHVtbXkgPSB7XG4gIGZyb21JUjogZnVuY3Rpb24gRHVtbXlfZnJvbUlSKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlBhdHRlcm5cIixcbiAgICAgIGdldFBhdHRlcm46IGZ1bmN0aW9uIER1bW15X2Zyb21JUl9nZXRQYXR0ZXJuKCkge1xuICAgICAgICByZXR1cm4gXCJob3RwaW5rXCI7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0U2hhZGluZ1BhdHRlcm5Gcm9tSVIocmF3KSB7XG4gIHZhciBzaGFkaW5nSVIgPSBTaGFkaW5nSVJzW3Jhd1swXV07XG5cbiAgaWYgKCFzaGFkaW5nSVIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gSVIgdHlwZTogJHtyYXdbMF19YCk7XG4gIH1cblxuICByZXR1cm4gc2hhZGluZ0lSLmZyb21JUihyYXcpO1xufVxuXG52YXIgVGlsaW5nUGF0dGVybiA9IGZ1bmN0aW9uIFRpbGluZ1BhdHRlcm5DbG9zdXJlKCkge1xuICB2YXIgUGFpbnRUeXBlID0ge1xuICAgIENPTE9SRUQ6IDEsXG4gICAgVU5DT0xPUkVEOiAyXG4gIH07XG4gIHZhciBNQVhfUEFUVEVSTl9TSVpFID0gMzAwMDtcblxuICBmdW5jdGlvbiBUaWxpbmdQYXR0ZXJuKElSLCBjb2xvciwgY3R4LCBjYW52YXNHcmFwaGljc0ZhY3RvcnksIGJhc2VUcmFuc2Zvcm0pIHtcbiAgICB0aGlzLm9wZXJhdG9yTGlzdCA9IElSWzJdO1xuICAgIHRoaXMubWF0cml4ID0gSVJbM10gfHwgWzEsIDAsIDAsIDEsIDAsIDBdO1xuICAgIHRoaXMuYmJveCA9IElSWzRdO1xuICAgIHRoaXMueHN0ZXAgPSBJUls1XTtcbiAgICB0aGlzLnlzdGVwID0gSVJbNl07XG4gICAgdGhpcy5wYWludFR5cGUgPSBJUls3XTtcbiAgICB0aGlzLnRpbGluZ1R5cGUgPSBJUls4XTtcbiAgICB0aGlzLmNvbG9yID0gY29sb3I7XG4gICAgdGhpcy5jYW52YXNHcmFwaGljc0ZhY3RvcnkgPSBjYW52YXNHcmFwaGljc0ZhY3Rvcnk7XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtID0gYmFzZVRyYW5zZm9ybTtcbiAgICB0aGlzLnR5cGUgPSBcIlBhdHRlcm5cIjtcbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgfVxuXG4gIFRpbGluZ1BhdHRlcm4ucHJvdG90eXBlID0ge1xuICAgIGNyZWF0ZVBhdHRlcm5DYW52YXM6IGZ1bmN0aW9uIFRpbGluUGF0dGVybl9jcmVhdGVQYXR0ZXJuQ2FudmFzKG93bmVyKSB7XG4gICAgICB2YXIgb3BlcmF0b3JMaXN0ID0gdGhpcy5vcGVyYXRvckxpc3Q7XG4gICAgICB2YXIgYmJveCA9IHRoaXMuYmJveDtcbiAgICAgIHZhciB4c3RlcCA9IHRoaXMueHN0ZXA7XG4gICAgICB2YXIgeXN0ZXAgPSB0aGlzLnlzdGVwO1xuICAgICAgdmFyIHBhaW50VHlwZSA9IHRoaXMucGFpbnRUeXBlO1xuICAgICAgdmFyIHRpbGluZ1R5cGUgPSB0aGlzLnRpbGluZ1R5cGU7XG4gICAgICB2YXIgY29sb3IgPSB0aGlzLmNvbG9yO1xuICAgICAgdmFyIGNhbnZhc0dyYXBoaWNzRmFjdG9yeSA9IHRoaXMuY2FudmFzR3JhcGhpY3NGYWN0b3J5O1xuICAgICAgKDAsIF91dGlsLmluZm8pKFwiVGlsaW5nVHlwZTogXCIgKyB0aWxpbmdUeXBlKTtcbiAgICAgIHZhciB4MCA9IGJib3hbMF0sXG4gICAgICAgICAgeTAgPSBiYm94WzFdLFxuICAgICAgICAgIHgxID0gYmJveFsyXSxcbiAgICAgICAgICB5MSA9IGJib3hbM107XG5cbiAgICAgIHZhciBtYXRyaXhTY2FsZSA9IF91dGlsLlV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUodGhpcy5tYXRyaXgpO1xuXG4gICAgICB2YXIgY3VyTWF0cml4U2NhbGUgPSBfdXRpbC5VdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKHRoaXMuYmFzZVRyYW5zZm9ybSk7XG5cbiAgICAgIHZhciBjb21iaW5lZFNjYWxlID0gW21hdHJpeFNjYWxlWzBdICogY3VyTWF0cml4U2NhbGVbMF0sIG1hdHJpeFNjYWxlWzFdICogY3VyTWF0cml4U2NhbGVbMV1dO1xuICAgICAgdmFyIGRpbXggPSB0aGlzLmdldFNpemVBbmRTY2FsZSh4c3RlcCwgdGhpcy5jdHguY2FudmFzLndpZHRoLCBjb21iaW5lZFNjYWxlWzBdKTtcbiAgICAgIHZhciBkaW15ID0gdGhpcy5nZXRTaXplQW5kU2NhbGUoeXN0ZXAsIHRoaXMuY3R4LmNhbnZhcy5oZWlnaHQsIGNvbWJpbmVkU2NhbGVbMV0pO1xuICAgICAgdmFyIHRtcENhbnZhcyA9IG93bmVyLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcInBhdHRlcm5cIiwgZGlteC5zaXplLCBkaW15LnNpemUsIHRydWUpO1xuICAgICAgdmFyIHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgICAgdmFyIGdyYXBoaWNzID0gY2FudmFzR3JhcGhpY3NGYWN0b3J5LmNyZWF0ZUNhbnZhc0dyYXBoaWNzKHRtcEN0eCk7XG4gICAgICBncmFwaGljcy5ncm91cExldmVsID0gb3duZXIuZ3JvdXBMZXZlbDtcbiAgICAgIHRoaXMuc2V0RmlsbEFuZFN0cm9rZVN0eWxlVG9Db250ZXh0KGdyYXBoaWNzLCBwYWludFR5cGUsIGNvbG9yKTtcbiAgICAgIGdyYXBoaWNzLnRyYW5zZm9ybShkaW14LnNjYWxlLCAwLCAwLCBkaW15LnNjYWxlLCAwLCAwKTtcbiAgICAgIGdyYXBoaWNzLnRyYW5zZm9ybSgxLCAwLCAwLCAxLCAteDAsIC15MCk7XG4gICAgICB0aGlzLmNsaXBCYm94KGdyYXBoaWNzLCBiYm94LCB4MCwgeTAsIHgxLCB5MSk7XG4gICAgICBncmFwaGljcy5leGVjdXRlT3BlcmF0b3JMaXN0KG9wZXJhdG9yTGlzdCk7XG4gICAgICB0aGlzLmN0eC50cmFuc2Zvcm0oMSwgMCwgMCwgMSwgeDAsIHkwKTtcbiAgICAgIHRoaXMuY3R4LnNjYWxlKDEgLyBkaW14LnNjYWxlLCAxIC8gZGlteS5zY2FsZSk7XG4gICAgICByZXR1cm4gdG1wQ2FudmFzLmNhbnZhcztcbiAgICB9LFxuICAgIGdldFNpemVBbmRTY2FsZTogZnVuY3Rpb24gVGlsaW5nUGF0dGVybl9nZXRTaXplQW5kU2NhbGUoc3RlcCwgcmVhbE91dHB1dFNpemUsIHNjYWxlKSB7XG4gICAgICBzdGVwID0gTWF0aC5hYnMoc3RlcCk7XG4gICAgICB2YXIgbWF4U2l6ZSA9IE1hdGgubWF4KE1BWF9QQVRURVJOX1NJWkUsIHJlYWxPdXRwdXRTaXplKTtcbiAgICAgIHZhciBzaXplID0gTWF0aC5jZWlsKHN0ZXAgKiBzY2FsZSk7XG5cbiAgICAgIGlmIChzaXplID49IG1heFNpemUpIHtcbiAgICAgICAgc2l6ZSA9IG1heFNpemU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2FsZSA9IHNpemUgLyBzdGVwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY2FsZSxcbiAgICAgICAgc2l6ZVxuICAgICAgfTtcbiAgICB9LFxuICAgIGNsaXBCYm94OiBmdW5jdGlvbiBjbGlwQmJveChncmFwaGljcywgYmJveCwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGJib3gpICYmIGJib3gubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIHZhciBiYm94V2lkdGggPSB4MSAtIHgwO1xuICAgICAgICB2YXIgYmJveEhlaWdodCA9IHkxIC0geTA7XG4gICAgICAgIGdyYXBoaWNzLmN0eC5yZWN0KHgwLCB5MCwgYmJveFdpZHRoLCBiYm94SGVpZ2h0KTtcbiAgICAgICAgZ3JhcGhpY3MuY2xpcCgpO1xuICAgICAgICBncmFwaGljcy5lbmRQYXRoKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXRGaWxsQW5kU3Ryb2tlU3R5bGVUb0NvbnRleHQ6IGZ1bmN0aW9uIHNldEZpbGxBbmRTdHJva2VTdHlsZVRvQ29udGV4dChncmFwaGljcywgcGFpbnRUeXBlLCBjb2xvcikge1xuICAgICAgY29uc3QgY29udGV4dCA9IGdyYXBoaWNzLmN0eCxcbiAgICAgICAgICAgIGN1cnJlbnQgPSBncmFwaGljcy5jdXJyZW50O1xuXG4gICAgICBzd2l0Y2ggKHBhaW50VHlwZSkge1xuICAgICAgICBjYXNlIFBhaW50VHlwZS5DT0xPUkVEOlxuICAgICAgICAgIHZhciBjdHggPSB0aGlzLmN0eDtcbiAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGN0eC5maWxsU3R5bGU7XG4gICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGN0eC5zdHJva2VTdHlsZTtcbiAgICAgICAgICBjdXJyZW50LmZpbGxDb2xvciA9IGN0eC5maWxsU3R5bGU7XG4gICAgICAgICAgY3VycmVudC5zdHJva2VDb2xvciA9IGN0eC5zdHJva2VTdHlsZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBhaW50VHlwZS5VTkNPTE9SRUQ6XG4gICAgICAgICAgdmFyIGNzc0NvbG9yID0gX3V0aWwuVXRpbC5tYWtlQ3NzUmdiKGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0pO1xuXG4gICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBjc3NDb2xvcjtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY3NzQ29sb3I7XG4gICAgICAgICAgY3VycmVudC5maWxsQ29sb3IgPSBjc3NDb2xvcjtcbiAgICAgICAgICBjdXJyZW50LnN0cm9rZUNvbG9yID0gY3NzQ29sb3I7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgX3V0aWwuRm9ybWF0RXJyb3IoYFVuc3VwcG9ydGVkIHBhaW50IHR5cGU6ICR7cGFpbnRUeXBlfWApO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0UGF0dGVybjogZnVuY3Rpb24gVGlsaW5nUGF0dGVybl9nZXRQYXR0ZXJuKGN0eCwgb3duZXIpIHtcbiAgICAgIGN0eCA9IHRoaXMuY3R4O1xuICAgICAgY3R4LnNldFRyYW5zZm9ybS5hcHBseShjdHgsIHRoaXMuYmFzZVRyYW5zZm9ybSk7XG4gICAgICBjdHgudHJhbnNmb3JtLmFwcGx5KGN0eCwgdGhpcy5tYXRyaXgpO1xuICAgICAgdmFyIHRlbXBvcmFyeVBhdHRlcm5DYW52YXMgPSB0aGlzLmNyZWF0ZVBhdHRlcm5DYW52YXMob3duZXIpO1xuICAgICAgcmV0dXJuIGN0eC5jcmVhdGVQYXR0ZXJuKHRlbXBvcmFyeVBhdHRlcm5DYW52YXMsIFwicmVwZWF0XCIpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIFRpbGluZ1BhdHRlcm47XG59KCk7XG5cbmV4cG9ydHMuVGlsaW5nUGF0dGVybiA9IFRpbGluZ1BhdHRlcm47XG5cbi8qKiovIH0pLFxuLyogMTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuR2xvYmFsV29ya2VyT3B0aW9ucyA9IHZvaWQgMDtcbmNvbnN0IEdsb2JhbFdvcmtlck9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZXhwb3J0cy5HbG9iYWxXb3JrZXJPcHRpb25zID0gR2xvYmFsV29ya2VyT3B0aW9ucztcbkdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyUG9ydCA9IEdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyUG9ydCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IEdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyUG9ydDtcbkdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyU3JjID0gR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJTcmMgPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBHbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclNyYztcblxuLyoqKi8gfSksXG4vKiAxMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5NZXNzYWdlSGFuZGxlciA9IHZvaWQgMDtcblxudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygyKTtcblxuY29uc3QgQ2FsbGJhY2tLaW5kID0ge1xuICBVTktOT1dOOiAwLFxuICBEQVRBOiAxLFxuICBFUlJPUjogMlxufTtcbmNvbnN0IFN0cmVhbUtpbmQgPSB7XG4gIFVOS05PV046IDAsXG4gIENBTkNFTDogMSxcbiAgQ0FOQ0VMX0NPTVBMRVRFOiAyLFxuICBDTE9TRTogMyxcbiAgRU5RVUVVRTogNCxcbiAgRVJST1I6IDUsXG4gIFBVTEw6IDYsXG4gIFBVTExfQ09NUExFVEU6IDcsXG4gIFNUQVJUX0NPTVBMRVRFOiA4XG59O1xuXG5mdW5jdGlvbiB3cmFwUmVhc29uKHJlYXNvbikge1xuICBpZiAodHlwZW9mIHJlYXNvbiAhPT0gXCJvYmplY3RcIiB8fCByZWFzb24gPT09IG51bGwpIHtcbiAgICByZXR1cm4gcmVhc29uO1xuICB9XG5cbiAgc3dpdGNoIChyZWFzb24ubmFtZSkge1xuICAgIGNhc2UgXCJBYm9ydEV4Y2VwdGlvblwiOlxuICAgICAgcmV0dXJuIG5ldyBfdXRpbC5BYm9ydEV4Y2VwdGlvbihyZWFzb24ubWVzc2FnZSk7XG5cbiAgICBjYXNlIFwiTWlzc2luZ1BERkV4Y2VwdGlvblwiOlxuICAgICAgcmV0dXJuIG5ldyBfdXRpbC5NaXNzaW5nUERGRXhjZXB0aW9uKHJlYXNvbi5tZXNzYWdlKTtcblxuICAgIGNhc2UgXCJVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb25cIjpcbiAgICAgIHJldHVybiBuZXcgX3V0aWwuVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uKHJlYXNvbi5tZXNzYWdlLCByZWFzb24uc3RhdHVzKTtcblxuICAgIGNhc2UgXCJVbmtub3duRXJyb3JFeGNlcHRpb25cIjpcbiAgICAgIHJldHVybiBuZXcgX3V0aWwuVW5rbm93bkVycm9yRXhjZXB0aW9uKHJlYXNvbi5tZXNzYWdlLCByZWFzb24uZGV0YWlscyk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG5ldyBfdXRpbC5Vbmtub3duRXJyb3JFeGNlcHRpb24ocmVhc29uLm1lc3NhZ2UsIHJlYXNvbi50b1N0cmluZygpKTtcbiAgfVxufVxuXG5jbGFzcyBNZXNzYWdlSGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZU5hbWUsIHRhcmdldE5hbWUsIGNvbU9iaikge1xuICAgIHRoaXMuc291cmNlTmFtZSA9IHNvdXJjZU5hbWU7XG4gICAgdGhpcy50YXJnZXROYW1lID0gdGFyZ2V0TmFtZTtcbiAgICB0aGlzLmNvbU9iaiA9IGNvbU9iajtcbiAgICB0aGlzLmNhbGxiYWNrSWQgPSAxO1xuICAgIHRoaXMuc3RyZWFtSWQgPSAxO1xuICAgIHRoaXMucG9zdE1lc3NhZ2VUcmFuc2ZlcnMgPSB0cnVlO1xuICAgIHRoaXMuc3RyZWFtU2lua3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuY2FsbGJhY2tDYXBhYmlsaXRpZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuYWN0aW9uSGFuZGxlciA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICB0aGlzLl9vbkNvbU9iak9uTWVzc2FnZSA9IGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBldmVudC5kYXRhO1xuXG4gICAgICBpZiAoZGF0YS50YXJnZXROYW1lICE9PSB0aGlzLnNvdXJjZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YS5zdHJlYW0pIHtcbiAgICAgICAgdGhpcy5fcHJvY2Vzc1N0cmVhbU1lc3NhZ2UoZGF0YSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YS5jYWxsYmFjaykge1xuICAgICAgICBjb25zdCBjYWxsYmFja0lkID0gZGF0YS5jYWxsYmFja0lkO1xuICAgICAgICBjb25zdCBjYXBhYmlsaXR5ID0gdGhpcy5jYWxsYmFja0NhcGFiaWxpdGllc1tjYWxsYmFja0lkXTtcblxuICAgICAgICBpZiAoIWNhcGFiaWxpdHkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZXNvbHZlIGNhbGxiYWNrICR7Y2FsbGJhY2tJZH1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSB0aGlzLmNhbGxiYWNrQ2FwYWJpbGl0aWVzW2NhbGxiYWNrSWRdO1xuXG4gICAgICAgIGlmIChkYXRhLmNhbGxiYWNrID09PSBDYWxsYmFja0tpbmQuREFUQSkge1xuICAgICAgICAgIGNhcGFiaWxpdHkucmVzb2x2ZShkYXRhLmRhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEuY2FsbGJhY2sgPT09IENhbGxiYWNrS2luZC5FUlJPUikge1xuICAgICAgICAgIGNhcGFiaWxpdHkucmVqZWN0KHdyYXBSZWFzb24oZGF0YS5yZWFzb24pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGNhbGxiYWNrIGNhc2VcIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGFjdGlvbiA9IHRoaXMuYWN0aW9uSGFuZGxlcltkYXRhLmFjdGlvbl07XG5cbiAgICAgIGlmICghYWN0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBhY3Rpb24gZnJvbSB3b3JrZXI6ICR7ZGF0YS5hY3Rpb259YCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhLmNhbGxiYWNrSWQpIHtcbiAgICAgICAgY29uc3QgY2JTb3VyY2VOYW1lID0gdGhpcy5zb3VyY2VOYW1lO1xuICAgICAgICBjb25zdCBjYlRhcmdldE5hbWUgPSBkYXRhLnNvdXJjZU5hbWU7XG4gICAgICAgIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgcmVzb2x2ZShhY3Rpb24oZGF0YS5kYXRhKSk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBzb3VyY2VOYW1lOiBjYlNvdXJjZU5hbWUsXG4gICAgICAgICAgICB0YXJnZXROYW1lOiBjYlRhcmdldE5hbWUsXG4gICAgICAgICAgICBjYWxsYmFjazogQ2FsbGJhY2tLaW5kLkRBVEEsXG4gICAgICAgICAgICBjYWxsYmFja0lkOiBkYXRhLmNhbGxiYWNrSWQsXG4gICAgICAgICAgICBkYXRhOiByZXN1bHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBzb3VyY2VOYW1lOiBjYlNvdXJjZU5hbWUsXG4gICAgICAgICAgICB0YXJnZXROYW1lOiBjYlRhcmdldE5hbWUsXG4gICAgICAgICAgICBjYWxsYmFjazogQ2FsbGJhY2tLaW5kLkVSUk9SLFxuICAgICAgICAgICAgY2FsbGJhY2tJZDogZGF0YS5jYWxsYmFja0lkLFxuICAgICAgICAgICAgcmVhc29uOiB3cmFwUmVhc29uKHJlYXNvbilcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGEuc3RyZWFtSWQpIHtcbiAgICAgICAgdGhpcy5fY3JlYXRlU3RyZWFtU2luayhkYXRhKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGFjdGlvbihkYXRhLmRhdGEpO1xuICAgIH07XG5cbiAgICBjb21PYmouYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgdGhpcy5fb25Db21PYmpPbk1lc3NhZ2UpO1xuICB9XG5cbiAgb24oYWN0aW9uTmFtZSwgaGFuZGxlcikge1xuICAgIGNvbnN0IGFoID0gdGhpcy5hY3Rpb25IYW5kbGVyO1xuXG4gICAgaWYgKGFoW2FjdGlvbk5hbWVdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZXJlIGlzIGFscmVhZHkgYW4gYWN0aW9uTmFtZSBjYWxsZWQgXCIke2FjdGlvbk5hbWV9XCJgKTtcbiAgICB9XG5cbiAgICBhaFthY3Rpb25OYW1lXSA9IGhhbmRsZXI7XG4gIH1cblxuICBzZW5kKGFjdGlvbk5hbWUsIGRhdGEsIHRyYW5zZmVycykge1xuICAgIHRoaXMuX3Bvc3RNZXNzYWdlKHtcbiAgICAgIHNvdXJjZU5hbWU6IHRoaXMuc291cmNlTmFtZSxcbiAgICAgIHRhcmdldE5hbWU6IHRoaXMudGFyZ2V0TmFtZSxcbiAgICAgIGFjdGlvbjogYWN0aW9uTmFtZSxcbiAgICAgIGRhdGFcbiAgICB9LCB0cmFuc2ZlcnMpO1xuICB9XG5cbiAgc2VuZFdpdGhQcm9taXNlKGFjdGlvbk5hbWUsIGRhdGEsIHRyYW5zZmVycykge1xuICAgIGNvbnN0IGNhbGxiYWNrSWQgPSB0aGlzLmNhbGxiYWNrSWQrKztcbiAgICBjb25zdCBjYXBhYmlsaXR5ID0gKDAsIF91dGlsLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KSgpO1xuICAgIHRoaXMuY2FsbGJhY2tDYXBhYmlsaXRpZXNbY2FsbGJhY2tJZF0gPSBjYXBhYmlsaXR5O1xuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX3Bvc3RNZXNzYWdlKHtcbiAgICAgICAgc291cmNlTmFtZTogdGhpcy5zb3VyY2VOYW1lLFxuICAgICAgICB0YXJnZXROYW1lOiB0aGlzLnRhcmdldE5hbWUsXG4gICAgICAgIGFjdGlvbjogYWN0aW9uTmFtZSxcbiAgICAgICAgY2FsbGJhY2tJZCxcbiAgICAgICAgZGF0YVxuICAgICAgfSwgdHJhbnNmZXJzKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgY2FwYWJpbGl0eS5yZWplY3QoZXgpO1xuICAgIH1cblxuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cblxuICBzZW5kV2l0aFN0cmVhbShhY3Rpb25OYW1lLCBkYXRhLCBxdWV1ZWluZ1N0cmF0ZWd5LCB0cmFuc2ZlcnMpIHtcbiAgICBjb25zdCBzdHJlYW1JZCA9IHRoaXMuc3RyZWFtSWQrKztcbiAgICBjb25zdCBzb3VyY2VOYW1lID0gdGhpcy5zb3VyY2VOYW1lO1xuICAgIGNvbnN0IHRhcmdldE5hbWUgPSB0aGlzLnRhcmdldE5hbWU7XG4gICAgY29uc3QgY29tT2JqID0gdGhpcy5jb21PYmo7XG4gICAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICBzdGFydDogY29udHJvbGxlciA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXJ0Q2FwYWJpbGl0eSA9ICgwLCBfdXRpbC5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSkoKTtcbiAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0gPSB7XG4gICAgICAgICAgY29udHJvbGxlcixcbiAgICAgICAgICBzdGFydENhbGw6IHN0YXJ0Q2FwYWJpbGl0eSxcbiAgICAgICAgICBwdWxsQ2FsbDogbnVsbCxcbiAgICAgICAgICBjYW5jZWxDYWxsOiBudWxsLFxuICAgICAgICAgIGlzQ2xvc2VkOiBmYWxzZVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX3Bvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb25OYW1lLFxuICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgZGVzaXJlZFNpemU6IGNvbnRyb2xsZXIuZGVzaXJlZFNpemVcbiAgICAgICAgfSwgdHJhbnNmZXJzKTtcblxuICAgICAgICByZXR1cm4gc3RhcnRDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICB9LFxuICAgICAgcHVsbDogY29udHJvbGxlciA9PiB7XG4gICAgICAgIGNvbnN0IHB1bGxDYXBhYmlsaXR5ID0gKDAsIF91dGlsLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KSgpO1xuICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXS5wdWxsQ2FsbCA9IHB1bGxDYXBhYmlsaXR5O1xuICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuUFVMTCxcbiAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICBkZXNpcmVkU2l6ZTogY29udHJvbGxlci5kZXNpcmVkU2l6ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHB1bGxDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICB9LFxuICAgICAgY2FuY2VsOiByZWFzb24gPT4ge1xuICAgICAgICAoMCwgX3V0aWwuYXNzZXJ0KShyZWFzb24gaW5zdGFuY2VvZiBFcnJvciwgXCJjYW5jZWwgbXVzdCBoYXZlIGEgdmFsaWQgcmVhc29uXCIpO1xuICAgICAgICBjb25zdCBjYW5jZWxDYXBhYmlsaXR5ID0gKDAsIF91dGlsLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KSgpO1xuICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXS5jYW5jZWxDYWxsID0gY2FuY2VsQ2FwYWJpbGl0eTtcbiAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0uaXNDbG9zZWQgPSB0cnVlO1xuICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuQ0FOQ0VMLFxuICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgIHJlYXNvbjogd3JhcFJlYXNvbihyZWFzb24pXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2FuY2VsQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgICAgfVxuICAgIH0sIHF1ZXVlaW5nU3RyYXRlZ3kpO1xuICB9XG5cbiAgX2NyZWF0ZVN0cmVhbVNpbmsoZGF0YSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGNvbnN0IGFjdGlvbiA9IHRoaXMuYWN0aW9uSGFuZGxlcltkYXRhLmFjdGlvbl07XG4gICAgY29uc3Qgc3RyZWFtSWQgPSBkYXRhLnN0cmVhbUlkO1xuICAgIGNvbnN0IHNvdXJjZU5hbWUgPSB0aGlzLnNvdXJjZU5hbWU7XG4gICAgY29uc3QgdGFyZ2V0TmFtZSA9IGRhdGEuc291cmNlTmFtZTtcbiAgICBjb25zdCBjb21PYmogPSB0aGlzLmNvbU9iajtcbiAgICBjb25zdCBzdHJlYW1TaW5rID0ge1xuICAgICAgZW5xdWV1ZShjaHVuaywgc2l6ZSA9IDEsIHRyYW5zZmVycykge1xuICAgICAgICBpZiAodGhpcy5pc0NhbmNlbGxlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxhc3REZXNpcmVkU2l6ZSA9IHRoaXMuZGVzaXJlZFNpemU7XG4gICAgICAgIHRoaXMuZGVzaXJlZFNpemUgLT0gc2l6ZTtcblxuICAgICAgICBpZiAobGFzdERlc2lyZWRTaXplID4gMCAmJiB0aGlzLmRlc2lyZWRTaXplIDw9IDApIHtcbiAgICAgICAgICB0aGlzLnNpbmtDYXBhYmlsaXR5ID0gKDAsIF91dGlsLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KSgpO1xuICAgICAgICAgIHRoaXMucmVhZHkgPSB0aGlzLnNpbmtDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLl9wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5FTlFVRVVFLFxuICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgIGNodW5rXG4gICAgICAgIH0sIHRyYW5zZmVycyk7XG4gICAgICB9LFxuXG4gICAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDYW5jZWxsZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmlzQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLkNMT1NFLFxuICAgICAgICAgIHN0cmVhbUlkXG4gICAgICAgIH0pO1xuICAgICAgICBkZWxldGUgc2VsZi5zdHJlYW1TaW5rc1tzdHJlYW1JZF07XG4gICAgICB9LFxuXG4gICAgICBlcnJvcihyZWFzb24pIHtcbiAgICAgICAgKDAsIF91dGlsLmFzc2VydCkocmVhc29uIGluc3RhbmNlb2YgRXJyb3IsIFwiZXJyb3IgbXVzdCBoYXZlIGEgdmFsaWQgcmVhc29uXCIpO1xuXG4gICAgICAgIGlmICh0aGlzLmlzQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pc0NhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5FUlJPUixcbiAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICByZWFzb246IHdyYXBSZWFzb24ocmVhc29uKVxuICAgICAgICB9KTtcbiAgICAgIH0sXG5cbiAgICAgIHNpbmtDYXBhYmlsaXR5OiAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCksXG4gICAgICBvblB1bGw6IG51bGwsXG4gICAgICBvbkNhbmNlbDogbnVsbCxcbiAgICAgIGlzQ2FuY2VsbGVkOiBmYWxzZSxcbiAgICAgIGRlc2lyZWRTaXplOiBkYXRhLmRlc2lyZWRTaXplLFxuICAgICAgcmVhZHk6IG51bGxcbiAgICB9O1xuICAgIHN0cmVhbVNpbmsuc2lua0NhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIHN0cmVhbVNpbmsucmVhZHkgPSBzdHJlYW1TaW5rLnNpbmtDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgdGhpcy5zdHJlYW1TaW5rc1tzdHJlYW1JZF0gPSBzdHJlYW1TaW5rO1xuICAgIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICByZXNvbHZlKGFjdGlvbihkYXRhLmRhdGEsIHN0cmVhbVNpbmspKTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5TVEFSVF9DT01QTEVURSxcbiAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgIHN1Y2Nlc3M6IHRydWVcbiAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5TVEFSVF9DT01QTEVURSxcbiAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgIHJlYXNvbjogd3JhcFJlYXNvbihyZWFzb24pXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIF9wcm9jZXNzU3RyZWFtTWVzc2FnZShkYXRhKSB7XG4gICAgY29uc3Qgc3RyZWFtSWQgPSBkYXRhLnN0cmVhbUlkO1xuICAgIGNvbnN0IHNvdXJjZU5hbWUgPSB0aGlzLnNvdXJjZU5hbWU7XG4gICAgY29uc3QgdGFyZ2V0TmFtZSA9IGRhdGEuc291cmNlTmFtZTtcbiAgICBjb25zdCBjb21PYmogPSB0aGlzLmNvbU9iajtcblxuICAgIHN3aXRjaCAoZGF0YS5zdHJlYW0pIHtcbiAgICAgIGNhc2UgU3RyZWFtS2luZC5TVEFSVF9DT01QTEVURTpcbiAgICAgICAgaWYgKGRhdGEuc3VjY2Vzcykge1xuICAgICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdLnN0YXJ0Q2FsbC5yZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0uc3RhcnRDYWxsLnJlamVjdCh3cmFwUmVhc29uKGRhdGEucmVhc29uKSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBTdHJlYW1LaW5kLlBVTExfQ09NUExFVEU6XG4gICAgICAgIGlmIChkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXS5wdWxsQ2FsbC5yZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0ucHVsbENhbGwucmVqZWN0KHdyYXBSZWFzb24oZGF0YS5yZWFzb24pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFN0cmVhbUtpbmQuUFVMTDpcbiAgICAgICAgaWYgKCF0aGlzLnN0cmVhbVNpbmtzW3N0cmVhbUlkXSkge1xuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5QVUxMX0NPTVBMRVRFLFxuICAgICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zdHJlYW1TaW5rc1tzdHJlYW1JZF0uZGVzaXJlZFNpemUgPD0gMCAmJiBkYXRhLmRlc2lyZWRTaXplID4gMCkge1xuICAgICAgICAgIHRoaXMuc3RyZWFtU2lua3Nbc3RyZWFtSWRdLnNpbmtDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RyZWFtU2lua3Nbc3RyZWFtSWRdLmRlc2lyZWRTaXplID0gZGF0YS5kZXNpcmVkU2l6ZTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIG9uUHVsbFxuICAgICAgICB9ID0gdGhpcy5zdHJlYW1TaW5rc1tkYXRhLnN0cmVhbUlkXTtcbiAgICAgICAgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICByZXNvbHZlKG9uUHVsbCAmJiBvblB1bGwoKSk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5QVUxMX0NPTVBMRVRFLFxuICAgICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuUFVMTF9DT01QTEVURSxcbiAgICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgICAgcmVhc29uOiB3cmFwUmVhc29uKHJlYXNvbilcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFN0cmVhbUtpbmQuRU5RVUVVRTpcbiAgICAgICAgKDAsIF91dGlsLmFzc2VydCkodGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0sIFwiZW5xdWV1ZSBzaG91bGQgaGF2ZSBzdHJlYW0gY29udHJvbGxlclwiKTtcblxuICAgICAgICBpZiAodGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0uaXNDbG9zZWQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdLmNvbnRyb2xsZXIuZW5xdWV1ZShkYXRhLmNodW5rKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgU3RyZWFtS2luZC5DTE9TRTpcbiAgICAgICAgKDAsIF91dGlsLmFzc2VydCkodGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0sIFwiY2xvc2Ugc2hvdWxkIGhhdmUgc3RyZWFtIGNvbnRyb2xsZXJcIik7XG5cbiAgICAgICAgaWYgKHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdLmlzQ2xvc2VkKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXS5pc0Nsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdLmNvbnRyb2xsZXIuY2xvc2UoKTtcblxuICAgICAgICB0aGlzLl9kZWxldGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbUlkKTtcblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBTdHJlYW1LaW5kLkVSUk9SOlxuICAgICAgICAoMCwgX3V0aWwuYXNzZXJ0KSh0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXSwgXCJlcnJvciBzaG91bGQgaGF2ZSBzdHJlYW0gY29udHJvbGxlclwiKTtcbiAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0uY29udHJvbGxlci5lcnJvcih3cmFwUmVhc29uKGRhdGEucmVhc29uKSk7XG5cbiAgICAgICAgdGhpcy5fZGVsZXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW1JZCk7XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgU3RyZWFtS2luZC5DQU5DRUxfQ09NUExFVEU6XG4gICAgICAgIGlmIChkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXS5jYW5jZWxDYWxsLnJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXS5jYW5jZWxDYWxsLnJlamVjdCh3cmFwUmVhc29uKGRhdGEucmVhc29uKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kZWxldGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbUlkKTtcblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBTdHJlYW1LaW5kLkNBTkNFTDpcbiAgICAgICAgaWYgKCF0aGlzLnN0cmVhbVNpbmtzW3N0cmVhbUlkXSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIG9uQ2FuY2VsXG4gICAgICAgIH0gPSB0aGlzLnN0cmVhbVNpbmtzW2RhdGEuc3RyZWFtSWRdO1xuICAgICAgICBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgIHJlc29sdmUob25DYW5jZWwgJiYgb25DYW5jZWwod3JhcFJlYXNvbihkYXRhLnJlYXNvbikpKTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLkNBTkNFTF9DT01QTEVURSxcbiAgICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLkNBTkNFTF9DT01QTEVURSxcbiAgICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgICAgcmVhc29uOiB3cmFwUmVhc29uKHJlYXNvbilcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3RyZWFtU2lua3Nbc3RyZWFtSWRdLnNpbmtDYXBhYmlsaXR5LnJlamVjdCh3cmFwUmVhc29uKGRhdGEucmVhc29uKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtU2lua3Nbc3RyZWFtSWRdLmlzQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgZGVsZXRlIHRoaXMuc3RyZWFtU2lua3Nbc3RyZWFtSWRdO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBzdHJlYW0gY2FzZVwiKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBfZGVsZXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW1JZCkge1xuICAgIGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChbdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0uc3RhcnRDYWxsLCB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXS5wdWxsQ2FsbCwgdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0uY2FuY2VsQ2FsbF0ubWFwKGZ1bmN0aW9uIChjYXBhYmlsaXR5KSB7XG4gICAgICByZXR1cm4gY2FwYWJpbGl0eSAmJiBjYXBhYmlsaXR5LnByb21pc2U7XG4gICAgfSkpO1xuICAgIGRlbGV0ZSB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXTtcbiAgfVxuXG4gIF9wb3N0TWVzc2FnZShtZXNzYWdlLCB0cmFuc2ZlcnMpIHtcbiAgICBpZiAodHJhbnNmZXJzICYmIHRoaXMucG9zdE1lc3NhZ2VUcmFuc2ZlcnMpIHtcbiAgICAgIHRoaXMuY29tT2JqLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIHRyYW5zZmVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29tT2JqLnBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5jb21PYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgdGhpcy5fb25Db21PYmpPbk1lc3NhZ2UpO1xuICB9XG5cbn1cblxuZXhwb3J0cy5NZXNzYWdlSGFuZGxlciA9IE1lc3NhZ2VIYW5kbGVyO1xuXG4vKioqLyB9KSxcbi8qIDE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLk1ldGFkYXRhID0gdm9pZCAwO1xuXG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIpO1xuXG52YXIgX3htbF9wYXJzZXIgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE1KTtcblxuY2xhc3MgTWV0YWRhdGEge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgKDAsIF91dGlsLmFzc2VydCkodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIsIFwiTWV0YWRhdGE6IGlucHV0IGlzIG5vdCBhIHN0cmluZ1wiKTtcbiAgICBkYXRhID0gdGhpcy5fcmVwYWlyKGRhdGEpO1xuICAgIGNvbnN0IHBhcnNlciA9IG5ldyBfeG1sX3BhcnNlci5TaW1wbGVYTUxQYXJzZXIoKTtcbiAgICBjb25zdCB4bWxEb2N1bWVudCA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcoZGF0YSk7XG4gICAgdGhpcy5fbWV0YWRhdGFNYXAgPSBuZXcgTWFwKCk7XG5cbiAgICBpZiAoeG1sRG9jdW1lbnQpIHtcbiAgICAgIHRoaXMuX3BhcnNlKHhtbERvY3VtZW50KTtcbiAgICB9XG4gIH1cblxuICBfcmVwYWlyKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YS5yZXBsYWNlKC9eW148XSsvLCBcIlwiKS5yZXBsYWNlKC8+XFxcXDM3NlxcXFwzNzcoW148XSspL2csIGZ1bmN0aW9uIChhbGwsIGNvZGVzKSB7XG4gICAgICBjb25zdCBieXRlcyA9IGNvZGVzLnJlcGxhY2UoL1xcXFwoWzAtM10pKFswLTddKShbMC03XSkvZywgZnVuY3Rpb24gKGNvZGUsIGQxLCBkMiwgZDMpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoZDEgKiA2NCArIGQyICogOCArIGQzICogMSk7XG4gICAgICB9KS5yZXBsYWNlKC8mKGFtcHxhcG9zfGd0fGx0fHF1b3QpOy9nLCBmdW5jdGlvbiAoc3RyLCBuYW1lKSB7XG4gICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgIGNhc2UgXCJhbXBcIjpcbiAgICAgICAgICAgIHJldHVybiBcIiZcIjtcblxuICAgICAgICAgIGNhc2UgXCJhcG9zXCI6XG4gICAgICAgICAgICByZXR1cm4gXCInXCI7XG5cbiAgICAgICAgICBjYXNlIFwiZ3RcIjpcbiAgICAgICAgICAgIHJldHVybiBcIj5cIjtcblxuICAgICAgICAgIGNhc2UgXCJsdFwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiPFwiO1xuXG4gICAgICAgICAgY2FzZSBcInF1b3RcIjpcbiAgICAgICAgICAgIHJldHVybiAnXCInO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBfcmVwYWlyOiAke25hbWV9IGlzbid0IGRlZmluZWQuYCk7XG4gICAgICB9KTtcbiAgICAgIGxldCBjaGFycyA9IFwiXCI7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGJ5dGVzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgICAgY29uc3QgY29kZSA9IGJ5dGVzLmNoYXJDb2RlQXQoaSkgKiAyNTYgKyBieXRlcy5jaGFyQ29kZUF0KGkgKyAxKTtcblxuICAgICAgICBpZiAoY29kZSA+PSAzMiAmJiBjb2RlIDwgMTI3ICYmIGNvZGUgIT09IDYwICYmIGNvZGUgIT09IDYyICYmIGNvZGUgIT09IDM4KSB7XG4gICAgICAgICAgY2hhcnMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGFycyArPSBcIiYjeFwiICsgKDB4MTAwMDAgKyBjb2RlKS50b1N0cmluZygxNikuc3Vic3RyaW5nKDEpICsgXCI7XCI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFwiPlwiICsgY2hhcnM7XG4gICAgfSk7XG4gIH1cblxuICBfcGFyc2UoeG1sRG9jdW1lbnQpIHtcbiAgICBsZXQgcmRmID0geG1sRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgaWYgKHJkZi5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcInJkZjpyZGZcIikge1xuICAgICAgcmRmID0gcmRmLmZpcnN0Q2hpbGQ7XG5cbiAgICAgIHdoaWxlIChyZGYgJiYgcmRmLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwicmRmOnJkZlwiKSB7XG4gICAgICAgIHJkZiA9IHJkZi5uZXh0U2libGluZztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBub2RlTmFtZSA9IHJkZiA/IHJkZi5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIDogbnVsbDtcblxuICAgIGlmICghcmRmIHx8IG5vZGVOYW1lICE9PSBcInJkZjpyZGZcIiB8fCAhcmRmLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNoaWxkcmVuID0gcmRmLmNoaWxkTm9kZXM7XG5cbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBjb25zdCBkZXNjID0gY2hpbGRyZW5baV07XG5cbiAgICAgIGlmIChkZXNjLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwicmRmOmRlc2NyaXB0aW9uXCIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGogPSAwLCBqaiA9IGRlc2MuY2hpbGROb2Rlcy5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgIGlmIChkZXNjLmNoaWxkTm9kZXNbal0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCIjdGV4dFwiKSB7XG4gICAgICAgICAgY29uc3QgZW50cnkgPSBkZXNjLmNoaWxkTm9kZXNbal07XG4gICAgICAgICAgY29uc3QgbmFtZSA9IGVudHJ5Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICB0aGlzLl9tZXRhZGF0YU1hcC5zZXQobmFtZSwgZW50cnkudGV4dENvbnRlbnQudHJpbSgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX21ldGFkYXRhTWFwLmhhcyhuYW1lKSA/IHRoaXMuX21ldGFkYXRhTWFwLmdldChuYW1lKSA6IG51bGw7XG4gIH1cblxuICBnZXRBbGwoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyh0aGlzLl9tZXRhZGF0YU1hcCk7XG4gIH1cblxuICBoYXMobmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9tZXRhZGF0YU1hcC5oYXMobmFtZSk7XG4gIH1cblxufVxuXG5leHBvcnRzLk1ldGFkYXRhID0gTWV0YWRhdGE7XG5cbi8qKiovIH0pLFxuLyogMTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuU2ltcGxlWE1MUGFyc2VyID0gdm9pZCAwO1xuY29uc3QgWE1MUGFyc2VyRXJyb3JDb2RlID0ge1xuICBOb0Vycm9yOiAwLFxuICBFbmRPZkRvY3VtZW50OiAtMSxcbiAgVW50ZXJtaW5hdGVkQ2RhdDogLTIsXG4gIFVudGVybWluYXRlZFhtbERlY2xhcmF0aW9uOiAtMyxcbiAgVW50ZXJtaW5hdGVkRG9jdHlwZURlY2xhcmF0aW9uOiAtNCxcbiAgVW50ZXJtaW5hdGVkQ29tbWVudDogLTUsXG4gIE1hbGZvcm1lZEVsZW1lbnQ6IC02LFxuICBPdXRPZk1lbW9yeTogLTcsXG4gIFVudGVybWluYXRlZEF0dHJpYnV0ZVZhbHVlOiAtOCxcbiAgVW50ZXJtaW5hdGVkRWxlbWVudDogLTksXG4gIEVsZW1lbnROZXZlckJlZ3VuOiAtMTBcbn07XG5cbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZShzLCBpbmRleCkge1xuICBjb25zdCBjaCA9IHNbaW5kZXhdO1xuICByZXR1cm4gY2ggPT09IFwiIFwiIHx8IGNoID09PSBcIlxcblwiIHx8IGNoID09PSBcIlxcclwiIHx8IGNoID09PSBcIlxcdFwiO1xufVxuXG5mdW5jdGlvbiBpc1doaXRlc3BhY2VTdHJpbmcocykge1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICBpZiAoIWlzV2hpdGVzcGFjZShzLCBpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5jbGFzcyBYTUxQYXJzZXJCYXNlIHtcbiAgX3Jlc29sdmVFbnRpdGllcyhzKSB7XG4gICAgcmV0dXJuIHMucmVwbGFjZSgvJihbXjtdKyk7L2csIChhbGwsIGVudGl0eSkgPT4ge1xuICAgICAgaWYgKGVudGl0eS5zdWJzdHJpbmcoMCwgMikgPT09IFwiI3hcIikge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChlbnRpdHkuc3Vic3RyaW5nKDIpLCAxNikpO1xuICAgICAgfSBlbHNlIGlmIChlbnRpdHkuc3Vic3RyaW5nKDAsIDEpID09PSBcIiNcIikge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChlbnRpdHkuc3Vic3RyaW5nKDEpLCAxMCkpO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGVudGl0eSkge1xuICAgICAgICBjYXNlIFwibHRcIjpcbiAgICAgICAgICByZXR1cm4gXCI8XCI7XG5cbiAgICAgICAgY2FzZSBcImd0XCI6XG4gICAgICAgICAgcmV0dXJuIFwiPlwiO1xuXG4gICAgICAgIGNhc2UgXCJhbXBcIjpcbiAgICAgICAgICByZXR1cm4gXCImXCI7XG5cbiAgICAgICAgY2FzZSBcInF1b3RcIjpcbiAgICAgICAgICByZXR1cm4gJ1wiJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMub25SZXNvbHZlRW50aXR5KGVudGl0eSk7XG4gICAgfSk7XG4gIH1cblxuICBfcGFyc2VDb250ZW50KHMsIHN0YXJ0KSB7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IFtdO1xuICAgIGxldCBwb3MgPSBzdGFydDtcblxuICAgIGZ1bmN0aW9uIHNraXBXcygpIHtcbiAgICAgIHdoaWxlIChwb3MgPCBzLmxlbmd0aCAmJiBpc1doaXRlc3BhY2UocywgcG9zKSkge1xuICAgICAgICArK3BvcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3aGlsZSAocG9zIDwgcy5sZW5ndGggJiYgIWlzV2hpdGVzcGFjZShzLCBwb3MpICYmIHNbcG9zXSAhPT0gXCI+XCIgJiYgc1twb3NdICE9PSBcIi9cIikge1xuICAgICAgKytwb3M7XG4gICAgfVxuXG4gICAgY29uc3QgbmFtZSA9IHMuc3Vic3RyaW5nKHN0YXJ0LCBwb3MpO1xuICAgIHNraXBXcygpO1xuXG4gICAgd2hpbGUgKHBvcyA8IHMubGVuZ3RoICYmIHNbcG9zXSAhPT0gXCI+XCIgJiYgc1twb3NdICE9PSBcIi9cIiAmJiBzW3Bvc10gIT09IFwiP1wiKSB7XG4gICAgICBza2lwV3MoKTtcbiAgICAgIGxldCBhdHRyTmFtZSA9IFwiXCIsXG4gICAgICAgICAgYXR0clZhbHVlID0gXCJcIjtcblxuICAgICAgd2hpbGUgKHBvcyA8IHMubGVuZ3RoICYmICFpc1doaXRlc3BhY2UocywgcG9zKSAmJiBzW3Bvc10gIT09IFwiPVwiKSB7XG4gICAgICAgIGF0dHJOYW1lICs9IHNbcG9zXTtcbiAgICAgICAgKytwb3M7XG4gICAgICB9XG5cbiAgICAgIHNraXBXcygpO1xuXG4gICAgICBpZiAoc1twb3NdICE9PSBcIj1cIikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgKytwb3M7XG4gICAgICBza2lwV3MoKTtcbiAgICAgIGNvbnN0IGF0dHJFbmRDaGFyID0gc1twb3NdO1xuXG4gICAgICBpZiAoYXR0ckVuZENoYXIgIT09ICdcIicgJiYgYXR0ckVuZENoYXIgIT09IFwiJ1wiKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhdHRyRW5kSW5kZXggPSBzLmluZGV4T2YoYXR0ckVuZENoYXIsICsrcG9zKTtcblxuICAgICAgaWYgKGF0dHJFbmRJbmRleCA8IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGF0dHJWYWx1ZSA9IHMuc3Vic3RyaW5nKHBvcywgYXR0ckVuZEluZGV4KTtcbiAgICAgIGF0dHJpYnV0ZXMucHVzaCh7XG4gICAgICAgIG5hbWU6IGF0dHJOYW1lLFxuICAgICAgICB2YWx1ZTogdGhpcy5fcmVzb2x2ZUVudGl0aWVzKGF0dHJWYWx1ZSlcbiAgICAgIH0pO1xuICAgICAgcG9zID0gYXR0ckVuZEluZGV4ICsgMTtcbiAgICAgIHNraXBXcygpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBuYW1lLFxuICAgICAgYXR0cmlidXRlcyxcbiAgICAgIHBhcnNlZDogcG9zIC0gc3RhcnRcbiAgICB9O1xuICB9XG5cbiAgX3BhcnNlUHJvY2Vzc2luZ0luc3RydWN0aW9uKHMsIHN0YXJ0KSB7XG4gICAgbGV0IHBvcyA9IHN0YXJ0O1xuXG4gICAgZnVuY3Rpb24gc2tpcFdzKCkge1xuICAgICAgd2hpbGUgKHBvcyA8IHMubGVuZ3RoICYmIGlzV2hpdGVzcGFjZShzLCBwb3MpKSB7XG4gICAgICAgICsrcG9zO1xuICAgICAgfVxuICAgIH1cblxuICAgIHdoaWxlIChwb3MgPCBzLmxlbmd0aCAmJiAhaXNXaGl0ZXNwYWNlKHMsIHBvcykgJiYgc1twb3NdICE9PSBcIj5cIiAmJiBzW3Bvc10gIT09IFwiL1wiKSB7XG4gICAgICArK3BvcztcbiAgICB9XG5cbiAgICBjb25zdCBuYW1lID0gcy5zdWJzdHJpbmcoc3RhcnQsIHBvcyk7XG4gICAgc2tpcFdzKCk7XG4gICAgY29uc3QgYXR0clN0YXJ0ID0gcG9zO1xuXG4gICAgd2hpbGUgKHBvcyA8IHMubGVuZ3RoICYmIChzW3Bvc10gIT09IFwiP1wiIHx8IHNbcG9zICsgMV0gIT09IFwiPlwiKSkge1xuICAgICAgKytwb3M7XG4gICAgfVxuXG4gICAgY29uc3QgdmFsdWUgPSBzLnN1YnN0cmluZyhhdHRyU3RhcnQsIHBvcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWUsXG4gICAgICB2YWx1ZSxcbiAgICAgIHBhcnNlZDogcG9zIC0gc3RhcnRcbiAgICB9O1xuICB9XG5cbiAgcGFyc2VYbWwocykge1xuICAgIGxldCBpID0gMDtcblxuICAgIHdoaWxlIChpIDwgcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGNoID0gc1tpXTtcbiAgICAgIGxldCBqID0gaTtcblxuICAgICAgaWYgKGNoID09PSBcIjxcIikge1xuICAgICAgICArK2o7XG4gICAgICAgIGNvbnN0IGNoMiA9IHNbal07XG4gICAgICAgIGxldCBxO1xuXG4gICAgICAgIHN3aXRjaCAoY2gyKSB7XG4gICAgICAgICAgY2FzZSBcIi9cIjpcbiAgICAgICAgICAgICsrajtcbiAgICAgICAgICAgIHEgPSBzLmluZGV4T2YoXCI+XCIsIGopO1xuXG4gICAgICAgICAgICBpZiAocSA8IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5vbkVycm9yKFhNTFBhcnNlckVycm9yQ29kZS5VbnRlcm1pbmF0ZWRFbGVtZW50KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLm9uRW5kRWxlbWVudChzLnN1YnN0cmluZyhqLCBxKSk7XG4gICAgICAgICAgICBqID0gcSArIDE7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCI/XCI6XG4gICAgICAgICAgICArK2o7XG5cbiAgICAgICAgICAgIGNvbnN0IHBpID0gdGhpcy5fcGFyc2VQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24ocywgaik7XG5cbiAgICAgICAgICAgIGlmIChzLnN1YnN0cmluZyhqICsgcGkucGFyc2VkLCBqICsgcGkucGFyc2VkICsgMikgIT09IFwiPz5cIikge1xuICAgICAgICAgICAgICB0aGlzLm9uRXJyb3IoWE1MUGFyc2VyRXJyb3JDb2RlLlVudGVybWluYXRlZFhtbERlY2xhcmF0aW9uKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLm9uUGkocGkubmFtZSwgcGkudmFsdWUpO1xuICAgICAgICAgICAgaiArPSBwaS5wYXJzZWQgKyAyO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiIVwiOlxuICAgICAgICAgICAgaWYgKHMuc3Vic3RyaW5nKGogKyAxLCBqICsgMykgPT09IFwiLS1cIikge1xuICAgICAgICAgICAgICBxID0gcy5pbmRleE9mKFwiLS0+XCIsIGogKyAzKTtcblxuICAgICAgICAgICAgICBpZiAocSA8IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uRXJyb3IoWE1MUGFyc2VyRXJyb3JDb2RlLlVudGVybWluYXRlZENvbW1lbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMub25Db21tZW50KHMuc3Vic3RyaW5nKGogKyAzLCBxKSk7XG4gICAgICAgICAgICAgIGogPSBxICsgMztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocy5zdWJzdHJpbmcoaiArIDEsIGogKyA4KSA9PT0gXCJbQ0RBVEFbXCIpIHtcbiAgICAgICAgICAgICAgcSA9IHMuaW5kZXhPZihcIl1dPlwiLCBqICsgOCk7XG5cbiAgICAgICAgICAgICAgaWYgKHEgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkVycm9yKFhNTFBhcnNlckVycm9yQ29kZS5VbnRlcm1pbmF0ZWRDZGF0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aGlzLm9uQ2RhdGEocy5zdWJzdHJpbmcoaiArIDgsIHEpKTtcbiAgICAgICAgICAgICAgaiA9IHEgKyAzO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzLnN1YnN0cmluZyhqICsgMSwgaiArIDgpID09PSBcIkRPQ1RZUEVcIikge1xuICAgICAgICAgICAgICBjb25zdCBxMiA9IHMuaW5kZXhPZihcIltcIiwgaiArIDgpO1xuICAgICAgICAgICAgICBsZXQgY29tcGxleERvY3R5cGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcSA9IHMuaW5kZXhPZihcIj5cIiwgaiArIDgpO1xuXG4gICAgICAgICAgICAgIGlmIChxIDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMub25FcnJvcihYTUxQYXJzZXJFcnJvckNvZGUuVW50ZXJtaW5hdGVkRG9jdHlwZURlY2xhcmF0aW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAocTIgPiAwICYmIHEgPiBxMikge1xuICAgICAgICAgICAgICAgIHEgPSBzLmluZGV4T2YoXCJdPlwiLCBqICsgOCk7XG5cbiAgICAgICAgICAgICAgICBpZiAocSA8IDApIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMub25FcnJvcihYTUxQYXJzZXJFcnJvckNvZGUuVW50ZXJtaW5hdGVkRG9jdHlwZURlY2xhcmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb21wbGV4RG9jdHlwZSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjb25zdCBkb2N0eXBlQ29udGVudCA9IHMuc3Vic3RyaW5nKGogKyA4LCBxICsgKGNvbXBsZXhEb2N0eXBlID8gMSA6IDApKTtcbiAgICAgICAgICAgICAgdGhpcy5vbkRvY3R5cGUoZG9jdHlwZUNvbnRlbnQpO1xuICAgICAgICAgICAgICBqID0gcSArIChjb21wbGV4RG9jdHlwZSA/IDIgOiAxKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMub25FcnJvcihYTUxQYXJzZXJFcnJvckNvZGUuTWFsZm9ybWVkRWxlbWVudCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IHRoaXMuX3BhcnNlQ29udGVudChzLCBqKTtcblxuICAgICAgICAgICAgaWYgKGNvbnRlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhpcy5vbkVycm9yKFhNTFBhcnNlckVycm9yQ29kZS5NYWxmb3JtZWRFbGVtZW50KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgaXNDbG9zZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKHMuc3Vic3RyaW5nKGogKyBjb250ZW50LnBhcnNlZCwgaiArIGNvbnRlbnQucGFyc2VkICsgMikgPT09IFwiLz5cIikge1xuICAgICAgICAgICAgICBpc0Nsb3NlZCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHMuc3Vic3RyaW5nKGogKyBjb250ZW50LnBhcnNlZCwgaiArIGNvbnRlbnQucGFyc2VkICsgMSkgIT09IFwiPlwiKSB7XG4gICAgICAgICAgICAgIHRoaXMub25FcnJvcihYTUxQYXJzZXJFcnJvckNvZGUuVW50ZXJtaW5hdGVkRWxlbWVudCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5vbkJlZ2luRWxlbWVudChjb250ZW50Lm5hbWUsIGNvbnRlbnQuYXR0cmlidXRlcywgaXNDbG9zZWQpO1xuICAgICAgICAgICAgaiArPSBjb250ZW50LnBhcnNlZCArIChpc0Nsb3NlZCA/IDIgOiAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aGlsZSAoaiA8IHMubGVuZ3RoICYmIHNbal0gIT09IFwiPFwiKSB7XG4gICAgICAgICAgaisrO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGV4dCA9IHMuc3Vic3RyaW5nKGksIGopO1xuICAgICAgICB0aGlzLm9uVGV4dCh0aGlzLl9yZXNvbHZlRW50aXRpZXModGV4dCkpO1xuICAgICAgfVxuXG4gICAgICBpID0gajtcbiAgICB9XG4gIH1cblxuICBvblJlc29sdmVFbnRpdHkobmFtZSkge1xuICAgIHJldHVybiBgJiR7bmFtZX07YDtcbiAgfVxuXG4gIG9uUGkobmFtZSwgdmFsdWUpIHt9XG5cbiAgb25Db21tZW50KHRleHQpIHt9XG5cbiAgb25DZGF0YSh0ZXh0KSB7fVxuXG4gIG9uRG9jdHlwZShkb2N0eXBlQ29udGVudCkge31cblxuICBvblRleHQodGV4dCkge31cblxuICBvbkJlZ2luRWxlbWVudChuYW1lLCBhdHRyaWJ1dGVzLCBpc0VtcHR5KSB7fVxuXG4gIG9uRW5kRWxlbWVudChuYW1lKSB7fVxuXG4gIG9uRXJyb3IoY29kZSkge31cblxufVxuXG5jbGFzcyBTaW1wbGVET01Ob2RlIHtcbiAgY29uc3RydWN0b3Iobm9kZU5hbWUsIG5vZGVWYWx1ZSkge1xuICAgIHRoaXMubm9kZU5hbWUgPSBub2RlTmFtZTtcbiAgICB0aGlzLm5vZGVWYWx1ZSA9IG5vZGVWYWx1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwYXJlbnROb2RlXCIsIHtcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIGdldCBmaXJzdENoaWxkKCkge1xuICAgIHJldHVybiB0aGlzLmNoaWxkTm9kZXMgJiYgdGhpcy5jaGlsZE5vZGVzWzBdO1xuICB9XG5cbiAgZ2V0IG5leHRTaWJsaW5nKCkge1xuICAgIGNvbnN0IGNoaWxkTm9kZXMgPSB0aGlzLnBhcmVudE5vZGUuY2hpbGROb2RlcztcblxuICAgIGlmICghY2hpbGROb2Rlcykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBjb25zdCBpbmRleCA9IGNoaWxkTm9kZXMuaW5kZXhPZih0aGlzKTtcblxuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoaWxkTm9kZXNbaW5kZXggKyAxXTtcbiAgfVxuXG4gIGdldCB0ZXh0Q29udGVudCgpIHtcbiAgICBpZiAoIXRoaXMuY2hpbGROb2Rlcykge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZVZhbHVlIHx8IFwiXCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2hpbGROb2Rlcy5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICByZXR1cm4gY2hpbGQudGV4dENvbnRlbnQ7XG4gICAgfSkuam9pbihcIlwiKTtcbiAgfVxuXG4gIGhhc0NoaWxkTm9kZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGROb2RlcyAmJiB0aGlzLmNoaWxkTm9kZXMubGVuZ3RoID4gMDtcbiAgfVxuXG59XG5cbmNsYXNzIFNpbXBsZVhNTFBhcnNlciBleHRlbmRzIFhNTFBhcnNlckJhc2Uge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2N1cnJlbnRGcmFnbWVudCA9IG51bGw7XG4gICAgdGhpcy5fc3RhY2sgPSBudWxsO1xuICAgIHRoaXMuX2Vycm9yQ29kZSA9IFhNTFBhcnNlckVycm9yQ29kZS5Ob0Vycm9yO1xuICB9XG5cbiAgcGFyc2VGcm9tU3RyaW5nKGRhdGEpIHtcbiAgICB0aGlzLl9jdXJyZW50RnJhZ21lbnQgPSBbXTtcbiAgICB0aGlzLl9zdGFjayA9IFtdO1xuICAgIHRoaXMuX2Vycm9yQ29kZSA9IFhNTFBhcnNlckVycm9yQ29kZS5Ob0Vycm9yO1xuICAgIHRoaXMucGFyc2VYbWwoZGF0YSk7XG5cbiAgICBpZiAodGhpcy5fZXJyb3JDb2RlICE9PSBYTUxQYXJzZXJFcnJvckNvZGUuTm9FcnJvcikge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBjb25zdCBbZG9jdW1lbnRFbGVtZW50XSA9IHRoaXMuX2N1cnJlbnRGcmFnbWVudDtcblxuICAgIGlmICghZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBkb2N1bWVudEVsZW1lbnRcbiAgICB9O1xuICB9XG5cbiAgb25SZXNvbHZlRW50aXR5KG5hbWUpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgXCJhcG9zXCI6XG4gICAgICAgIHJldHVybiBcIidcIjtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIub25SZXNvbHZlRW50aXR5KG5hbWUpO1xuICB9XG5cbiAgb25UZXh0KHRleHQpIHtcbiAgICBpZiAoaXNXaGl0ZXNwYWNlU3RyaW5nKHRleHQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgbm9kZSA9IG5ldyBTaW1wbGVET01Ob2RlKFwiI3RleHRcIiwgdGV4dCk7XG5cbiAgICB0aGlzLl9jdXJyZW50RnJhZ21lbnQucHVzaChub2RlKTtcbiAgfVxuXG4gIG9uQ2RhdGEodGV4dCkge1xuICAgIGNvbnN0IG5vZGUgPSBuZXcgU2ltcGxlRE9NTm9kZShcIiN0ZXh0XCIsIHRleHQpO1xuXG4gICAgdGhpcy5fY3VycmVudEZyYWdtZW50LnB1c2gobm9kZSk7XG4gIH1cblxuICBvbkJlZ2luRWxlbWVudChuYW1lLCBhdHRyaWJ1dGVzLCBpc0VtcHR5KSB7XG4gICAgY29uc3Qgbm9kZSA9IG5ldyBTaW1wbGVET01Ob2RlKG5hbWUpO1xuICAgIG5vZGUuY2hpbGROb2RlcyA9IFtdO1xuXG4gICAgdGhpcy5fY3VycmVudEZyYWdtZW50LnB1c2gobm9kZSk7XG5cbiAgICBpZiAoaXNFbXB0eSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3N0YWNrLnB1c2godGhpcy5fY3VycmVudEZyYWdtZW50KTtcblxuICAgIHRoaXMuX2N1cnJlbnRGcmFnbWVudCA9IG5vZGUuY2hpbGROb2RlcztcbiAgfVxuXG4gIG9uRW5kRWxlbWVudChuYW1lKSB7XG4gICAgdGhpcy5fY3VycmVudEZyYWdtZW50ID0gdGhpcy5fc3RhY2sucG9wKCkgfHwgW107XG4gICAgY29uc3QgbGFzdEVsZW1lbnQgPSB0aGlzLl9jdXJyZW50RnJhZ21lbnRbdGhpcy5fY3VycmVudEZyYWdtZW50Lmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKCFsYXN0RWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGxhc3RFbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgbGFzdEVsZW1lbnQuY2hpbGROb2Rlc1tpXS5wYXJlbnROb2RlID0gbGFzdEVsZW1lbnQ7XG4gICAgfVxuICB9XG5cbiAgb25FcnJvcihjb2RlKSB7XG4gICAgdGhpcy5fZXJyb3JDb2RlID0gY29kZTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuU2ltcGxlWE1MUGFyc2VyID0gU2ltcGxlWE1MUGFyc2VyO1xuXG4vKioqLyB9KSxcbi8qIDE2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLk9wdGlvbmFsQ29udGVudENvbmZpZyA9IHZvaWQgMDtcblxudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygyKTtcblxuY2xhc3MgT3B0aW9uYWxDb250ZW50R3JvdXAge1xuICBjb25zdHJ1Y3RvcihuYW1lLCBpbnRlbnQpIHtcbiAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5pbnRlbnQgPSBpbnRlbnQ7XG4gIH1cblxufVxuXG5jbGFzcyBPcHRpb25hbENvbnRlbnRDb25maWcge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgdGhpcy5uYW1lID0gbnVsbDtcbiAgICB0aGlzLmNyZWF0b3IgPSBudWxsO1xuICAgIHRoaXMuX29yZGVyID0gbnVsbDtcbiAgICB0aGlzLl9ncm91cHMgPSBuZXcgTWFwKCk7XG5cbiAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMubmFtZSA9IGRhdGEubmFtZTtcbiAgICB0aGlzLmNyZWF0b3IgPSBkYXRhLmNyZWF0b3I7XG4gICAgdGhpcy5fb3JkZXIgPSBkYXRhLm9yZGVyO1xuXG4gICAgZm9yIChjb25zdCBncm91cCBvZiBkYXRhLmdyb3Vwcykge1xuICAgICAgdGhpcy5fZ3JvdXBzLnNldChncm91cC5pZCwgbmV3IE9wdGlvbmFsQ29udGVudEdyb3VwKGdyb3VwLm5hbWUsIGdyb3VwLmludGVudCkpO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmJhc2VTdGF0ZSA9PT0gXCJPRkZcIikge1xuICAgICAgZm9yIChjb25zdCBncm91cCBvZiB0aGlzLl9ncm91cHMpIHtcbiAgICAgICAgZ3JvdXAudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoY29uc3Qgb24gb2YgZGF0YS5vbikge1xuICAgICAgdGhpcy5fZ3JvdXBzLmdldChvbikudmlzaWJsZSA9IHRydWU7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBvZmYgb2YgZGF0YS5vZmYpIHtcbiAgICAgIHRoaXMuX2dyb3Vwcy5nZXQob2ZmKS52aXNpYmxlID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaXNWaXNpYmxlKGdyb3VwKSB7XG4gICAgaWYgKGdyb3VwLnR5cGUgPT09IFwiT0NHXCIpIHtcbiAgICAgIGlmICghdGhpcy5fZ3JvdXBzLmhhcyhncm91cC5pZCkpIHtcbiAgICAgICAgKDAsIF91dGlsLndhcm4pKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtncm91cC5pZH1gKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9ncm91cHMuZ2V0KGdyb3VwLmlkKS52aXNpYmxlO1xuICAgIH0gZWxzZSBpZiAoZ3JvdXAudHlwZSA9PT0gXCJPQ01EXCIpIHtcbiAgICAgIGlmIChncm91cC5leHByZXNzaW9uKSB7XG4gICAgICAgICgwLCBfdXRpbC53YXJuKShcIlZpc2liaWxpdHkgZXhwcmVzc2lvbiBub3Qgc3VwcG9ydGVkIHlldC5cIik7XG4gICAgICB9XG5cbiAgICAgIGlmICghZ3JvdXAucG9saWN5IHx8IGdyb3VwLnBvbGljeSA9PT0gXCJBbnlPblwiKSB7XG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgZ3JvdXAuaWRzKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9ncm91cHMuaGFzKGlkKSkge1xuICAgICAgICAgICAgKDAsIF91dGlsLndhcm4pKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtpZH1gKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLl9ncm91cHMuZ2V0KGlkKS52aXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGdyb3VwLnBvbGljeSA9PT0gXCJBbGxPblwiKSB7XG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgZ3JvdXAuaWRzKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9ncm91cHMuaGFzKGlkKSkge1xuICAgICAgICAgICAgKDAsIF91dGlsLndhcm4pKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtpZH1gKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghdGhpcy5fZ3JvdXBzLmdldChpZCkudmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChncm91cC5wb2xpY3kgPT09IFwiQW55T2ZmXCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBpZCBvZiBncm91cC5pZHMpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuX2dyb3Vwcy5oYXMoaWQpKSB7XG4gICAgICAgICAgICAoMCwgX3V0aWwud2FybikoYE9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGZvdW5kOiAke2lkfWApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCF0aGlzLl9ncm91cHMuZ2V0KGlkKS52aXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGdyb3VwLnBvbGljeSA9PT0gXCJBbGxPZmZcIikge1xuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIGdyb3VwLmlkcykge1xuICAgICAgICAgIGlmICghdGhpcy5fZ3JvdXBzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgICgwLCBfdXRpbC53YXJuKShgT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZm91bmQ6ICR7aWR9YCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5fZ3JvdXBzLmdldChpZCkudmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAoMCwgX3V0aWwud2FybikoYFVua25vd24gb3B0aW9uYWwgY29udGVudCBwb2xpY3kgJHtncm91cC5wb2xpY3l9LmApO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgKDAsIF91dGlsLndhcm4pKGBVbmtub3duIGdyb3VwIHR5cGUgJHtncm91cC50eXBlfS5gKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHNldFZpc2liaWxpdHkoaWQsIHZpc2libGUgPSB0cnVlKSB7XG4gICAgaWYgKCF0aGlzLl9ncm91cHMuaGFzKGlkKSkge1xuICAgICAgKDAsIF91dGlsLndhcm4pKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtpZH1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9ncm91cHMuZ2V0KGlkKS52aXNpYmxlID0gISF2aXNpYmxlO1xuICB9XG5cbiAgZ2V0T3JkZXIoKSB7XG4gICAgaWYgKCF0aGlzLl9ncm91cHMuc2l6ZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX29yZGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb3JkZXIuc2xpY2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl9ncm91cHMua2V5cygpKTtcbiAgfVxuXG4gIGdldEdyb3VwcygpIHtcbiAgICBpZiAoIXRoaXMuX2dyb3Vwcy5zaXplKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKHRoaXMuX2dyb3Vwcyk7XG4gIH1cblxuICBnZXRHcm91cChpZCkge1xuICAgIHJldHVybiB0aGlzLl9ncm91cHMuZ2V0KGlkKSB8fCBudWxsO1xuICB9XG5cbn1cblxuZXhwb3J0cy5PcHRpb25hbENvbnRlbnRDb25maWcgPSBPcHRpb25hbENvbnRlbnRDb25maWc7XG5cbi8qKiovIH0pLFxuLyogMTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuUERGRGF0YVRyYW5zcG9ydFN0cmVhbSA9IHZvaWQgMDtcblxudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygyKTtcblxuY2xhc3MgUERGRGF0YVRyYW5zcG9ydFN0cmVhbSB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtcywgcGRmRGF0YVJhbmdlVHJhbnNwb3J0KSB7XG4gICAgKDAsIF91dGlsLmFzc2VydCkocGRmRGF0YVJhbmdlVHJhbnNwb3J0LCAnUERGRGF0YVRyYW5zcG9ydFN0cmVhbSAtIG1pc3NpbmcgcmVxdWlyZWQgXCJwZGZEYXRhUmFuZ2VUcmFuc3BvcnRcIiBhcmd1bWVudC4nKTtcbiAgICB0aGlzLl9xdWV1ZWRDaHVua3MgPSBbXTtcbiAgICB0aGlzLl9wcm9ncmVzc2l2ZURvbmUgPSBwYXJhbXMucHJvZ3Jlc3NpdmVEb25lIHx8IGZhbHNlO1xuICAgIGNvbnN0IGluaXRpYWxEYXRhID0gcGFyYW1zLmluaXRpYWxEYXRhO1xuXG4gICAgaWYgKGluaXRpYWxEYXRhICYmIGluaXRpYWxEYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGluaXRpYWxEYXRhKS5idWZmZXI7XG5cbiAgICAgIHRoaXMuX3F1ZXVlZENodW5rcy5wdXNoKGJ1ZmZlcik7XG4gICAgfVxuXG4gICAgdGhpcy5fcGRmRGF0YVJhbmdlVHJhbnNwb3J0ID0gcGRmRGF0YVJhbmdlVHJhbnNwb3J0O1xuICAgIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkID0gIXBhcmFtcy5kaXNhYmxlU3RyZWFtO1xuICAgIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSAhcGFyYW1zLmRpc2FibGVSYW5nZTtcbiAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gcGFyYW1zLmxlbmd0aDtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fcmFuZ2VSZWFkZXJzID0gW107XG5cbiAgICB0aGlzLl9wZGZEYXRhUmFuZ2VUcmFuc3BvcnQuYWRkUmFuZ2VMaXN0ZW5lcigoYmVnaW4sIGNodW5rKSA9PiB7XG4gICAgICB0aGlzLl9vblJlY2VpdmVEYXRhKHtcbiAgICAgICAgYmVnaW4sXG4gICAgICAgIGNodW5rXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRoaXMuX3BkZkRhdGFSYW5nZVRyYW5zcG9ydC5hZGRQcm9ncmVzc0xpc3RlbmVyKChsb2FkZWQsIHRvdGFsKSA9PiB7XG4gICAgICB0aGlzLl9vblByb2dyZXNzKHtcbiAgICAgICAgbG9hZGVkLFxuICAgICAgICB0b3RhbFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9wZGZEYXRhUmFuZ2VUcmFuc3BvcnQuYWRkUHJvZ3Jlc3NpdmVSZWFkTGlzdGVuZXIoY2h1bmsgPT4ge1xuICAgICAgdGhpcy5fb25SZWNlaXZlRGF0YSh7XG4gICAgICAgIGNodW5rXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRoaXMuX3BkZkRhdGFSYW5nZVRyYW5zcG9ydC5hZGRQcm9ncmVzc2l2ZURvbmVMaXN0ZW5lcigoKSA9PiB7XG4gICAgICB0aGlzLl9vblByb2dyZXNzaXZlRG9uZSgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fcGRmRGF0YVJhbmdlVHJhbnNwb3J0LnRyYW5zcG9ydFJlYWR5KCk7XG4gIH1cblxuICBfb25SZWNlaXZlRGF0YShhcmdzKSB7XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYXJncy5jaHVuaykuYnVmZmVyO1xuXG4gICAgaWYgKGFyZ3MuYmVnaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyKSB7XG4gICAgICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLl9lbnF1ZXVlKGJ1ZmZlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9xdWV1ZWRDaHVua3MucHVzaChidWZmZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBmb3VuZCA9IHRoaXMuX3JhbmdlUmVhZGVycy5zb21lKGZ1bmN0aW9uIChyYW5nZVJlYWRlcikge1xuICAgICAgICBpZiAocmFuZ2VSZWFkZXIuX2JlZ2luICE9PSBhcmdzLmJlZ2luKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmFuZ2VSZWFkZXIuX2VucXVldWUoYnVmZmVyKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuXG4gICAgICAoMCwgX3V0aWwuYXNzZXJ0KShmb3VuZCwgXCJfb25SZWNlaXZlRGF0YSAtIG5vIGBQREZEYXRhVHJhbnNwb3J0U3RyZWFtUmFuZ2VSZWFkZXJgIGluc3RhbmNlIGZvdW5kLlwiKTtcbiAgICB9XG4gIH1cblxuICBnZXQgX3Byb2dyZXNzaXZlRGF0YUxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPyB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlci5fbG9hZGVkIDogMDtcbiAgfVxuXG4gIF9vblByb2dyZXNzKGV2dCkge1xuICAgIGlmIChldnQudG90YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgZmlyc3RSZWFkZXIgPSB0aGlzLl9yYW5nZVJlYWRlcnNbMF07XG5cbiAgICAgIGlmIChmaXJzdFJlYWRlciAmJiBmaXJzdFJlYWRlci5vblByb2dyZXNzKSB7XG4gICAgICAgIGZpcnN0UmVhZGVyLm9uUHJvZ3Jlc3Moe1xuICAgICAgICAgIGxvYWRlZDogZXZ0LmxvYWRlZFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZnVsbFJlYWRlciA9IHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyO1xuXG4gICAgICBpZiAoZnVsbFJlYWRlciAmJiBmdWxsUmVhZGVyLm9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgZnVsbFJlYWRlci5vblByb2dyZXNzKHtcbiAgICAgICAgICBsb2FkZWQ6IGV2dC5sb2FkZWQsXG4gICAgICAgICAgdG90YWw6IGV2dC50b3RhbFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfb25Qcm9ncmVzc2l2ZURvbmUoKSB7XG4gICAgaWYgKHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyKSB7XG4gICAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlci5wcm9ncmVzc2l2ZURvbmUoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9wcm9ncmVzc2l2ZURvbmUgPSB0cnVlO1xuICB9XG5cbiAgX3JlbW92ZVJhbmdlUmVhZGVyKHJlYWRlcikge1xuICAgIGNvbnN0IGkgPSB0aGlzLl9yYW5nZVJlYWRlcnMuaW5kZXhPZihyZWFkZXIpO1xuXG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgdGhpcy5fcmFuZ2VSZWFkZXJzLnNwbGljZShpLCAxKTtcbiAgICB9XG4gIH1cblxuICBnZXRGdWxsUmVhZGVyKCkge1xuICAgICgwLCBfdXRpbC5hc3NlcnQpKCF0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciwgXCJQREZEYXRhVHJhbnNwb3J0U3RyZWFtLmdldEZ1bGxSZWFkZXIgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2UuXCIpO1xuICAgIGNvbnN0IHF1ZXVlZENodW5rcyA9IHRoaXMuX3F1ZXVlZENodW5rcztcbiAgICB0aGlzLl9xdWV1ZWRDaHVua3MgPSBudWxsO1xuICAgIHJldHVybiBuZXcgUERGRGF0YVRyYW5zcG9ydFN0cmVhbVJlYWRlcih0aGlzLCBxdWV1ZWRDaHVua3MsIHRoaXMuX3Byb2dyZXNzaXZlRG9uZSk7XG4gIH1cblxuICBnZXRSYW5nZVJlYWRlcihiZWdpbiwgZW5kKSB7XG4gICAgaWYgKGVuZCA8PSB0aGlzLl9wcm9ncmVzc2l2ZURhdGFMZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBQREZEYXRhVHJhbnNwb3J0U3RyZWFtUmFuZ2VSZWFkZXIodGhpcywgYmVnaW4sIGVuZCk7XG5cbiAgICB0aGlzLl9wZGZEYXRhUmFuZ2VUcmFuc3BvcnQucmVxdWVzdERhdGFSYW5nZShiZWdpbiwgZW5kKTtcblxuICAgIHRoaXMuX3JhbmdlUmVhZGVycy5wdXNoKHJlYWRlcik7XG5cbiAgICByZXR1cm4gcmVhZGVyO1xuICB9XG5cbiAgY2FuY2VsQWxsUmVxdWVzdHMocmVhc29uKSB7XG4gICAgaWYgKHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyKSB7XG4gICAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICB9XG5cbiAgICBjb25zdCByZWFkZXJzID0gdGhpcy5fcmFuZ2VSZWFkZXJzLnNsaWNlKDApO1xuXG4gICAgcmVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChyYW5nZVJlYWRlcikge1xuICAgICAgcmFuZ2VSZWFkZXIuY2FuY2VsKHJlYXNvbik7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9wZGZEYXRhUmFuZ2VUcmFuc3BvcnQuYWJvcnQoKTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuUERGRGF0YVRyYW5zcG9ydFN0cmVhbSA9IFBERkRhdGFUcmFuc3BvcnRTdHJlYW07XG5cbmNsYXNzIFBERkRhdGFUcmFuc3BvcnRTdHJlYW1SZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0sIHF1ZXVlZENodW5rcywgcHJvZ3Jlc3NpdmVEb25lID0gZmFsc2UpIHtcbiAgICB0aGlzLl9zdHJlYW0gPSBzdHJlYW07XG4gICAgdGhpcy5fZG9uZSA9IHByb2dyZXNzaXZlRG9uZSB8fCBmYWxzZTtcbiAgICB0aGlzLl9maWxlbmFtZSA9IG51bGw7XG4gICAgdGhpcy5fcXVldWVkQ2h1bmtzID0gcXVldWVkQ2h1bmtzIHx8IFtdO1xuICAgIHRoaXMuX2xvYWRlZCA9IDA7XG5cbiAgICBmb3IgKGNvbnN0IGNodW5rIG9mIHRoaXMuX3F1ZXVlZENodW5rcykge1xuICAgICAgdGhpcy5fbG9hZGVkICs9IGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVxdWVzdHMgPSBbXTtcbiAgICB0aGlzLl9oZWFkZXJzUmVhZHkgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBzdHJlYW0uX2Z1bGxSZXF1ZXN0UmVhZGVyID0gdGhpcztcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICB9XG5cbiAgX2VucXVldWUoY2h1bmspIHtcbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSA9IHRoaXMuX3JlcXVlc3RzLnNoaWZ0KCk7XG5cbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcXVldWVkQ2h1bmtzLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIHRoaXMuX2xvYWRlZCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICB9XG5cbiAgZ2V0IGhlYWRlcnNSZWFkeSgpIHtcbiAgICByZXR1cm4gdGhpcy5faGVhZGVyc1JlYWR5O1xuICB9XG5cbiAgZ2V0IGZpbGVuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9maWxlbmFtZTtcbiAgfVxuXG4gIGdldCBpc1JhbmdlU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJlYW0uX2lzUmFuZ2VTdXBwb3J0ZWQ7XG4gIH1cblxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0cmVhbS5faXNTdHJlYW1pbmdTdXBwb3J0ZWQ7XG4gIH1cblxuICBnZXQgY29udGVudExlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RyZWFtLl9jb250ZW50TGVuZ3RoO1xuICB9XG5cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBpZiAodGhpcy5fcXVldWVkQ2h1bmtzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fcXVldWVkQ2h1bmtzLnNoaWZ0KCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgPSAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCk7XG5cbiAgICB0aGlzLl9yZXF1ZXN0cy5wdXNoKHJlcXVlc3RDYXBhYmlsaXR5KTtcblxuICAgIHJldHVybiByZXF1ZXN0Q2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG5cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuXG4gICAgdGhpcy5fcmVxdWVzdHMuZm9yRWFjaChmdW5jdGlvbiAocmVxdWVzdENhcGFiaWxpdHkpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRoaXMuX3JlcXVlc3RzID0gW107XG4gIH1cblxuICBwcm9ncmVzc2l2ZURvbmUoKSB7XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgfVxuXG59XG5cbmNsYXNzIFBERkRhdGFUcmFuc3BvcnRTdHJlYW1SYW5nZVJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSwgYmVnaW4sIGVuZCkge1xuICAgIHRoaXMuX3N0cmVhbSA9IHN0cmVhbTtcbiAgICB0aGlzLl9iZWdpbiA9IGJlZ2luO1xuICAgIHRoaXMuX2VuZCA9IGVuZDtcbiAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IG51bGw7XG4gICAgdGhpcy5fcmVxdWVzdHMgPSBbXTtcbiAgICB0aGlzLl9kb25lID0gZmFsc2U7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgfVxuXG4gIF9lbnF1ZXVlKGNodW5rKSB7XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcmVxdWVzdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IGNodW5rO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByZXF1ZXN0c0NhcGFiaWxpdHkgPSB0aGlzLl9yZXF1ZXN0cy5zaGlmdCgpO1xuXG4gICAgICByZXF1ZXN0c0NhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9yZXF1ZXN0cy5mb3JFYWNoKGZ1bmN0aW9uIChyZXF1ZXN0Q2FwYWJpbGl0eSkge1xuICAgICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fcmVxdWVzdHMgPSBbXTtcbiAgICB9XG5cbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcblxuICAgIHRoaXMuX3N0cmVhbS5fcmVtb3ZlUmFuZ2VSZWFkZXIodGhpcyk7XG4gIH1cblxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBpZiAodGhpcy5fcXVldWVkQ2h1bmspIHtcbiAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fcXVldWVkQ2h1bms7XG4gICAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IG51bGw7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5ID0gKDAsIF91dGlsLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KSgpO1xuXG4gICAgdGhpcy5fcmVxdWVzdHMucHVzaChyZXF1ZXN0Q2FwYWJpbGl0eSk7XG5cbiAgICByZXR1cm4gcmVxdWVzdENhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuXG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcblxuICAgIHRoaXMuX3JlcXVlc3RzLmZvckVhY2goZnVuY3Rpb24gKHJlcXVlc3RDYXBhYmlsaXR5KSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9yZXF1ZXN0cyA9IFtdO1xuXG4gICAgdGhpcy5fc3RyZWFtLl9yZW1vdmVSYW5nZVJlYWRlcih0aGlzKTtcbiAgfVxuXG59XG5cbi8qKiovIH0pLFxuLyogMTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuV2ViR0xDb250ZXh0ID0gdm9pZCAwO1xuXG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIpO1xuXG5jbGFzcyBXZWJHTENvbnRleHQge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgZW5hYmxlID0gZmFsc2VcbiAgfSkge1xuICAgIHRoaXMuX2VuYWJsZWQgPSBlbmFibGUgPT09IHRydWU7XG4gIH1cblxuICBnZXQgaXNFbmFibGVkKCkge1xuICAgIGxldCBlbmFibGVkID0gdGhpcy5fZW5hYmxlZDtcblxuICAgIGlmIChlbmFibGVkKSB7XG4gICAgICBlbmFibGVkID0gV2ViR0xVdGlscy50cnlJbml0R0woKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKDAsIF91dGlsLnNoYWRvdykodGhpcywgXCJpc0VuYWJsZWRcIiwgZW5hYmxlZCk7XG4gIH1cblxuICBjb21wb3NlU01hc2soe1xuICAgIGxheWVyLFxuICAgIG1hc2ssXG4gICAgcHJvcGVydGllc1xuICB9KSB7XG4gICAgcmV0dXJuIFdlYkdMVXRpbHMuY29tcG9zZVNNYXNrKGxheWVyLCBtYXNrLCBwcm9wZXJ0aWVzKTtcbiAgfVxuXG4gIGRyYXdGaWd1cmVzKHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgYmFja2dyb3VuZENvbG9yLFxuICAgIGZpZ3VyZXMsXG4gICAgY29udGV4dFxuICB9KSB7XG4gICAgcmV0dXJuIFdlYkdMVXRpbHMuZHJhd0ZpZ3VyZXMod2lkdGgsIGhlaWdodCwgYmFja2dyb3VuZENvbG9yLCBmaWd1cmVzLCBjb250ZXh0KTtcbiAgfVxuXG4gIGNsZWFyKCkge1xuICAgIFdlYkdMVXRpbHMuY2xlYW51cCgpO1xuICB9XG5cbn1cblxuZXhwb3J0cy5XZWJHTENvbnRleHQgPSBXZWJHTENvbnRleHQ7XG5cbnZhciBXZWJHTFV0aWxzID0gZnVuY3Rpb24gV2ViR0xVdGlsc0Nsb3N1cmUoKSB7XG4gIGZ1bmN0aW9uIGxvYWRTaGFkZXIoZ2wsIGNvZGUsIHNoYWRlclR5cGUpIHtcbiAgICB2YXIgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHNoYWRlclR5cGUpO1xuICAgIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIGNvZGUpO1xuICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcbiAgICB2YXIgY29tcGlsZWQgPSBnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUyk7XG5cbiAgICBpZiAoIWNvbXBpbGVkKSB7XG4gICAgICB2YXIgZXJyb3JNc2cgPSBnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBkdXJpbmcgc2hhZGVyIGNvbXBpbGF0aW9uOiBcIiArIGVycm9yTXNnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2hhZGVyO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVmVydGV4U2hhZGVyKGdsLCBjb2RlKSB7XG4gICAgcmV0dXJuIGxvYWRTaGFkZXIoZ2wsIGNvZGUsIGdsLlZFUlRFWF9TSEFERVIpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRnJhZ21lbnRTaGFkZXIoZ2wsIGNvZGUpIHtcbiAgICByZXR1cm4gbG9hZFNoYWRlcihnbCwgY29kZSwgZ2wuRlJBR01FTlRfU0hBREVSKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVByb2dyYW0oZ2wsIHNoYWRlcnMpIHtcbiAgICB2YXIgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHNoYWRlcnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHNoYWRlcnNbaV0pO1xuICAgIH1cblxuICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuICAgIHZhciBsaW5rZWQgPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkxJTktfU1RBVFVTKTtcblxuICAgIGlmICghbGlua2VkKSB7XG4gICAgICB2YXIgZXJyb3JNc2cgPSBnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIGR1cmluZyBwcm9ncmFtIGxpbmtpbmc6IFwiICsgZXJyb3JNc2cpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9ncmFtO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVGV4dHVyZShnbCwgaW1hZ2UsIHRleHR1cmVJZCkge1xuICAgIGdsLmFjdGl2ZVRleHR1cmUodGV4dHVyZUlkKTtcbiAgICB2YXIgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgaW1hZ2UpO1xuICAgIHJldHVybiB0ZXh0dXJlO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRHTCwgY3VycmVudENhbnZhcztcblxuICBmdW5jdGlvbiBnZW5lcmF0ZUdMKCkge1xuICAgIGlmIChjdXJyZW50R0wpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjdXJyZW50Q2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICBjdXJyZW50R0wgPSBjdXJyZW50Q2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbFwiLCB7XG4gICAgICBwcmVtdWx0aXBsaWVkYWxwaGE6IGZhbHNlXG4gICAgfSk7XG4gIH1cblxuICB2YXIgc21hc2tWZXJ0ZXhTaGFkZXJDb2RlID0gXCJcXFxuICBhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gIGF0dHJpYnV0ZSB2ZWMyIGFfdGV4Q29vcmQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICB1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgdmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gIHZvaWQgbWFpbigpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgICB2ZWMyIGNsaXBTcGFjZSA9IChhX3Bvc2l0aW9uIC8gdV9yZXNvbHV0aW9uKSAqIDIuMCAtIDEuMDsgICBcXFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNChjbGlwU3BhY2UgKiB2ZWMyKDEsIC0xKSwgMCwgMSk7ICAgICAgICAgIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgICB2X3RleENvb3JkID0gYV90ZXhDb29yZDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiO1xuICB2YXIgc21hc2tGcmFnbWVudFNoYWRlckNvZGUgPSBcIlxcXG4gIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICB1bmlmb3JtIHZlYzQgdV9iYWNrZHJvcDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gIHVuaWZvcm0gaW50IHVfc3VidHlwZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgdW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICB1bmlmb3JtIHNhbXBsZXIyRCB1X21hc2s7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgdmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gIHZvaWQgbWFpbigpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgICB2ZWM0IGltYWdlQ29sb3IgPSB0ZXh0dXJlMkQodV9pbWFnZSwgdl90ZXhDb29yZCk7ICAgICAgICAgICBcXFxuICAgIHZlYzQgbWFza0NvbG9yID0gdGV4dHVyZTJEKHVfbWFzaywgdl90ZXhDb29yZCk7ICAgICAgICAgICAgIFxcXG4gICAgaWYgKHVfYmFja2Ryb3AuYSA+IDAuMCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgICAgIG1hc2tDb2xvci5yZ2IgPSBtYXNrQ29sb3IucmdiICogbWFza0NvbG9yLmEgKyAgICAgICAgICAgICBcXFxuICAgICAgICAgICAgICAgICAgICAgIHVfYmFja2Ryb3AucmdiICogKDEuMCAtIG1hc2tDb2xvci5hKTsgICAgIFxcXG4gICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgICBmbG9hdCBsdW07ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICAgIGlmICh1X3N1YnR5cGUgPT0gMCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gICAgICBsdW0gPSBtYXNrQ29sb3IuYTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICAgICAgbHVtID0gbWFza0NvbG9yLnIgKiAwLjMgKyBtYXNrQ29sb3IuZyAqIDAuNTkgKyAgICAgICAgICAgIFxcXG4gICAgICAgICAgICBtYXNrQ29sb3IuYiAqIDAuMTE7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICAgIGltYWdlQ29sb3IuYSAqPSBsdW07ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gICAgaW1hZ2VDb2xvci5yZ2IgKj0gaW1hZ2VDb2xvci5hOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgICBnbF9GcmFnQ29sb3IgPSBpbWFnZUNvbG9yOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiO1xuICB2YXIgc21hc2tDYWNoZSA9IG51bGw7XG5cbiAgZnVuY3Rpb24gaW5pdFNtYXNrR0woKSB7XG4gICAgdmFyIGNhbnZhcywgZ2w7XG4gICAgZ2VuZXJhdGVHTCgpO1xuICAgIGNhbnZhcyA9IGN1cnJlbnRDYW52YXM7XG4gICAgY3VycmVudENhbnZhcyA9IG51bGw7XG4gICAgZ2wgPSBjdXJyZW50R0w7XG4gICAgY3VycmVudEdMID0gbnVsbDtcbiAgICB2YXIgdmVydGV4U2hhZGVyID0gY3JlYXRlVmVydGV4U2hhZGVyKGdsLCBzbWFza1ZlcnRleFNoYWRlckNvZGUpO1xuICAgIHZhciBmcmFnbWVudFNoYWRlciA9IGNyZWF0ZUZyYWdtZW50U2hhZGVyKGdsLCBzbWFza0ZyYWdtZW50U2hhZGVyQ29kZSk7XG4gICAgdmFyIHByb2dyYW0gPSBjcmVhdGVQcm9ncmFtKGdsLCBbdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcl0pO1xuICAgIGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgdmFyIGNhY2hlID0ge307XG4gICAgY2FjaGUuZ2wgPSBnbDtcbiAgICBjYWNoZS5jYW52YXMgPSBjYW52YXM7XG4gICAgY2FjaGUucmVzb2x1dGlvbkxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9yZXNvbHV0aW9uXCIpO1xuICAgIGNhY2hlLnBvc2l0aW9uTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBcImFfcG9zaXRpb25cIik7XG4gICAgY2FjaGUuYmFja2Ryb3BMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVfYmFja2Ryb3BcIik7XG4gICAgY2FjaGUuc3VidHlwZUxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9zdWJ0eXBlXCIpO1xuICAgIHZhciB0ZXhDb29yZExvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgXCJhX3RleENvb3JkXCIpO1xuICAgIHZhciB0ZXhMYXllckxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9pbWFnZVwiKTtcbiAgICB2YXIgdGV4TWFza0xvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9tYXNrXCIpO1xuICAgIHZhciB0ZXhDb29yZEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0ZXhDb29yZEJ1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkoWzAuMCwgMC4wLCAxLjAsIDAuMCwgMC4wLCAxLjAsIDAuMCwgMS4wLCAxLjAsIDAuMCwgMS4wLCAxLjBdKSwgZ2wuU1RBVElDX0RSQVcpO1xuICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRleENvb3JkTG9jYXRpb24pO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGV4Q29vcmRMb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAgICBnbC51bmlmb3JtMWkodGV4TGF5ZXJMb2NhdGlvbiwgMCk7XG4gICAgZ2wudW5pZm9ybTFpKHRleE1hc2tMb2NhdGlvbiwgMSk7XG4gICAgc21hc2tDYWNoZSA9IGNhY2hlO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcG9zZVNNYXNrKGxheWVyLCBtYXNrLCBwcm9wZXJ0aWVzKSB7XG4gICAgdmFyIHdpZHRoID0gbGF5ZXIud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IGxheWVyLmhlaWdodDtcblxuICAgIGlmICghc21hc2tDYWNoZSkge1xuICAgICAgaW5pdFNtYXNrR0woKTtcbiAgICB9XG5cbiAgICB2YXIgY2FjaGUgPSBzbWFza0NhY2hlLFxuICAgICAgICBjYW52YXMgPSBjYWNoZS5jYW52YXMsXG4gICAgICAgIGdsID0gY2FjaGUuZ2w7XG4gICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICBnbC52aWV3cG9ydCgwLCAwLCBnbC5kcmF3aW5nQnVmZmVyV2lkdGgsIGdsLmRyYXdpbmdCdWZmZXJIZWlnaHQpO1xuICAgIGdsLnVuaWZvcm0yZihjYWNoZS5yZXNvbHV0aW9uTG9jYXRpb24sIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgaWYgKHByb3BlcnRpZXMuYmFja2Ryb3ApIHtcbiAgICAgIGdsLnVuaWZvcm00ZihjYWNoZS5yZXNvbHV0aW9uTG9jYXRpb24sIHByb3BlcnRpZXMuYmFja2Ryb3BbMF0sIHByb3BlcnRpZXMuYmFja2Ryb3BbMV0sIHByb3BlcnRpZXMuYmFja2Ryb3BbMl0sIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbC51bmlmb3JtNGYoY2FjaGUucmVzb2x1dGlvbkxvY2F0aW9uLCAwLCAwLCAwLCAwKTtcbiAgICB9XG5cbiAgICBnbC51bmlmb3JtMWkoY2FjaGUuc3VidHlwZUxvY2F0aW9uLCBwcm9wZXJ0aWVzLnN1YnR5cGUgPT09IFwiTHVtaW5vc2l0eVwiID8gMSA6IDApO1xuICAgIHZhciB0ZXh0dXJlID0gY3JlYXRlVGV4dHVyZShnbCwgbGF5ZXIsIGdsLlRFWFRVUkUwKTtcbiAgICB2YXIgbWFza1RleHR1cmUgPSBjcmVhdGVUZXh0dXJlKGdsLCBtYXNrLCBnbC5URVhUVVJFMSk7XG4gICAgdmFyIGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCB3aWR0aCwgMCwgMCwgaGVpZ2h0LCAwLCBoZWlnaHQsIHdpZHRoLCAwLCB3aWR0aCwgaGVpZ2h0XSksIGdsLlNUQVRJQ19EUkFXKTtcbiAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShjYWNoZS5wb3NpdGlvbkxvY2F0aW9uKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGNhY2hlLnBvc2l0aW9uTG9jYXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG4gICAgZ2wuY2xlYXJDb2xvcigwLCAwLCAwLCAwKTtcbiAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuICAgIGdsLmJsZW5kRnVuYyhnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xuICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xuICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVTLCAwLCA2KTtcbiAgICBnbC5mbHVzaCgpO1xuICAgIGdsLmRlbGV0ZVRleHR1cmUodGV4dHVyZSk7XG4gICAgZ2wuZGVsZXRlVGV4dHVyZShtYXNrVGV4dHVyZSk7XG4gICAgZ2wuZGVsZXRlQnVmZmVyKGJ1ZmZlcik7XG4gICAgcmV0dXJuIGNhbnZhcztcbiAgfVxuXG4gIHZhciBmaWd1cmVzVmVydGV4U2hhZGVyQ29kZSA9IFwiXFxcbiAgYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvbjsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICBhdHRyaWJ1dGUgdmVjMyBhX2NvbG9yOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgdW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICB1bmlmb3JtIHZlYzIgdV9zY2FsZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gIHVuaWZvcm0gdmVjMiB1X29mZnNldDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICB2YXJ5aW5nIHZlYzQgdl9jb2xvcjsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgdm9pZCBtYWluKCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICAgIHZlYzIgcG9zaXRpb24gPSAoYV9wb3NpdGlvbiArIHVfb2Zmc2V0KSAqIHVfc2NhbGU7ICAgICAgICAgIFxcXG4gICAgdmVjMiBjbGlwU3BhY2UgPSAocG9zaXRpb24gLyB1X3Jlc29sdXRpb24pICogMi4wIC0gMS4wOyAgICAgXFxcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoY2xpcFNwYWNlICogdmVjMigxLCAtMSksIDAsIDEpOyAgICAgICAgICBcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gICAgdl9jb2xvciA9IHZlYzQoYV9jb2xvciAvIDI1NS4wLCAxLjApOyAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjtcbiAgdmFyIGZpZ3VyZXNGcmFnbWVudFNoYWRlckNvZGUgPSBcIlxcXG4gIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICB2YXJ5aW5nIHZlYzQgdl9jb2xvcjsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgdm9pZCBtYWluKCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICAgIGdsX0ZyYWdDb2xvciA9IHZfY29sb3I7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCI7XG4gIHZhciBmaWd1cmVzQ2FjaGUgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIGluaXRGaWd1cmVzR0woKSB7XG4gICAgdmFyIGNhbnZhcywgZ2w7XG4gICAgZ2VuZXJhdGVHTCgpO1xuICAgIGNhbnZhcyA9IGN1cnJlbnRDYW52YXM7XG4gICAgY3VycmVudENhbnZhcyA9IG51bGw7XG4gICAgZ2wgPSBjdXJyZW50R0w7XG4gICAgY3VycmVudEdMID0gbnVsbDtcbiAgICB2YXIgdmVydGV4U2hhZGVyID0gY3JlYXRlVmVydGV4U2hhZGVyKGdsLCBmaWd1cmVzVmVydGV4U2hhZGVyQ29kZSk7XG4gICAgdmFyIGZyYWdtZW50U2hhZGVyID0gY3JlYXRlRnJhZ21lbnRTaGFkZXIoZ2wsIGZpZ3VyZXNGcmFnbWVudFNoYWRlckNvZGUpO1xuICAgIHZhciBwcm9ncmFtID0gY3JlYXRlUHJvZ3JhbShnbCwgW3ZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXJdKTtcbiAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuICAgIHZhciBjYWNoZSA9IHt9O1xuICAgIGNhY2hlLmdsID0gZ2w7XG4gICAgY2FjaGUuY2FudmFzID0gY2FudmFzO1xuICAgIGNhY2hlLnJlc29sdXRpb25Mb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVfcmVzb2x1dGlvblwiKTtcbiAgICBjYWNoZS5zY2FsZUxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9zY2FsZVwiKTtcbiAgICBjYWNoZS5vZmZzZXRMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVfb2Zmc2V0XCIpO1xuICAgIGNhY2hlLnBvc2l0aW9uTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBcImFfcG9zaXRpb25cIik7XG4gICAgY2FjaGUuY29sb3JMb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIFwiYV9jb2xvclwiKTtcbiAgICBmaWd1cmVzQ2FjaGUgPSBjYWNoZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRyYXdGaWd1cmVzKHdpZHRoLCBoZWlnaHQsIGJhY2tncm91bmRDb2xvciwgZmlndXJlcywgY29udGV4dCkge1xuICAgIGlmICghZmlndXJlc0NhY2hlKSB7XG4gICAgICBpbml0RmlndXJlc0dMKCk7XG4gICAgfVxuXG4gICAgdmFyIGNhY2hlID0gZmlndXJlc0NhY2hlLFxuICAgICAgICBjYW52YXMgPSBjYWNoZS5jYW52YXMsXG4gICAgICAgIGdsID0gY2FjaGUuZ2w7XG4gICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICBnbC52aWV3cG9ydCgwLCAwLCBnbC5kcmF3aW5nQnVmZmVyV2lkdGgsIGdsLmRyYXdpbmdCdWZmZXJIZWlnaHQpO1xuICAgIGdsLnVuaWZvcm0yZihjYWNoZS5yZXNvbHV0aW9uTG9jYXRpb24sIHdpZHRoLCBoZWlnaHQpO1xuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIGksIGlpLCByb3dzO1xuXG4gICAgZm9yIChpID0gMCwgaWkgPSBmaWd1cmVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIHN3aXRjaCAoZmlndXJlc1tpXS50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJsYXR0aWNlXCI6XG4gICAgICAgICAgcm93cyA9IGZpZ3VyZXNbaV0uY29vcmRzLmxlbmd0aCAvIGZpZ3VyZXNbaV0udmVydGljZXNQZXJSb3cgfCAwO1xuICAgICAgICAgIGNvdW50ICs9IChyb3dzIC0gMSkgKiAoZmlndXJlc1tpXS52ZXJ0aWNlc1BlclJvdyAtIDEpICogNjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwidHJpYW5nbGVzXCI6XG4gICAgICAgICAgY291bnQgKz0gZmlndXJlc1tpXS5jb29yZHMubGVuZ3RoO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjb29yZHMgPSBuZXcgRmxvYXQzMkFycmF5KGNvdW50ICogMik7XG4gICAgdmFyIGNvbG9ycyA9IG5ldyBVaW50OEFycmF5KGNvdW50ICogMyk7XG4gICAgdmFyIGNvb3Jkc01hcCA9IGNvbnRleHQuY29vcmRzLFxuICAgICAgICBjb2xvcnNNYXAgPSBjb250ZXh0LmNvbG9ycztcbiAgICB2YXIgcEluZGV4ID0gMCxcbiAgICAgICAgY0luZGV4ID0gMDtcblxuICAgIGZvciAoaSA9IDAsIGlpID0gZmlndXJlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICB2YXIgZmlndXJlID0gZmlndXJlc1tpXSxcbiAgICAgICAgICBwcyA9IGZpZ3VyZS5jb29yZHMsXG4gICAgICAgICAgY3MgPSBmaWd1cmUuY29sb3JzO1xuXG4gICAgICBzd2l0Y2ggKGZpZ3VyZS50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJsYXR0aWNlXCI6XG4gICAgICAgICAgdmFyIGNvbHMgPSBmaWd1cmUudmVydGljZXNQZXJSb3c7XG4gICAgICAgICAgcm93cyA9IHBzLmxlbmd0aCAvIGNvbHMgfCAwO1xuXG4gICAgICAgICAgZm9yICh2YXIgcm93ID0gMTsgcm93IDwgcm93czsgcm93KyspIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSByb3cgKiBjb2xzICsgMTtcblxuICAgICAgICAgICAgZm9yICh2YXIgY29sID0gMTsgY29sIDwgY29sczsgY29sKyssIG9mZnNldCsrKSB7XG4gICAgICAgICAgICAgIGNvb3Jkc1twSW5kZXhdID0gY29vcmRzTWFwW3BzW29mZnNldCAtIGNvbHMgLSAxXV07XG4gICAgICAgICAgICAgIGNvb3Jkc1twSW5kZXggKyAxXSA9IGNvb3Jkc01hcFtwc1tvZmZzZXQgLSBjb2xzIC0gMV0gKyAxXTtcbiAgICAgICAgICAgICAgY29vcmRzW3BJbmRleCArIDJdID0gY29vcmRzTWFwW3BzW29mZnNldCAtIGNvbHNdXTtcbiAgICAgICAgICAgICAgY29vcmRzW3BJbmRleCArIDNdID0gY29vcmRzTWFwW3BzW29mZnNldCAtIGNvbHNdICsgMV07XG4gICAgICAgICAgICAgIGNvb3Jkc1twSW5kZXggKyA0XSA9IGNvb3Jkc01hcFtwc1tvZmZzZXQgLSAxXV07XG4gICAgICAgICAgICAgIGNvb3Jkc1twSW5kZXggKyA1XSA9IGNvb3Jkc01hcFtwc1tvZmZzZXQgLSAxXSArIDFdO1xuICAgICAgICAgICAgICBjb2xvcnNbY0luZGV4XSA9IGNvbG9yc01hcFtjc1tvZmZzZXQgLSBjb2xzIC0gMV1dO1xuICAgICAgICAgICAgICBjb2xvcnNbY0luZGV4ICsgMV0gPSBjb2xvcnNNYXBbY3Nbb2Zmc2V0IC0gY29scyAtIDFdICsgMV07XG4gICAgICAgICAgICAgIGNvbG9yc1tjSW5kZXggKyAyXSA9IGNvbG9yc01hcFtjc1tvZmZzZXQgLSBjb2xzIC0gMV0gKyAyXTtcbiAgICAgICAgICAgICAgY29sb3JzW2NJbmRleCArIDNdID0gY29sb3JzTWFwW2NzW29mZnNldCAtIGNvbHNdXTtcbiAgICAgICAgICAgICAgY29sb3JzW2NJbmRleCArIDRdID0gY29sb3JzTWFwW2NzW29mZnNldCAtIGNvbHNdICsgMV07XG4gICAgICAgICAgICAgIGNvbG9yc1tjSW5kZXggKyA1XSA9IGNvbG9yc01hcFtjc1tvZmZzZXQgLSBjb2xzXSArIDJdO1xuICAgICAgICAgICAgICBjb2xvcnNbY0luZGV4ICsgNl0gPSBjb2xvcnNNYXBbY3Nbb2Zmc2V0IC0gMV1dO1xuICAgICAgICAgICAgICBjb2xvcnNbY0luZGV4ICsgN10gPSBjb2xvcnNNYXBbY3Nbb2Zmc2V0IC0gMV0gKyAxXTtcbiAgICAgICAgICAgICAgY29sb3JzW2NJbmRleCArIDhdID0gY29sb3JzTWFwW2NzW29mZnNldCAtIDFdICsgMl07XG4gICAgICAgICAgICAgIGNvb3Jkc1twSW5kZXggKyA2XSA9IGNvb3Jkc1twSW5kZXggKyAyXTtcbiAgICAgICAgICAgICAgY29vcmRzW3BJbmRleCArIDddID0gY29vcmRzW3BJbmRleCArIDNdO1xuICAgICAgICAgICAgICBjb29yZHNbcEluZGV4ICsgOF0gPSBjb29yZHNbcEluZGV4ICsgNF07XG4gICAgICAgICAgICAgIGNvb3Jkc1twSW5kZXggKyA5XSA9IGNvb3Jkc1twSW5kZXggKyA1XTtcbiAgICAgICAgICAgICAgY29vcmRzW3BJbmRleCArIDEwXSA9IGNvb3Jkc01hcFtwc1tvZmZzZXRdXTtcbiAgICAgICAgICAgICAgY29vcmRzW3BJbmRleCArIDExXSA9IGNvb3Jkc01hcFtwc1tvZmZzZXRdICsgMV07XG4gICAgICAgICAgICAgIGNvbG9yc1tjSW5kZXggKyA5XSA9IGNvbG9yc1tjSW5kZXggKyAzXTtcbiAgICAgICAgICAgICAgY29sb3JzW2NJbmRleCArIDEwXSA9IGNvbG9yc1tjSW5kZXggKyA0XTtcbiAgICAgICAgICAgICAgY29sb3JzW2NJbmRleCArIDExXSA9IGNvbG9yc1tjSW5kZXggKyA1XTtcbiAgICAgICAgICAgICAgY29sb3JzW2NJbmRleCArIDEyXSA9IGNvbG9yc1tjSW5kZXggKyA2XTtcbiAgICAgICAgICAgICAgY29sb3JzW2NJbmRleCArIDEzXSA9IGNvbG9yc1tjSW5kZXggKyA3XTtcbiAgICAgICAgICAgICAgY29sb3JzW2NJbmRleCArIDE0XSA9IGNvbG9yc1tjSW5kZXggKyA4XTtcbiAgICAgICAgICAgICAgY29sb3JzW2NJbmRleCArIDE1XSA9IGNvbG9yc01hcFtjc1tvZmZzZXRdXTtcbiAgICAgICAgICAgICAgY29sb3JzW2NJbmRleCArIDE2XSA9IGNvbG9yc01hcFtjc1tvZmZzZXRdICsgMV07XG4gICAgICAgICAgICAgIGNvbG9yc1tjSW5kZXggKyAxN10gPSBjb2xvcnNNYXBbY3Nbb2Zmc2V0XSArIDJdO1xuICAgICAgICAgICAgICBwSW5kZXggKz0gMTI7XG4gICAgICAgICAgICAgIGNJbmRleCArPSAxODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwidHJpYW5nbGVzXCI6XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpqID0gcHMubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgICAgY29vcmRzW3BJbmRleF0gPSBjb29yZHNNYXBbcHNbal1dO1xuICAgICAgICAgICAgY29vcmRzW3BJbmRleCArIDFdID0gY29vcmRzTWFwW3BzW2pdICsgMV07XG4gICAgICAgICAgICBjb2xvcnNbY0luZGV4XSA9IGNvbG9yc01hcFtjc1tqXV07XG4gICAgICAgICAgICBjb2xvcnNbY0luZGV4ICsgMV0gPSBjb2xvcnNNYXBbY3Nbal0gKyAxXTtcbiAgICAgICAgICAgIGNvbG9yc1tjSW5kZXggKyAyXSA9IGNvbG9yc01hcFtjc1tqXSArIDJdO1xuICAgICAgICAgICAgcEluZGV4ICs9IDI7XG4gICAgICAgICAgICBjSW5kZXggKz0gMztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICBnbC5jbGVhckNvbG9yKGJhY2tncm91bmRDb2xvclswXSAvIDI1NSwgYmFja2dyb3VuZENvbG9yWzFdIC8gMjU1LCBiYWNrZ3JvdW5kQ29sb3JbMl0gLyAyNTUsIDEuMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdsLmNsZWFyQ29sb3IoMCwgMCwgMCwgMCk7XG4gICAgfVxuXG4gICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG4gICAgdmFyIGNvb3Jkc0J1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBjb29yZHNCdWZmZXIpO1xuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBjb29yZHMsIGdsLlNUQVRJQ19EUkFXKTtcbiAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShjYWNoZS5wb3NpdGlvbkxvY2F0aW9uKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGNhY2hlLnBvc2l0aW9uTG9jYXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG4gICAgdmFyIGNvbG9yc0J1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBjb2xvcnNCdWZmZXIpO1xuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBjb2xvcnMsIGdsLlNUQVRJQ19EUkFXKTtcbiAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShjYWNoZS5jb2xvckxvY2F0aW9uKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGNhY2hlLmNvbG9yTG9jYXRpb24sIDMsIGdsLlVOU0lHTkVEX0JZVEUsIGZhbHNlLCAwLCAwKTtcbiAgICBnbC51bmlmb3JtMmYoY2FjaGUuc2NhbGVMb2NhdGlvbiwgY29udGV4dC5zY2FsZVgsIGNvbnRleHQuc2NhbGVZKTtcbiAgICBnbC51bmlmb3JtMmYoY2FjaGUub2Zmc2V0TG9jYXRpb24sIGNvbnRleHQub2Zmc2V0WCwgY29udGV4dC5vZmZzZXRZKTtcbiAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFUywgMCwgY291bnQpO1xuICAgIGdsLmZsdXNoKCk7XG4gICAgZ2wuZGVsZXRlQnVmZmVyKGNvb3Jkc0J1ZmZlcik7XG4gICAgZ2wuZGVsZXRlQnVmZmVyKGNvbG9yc0J1ZmZlcik7XG4gICAgcmV0dXJuIGNhbnZhcztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdHJ5SW5pdEdMKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZ2VuZXJhdGVHTCgpO1xuICAgICAgICByZXR1cm4gISFjdXJyZW50R0w7XG4gICAgICB9IGNhdGNoIChleCkge31cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICBjb21wb3NlU01hc2ssXG4gICAgZHJhd0ZpZ3VyZXMsXG5cbiAgICBjbGVhbnVwKCkge1xuICAgICAgaWYgKHNtYXNrQ2FjaGUgJiYgc21hc2tDYWNoZS5jYW52YXMpIHtcbiAgICAgICAgc21hc2tDYWNoZS5jYW52YXMud2lkdGggPSAwO1xuICAgICAgICBzbWFza0NhY2hlLmNhbnZhcy5oZWlnaHQgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmlndXJlc0NhY2hlICYmIGZpZ3VyZXNDYWNoZS5jYW52YXMpIHtcbiAgICAgICAgZmlndXJlc0NhY2hlLmNhbnZhcy53aWR0aCA9IDA7XG4gICAgICAgIGZpZ3VyZXNDYWNoZS5jYW52YXMuaGVpZ2h0ID0gMDtcbiAgICAgIH1cblxuICAgICAgc21hc2tDYWNoZSA9IG51bGw7XG4gICAgICBmaWd1cmVzQ2FjaGUgPSBudWxsO1xuICAgIH1cblxuICB9O1xufSgpO1xuXG4vKioqLyB9KSxcbi8qIDE5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkFubm90YXRpb25MYXllciA9IHZvaWQgMDtcblxudmFyIF9kaXNwbGF5X3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcblxudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygyKTtcblxudmFyIF9hbm5vdGF0aW9uX3N0b3JhZ2UgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDgpO1xuXG5jbGFzcyBBbm5vdGF0aW9uRWxlbWVudEZhY3Rvcnkge1xuICBzdGF0aWMgY3JlYXRlKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBzdWJ0eXBlID0gcGFyYW1ldGVycy5kYXRhLmFubm90YXRpb25UeXBlO1xuXG4gICAgc3dpdGNoIChzdWJ0eXBlKSB7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLkxJTks6XG4gICAgICAgIHJldHVybiBuZXcgTGlua0Fubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuXG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLlRFWFQ6XG4gICAgICAgIHJldHVybiBuZXcgVGV4dEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuXG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLldJREdFVDpcbiAgICAgICAgY29uc3QgZmllbGRUeXBlID0gcGFyYW1ldGVycy5kYXRhLmZpZWxkVHlwZTtcblxuICAgICAgICBzd2l0Y2ggKGZpZWxkVHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJUeFwiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0V2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG5cbiAgICAgICAgICBjYXNlIFwiQnRuXCI6XG4gICAgICAgICAgICBpZiAocGFyYW1ldGVycy5kYXRhLnJhZGlvQnV0dG9uKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgUmFkaW9CdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW1ldGVycy5kYXRhLmNoZWNrQm94KSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgQ2hlY2tib3hXaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQdXNoQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG5cbiAgICAgICAgICBjYXNlIFwiQ2hcIjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hvaWNlV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFdpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuXG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLlBPUFVQOlxuICAgICAgICByZXR1cm4gbmV3IFBvcHVwQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG5cbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuRlJFRVRFWFQ6XG4gICAgICAgIHJldHVybiBuZXcgRnJlZVRleHRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcblxuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5MSU5FOlxuICAgICAgICByZXR1cm4gbmV3IExpbmVBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcblxuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5TUVVBUkU6XG4gICAgICAgIHJldHVybiBuZXcgU3F1YXJlQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG5cbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuQ0lSQ0xFOlxuICAgICAgICByZXR1cm4gbmV3IENpcmNsZUFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuXG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLlBPTFlMSU5FOlxuICAgICAgICByZXR1cm4gbmV3IFBvbHlsaW5lQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG5cbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuQ0FSRVQ6XG4gICAgICAgIHJldHVybiBuZXcgQ2FyZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcblxuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5JTks6XG4gICAgICAgIHJldHVybiBuZXcgSW5rQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG5cbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuUE9MWUdPTjpcbiAgICAgICAgcmV0dXJuIG5ldyBQb2x5Z29uQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG5cbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuSElHSExJR0hUOlxuICAgICAgICByZXR1cm4gbmV3IEhpZ2hsaWdodEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuXG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLlVOREVSTElORTpcbiAgICAgICAgcmV0dXJuIG5ldyBVbmRlcmxpbmVBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcblxuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5TUVVJR0dMWTpcbiAgICAgICAgcmV0dXJuIG5ldyBTcXVpZ2dseUFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuXG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLlNUUklLRU9VVDpcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJpa2VPdXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcblxuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5TVEFNUDpcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFtcEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuXG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLkZJTEVBVFRBQ0hNRU5UOlxuICAgICAgICByZXR1cm4gbmV3IEZpbGVBdHRhY2htZW50QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBuZXcgQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgfVxuICB9XG5cbn1cblxuY2xhc3MgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzLCBpc1JlbmRlcmFibGUgPSBmYWxzZSwgaWdub3JlQm9yZGVyID0gZmFsc2UpIHtcbiAgICB0aGlzLmlzUmVuZGVyYWJsZSA9IGlzUmVuZGVyYWJsZTtcbiAgICB0aGlzLmRhdGEgPSBwYXJhbWV0ZXJzLmRhdGE7XG4gICAgdGhpcy5sYXllciA9IHBhcmFtZXRlcnMubGF5ZXI7XG4gICAgdGhpcy5wYWdlID0gcGFyYW1ldGVycy5wYWdlO1xuICAgIHRoaXMudmlld3BvcnQgPSBwYXJhbWV0ZXJzLnZpZXdwb3J0O1xuICAgIHRoaXMubGlua1NlcnZpY2UgPSBwYXJhbWV0ZXJzLmxpbmtTZXJ2aWNlO1xuICAgIHRoaXMuZG93bmxvYWRNYW5hZ2VyID0gcGFyYW1ldGVycy5kb3dubG9hZE1hbmFnZXI7XG4gICAgdGhpcy5pbWFnZVJlc291cmNlc1BhdGggPSBwYXJhbWV0ZXJzLmltYWdlUmVzb3VyY2VzUGF0aDtcbiAgICB0aGlzLnJlbmRlckludGVyYWN0aXZlRm9ybXMgPSBwYXJhbWV0ZXJzLnJlbmRlckludGVyYWN0aXZlRm9ybXM7XG4gICAgdGhpcy5zdmdGYWN0b3J5ID0gcGFyYW1ldGVycy5zdmdGYWN0b3J5O1xuICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2UgPSBwYXJhbWV0ZXJzLmFubm90YXRpb25TdG9yYWdlO1xuXG4gICAgaWYgKGlzUmVuZGVyYWJsZSkge1xuICAgICAgdGhpcy5jb250YWluZXIgPSB0aGlzLl9jcmVhdGVDb250YWluZXIoaWdub3JlQm9yZGVyKTtcbiAgICB9XG4gIH1cblxuICBfY3JlYXRlQ29udGFpbmVyKGlnbm9yZUJvcmRlciA9IGZhbHNlKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YSxcbiAgICAgICAgICBwYWdlID0gdGhpcy5wYWdlLFxuICAgICAgICAgIHZpZXdwb3J0ID0gdGhpcy52aWV3cG9ydDtcbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2VjdGlvblwiKTtcbiAgICBsZXQgd2lkdGggPSBkYXRhLnJlY3RbMl0gLSBkYXRhLnJlY3RbMF07XG4gICAgbGV0IGhlaWdodCA9IGRhdGEucmVjdFszXSAtIGRhdGEucmVjdFsxXTtcbiAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKFwiZGF0YS1hbm5vdGF0aW9uLWlkXCIsIGRhdGEuaWQpO1xuXG4gICAgY29uc3QgcmVjdCA9IF91dGlsLlV0aWwubm9ybWFsaXplUmVjdChbZGF0YS5yZWN0WzBdLCBwYWdlLnZpZXdbM10gLSBkYXRhLnJlY3RbMV0gKyBwYWdlLnZpZXdbMV0sIGRhdGEucmVjdFsyXSwgcGFnZS52aWV3WzNdIC0gZGF0YS5yZWN0WzNdICsgcGFnZS52aWV3WzFdXSk7XG5cbiAgICBjb250YWluZXIuc3R5bGUudHJhbnNmb3JtID0gYG1hdHJpeCgke3ZpZXdwb3J0LnRyYW5zZm9ybS5qb2luKFwiLFwiKX0pYDtcbiAgICBjb250YWluZXIuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gYC0ke3JlY3RbMF19cHggLSR7cmVjdFsxXX1weGA7XG5cbiAgICBpZiAoIWlnbm9yZUJvcmRlciAmJiBkYXRhLmJvcmRlclN0eWxlLndpZHRoID4gMCkge1xuICAgICAgY29udGFpbmVyLnN0eWxlLmJvcmRlcldpZHRoID0gYCR7ZGF0YS5ib3JkZXJTdHlsZS53aWR0aH1weGA7XG5cbiAgICAgIGlmIChkYXRhLmJvcmRlclN0eWxlLnN0eWxlICE9PSBfdXRpbC5Bbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlLlVOREVSTElORSkge1xuICAgICAgICB3aWR0aCA9IHdpZHRoIC0gMiAqIGRhdGEuYm9yZGVyU3R5bGUud2lkdGg7XG4gICAgICAgIGhlaWdodCA9IGhlaWdodCAtIDIgKiBkYXRhLmJvcmRlclN0eWxlLndpZHRoO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBob3Jpem9udGFsUmFkaXVzID0gZGF0YS5ib3JkZXJTdHlsZS5ob3Jpem9udGFsQ29ybmVyUmFkaXVzO1xuICAgICAgY29uc3QgdmVydGljYWxSYWRpdXMgPSBkYXRhLmJvcmRlclN0eWxlLnZlcnRpY2FsQ29ybmVyUmFkaXVzO1xuXG4gICAgICBpZiAoaG9yaXpvbnRhbFJhZGl1cyA+IDAgfHwgdmVydGljYWxSYWRpdXMgPiAwKSB7XG4gICAgICAgIGNvbnN0IHJhZGl1cyA9IGAke2hvcml6b250YWxSYWRpdXN9cHggLyAke3ZlcnRpY2FsUmFkaXVzfXB4YDtcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLmJvcmRlclJhZGl1cyA9IHJhZGl1cztcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChkYXRhLmJvcmRlclN0eWxlLnN0eWxlKSB7XG4gICAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZS5TT0xJRDpcbiAgICAgICAgICBjb250YWluZXIuc3R5bGUuYm9yZGVyU3R5bGUgPSBcInNvbGlkXCI7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlLkRBU0hFRDpcbiAgICAgICAgICBjb250YWluZXIuc3R5bGUuYm9yZGVyU3R5bGUgPSBcImRhc2hlZFwiO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZS5CRVZFTEVEOlxuICAgICAgICAgICgwLCBfdXRpbC53YXJuKShcIlVuaW1wbGVtZW50ZWQgYm9yZGVyIHN0eWxlOiBiZXZlbGVkXCIpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZS5JTlNFVDpcbiAgICAgICAgICAoMCwgX3V0aWwud2FybikoXCJVbmltcGxlbWVudGVkIGJvcmRlciBzdHlsZTogaW5zZXRcIik7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlLlVOREVSTElORTpcbiAgICAgICAgICBjb250YWluZXIuc3R5bGUuYm9yZGVyQm90dG9tU3R5bGUgPSBcInNvbGlkXCI7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGEuY29sb3IpIHtcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLmJvcmRlckNvbG9yID0gX3V0aWwuVXRpbC5tYWtlQ3NzUmdiKGRhdGEuY29sb3JbMF0gfCAwLCBkYXRhLmNvbG9yWzFdIHwgMCwgZGF0YS5jb2xvclsyXSB8IDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLmJvcmRlcldpZHRoID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb250YWluZXIuc3R5bGUubGVmdCA9IGAke3JlY3RbMF19cHhgO1xuICAgIGNvbnRhaW5lci5zdHlsZS50b3AgPSBgJHtyZWN0WzFdfXB4YDtcbiAgICBjb250YWluZXIuc3R5bGUud2lkdGggPSBgJHt3aWR0aH1weGA7XG4gICAgY29udGFpbmVyLnN0eWxlLmhlaWdodCA9IGAke2hlaWdodH1weGA7XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfVxuXG4gIF9jcmVhdGVQb3B1cChjb250YWluZXIsIHRyaWdnZXIsIGRhdGEpIHtcbiAgICBpZiAoIXRyaWdnZXIpIHtcbiAgICAgIHRyaWdnZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdHJpZ2dlci5zdHlsZS5oZWlnaHQgPSBjb250YWluZXIuc3R5bGUuaGVpZ2h0O1xuICAgICAgdHJpZ2dlci5zdHlsZS53aWR0aCA9IGNvbnRhaW5lci5zdHlsZS53aWR0aDtcbiAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0cmlnZ2VyKTtcbiAgICB9XG5cbiAgICBjb25zdCBwb3B1cEVsZW1lbnQgPSBuZXcgUG9wdXBFbGVtZW50KHtcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIHRyaWdnZXIsXG4gICAgICBjb2xvcjogZGF0YS5jb2xvcixcbiAgICAgIHRpdGxlOiBkYXRhLnRpdGxlLFxuICAgICAgbW9kaWZpY2F0aW9uRGF0ZTogZGF0YS5tb2RpZmljYXRpb25EYXRlLFxuICAgICAgY29udGVudHM6IGRhdGEuY29udGVudHMsXG4gICAgICBoaWRlV3JhcHBlcjogdHJ1ZVxuICAgIH0pO1xuICAgIGNvbnN0IHBvcHVwID0gcG9wdXBFbGVtZW50LnJlbmRlcigpO1xuICAgIHBvcHVwLnN0eWxlLmxlZnQgPSBjb250YWluZXIuc3R5bGUud2lkdGg7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHBvcHVwKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiQWJzdHJhY3QgbWV0aG9kIGBBbm5vdGF0aW9uRWxlbWVudC5yZW5kZXJgIGNhbGxlZFwiKTtcbiAgfVxuXG59XG5cbmNsYXNzIExpbmtBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIGNvbnN0IGlzUmVuZGVyYWJsZSA9ICEhKHBhcmFtZXRlcnMuZGF0YS51cmwgfHwgcGFyYW1ldGVycy5kYXRhLmRlc3QgfHwgcGFyYW1ldGVycy5kYXRhLmFjdGlvbik7XG4gICAgc3VwZXIocGFyYW1ldGVycywgaXNSZW5kZXJhYmxlKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSBcImxpbmtBbm5vdGF0aW9uXCI7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YSxcbiAgICAgIGxpbmtTZXJ2aWNlXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuXG4gICAgaWYgKGRhdGEudXJsKSB7XG4gICAgICAoMCwgX2Rpc3BsYXlfdXRpbHMuYWRkTGlua0F0dHJpYnV0ZXMpKGxpbmssIHtcbiAgICAgICAgdXJsOiBkYXRhLnVybCxcbiAgICAgICAgdGFyZ2V0OiBkYXRhLm5ld1dpbmRvdyA/IF9kaXNwbGF5X3V0aWxzLkxpbmtUYXJnZXQuQkxBTksgOiBsaW5rU2VydmljZS5leHRlcm5hbExpbmtUYXJnZXQsXG4gICAgICAgIHJlbDogbGlua1NlcnZpY2UuZXh0ZXJuYWxMaW5rUmVsLFxuICAgICAgICBlbmFibGVkOiBsaW5rU2VydmljZS5leHRlcm5hbExpbmtFbmFibGVkXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuYWN0aW9uKSB7XG4gICAgICB0aGlzLl9iaW5kTmFtZWRBY3Rpb24obGluaywgZGF0YS5hY3Rpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9iaW5kTGluayhsaW5rLCBkYXRhLmRlc3QpO1xuICAgIH1cblxuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGxpbmspO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuXG4gIF9iaW5kTGluayhsaW5rLCBkZXN0aW5hdGlvbikge1xuICAgIGxpbmsuaHJlZiA9IHRoaXMubGlua1NlcnZpY2UuZ2V0RGVzdGluYXRpb25IYXNoKGRlc3RpbmF0aW9uKTtcblxuICAgIGxpbmsub25jbGljayA9ICgpID0+IHtcbiAgICAgIGlmIChkZXN0aW5hdGlvbikge1xuICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLm5hdmlnYXRlVG8oZGVzdGluYXRpb24pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIGlmIChkZXN0aW5hdGlvbikge1xuICAgICAgbGluay5jbGFzc05hbWUgPSBcImludGVybmFsTGlua1wiO1xuICAgIH1cbiAgfVxuXG4gIF9iaW5kTmFtZWRBY3Rpb24obGluaywgYWN0aW9uKSB7XG4gICAgbGluay5ocmVmID0gdGhpcy5saW5rU2VydmljZS5nZXRBbmNob3JVcmwoXCJcIik7XG5cbiAgICBsaW5rLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV4ZWN1dGVOYW1lZEFjdGlvbihhY3Rpb24pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBsaW5rLmNsYXNzTmFtZSA9IFwiaW50ZXJuYWxMaW5rXCI7XG4gIH1cblxufVxuXG5jbGFzcyBUZXh0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBpc1JlbmRlcmFibGUgPSAhIShwYXJhbWV0ZXJzLmRhdGEuaGFzUG9wdXAgfHwgcGFyYW1ldGVycy5kYXRhLnRpdGxlIHx8IHBhcmFtZXRlcnMuZGF0YS5jb250ZW50cyk7XG4gICAgc3VwZXIocGFyYW1ldGVycywgaXNSZW5kZXJhYmxlKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSBcInRleHRBbm5vdGF0aW9uXCI7XG4gICAgY29uc3QgaW1hZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgIGltYWdlLnN0eWxlLmhlaWdodCA9IHRoaXMuY29udGFpbmVyLnN0eWxlLmhlaWdodDtcbiAgICBpbWFnZS5zdHlsZS53aWR0aCA9IHRoaXMuY29udGFpbmVyLnN0eWxlLndpZHRoO1xuICAgIGltYWdlLnNyYyA9IHRoaXMuaW1hZ2VSZXNvdXJjZXNQYXRoICsgXCJhbm5vdGF0aW9uLVwiICsgdGhpcy5kYXRhLm5hbWUudG9Mb3dlckNhc2UoKSArIFwiLnN2Z1wiO1xuICAgIGltYWdlLmFsdCA9IFwiW3t7dHlwZX19IEFubm90YXRpb25dXCI7XG4gICAgaW1hZ2UuZGF0YXNldC5sMTBuSWQgPSBcInRleHRfYW5ub3RhdGlvbl90eXBlXCI7XG4gICAgaW1hZ2UuZGF0YXNldC5sMTBuQXJncyA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIHR5cGU6IHRoaXMuZGF0YS5uYW1lXG4gICAgfSk7XG5cbiAgICBpZiAoIXRoaXMuZGF0YS5oYXNQb3B1cCkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAodGhpcy5jb250YWluZXIsIGltYWdlLCB0aGlzLmRhdGEpO1xuICAgIH1cblxuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGltYWdlKTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cblxufVxuXG5jbGFzcyBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuXG59XG5cbmNsYXNzIFRleHRXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIFdpZGdldEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIGNvbnN0IGlzUmVuZGVyYWJsZSA9IHBhcmFtZXRlcnMucmVuZGVySW50ZXJhY3RpdmVGb3JtcyB8fCAhcGFyYW1ldGVycy5kYXRhLmhhc0FwcGVhcmFuY2UgJiYgISFwYXJhbWV0ZXJzLmRhdGEuZmllbGRWYWx1ZTtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCBpc1JlbmRlcmFibGUpO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IFRFWFRfQUxJR05NRU5UID0gW1wibGVmdFwiLCBcImNlbnRlclwiLCBcInJpZ2h0XCJdO1xuICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIGNvbnN0IGlkID0gdGhpcy5kYXRhLmlkO1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IFwidGV4dFdpZGdldEFubm90YXRpb25cIjtcbiAgICBsZXQgZWxlbWVudCA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5yZW5kZXJJbnRlcmFjdGl2ZUZvcm1zKSB7XG4gICAgICBjb25zdCB0ZXh0Q29udGVudCA9IHN0b3JhZ2UuZ2V0T3JDcmVhdGVWYWx1ZShpZCwgdGhpcy5kYXRhLmZpZWxkVmFsdWUpO1xuXG4gICAgICBpZiAodGhpcy5kYXRhLm11bHRpTGluZSkge1xuICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIpO1xuICAgICAgICBlbGVtZW50LnRleHRDb250ZW50ID0gdGV4dENvbnRlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgICBlbGVtZW50LnR5cGUgPSBcInRleHRcIjtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLCB0ZXh0Q29udGVudCk7XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCBldmVudC50YXJnZXQudmFsdWUpO1xuICAgICAgfSk7XG4gICAgICBlbGVtZW50LmRpc2FibGVkID0gdGhpcy5kYXRhLnJlYWRPbmx5O1xuICAgICAgZWxlbWVudC5uYW1lID0gdGhpcy5kYXRhLmZpZWxkTmFtZTtcblxuICAgICAgaWYgKHRoaXMuZGF0YS5tYXhMZW4gIT09IG51bGwpIHtcbiAgICAgICAgZWxlbWVudC5tYXhMZW5ndGggPSB0aGlzLmRhdGEubWF4TGVuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5kYXRhLmNvbWIpIHtcbiAgICAgICAgY29uc3QgZmllbGRXaWR0aCA9IHRoaXMuZGF0YS5yZWN0WzJdIC0gdGhpcy5kYXRhLnJlY3RbMF07XG4gICAgICAgIGNvbnN0IGNvbWJXaWR0aCA9IGZpZWxkV2lkdGggLyB0aGlzLmRhdGEubWF4TGVuO1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJjb21iXCIpO1xuICAgICAgICBlbGVtZW50LnN0eWxlLmxldHRlclNwYWNpbmcgPSBgY2FsYygke2NvbWJXaWR0aH1weCAtIDFjaClgO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGVsZW1lbnQudGV4dENvbnRlbnQgPSB0aGlzLmRhdGEuZmllbGRWYWx1ZTtcbiAgICAgIGVsZW1lbnQuc3R5bGUudmVydGljYWxBbGlnbiA9IFwibWlkZGxlXCI7XG4gICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcInRhYmxlLWNlbGxcIjtcbiAgICAgIGxldCBmb250ID0gbnVsbDtcblxuICAgICAgaWYgKHRoaXMuZGF0YS5mb250UmVmTmFtZSAmJiB0aGlzLnBhZ2UuY29tbW9uT2Jqcy5oYXModGhpcy5kYXRhLmZvbnRSZWZOYW1lKSkge1xuICAgICAgICBmb250ID0gdGhpcy5wYWdlLmNvbW1vbk9ianMuZ2V0KHRoaXMuZGF0YS5mb250UmVmTmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3NldFRleHRTdHlsZShlbGVtZW50LCBmb250KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5kYXRhLnRleHRBbGlnbm1lbnQgIT09IG51bGwpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUudGV4dEFsaWduID0gVEVYVF9BTElHTk1FTlRbdGhpcy5kYXRhLnRleHRBbGlnbm1lbnRdO1xuICAgIH1cblxuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuXG4gIF9zZXRUZXh0U3R5bGUoZWxlbWVudCwgZm9udCkge1xuICAgIGNvbnN0IHN0eWxlID0gZWxlbWVudC5zdHlsZTtcbiAgICBzdHlsZS5mb250U2l6ZSA9IGAke3RoaXMuZGF0YS5mb250U2l6ZX1weGA7XG4gICAgc3R5bGUuZGlyZWN0aW9uID0gdGhpcy5kYXRhLmZvbnREaXJlY3Rpb24gPCAwID8gXCJydGxcIiA6IFwibHRyXCI7XG5cbiAgICBpZiAoIWZvbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgYm9sZCA9IFwibm9ybWFsXCI7XG5cbiAgICBpZiAoZm9udC5ibGFjaykge1xuICAgICAgYm9sZCA9IFwiOTAwXCI7XG4gICAgfSBlbHNlIGlmIChmb250LmJvbGQpIHtcbiAgICAgIGJvbGQgPSBcImJvbGRcIjtcbiAgICB9XG5cbiAgICBzdHlsZS5mb250V2VpZ2h0ID0gYm9sZDtcbiAgICBzdHlsZS5mb250U3R5bGUgPSBmb250Lml0YWxpYyA/IFwiaXRhbGljXCIgOiBcIm5vcm1hbFwiO1xuICAgIGNvbnN0IGZvbnRGYW1pbHkgPSBmb250LmxvYWRlZE5hbWUgPyBgXCIke2ZvbnQubG9hZGVkTmFtZX1cIiwgYCA6IFwiXCI7XG4gICAgY29uc3QgZmFsbGJhY2tOYW1lID0gZm9udC5mYWxsYmFja05hbWUgfHwgXCJIZWx2ZXRpY2EsIHNhbnMtc2VyaWZcIjtcbiAgICBzdHlsZS5mb250RmFtaWx5ID0gZm9udEZhbWlseSArIGZhbGxiYWNrTmFtZTtcbiAgfVxuXG59XG5cbmNsYXNzIENoZWNrYm94V2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCBwYXJhbWV0ZXJzLnJlbmRlckludGVyYWN0aXZlRm9ybXMpO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgY29uc3QgaWQgPSBkYXRhLmlkO1xuICAgIGNvbnN0IHZhbHVlID0gc3RvcmFnZS5nZXRPckNyZWF0ZVZhbHVlKGlkLCBkYXRhLmZpZWxkVmFsdWUgJiYgZGF0YS5maWVsZFZhbHVlICE9PSBcIk9mZlwiKTtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSBcImJ1dHRvbldpZGdldEFubm90YXRpb24gY2hlY2tCb3hcIjtcbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgIGVsZW1lbnQuZGlzYWJsZWQgPSBkYXRhLnJlYWRPbmx5O1xuICAgIGVsZW1lbnQudHlwZSA9IFwiY2hlY2tib3hcIjtcbiAgICBlbGVtZW50Lm5hbWUgPSB0aGlzLmRhdGEuZmllbGROYW1lO1xuXG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImNoZWNrZWRcIiwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwgZXZlbnQudGFyZ2V0LmNoZWNrZWQpO1xuICAgIH0pO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuXG59XG5cbmNsYXNzIFJhZGlvQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCBwYXJhbWV0ZXJzLnJlbmRlckludGVyYWN0aXZlRm9ybXMpO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IFwiYnV0dG9uV2lkZ2V0QW5ub3RhdGlvbiByYWRpb0J1dHRvblwiO1xuICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgY29uc3QgaWQgPSBkYXRhLmlkO1xuICAgIGNvbnN0IHZhbHVlID0gc3RvcmFnZS5nZXRPckNyZWF0ZVZhbHVlKGlkLCBkYXRhLmZpZWxkVmFsdWUgPT09IGRhdGEuYnV0dG9uVmFsdWUpO1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgZWxlbWVudC5kaXNhYmxlZCA9IGRhdGEucmVhZE9ubHk7XG4gICAgZWxlbWVudC50eXBlID0gXCJyYWRpb1wiO1xuICAgIGVsZW1lbnQubmFtZSA9IGRhdGEuZmllbGROYW1lO1xuXG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImNoZWNrZWRcIiwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgY29uc3QgbmFtZSA9IGV2ZW50LnRhcmdldC5uYW1lO1xuXG4gICAgICBmb3IgKGNvbnN0IHJhZGlvIG9mIGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKG5hbWUpKSB7XG4gICAgICAgIGlmIChyYWRpbyAhPT0gZXZlbnQudGFyZ2V0KSB7XG4gICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShyYWRpby5wYXJlbnROb2RlLmdldEF0dHJpYnV0ZShcImRhdGEtYW5ub3RhdGlvbi1pZFwiKSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIGV2ZW50LnRhcmdldC5jaGVja2VkKTtcbiAgICB9KTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cblxufVxuXG5jbGFzcyBQdXNoQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBMaW5rQW5ub3RhdGlvbkVsZW1lbnQge1xuICByZW5kZXIoKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gc3VwZXIucmVuZGVyKCk7XG4gICAgY29udGFpbmVyLmNsYXNzTmFtZSA9IFwiYnV0dG9uV2lkZ2V0QW5ub3RhdGlvbiBwdXNoQnV0dG9uXCI7XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfVxuXG59XG5cbmNsYXNzIENob2ljZVdpZGdldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywgcGFyYW1ldGVycy5yZW5kZXJJbnRlcmFjdGl2ZUZvcm1zKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSBcImNob2ljZVdpZGdldEFubm90YXRpb25cIjtcbiAgICBjb25zdCBzdG9yYWdlID0gdGhpcy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICBjb25zdCBpZCA9IHRoaXMuZGF0YS5pZDtcbiAgICBzdG9yYWdlLmdldE9yQ3JlYXRlVmFsdWUoaWQsIHRoaXMuZGF0YS5maWVsZFZhbHVlLmxlbmd0aCA+IDAgPyB0aGlzLmRhdGEuZmllbGRWYWx1ZVswXSA6IG51bGwpO1xuICAgIGNvbnN0IHNlbGVjdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIpO1xuICAgIHNlbGVjdEVsZW1lbnQuZGlzYWJsZWQgPSB0aGlzLmRhdGEucmVhZE9ubHk7XG4gICAgc2VsZWN0RWxlbWVudC5uYW1lID0gdGhpcy5kYXRhLmZpZWxkTmFtZTtcblxuICAgIGlmICghdGhpcy5kYXRhLmNvbWJvKSB7XG4gICAgICBzZWxlY3RFbGVtZW50LnNpemUgPSB0aGlzLmRhdGEub3B0aW9ucy5sZW5ndGg7XG5cbiAgICAgIGlmICh0aGlzLmRhdGEubXVsdGlTZWxlY3QpIHtcbiAgICAgICAgc2VsZWN0RWxlbWVudC5tdWx0aXBsZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBvcHRpb24gb2YgdGhpcy5kYXRhLm9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IG9wdGlvbkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgb3B0aW9uRWxlbWVudC50ZXh0Q29udGVudCA9IG9wdGlvbi5kaXNwbGF5VmFsdWU7XG4gICAgICBvcHRpb25FbGVtZW50LnZhbHVlID0gb3B0aW9uLmV4cG9ydFZhbHVlO1xuXG4gICAgICBpZiAodGhpcy5kYXRhLmZpZWxkVmFsdWUuaW5jbHVkZXMob3B0aW9uLmV4cG9ydFZhbHVlKSkge1xuICAgICAgICBvcHRpb25FbGVtZW50LnNldEF0dHJpYnV0ZShcInNlbGVjdGVkXCIsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBzZWxlY3RFbGVtZW50LmFwcGVuZENoaWxkKG9wdGlvbkVsZW1lbnQpO1xuICAgIH1cblxuICAgIHNlbGVjdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IGV2ZW50LnRhcmdldC5vcHRpb25zO1xuICAgICAgY29uc3QgdmFsdWUgPSBvcHRpb25zW29wdGlvbnMuc2VsZWN0ZWRJbmRleF0udmFsdWU7XG4gICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB2YWx1ZSk7XG4gICAgfSk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoc2VsZWN0RWxlbWVudCk7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG5cbn1cblxuY2xhc3MgUG9wdXBBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIGNvbnN0IGlzUmVuZGVyYWJsZSA9ICEhKHBhcmFtZXRlcnMuZGF0YS50aXRsZSB8fCBwYXJhbWV0ZXJzLmRhdGEuY29udGVudHMpO1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIGlzUmVuZGVyYWJsZSk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgSUdOT1JFX1RZUEVTID0gW1wiTGluZVwiLCBcIlNxdWFyZVwiLCBcIkNpcmNsZVwiLCBcIlBvbHlMaW5lXCIsIFwiUG9seWdvblwiLCBcIklua1wiXTtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSBcInBvcHVwQW5ub3RhdGlvblwiO1xuXG4gICAgaWYgKElHTk9SRV9UWVBFUy5pbmNsdWRlcyh0aGlzLmRhdGEucGFyZW50VHlwZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgICB9XG5cbiAgICBjb25zdCBzZWxlY3RvciA9IGBbZGF0YS1hbm5vdGF0aW9uLWlkPVwiJHt0aGlzLmRhdGEucGFyZW50SWR9XCJdYDtcbiAgICBjb25zdCBwYXJlbnRFbGVtZW50ID0gdGhpcy5sYXllci5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcblxuICAgIGlmICghcGFyZW50RWxlbWVudCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICAgIH1cblxuICAgIGNvbnN0IHBvcHVwID0gbmV3IFBvcHVwRWxlbWVudCh7XG4gICAgICBjb250YWluZXI6IHRoaXMuY29udGFpbmVyLFxuICAgICAgdHJpZ2dlcjogcGFyZW50RWxlbWVudCxcbiAgICAgIGNvbG9yOiB0aGlzLmRhdGEuY29sb3IsXG4gICAgICB0aXRsZTogdGhpcy5kYXRhLnRpdGxlLFxuICAgICAgbW9kaWZpY2F0aW9uRGF0ZTogdGhpcy5kYXRhLm1vZGlmaWNhdGlvbkRhdGUsXG4gICAgICBjb250ZW50czogdGhpcy5kYXRhLmNvbnRlbnRzXG4gICAgfSk7XG4gICAgY29uc3QgcGFyZW50TGVmdCA9IHBhcnNlRmxvYXQocGFyZW50RWxlbWVudC5zdHlsZS5sZWZ0KTtcbiAgICBjb25zdCBwYXJlbnRXaWR0aCA9IHBhcnNlRmxvYXQocGFyZW50RWxlbWVudC5zdHlsZS53aWR0aCk7XG4gICAgdGhpcy5jb250YWluZXIuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gYC0ke3BhcmVudExlZnQgKyBwYXJlbnRXaWR0aH1weCAtJHtwYXJlbnRFbGVtZW50LnN0eWxlLnRvcH1gO1xuICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmxlZnQgPSBgJHtwYXJlbnRMZWZ0ICsgcGFyZW50V2lkdGh9cHhgO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHBvcHVwLnJlbmRlcigpKTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cblxufVxuXG5jbGFzcyBQb3B1cEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgdGhpcy5jb250YWluZXIgPSBwYXJhbWV0ZXJzLmNvbnRhaW5lcjtcbiAgICB0aGlzLnRyaWdnZXIgPSBwYXJhbWV0ZXJzLnRyaWdnZXI7XG4gICAgdGhpcy5jb2xvciA9IHBhcmFtZXRlcnMuY29sb3I7XG4gICAgdGhpcy50aXRsZSA9IHBhcmFtZXRlcnMudGl0bGU7XG4gICAgdGhpcy5tb2RpZmljYXRpb25EYXRlID0gcGFyYW1ldGVycy5tb2RpZmljYXRpb25EYXRlO1xuICAgIHRoaXMuY29udGVudHMgPSBwYXJhbWV0ZXJzLmNvbnRlbnRzO1xuICAgIHRoaXMuaGlkZVdyYXBwZXIgPSBwYXJhbWV0ZXJzLmhpZGVXcmFwcGVyIHx8IGZhbHNlO1xuICAgIHRoaXMucGlubmVkID0gZmFsc2U7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgQkFDS0dST1VORF9FTkxJR0hUID0gMC43O1xuICAgIGNvbnN0IHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHdyYXBwZXIuY2xhc3NOYW1lID0gXCJwb3B1cFdyYXBwZXJcIjtcbiAgICB0aGlzLmhpZGVFbGVtZW50ID0gdGhpcy5oaWRlV3JhcHBlciA/IHdyYXBwZXIgOiB0aGlzLmNvbnRhaW5lcjtcbiAgICB0aGlzLmhpZGVFbGVtZW50LnNldEF0dHJpYnV0ZShcImhpZGRlblwiLCB0cnVlKTtcbiAgICBjb25zdCBwb3B1cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgcG9wdXAuY2xhc3NOYW1lID0gXCJwb3B1cFwiO1xuICAgIGNvbnN0IGNvbG9yID0gdGhpcy5jb2xvcjtcblxuICAgIGlmIChjb2xvcikge1xuICAgICAgY29uc3QgciA9IEJBQ0tHUk9VTkRfRU5MSUdIVCAqICgyNTUgLSBjb2xvclswXSkgKyBjb2xvclswXTtcbiAgICAgIGNvbnN0IGcgPSBCQUNLR1JPVU5EX0VOTElHSFQgKiAoMjU1IC0gY29sb3JbMV0pICsgY29sb3JbMV07XG4gICAgICBjb25zdCBiID0gQkFDS0dST1VORF9FTkxJR0hUICogKDI1NSAtIGNvbG9yWzJdKSArIGNvbG9yWzJdO1xuICAgICAgcG9wdXAuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gX3V0aWwuVXRpbC5tYWtlQ3NzUmdiKHIgfCAwLCBnIHwgMCwgYiB8IDApO1xuICAgIH1cblxuICAgIGNvbnN0IHRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImgxXCIpO1xuICAgIHRpdGxlLnRleHRDb250ZW50ID0gdGhpcy50aXRsZTtcbiAgICBwb3B1cC5hcHBlbmRDaGlsZCh0aXRsZSk7XG5cbiAgICBjb25zdCBkYXRlT2JqZWN0ID0gX2Rpc3BsYXlfdXRpbHMuUERGRGF0ZVN0cmluZy50b0RhdGVPYmplY3QodGhpcy5tb2RpZmljYXRpb25EYXRlKTtcblxuICAgIGlmIChkYXRlT2JqZWN0KSB7XG4gICAgICBjb25zdCBtb2RpZmljYXRpb25EYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICBtb2RpZmljYXRpb25EYXRlLnRleHRDb250ZW50ID0gXCJ7e2RhdGV9fSwge3t0aW1lfX1cIjtcbiAgICAgIG1vZGlmaWNhdGlvbkRhdGUuZGF0YXNldC5sMTBuSWQgPSBcImFubm90YXRpb25fZGF0ZV9zdHJpbmdcIjtcbiAgICAgIG1vZGlmaWNhdGlvbkRhdGUuZGF0YXNldC5sMTBuQXJncyA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgZGF0ZTogZGF0ZU9iamVjdC50b0xvY2FsZURhdGVTdHJpbmcoKSxcbiAgICAgICAgdGltZTogZGF0ZU9iamVjdC50b0xvY2FsZVRpbWVTdHJpbmcoKVxuICAgICAgfSk7XG4gICAgICBwb3B1cC5hcHBlbmRDaGlsZChtb2RpZmljYXRpb25EYXRlKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb250ZW50cyA9IHRoaXMuX2Zvcm1hdENvbnRlbnRzKHRoaXMuY29udGVudHMpO1xuXG4gICAgcG9wdXAuYXBwZW5kQ2hpbGQoY29udGVudHMpO1xuICAgIHRoaXMudHJpZ2dlci5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fdG9nZ2xlLmJpbmQodGhpcykpO1xuICAgIHRoaXMudHJpZ2dlci5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdmVyXCIsIHRoaXMuX3Nob3cuYmluZCh0aGlzLCBmYWxzZSkpO1xuICAgIHRoaXMudHJpZ2dlci5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdXRcIiwgdGhpcy5faGlkZS5iaW5kKHRoaXMsIGZhbHNlKSk7XG4gICAgcG9wdXAuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2hpZGUuYmluZCh0aGlzLCB0cnVlKSk7XG4gICAgd3JhcHBlci5hcHBlbmRDaGlsZChwb3B1cCk7XG4gICAgcmV0dXJuIHdyYXBwZXI7XG4gIH1cblxuICBfZm9ybWF0Q29udGVudHMoY29udGVudHMpIHtcbiAgICBjb25zdCBwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIik7XG4gICAgY29uc3QgbGluZXMgPSBjb250ZW50cy5zcGxpdCgvKD86XFxyXFxuP3xcXG4pLyk7XG5cbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBsaW5lcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBjb25zdCBsaW5lID0gbGluZXNbaV07XG4gICAgICBwLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxpbmUpKTtcblxuICAgICAgaWYgKGkgPCBpaSAtIDEpIHtcbiAgICAgICAgcC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIikpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwO1xuICB9XG5cbiAgX3RvZ2dsZSgpIHtcbiAgICBpZiAodGhpcy5waW5uZWQpIHtcbiAgICAgIHRoaXMuX2hpZGUodHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Nob3codHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgX3Nob3cocGluID0gZmFsc2UpIHtcbiAgICBpZiAocGluKSB7XG4gICAgICB0aGlzLnBpbm5lZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGlkZUVsZW1lbnQuaGFzQXR0cmlidXRlKFwiaGlkZGVuXCIpKSB7XG4gICAgICB0aGlzLmhpZGVFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImhpZGRlblwiKTtcbiAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLnpJbmRleCArPSAxO1xuICAgIH1cbiAgfVxuXG4gIF9oaWRlKHVucGluID0gdHJ1ZSkge1xuICAgIGlmICh1bnBpbikge1xuICAgICAgdGhpcy5waW5uZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaGlkZUVsZW1lbnQuaGFzQXR0cmlidXRlKFwiaGlkZGVuXCIpICYmICF0aGlzLnBpbm5lZCkge1xuICAgICAgdGhpcy5oaWRlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJoaWRkZW5cIiwgdHJ1ZSk7XG4gICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS56SW5kZXggLT0gMTtcbiAgICB9XG4gIH1cblxufVxuXG5jbGFzcyBGcmVlVGV4dEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgaXNSZW5kZXJhYmxlID0gISEocGFyYW1ldGVycy5kYXRhLmhhc1BvcHVwIHx8IHBhcmFtZXRlcnMuZGF0YS50aXRsZSB8fCBwYXJhbWV0ZXJzLmRhdGEuY29udGVudHMpO1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIGlzUmVuZGVyYWJsZSwgdHJ1ZSk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NOYW1lID0gXCJmcmVlVGV4dEFubm90YXRpb25cIjtcblxuICAgIGlmICghdGhpcy5kYXRhLmhhc1BvcHVwKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCh0aGlzLmNvbnRhaW5lciwgbnVsbCwgdGhpcy5kYXRhKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cblxufVxuXG5jbGFzcyBMaW5lQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBpc1JlbmRlcmFibGUgPSAhIShwYXJhbWV0ZXJzLmRhdGEuaGFzUG9wdXAgfHwgcGFyYW1ldGVycy5kYXRhLnRpdGxlIHx8IHBhcmFtZXRlcnMuZGF0YS5jb250ZW50cyk7XG4gICAgc3VwZXIocGFyYW1ldGVycywgaXNSZW5kZXJhYmxlLCB0cnVlKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSBcImxpbmVBbm5vdGF0aW9uXCI7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBjb25zdCB3aWR0aCA9IGRhdGEucmVjdFsyXSAtIGRhdGEucmVjdFswXTtcbiAgICBjb25zdCBoZWlnaHQgPSBkYXRhLnJlY3RbM10gLSBkYXRhLnJlY3RbMV07XG4gICAgY29uc3Qgc3ZnID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb25zdCBsaW5lID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6bGluZVwiKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZShcIngxXCIsIGRhdGEucmVjdFsyXSAtIGRhdGEubGluZUNvb3JkaW5hdGVzWzBdKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZShcInkxXCIsIGRhdGEucmVjdFszXSAtIGRhdGEubGluZUNvb3JkaW5hdGVzWzFdKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZShcIngyXCIsIGRhdGEucmVjdFsyXSAtIGRhdGEubGluZUNvb3JkaW5hdGVzWzJdKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZShcInkyXCIsIGRhdGEucmVjdFszXSAtIGRhdGEubGluZUNvb3JkaW5hdGVzWzNdKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBkYXRhLmJvcmRlclN0eWxlLndpZHRoIHx8IDEpO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgc3ZnLmFwcGVuZENoaWxkKGxpbmUpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzdmcpO1xuXG4gICAgdGhpcy5fY3JlYXRlUG9wdXAodGhpcy5jb250YWluZXIsIGxpbmUsIGRhdGEpO1xuXG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG5cbn1cblxuY2xhc3MgU3F1YXJlQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBpc1JlbmRlcmFibGUgPSAhIShwYXJhbWV0ZXJzLmRhdGEuaGFzUG9wdXAgfHwgcGFyYW1ldGVycy5kYXRhLnRpdGxlIHx8IHBhcmFtZXRlcnMuZGF0YS5jb250ZW50cyk7XG4gICAgc3VwZXIocGFyYW1ldGVycywgaXNSZW5kZXJhYmxlLCB0cnVlKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSBcInNxdWFyZUFubm90YXRpb25cIjtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xuICAgIGNvbnN0IHdpZHRoID0gZGF0YS5yZWN0WzJdIC0gZGF0YS5yZWN0WzBdO1xuICAgIGNvbnN0IGhlaWdodCA9IGRhdGEucmVjdFszXSAtIGRhdGEucmVjdFsxXTtcbiAgICBjb25zdCBzdmcgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlKHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnN0IGJvcmRlcldpZHRoID0gZGF0YS5ib3JkZXJTdHlsZS53aWR0aDtcbiAgICBjb25zdCBzcXVhcmUgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpyZWN0XCIpO1xuICAgIHNxdWFyZS5zZXRBdHRyaWJ1dGUoXCJ4XCIsIGJvcmRlcldpZHRoIC8gMik7XG4gICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcInlcIiwgYm9yZGVyV2lkdGggLyAyKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgd2lkdGggLSBib3JkZXJXaWR0aCk7XG4gICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBoZWlnaHQgLSBib3JkZXJXaWR0aCk7XG4gICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBib3JkZXJXaWR0aCB8fCAxKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJub25lXCIpO1xuICAgIHN2Zy5hcHBlbmRDaGlsZChzcXVhcmUpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzdmcpO1xuXG4gICAgdGhpcy5fY3JlYXRlUG9wdXAodGhpcy5jb250YWluZXIsIHNxdWFyZSwgZGF0YSk7XG5cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cblxufVxuXG5jbGFzcyBDaXJjbGVBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIGNvbnN0IGlzUmVuZGVyYWJsZSA9ICEhKHBhcmFtZXRlcnMuZGF0YS5oYXNQb3B1cCB8fCBwYXJhbWV0ZXJzLmRhdGEudGl0bGUgfHwgcGFyYW1ldGVycy5kYXRhLmNvbnRlbnRzKTtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCBpc1JlbmRlcmFibGUsIHRydWUpO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IFwiY2lyY2xlQW5ub3RhdGlvblwiO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgY29uc3Qgd2lkdGggPSBkYXRhLnJlY3RbMl0gLSBkYXRhLnJlY3RbMF07XG4gICAgY29uc3QgaGVpZ2h0ID0gZGF0YS5yZWN0WzNdIC0gZGF0YS5yZWN0WzFdO1xuICAgIGNvbnN0IHN2ZyA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGUod2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3QgYm9yZGVyV2lkdGggPSBkYXRhLmJvcmRlclN0eWxlLndpZHRoO1xuICAgIGNvbnN0IGNpcmNsZSA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOmVsbGlwc2VcIik7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcImN4XCIsIHdpZHRoIC8gMik7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcImN5XCIsIGhlaWdodCAvIDIpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJyeFwiLCB3aWR0aCAvIDIgLSBib3JkZXJXaWR0aCAvIDIpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJyeVwiLCBoZWlnaHQgLyAyIC0gYm9yZGVyV2lkdGggLyAyKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIGJvcmRlcldpZHRoIHx8IDEpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcIm5vbmVcIik7XG4gICAgc3ZnLmFwcGVuZENoaWxkKGNpcmNsZSk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHN2Zyk7XG5cbiAgICB0aGlzLl9jcmVhdGVQb3B1cCh0aGlzLmNvbnRhaW5lciwgY2lyY2xlLCBkYXRhKTtcblxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuXG59XG5cbmNsYXNzIFBvbHlsaW5lQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBpc1JlbmRlcmFibGUgPSAhIShwYXJhbWV0ZXJzLmRhdGEuaGFzUG9wdXAgfHwgcGFyYW1ldGVycy5kYXRhLnRpdGxlIHx8IHBhcmFtZXRlcnMuZGF0YS5jb250ZW50cyk7XG4gICAgc3VwZXIocGFyYW1ldGVycywgaXNSZW5kZXJhYmxlLCB0cnVlKTtcbiAgICB0aGlzLmNvbnRhaW5lckNsYXNzTmFtZSA9IFwicG9seWxpbmVBbm5vdGF0aW9uXCI7XG4gICAgdGhpcy5zdmdFbGVtZW50TmFtZSA9IFwic3ZnOnBvbHlsaW5lXCI7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NOYW1lID0gdGhpcy5jb250YWluZXJDbGFzc05hbWU7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBjb25zdCB3aWR0aCA9IGRhdGEucmVjdFsyXSAtIGRhdGEucmVjdFswXTtcbiAgICBjb25zdCBoZWlnaHQgPSBkYXRhLnJlY3RbM10gLSBkYXRhLnJlY3RbMV07XG4gICAgY29uc3Qgc3ZnID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICBsZXQgcG9pbnRzID0gW107XG5cbiAgICBmb3IgKGNvbnN0IGNvb3JkaW5hdGUgb2YgZGF0YS52ZXJ0aWNlcykge1xuICAgICAgY29uc3QgeCA9IGNvb3JkaW5hdGUueCAtIGRhdGEucmVjdFswXTtcbiAgICAgIGNvbnN0IHkgPSBkYXRhLnJlY3RbM10gLSBjb29yZGluYXRlLnk7XG4gICAgICBwb2ludHMucHVzaCh4ICsgXCIsXCIgKyB5KTtcbiAgICB9XG5cbiAgICBwb2ludHMgPSBwb2ludHMuam9pbihcIiBcIik7XG4gICAgY29uc3QgcG9seWxpbmUgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudCh0aGlzLnN2Z0VsZW1lbnROYW1lKTtcbiAgICBwb2x5bGluZS5zZXRBdHRyaWJ1dGUoXCJwb2ludHNcIiwgcG9pbnRzKTtcbiAgICBwb2x5bGluZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgZGF0YS5ib3JkZXJTdHlsZS53aWR0aCB8fCAxKTtcbiAgICBwb2x5bGluZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBwb2x5bGluZS5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwibm9uZVwiKTtcbiAgICBzdmcuYXBwZW5kQ2hpbGQocG9seWxpbmUpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzdmcpO1xuXG4gICAgdGhpcy5fY3JlYXRlUG9wdXAodGhpcy5jb250YWluZXIsIHBvbHlsaW5lLCBkYXRhKTtcblxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuXG59XG5cbmNsYXNzIFBvbHlnb25Bbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIFBvbHlsaW5lQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycyk7XG4gICAgdGhpcy5jb250YWluZXJDbGFzc05hbWUgPSBcInBvbHlnb25Bbm5vdGF0aW9uXCI7XG4gICAgdGhpcy5zdmdFbGVtZW50TmFtZSA9IFwic3ZnOnBvbHlnb25cIjtcbiAgfVxuXG59XG5cbmNsYXNzIENhcmV0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBpc1JlbmRlcmFibGUgPSAhIShwYXJhbWV0ZXJzLmRhdGEuaGFzUG9wdXAgfHwgcGFyYW1ldGVycy5kYXRhLnRpdGxlIHx8IHBhcmFtZXRlcnMuZGF0YS5jb250ZW50cyk7XG4gICAgc3VwZXIocGFyYW1ldGVycywgaXNSZW5kZXJhYmxlLCB0cnVlKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSBcImNhcmV0QW5ub3RhdGlvblwiO1xuXG4gICAgaWYgKCF0aGlzLmRhdGEuaGFzUG9wdXApIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKHRoaXMuY29udGFpbmVyLCBudWxsLCB0aGlzLmRhdGEpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuXG59XG5cbmNsYXNzIElua0Fubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgaXNSZW5kZXJhYmxlID0gISEocGFyYW1ldGVycy5kYXRhLmhhc1BvcHVwIHx8IHBhcmFtZXRlcnMuZGF0YS50aXRsZSB8fCBwYXJhbWV0ZXJzLmRhdGEuY29udGVudHMpO1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIGlzUmVuZGVyYWJsZSwgdHJ1ZSk7XG4gICAgdGhpcy5jb250YWluZXJDbGFzc05hbWUgPSBcImlua0Fubm90YXRpb25cIjtcbiAgICB0aGlzLnN2Z0VsZW1lbnROYW1lID0gXCJzdmc6cG9seWxpbmVcIjtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSB0aGlzLmNvbnRhaW5lckNsYXNzTmFtZTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xuICAgIGNvbnN0IHdpZHRoID0gZGF0YS5yZWN0WzJdIC0gZGF0YS5yZWN0WzBdO1xuICAgIGNvbnN0IGhlaWdodCA9IGRhdGEucmVjdFszXSAtIGRhdGEucmVjdFsxXTtcbiAgICBjb25zdCBzdmcgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlKHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgZm9yIChjb25zdCBpbmtMaXN0IG9mIGRhdGEuaW5rTGlzdHMpIHtcbiAgICAgIGxldCBwb2ludHMgPSBbXTtcblxuICAgICAgZm9yIChjb25zdCBjb29yZGluYXRlIG9mIGlua0xpc3QpIHtcbiAgICAgICAgY29uc3QgeCA9IGNvb3JkaW5hdGUueCAtIGRhdGEucmVjdFswXTtcbiAgICAgICAgY29uc3QgeSA9IGRhdGEucmVjdFszXSAtIGNvb3JkaW5hdGUueTtcbiAgICAgICAgcG9pbnRzLnB1c2goYCR7eH0sJHt5fWApO1xuICAgICAgfVxuXG4gICAgICBwb2ludHMgPSBwb2ludHMuam9pbihcIiBcIik7XG4gICAgICBjb25zdCBwb2x5bGluZSA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KHRoaXMuc3ZnRWxlbWVudE5hbWUpO1xuICAgICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwicG9pbnRzXCIsIHBvaW50cyk7XG4gICAgICBwb2x5bGluZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgZGF0YS5ib3JkZXJTdHlsZS53aWR0aCB8fCAxKTtcbiAgICAgIHBvbHlsaW5lLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcIm5vbmVcIik7XG5cbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKHRoaXMuY29udGFpbmVyLCBwb2x5bGluZSwgZGF0YSk7XG5cbiAgICAgIHN2Zy5hcHBlbmRDaGlsZChwb2x5bGluZSk7XG4gICAgfVxuXG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHN2Zyk7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG5cbn1cblxuY2xhc3MgSGlnaGxpZ2h0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBpc1JlbmRlcmFibGUgPSAhIShwYXJhbWV0ZXJzLmRhdGEuaGFzUG9wdXAgfHwgcGFyYW1ldGVycy5kYXRhLnRpdGxlIHx8IHBhcmFtZXRlcnMuZGF0YS5jb250ZW50cyk7XG4gICAgc3VwZXIocGFyYW1ldGVycywgaXNSZW5kZXJhYmxlLCB0cnVlKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSBcImhpZ2hsaWdodEFubm90YXRpb25cIjtcblxuICAgIGlmICghdGhpcy5kYXRhLmhhc1BvcHVwKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCh0aGlzLmNvbnRhaW5lciwgbnVsbCwgdGhpcy5kYXRhKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cblxufVxuXG5jbGFzcyBVbmRlcmxpbmVBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIGNvbnN0IGlzUmVuZGVyYWJsZSA9ICEhKHBhcmFtZXRlcnMuZGF0YS5oYXNQb3B1cCB8fCBwYXJhbWV0ZXJzLmRhdGEudGl0bGUgfHwgcGFyYW1ldGVycy5kYXRhLmNvbnRlbnRzKTtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCBpc1JlbmRlcmFibGUsIHRydWUpO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IFwidW5kZXJsaW5lQW5ub3RhdGlvblwiO1xuXG4gICAgaWYgKCF0aGlzLmRhdGEuaGFzUG9wdXApIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKHRoaXMuY29udGFpbmVyLCBudWxsLCB0aGlzLmRhdGEpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuXG59XG5cbmNsYXNzIFNxdWlnZ2x5QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBpc1JlbmRlcmFibGUgPSAhIShwYXJhbWV0ZXJzLmRhdGEuaGFzUG9wdXAgfHwgcGFyYW1ldGVycy5kYXRhLnRpdGxlIHx8IHBhcmFtZXRlcnMuZGF0YS5jb250ZW50cyk7XG4gICAgc3VwZXIocGFyYW1ldGVycywgaXNSZW5kZXJhYmxlLCB0cnVlKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSBcInNxdWlnZ2x5QW5ub3RhdGlvblwiO1xuXG4gICAgaWYgKCF0aGlzLmRhdGEuaGFzUG9wdXApIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKHRoaXMuY29udGFpbmVyLCBudWxsLCB0aGlzLmRhdGEpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuXG59XG5cbmNsYXNzIFN0cmlrZU91dEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgaXNSZW5kZXJhYmxlID0gISEocGFyYW1ldGVycy5kYXRhLmhhc1BvcHVwIHx8IHBhcmFtZXRlcnMuZGF0YS50aXRsZSB8fCBwYXJhbWV0ZXJzLmRhdGEuY29udGVudHMpO1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIGlzUmVuZGVyYWJsZSwgdHJ1ZSk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NOYW1lID0gXCJzdHJpa2VvdXRBbm5vdGF0aW9uXCI7XG5cbiAgICBpZiAoIXRoaXMuZGF0YS5oYXNQb3B1cCkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAodGhpcy5jb250YWluZXIsIG51bGwsIHRoaXMuZGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG5cbn1cblxuY2xhc3MgU3RhbXBBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIGNvbnN0IGlzUmVuZGVyYWJsZSA9ICEhKHBhcmFtZXRlcnMuZGF0YS5oYXNQb3B1cCB8fCBwYXJhbWV0ZXJzLmRhdGEudGl0bGUgfHwgcGFyYW1ldGVycy5kYXRhLmNvbnRlbnRzKTtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCBpc1JlbmRlcmFibGUsIHRydWUpO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IFwic3RhbXBBbm5vdGF0aW9uXCI7XG5cbiAgICBpZiAoIXRoaXMuZGF0YS5oYXNQb3B1cCkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAodGhpcy5jb250YWluZXIsIG51bGwsIHRoaXMuZGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG5cbn1cblxuY2xhc3MgRmlsZUF0dGFjaG1lbnRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHRydWUpO1xuICAgIGNvbnN0IHtcbiAgICAgIGZpbGVuYW1lLFxuICAgICAgY29udGVudFxuICAgIH0gPSB0aGlzLmRhdGEuZmlsZTtcbiAgICB0aGlzLmZpbGVuYW1lID0gKDAsIF9kaXNwbGF5X3V0aWxzLmdldEZpbGVuYW1lRnJvbVVybCkoZmlsZW5hbWUpO1xuICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG5cbiAgICBpZiAodGhpcy5saW5rU2VydmljZS5ldmVudEJ1cykge1xuICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cy5kaXNwYXRjaChcImZpbGVhdHRhY2htZW50YW5ub3RhdGlvblwiLCB7XG4gICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgaWQ6ICgwLCBfdXRpbC5zdHJpbmdUb1BERlN0cmluZykoZmlsZW5hbWUpLFxuICAgICAgICBmaWxlbmFtZSxcbiAgICAgICAgY29udGVudFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IFwiZmlsZUF0dGFjaG1lbnRBbm5vdGF0aW9uXCI7XG4gICAgY29uc3QgdHJpZ2dlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdHJpZ2dlci5zdHlsZS5oZWlnaHQgPSB0aGlzLmNvbnRhaW5lci5zdHlsZS5oZWlnaHQ7XG4gICAgdHJpZ2dlci5zdHlsZS53aWR0aCA9IHRoaXMuY29udGFpbmVyLnN0eWxlLndpZHRoO1xuICAgIHRyaWdnZXIuYWRkRXZlbnRMaXN0ZW5lcihcImRibGNsaWNrXCIsIHRoaXMuX2Rvd25sb2FkLmJpbmQodGhpcykpO1xuXG4gICAgaWYgKCF0aGlzLmRhdGEuaGFzUG9wdXAgJiYgKHRoaXMuZGF0YS50aXRsZSB8fCB0aGlzLmRhdGEuY29udGVudHMpKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCh0aGlzLmNvbnRhaW5lciwgdHJpZ2dlciwgdGhpcy5kYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0cmlnZ2VyKTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cblxuICBfZG93bmxvYWQoKSB7XG4gICAgaWYgKCF0aGlzLmRvd25sb2FkTWFuYWdlcikge1xuICAgICAgKDAsIF91dGlsLndhcm4pKFwiRG93bmxvYWQgY2Fubm90IGJlIHN0YXJ0ZWQgZHVlIHRvIHVuYXZhaWxhYmxlIGRvd25sb2FkIG1hbmFnZXJcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5kb3dubG9hZE1hbmFnZXIuZG93bmxvYWREYXRhKHRoaXMuY29udGVudCwgdGhpcy5maWxlbmFtZSwgXCJcIik7XG4gIH1cblxufVxuXG5jbGFzcyBBbm5vdGF0aW9uTGF5ZXIge1xuICBzdGF0aWMgcmVuZGVyKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBzb3J0ZWRBbm5vdGF0aW9ucyA9IFtdLFxuICAgICAgICAgIHBvcHVwQW5ub3RhdGlvbnMgPSBbXTtcblxuICAgIGZvciAoY29uc3QgZGF0YSBvZiBwYXJhbWV0ZXJzLmFubm90YXRpb25zKSB7XG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhLmFubm90YXRpb25UeXBlID09PSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5QT1BVUCkge1xuICAgICAgICBwb3B1cEFubm90YXRpb25zLnB1c2goZGF0YSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzb3J0ZWRBbm5vdGF0aW9ucy5wdXNoKGRhdGEpO1xuICAgIH1cblxuICAgIGlmIChwb3B1cEFubm90YXRpb25zLmxlbmd0aCkge1xuICAgICAgc29ydGVkQW5ub3RhdGlvbnMucHVzaCguLi5wb3B1cEFubm90YXRpb25zKTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGRhdGEgb2Ygc29ydGVkQW5ub3RhdGlvbnMpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBBbm5vdGF0aW9uRWxlbWVudEZhY3RvcnkuY3JlYXRlKHtcbiAgICAgICAgZGF0YSxcbiAgICAgICAgbGF5ZXI6IHBhcmFtZXRlcnMuZGl2LFxuICAgICAgICBwYWdlOiBwYXJhbWV0ZXJzLnBhZ2UsXG4gICAgICAgIHZpZXdwb3J0OiBwYXJhbWV0ZXJzLnZpZXdwb3J0LFxuICAgICAgICBsaW5rU2VydmljZTogcGFyYW1ldGVycy5saW5rU2VydmljZSxcbiAgICAgICAgZG93bmxvYWRNYW5hZ2VyOiBwYXJhbWV0ZXJzLmRvd25sb2FkTWFuYWdlcixcbiAgICAgICAgaW1hZ2VSZXNvdXJjZXNQYXRoOiBwYXJhbWV0ZXJzLmltYWdlUmVzb3VyY2VzUGF0aCB8fCBcIlwiLFxuICAgICAgICByZW5kZXJJbnRlcmFjdGl2ZUZvcm1zOiB0eXBlb2YgcGFyYW1ldGVycy5yZW5kZXJJbnRlcmFjdGl2ZUZvcm1zID09PSBcImJvb2xlYW5cIiA/IHBhcmFtZXRlcnMucmVuZGVySW50ZXJhY3RpdmVGb3JtcyA6IHRydWUsXG4gICAgICAgIHN2Z0ZhY3Rvcnk6IG5ldyBfZGlzcGxheV91dGlscy5ET01TVkdGYWN0b3J5KCksXG4gICAgICAgIGFubm90YXRpb25TdG9yYWdlOiBwYXJhbWV0ZXJzLmFubm90YXRpb25TdG9yYWdlIHx8IG5ldyBfYW5ub3RhdGlvbl9zdG9yYWdlLkFubm90YXRpb25TdG9yYWdlKClcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZWxlbWVudC5pc1JlbmRlcmFibGUpIHtcbiAgICAgICAgcGFyYW1ldGVycy5kaXYuYXBwZW5kQ2hpbGQoZWxlbWVudC5yZW5kZXIoKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIHVwZGF0ZShwYXJhbWV0ZXJzKSB7XG4gICAgZm9yIChjb25zdCBkYXRhIG9mIHBhcmFtZXRlcnMuYW5ub3RhdGlvbnMpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBwYXJhbWV0ZXJzLmRpdi5xdWVyeVNlbGVjdG9yKGBbZGF0YS1hbm5vdGF0aW9uLWlkPVwiJHtkYXRhLmlkfVwiXWApO1xuXG4gICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9IGBtYXRyaXgoJHtwYXJhbWV0ZXJzLnZpZXdwb3J0LnRyYW5zZm9ybS5qb2luKFwiLFwiKX0pYDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwYXJhbWV0ZXJzLmRpdi5yZW1vdmVBdHRyaWJ1dGUoXCJoaWRkZW5cIik7XG4gIH1cblxufVxuXG5leHBvcnRzLkFubm90YXRpb25MYXllciA9IEFubm90YXRpb25MYXllcjtcblxuLyoqKi8gfSksXG4vKiAyMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5yZW5kZXJUZXh0TGF5ZXIgPSB2b2lkIDA7XG5cbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMik7XG5cbnZhciByZW5kZXJUZXh0TGF5ZXIgPSBmdW5jdGlvbiByZW5kZXJUZXh0TGF5ZXJDbG9zdXJlKCkge1xuICB2YXIgTUFYX1RFWFRfRElWU19UT19SRU5ERVIgPSAxMDAwMDA7XG4gIHZhciBOb25XaGl0ZXNwYWNlUmVnZXhwID0gL1xcUy87XG5cbiAgZnVuY3Rpb24gaXNBbGxXaGl0ZXNwYWNlKHN0cikge1xuICAgIHJldHVybiAhTm9uV2hpdGVzcGFjZVJlZ2V4cC50ZXN0KHN0cik7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBlbmRUZXh0KHRhc2ssIGdlb20sIHN0eWxlcykge1xuICAgIHZhciB0ZXh0RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgdmFyIHRleHREaXZQcm9wZXJ0aWVzID0ge1xuICAgICAgYW5nbGU6IDAsXG4gICAgICBjYW52YXNXaWR0aDogMCxcbiAgICAgIGlzV2hpdGVzcGFjZTogZmFsc2UsXG4gICAgICBvcmlnaW5hbFRyYW5zZm9ybTogbnVsbCxcbiAgICAgIHBhZGRpbmdCb3R0b206IDAsXG4gICAgICBwYWRkaW5nTGVmdDogMCxcbiAgICAgIHBhZGRpbmdSaWdodDogMCxcbiAgICAgIHBhZGRpbmdUb3A6IDAsXG4gICAgICBzY2FsZTogMVxuICAgIH07XG5cbiAgICB0YXNrLl90ZXh0RGl2cy5wdXNoKHRleHREaXYpO1xuXG4gICAgaWYgKGlzQWxsV2hpdGVzcGFjZShnZW9tLnN0cikpIHtcbiAgICAgIHRleHREaXZQcm9wZXJ0aWVzLmlzV2hpdGVzcGFjZSA9IHRydWU7XG5cbiAgICAgIHRhc2suX3RleHREaXZQcm9wZXJ0aWVzLnNldCh0ZXh0RGl2LCB0ZXh0RGl2UHJvcGVydGllcyk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdHggPSBfdXRpbC5VdGlsLnRyYW5zZm9ybSh0YXNrLl92aWV3cG9ydC50cmFuc2Zvcm0sIGdlb20udHJhbnNmb3JtKTtcblxuICAgIHZhciBhbmdsZSA9IE1hdGguYXRhbjIodHhbMV0sIHR4WzBdKTtcbiAgICB2YXIgc3R5bGUgPSBzdHlsZXNbZ2VvbS5mb250TmFtZV07XG5cbiAgICBpZiAoc3R5bGUudmVydGljYWwpIHtcbiAgICAgIGFuZ2xlICs9IE1hdGguUEkgLyAyO1xuICAgIH1cblxuICAgIHZhciBmb250SGVpZ2h0ID0gTWF0aC5zcXJ0KHR4WzJdICogdHhbMl0gKyB0eFszXSAqIHR4WzNdKTtcbiAgICB2YXIgZm9udEFzY2VudCA9IGZvbnRIZWlnaHQ7XG5cbiAgICBpZiAoc3R5bGUuYXNjZW50KSB7XG4gICAgICBmb250QXNjZW50ID0gc3R5bGUuYXNjZW50ICogZm9udEFzY2VudDtcbiAgICB9IGVsc2UgaWYgKHN0eWxlLmRlc2NlbnQpIHtcbiAgICAgIGZvbnRBc2NlbnQgPSAoMSArIHN0eWxlLmRlc2NlbnQpICogZm9udEFzY2VudDtcbiAgICB9XG5cbiAgICBsZXQgbGVmdCwgdG9wO1xuXG4gICAgaWYgKGFuZ2xlID09PSAwKSB7XG4gICAgICBsZWZ0ID0gdHhbNF07XG4gICAgICB0b3AgPSB0eFs1XSAtIGZvbnRBc2NlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlZnQgPSB0eFs0XSArIGZvbnRBc2NlbnQgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgICB0b3AgPSB0eFs1XSAtIGZvbnRBc2NlbnQgKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgfVxuXG4gICAgdGV4dERpdi5zdHlsZS5sZWZ0ID0gYCR7bGVmdH1weGA7XG4gICAgdGV4dERpdi5zdHlsZS50b3AgPSBgJHt0b3B9cHhgO1xuICAgIHRleHREaXYuc3R5bGUuZm9udFNpemUgPSBgJHtmb250SGVpZ2h0fXB4YDtcbiAgICB0ZXh0RGl2LnN0eWxlLmZvbnRGYW1pbHkgPSBzdHlsZS5mb250RmFtaWx5O1xuICAgIHRleHREaXYudGV4dENvbnRlbnQgPSBnZW9tLnN0cjtcblxuICAgIGlmICh0YXNrLl9mb250SW5zcGVjdG9yRW5hYmxlZCkge1xuICAgICAgdGV4dERpdi5kYXRhc2V0LmZvbnROYW1lID0gZ2VvbS5mb250TmFtZTtcbiAgICB9XG5cbiAgICBpZiAoYW5nbGUgIT09IDApIHtcbiAgICAgIHRleHREaXZQcm9wZXJ0aWVzLmFuZ2xlID0gYW5nbGUgKiAoMTgwIC8gTWF0aC5QSSk7XG4gICAgfVxuXG4gICAgbGV0IHNob3VsZFNjYWxlVGV4dCA9IGZhbHNlO1xuXG4gICAgaWYgKGdlb20uc3RyLmxlbmd0aCA+IDEpIHtcbiAgICAgIHNob3VsZFNjYWxlVGV4dCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChnZW9tLnRyYW5zZm9ybVswXSAhPT0gZ2VvbS50cmFuc2Zvcm1bM10pIHtcbiAgICAgIGNvbnN0IGFic1NjYWxlWCA9IE1hdGguYWJzKGdlb20udHJhbnNmb3JtWzBdKSxcbiAgICAgICAgICAgIGFic1NjYWxlWSA9IE1hdGguYWJzKGdlb20udHJhbnNmb3JtWzNdKTtcblxuICAgICAgaWYgKGFic1NjYWxlWCAhPT0gYWJzU2NhbGVZICYmIE1hdGgubWF4KGFic1NjYWxlWCwgYWJzU2NhbGVZKSAvIE1hdGgubWluKGFic1NjYWxlWCwgYWJzU2NhbGVZKSA+IDEuNSkge1xuICAgICAgICBzaG91bGRTY2FsZVRleHQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaG91bGRTY2FsZVRleHQpIHtcbiAgICAgIGlmIChzdHlsZS52ZXJ0aWNhbCkge1xuICAgICAgICB0ZXh0RGl2UHJvcGVydGllcy5jYW52YXNXaWR0aCA9IGdlb20uaGVpZ2h0ICogdGFzay5fdmlld3BvcnQuc2NhbGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZXh0RGl2UHJvcGVydGllcy5jYW52YXNXaWR0aCA9IGdlb20ud2lkdGggKiB0YXNrLl92aWV3cG9ydC5zY2FsZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0YXNrLl90ZXh0RGl2UHJvcGVydGllcy5zZXQodGV4dERpdiwgdGV4dERpdlByb3BlcnRpZXMpO1xuXG4gICAgaWYgKHRhc2suX3RleHRDb250ZW50U3RyZWFtKSB7XG4gICAgICB0YXNrLl9sYXlvdXRUZXh0KHRleHREaXYpO1xuICAgIH1cblxuICAgIGlmICh0YXNrLl9lbmhhbmNlVGV4dFNlbGVjdGlvbikge1xuICAgICAgdmFyIGFuZ2xlQ29zID0gMSxcbiAgICAgICAgICBhbmdsZVNpbiA9IDA7XG5cbiAgICAgIGlmIChhbmdsZSAhPT0gMCkge1xuICAgICAgICBhbmdsZUNvcyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICAgICAgYW5nbGVTaW4gPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkaXZXaWR0aCA9IChzdHlsZS52ZXJ0aWNhbCA/IGdlb20uaGVpZ2h0IDogZ2VvbS53aWR0aCkgKiB0YXNrLl92aWV3cG9ydC5zY2FsZTtcbiAgICAgIHZhciBkaXZIZWlnaHQgPSBmb250SGVpZ2h0O1xuICAgICAgdmFyIG0sIGI7XG5cbiAgICAgIGlmIChhbmdsZSAhPT0gMCkge1xuICAgICAgICBtID0gW2FuZ2xlQ29zLCBhbmdsZVNpbiwgLWFuZ2xlU2luLCBhbmdsZUNvcywgbGVmdCwgdG9wXTtcbiAgICAgICAgYiA9IF91dGlsLlV0aWwuZ2V0QXhpYWxBbGlnbmVkQm91bmRpbmdCb3goWzAsIDAsIGRpdldpZHRoLCBkaXZIZWlnaHRdLCBtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGIgPSBbbGVmdCwgdG9wLCBsZWZ0ICsgZGl2V2lkdGgsIHRvcCArIGRpdkhlaWdodF07XG4gICAgICB9XG5cbiAgICAgIHRhc2suX2JvdW5kcy5wdXNoKHtcbiAgICAgICAgbGVmdDogYlswXSxcbiAgICAgICAgdG9wOiBiWzFdLFxuICAgICAgICByaWdodDogYlsyXSxcbiAgICAgICAgYm90dG9tOiBiWzNdLFxuICAgICAgICBkaXY6IHRleHREaXYsXG4gICAgICAgIHNpemU6IFtkaXZXaWR0aCwgZGl2SGVpZ2h0XSxcbiAgICAgICAgbVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyKHRhc2spIHtcbiAgICBpZiAodGFzay5fY2FuY2VsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdGV4dERpdnMgPSB0YXNrLl90ZXh0RGl2cztcbiAgICB2YXIgY2FwYWJpbGl0eSA9IHRhc2suX2NhcGFiaWxpdHk7XG4gICAgdmFyIHRleHREaXZzTGVuZ3RoID0gdGV4dERpdnMubGVuZ3RoO1xuXG4gICAgaWYgKHRleHREaXZzTGVuZ3RoID4gTUFYX1RFWFRfRElWU19UT19SRU5ERVIpIHtcbiAgICAgIHRhc2suX3JlbmRlcmluZ0RvbmUgPSB0cnVlO1xuICAgICAgY2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0YXNrLl90ZXh0Q29udGVudFN0cmVhbSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0RGl2c0xlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRhc2suX2xheW91dFRleHQodGV4dERpdnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRhc2suX3JlbmRlcmluZ0RvbmUgPSB0cnVlO1xuICAgIGNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZFBvc2l0aXZlTWluKHRzLCBvZmZzZXQsIGNvdW50KSB7XG4gICAgbGV0IHJlc3VsdCA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHQgPSB0c1tvZmZzZXQrK107XG5cbiAgICAgIGlmICh0ID4gMCkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQgPyBNYXRoLm1pbih0LCByZXN1bHQpIDogdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gZXhwYW5kKHRhc2spIHtcbiAgICB2YXIgYm91bmRzID0gdGFzay5fYm91bmRzO1xuICAgIHZhciB2aWV3cG9ydCA9IHRhc2suX3ZpZXdwb3J0O1xuICAgIHZhciBleHBhbmRlZCA9IGV4cGFuZEJvdW5kcyh2aWV3cG9ydC53aWR0aCwgdmlld3BvcnQuaGVpZ2h0LCBib3VuZHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBhbmRlZC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRpdiA9IGJvdW5kc1tpXS5kaXY7XG5cbiAgICAgIHZhciBkaXZQcm9wZXJ0aWVzID0gdGFzay5fdGV4dERpdlByb3BlcnRpZXMuZ2V0KGRpdik7XG5cbiAgICAgIGlmIChkaXZQcm9wZXJ0aWVzLmFuZ2xlID09PSAwKSB7XG4gICAgICAgIGRpdlByb3BlcnRpZXMucGFkZGluZ0xlZnQgPSBib3VuZHNbaV0ubGVmdCAtIGV4cGFuZGVkW2ldLmxlZnQ7XG4gICAgICAgIGRpdlByb3BlcnRpZXMucGFkZGluZ1RvcCA9IGJvdW5kc1tpXS50b3AgLSBleHBhbmRlZFtpXS50b3A7XG4gICAgICAgIGRpdlByb3BlcnRpZXMucGFkZGluZ1JpZ2h0ID0gZXhwYW5kZWRbaV0ucmlnaHQgLSBib3VuZHNbaV0ucmlnaHQ7XG4gICAgICAgIGRpdlByb3BlcnRpZXMucGFkZGluZ0JvdHRvbSA9IGV4cGFuZGVkW2ldLmJvdHRvbSAtIGJvdW5kc1tpXS5ib3R0b207XG5cbiAgICAgICAgdGFzay5fdGV4dERpdlByb3BlcnRpZXMuc2V0KGRpdiwgZGl2UHJvcGVydGllcyk7XG5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBlID0gZXhwYW5kZWRbaV0sXG4gICAgICAgICAgYiA9IGJvdW5kc1tpXTtcbiAgICAgIHZhciBtID0gYi5tLFxuICAgICAgICAgIGMgPSBtWzBdLFxuICAgICAgICAgIHMgPSBtWzFdO1xuICAgICAgdmFyIHBvaW50cyA9IFtbMCwgMF0sIFswLCBiLnNpemVbMV1dLCBbYi5zaXplWzBdLCAwXSwgYi5zaXplXTtcbiAgICAgIHZhciB0cyA9IG5ldyBGbG9hdDY0QXJyYXkoNjQpO1xuICAgICAgcG9pbnRzLmZvckVhY2goZnVuY3Rpb24gKHAsIGopIHtcbiAgICAgICAgdmFyIHQgPSBfdXRpbC5VdGlsLmFwcGx5VHJhbnNmb3JtKHAsIG0pO1xuXG4gICAgICAgIHRzW2ogKyAwXSA9IGMgJiYgKGUubGVmdCAtIHRbMF0pIC8gYztcbiAgICAgICAgdHNbaiArIDRdID0gcyAmJiAoZS50b3AgLSB0WzFdKSAvIHM7XG4gICAgICAgIHRzW2ogKyA4XSA9IGMgJiYgKGUucmlnaHQgLSB0WzBdKSAvIGM7XG4gICAgICAgIHRzW2ogKyAxMl0gPSBzICYmIChlLmJvdHRvbSAtIHRbMV0pIC8gcztcbiAgICAgICAgdHNbaiArIDE2XSA9IHMgJiYgKGUubGVmdCAtIHRbMF0pIC8gLXM7XG4gICAgICAgIHRzW2ogKyAyMF0gPSBjICYmIChlLnRvcCAtIHRbMV0pIC8gYztcbiAgICAgICAgdHNbaiArIDI0XSA9IHMgJiYgKGUucmlnaHQgLSB0WzBdKSAvIC1zO1xuICAgICAgICB0c1tqICsgMjhdID0gYyAmJiAoZS5ib3R0b20gLSB0WzFdKSAvIGM7XG4gICAgICAgIHRzW2ogKyAzMl0gPSBjICYmIChlLmxlZnQgLSB0WzBdKSAvIC1jO1xuICAgICAgICB0c1tqICsgMzZdID0gcyAmJiAoZS50b3AgLSB0WzFdKSAvIC1zO1xuICAgICAgICB0c1tqICsgNDBdID0gYyAmJiAoZS5yaWdodCAtIHRbMF0pIC8gLWM7XG4gICAgICAgIHRzW2ogKyA0NF0gPSBzICYmIChlLmJvdHRvbSAtIHRbMV0pIC8gLXM7XG4gICAgICAgIHRzW2ogKyA0OF0gPSBzICYmIChlLmxlZnQgLSB0WzBdKSAvIHM7XG4gICAgICAgIHRzW2ogKyA1Ml0gPSBjICYmIChlLnRvcCAtIHRbMV0pIC8gLWM7XG4gICAgICAgIHRzW2ogKyA1Nl0gPSBzICYmIChlLnJpZ2h0IC0gdFswXSkgLyBzO1xuICAgICAgICB0c1tqICsgNjBdID0gYyAmJiAoZS5ib3R0b20gLSB0WzFdKSAvIC1jO1xuICAgICAgfSk7XG4gICAgICB2YXIgYm94U2NhbGUgPSAxICsgTWF0aC5taW4oTWF0aC5hYnMoYyksIE1hdGguYWJzKHMpKTtcbiAgICAgIGRpdlByb3BlcnRpZXMucGFkZGluZ0xlZnQgPSBmaW5kUG9zaXRpdmVNaW4odHMsIDMyLCAxNikgLyBib3hTY2FsZTtcbiAgICAgIGRpdlByb3BlcnRpZXMucGFkZGluZ1RvcCA9IGZpbmRQb3NpdGl2ZU1pbih0cywgNDgsIDE2KSAvIGJveFNjYWxlO1xuICAgICAgZGl2UHJvcGVydGllcy5wYWRkaW5nUmlnaHQgPSBmaW5kUG9zaXRpdmVNaW4odHMsIDAsIDE2KSAvIGJveFNjYWxlO1xuICAgICAgZGl2UHJvcGVydGllcy5wYWRkaW5nQm90dG9tID0gZmluZFBvc2l0aXZlTWluKHRzLCAxNiwgMTYpIC8gYm94U2NhbGU7XG5cbiAgICAgIHRhc2suX3RleHREaXZQcm9wZXJ0aWVzLnNldChkaXYsIGRpdlByb3BlcnRpZXMpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGV4cGFuZEJvdW5kcyh3aWR0aCwgaGVpZ2h0LCBib3hlcykge1xuICAgIHZhciBib3VuZHMgPSBib3hlcy5tYXAoZnVuY3Rpb24gKGJveCwgaSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDE6IGJveC5sZWZ0LFxuICAgICAgICB5MTogYm94LnRvcCxcbiAgICAgICAgeDI6IGJveC5yaWdodCxcbiAgICAgICAgeTI6IGJveC5ib3R0b20sXG4gICAgICAgIGluZGV4OiBpLFxuICAgICAgICB4MU5ldzogdW5kZWZpbmVkLFxuICAgICAgICB4Mk5ldzogdW5kZWZpbmVkXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGV4cGFuZEJvdW5kc0xUUih3aWR0aCwgYm91bmRzKTtcbiAgICB2YXIgZXhwYW5kZWQgPSBuZXcgQXJyYXkoYm94ZXMubGVuZ3RoKTtcbiAgICBib3VuZHMuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgdmFyIGkgPSBiLmluZGV4O1xuICAgICAgZXhwYW5kZWRbaV0gPSB7XG4gICAgICAgIGxlZnQ6IGIueDFOZXcsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgcmlnaHQ6IGIueDJOZXcsXG4gICAgICAgIGJvdHRvbTogMFxuICAgICAgfTtcbiAgICB9KTtcbiAgICBib3hlcy5tYXAoZnVuY3Rpb24gKGJveCwgaSkge1xuICAgICAgdmFyIGUgPSBleHBhbmRlZFtpXSxcbiAgICAgICAgICBiID0gYm91bmRzW2ldO1xuICAgICAgYi54MSA9IGJveC50b3A7XG4gICAgICBiLnkxID0gd2lkdGggLSBlLnJpZ2h0O1xuICAgICAgYi54MiA9IGJveC5ib3R0b207XG4gICAgICBiLnkyID0gd2lkdGggLSBlLmxlZnQ7XG4gICAgICBiLmluZGV4ID0gaTtcbiAgICAgIGIueDFOZXcgPSB1bmRlZmluZWQ7XG4gICAgICBiLngyTmV3ID0gdW5kZWZpbmVkO1xuICAgIH0pO1xuICAgIGV4cGFuZEJvdW5kc0xUUihoZWlnaHQsIGJvdW5kcyk7XG4gICAgYm91bmRzLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgIHZhciBpID0gYi5pbmRleDtcbiAgICAgIGV4cGFuZGVkW2ldLnRvcCA9IGIueDFOZXc7XG4gICAgICBleHBhbmRlZFtpXS5ib3R0b20gPSBiLngyTmV3O1xuICAgIH0pO1xuICAgIHJldHVybiBleHBhbmRlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4cGFuZEJvdW5kc0xUUih3aWR0aCwgYm91bmRzKSB7XG4gICAgYm91bmRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLngxIC0gYi54MSB8fCBhLmluZGV4IC0gYi5pbmRleDtcbiAgICB9KTtcbiAgICB2YXIgZmFrZUJvdW5kYXJ5ID0ge1xuICAgICAgeDE6IC1JbmZpbml0eSxcbiAgICAgIHkxOiAtSW5maW5pdHksXG4gICAgICB4MjogMCxcbiAgICAgIHkyOiBJbmZpbml0eSxcbiAgICAgIGluZGV4OiAtMSxcbiAgICAgIHgxTmV3OiAwLFxuICAgICAgeDJOZXc6IDBcbiAgICB9O1xuICAgIHZhciBob3Jpem9uID0gW3tcbiAgICAgIHN0YXJ0OiAtSW5maW5pdHksXG4gICAgICBlbmQ6IEluZmluaXR5LFxuICAgICAgYm91bmRhcnk6IGZha2VCb3VuZGFyeVxuICAgIH1dO1xuICAgIGJvdW5kcy5mb3JFYWNoKGZ1bmN0aW9uIChib3VuZGFyeSkge1xuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICB3aGlsZSAoaSA8IGhvcml6b24ubGVuZ3RoICYmIGhvcml6b25baV0uZW5kIDw9IGJvdW5kYXJ5LnkxKSB7XG4gICAgICAgIGkrKztcbiAgICAgIH1cblxuICAgICAgdmFyIGogPSBob3Jpem9uLmxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChqID49IDAgJiYgaG9yaXpvbltqXS5zdGFydCA+PSBib3VuZGFyeS55Mikge1xuICAgICAgICBqLS07XG4gICAgICB9XG5cbiAgICAgIHZhciBob3Jpem9uUGFydCwgYWZmZWN0ZWRCb3VuZGFyeTtcbiAgICAgIHZhciBxLFxuICAgICAgICAgIGssXG4gICAgICAgICAgbWF4WE5ldyA9IC1JbmZpbml0eTtcblxuICAgICAgZm9yIChxID0gaTsgcSA8PSBqOyBxKyspIHtcbiAgICAgICAgaG9yaXpvblBhcnQgPSBob3Jpem9uW3FdO1xuICAgICAgICBhZmZlY3RlZEJvdW5kYXJ5ID0gaG9yaXpvblBhcnQuYm91bmRhcnk7XG4gICAgICAgIHZhciB4TmV3O1xuXG4gICAgICAgIGlmIChhZmZlY3RlZEJvdW5kYXJ5LngyID4gYm91bmRhcnkueDEpIHtcbiAgICAgICAgICB4TmV3ID0gYWZmZWN0ZWRCb3VuZGFyeS5pbmRleCA+IGJvdW5kYXJ5LmluZGV4ID8gYWZmZWN0ZWRCb3VuZGFyeS54MU5ldyA6IGJvdW5kYXJ5LngxO1xuICAgICAgICB9IGVsc2UgaWYgKGFmZmVjdGVkQm91bmRhcnkueDJOZXcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHhOZXcgPSAoYWZmZWN0ZWRCb3VuZGFyeS54MiArIGJvdW5kYXJ5LngxKSAvIDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeE5ldyA9IGFmZmVjdGVkQm91bmRhcnkueDJOZXc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeE5ldyA+IG1heFhOZXcpIHtcbiAgICAgICAgICBtYXhYTmV3ID0geE5ldztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBib3VuZGFyeS54MU5ldyA9IG1heFhOZXc7XG5cbiAgICAgIGZvciAocSA9IGk7IHEgPD0gajsgcSsrKSB7XG4gICAgICAgIGhvcml6b25QYXJ0ID0gaG9yaXpvbltxXTtcbiAgICAgICAgYWZmZWN0ZWRCb3VuZGFyeSA9IGhvcml6b25QYXJ0LmJvdW5kYXJ5O1xuXG4gICAgICAgIGlmIChhZmZlY3RlZEJvdW5kYXJ5LngyTmV3ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoYWZmZWN0ZWRCb3VuZGFyeS54MiA+IGJvdW5kYXJ5LngxKSB7XG4gICAgICAgICAgICBpZiAoYWZmZWN0ZWRCb3VuZGFyeS5pbmRleCA+IGJvdW5kYXJ5LmluZGV4KSB7XG4gICAgICAgICAgICAgIGFmZmVjdGVkQm91bmRhcnkueDJOZXcgPSBhZmZlY3RlZEJvdW5kYXJ5LngyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZmZlY3RlZEJvdW5kYXJ5LngyTmV3ID0gbWF4WE5ldztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYWZmZWN0ZWRCb3VuZGFyeS54Mk5ldyA+IG1heFhOZXcpIHtcbiAgICAgICAgICBhZmZlY3RlZEJvdW5kYXJ5LngyTmV3ID0gTWF0aC5tYXgobWF4WE5ldywgYWZmZWN0ZWRCb3VuZGFyeS54Mik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGNoYW5nZWRIb3Jpem9uID0gW10sXG4gICAgICAgICAgbGFzdEJvdW5kYXJ5ID0gbnVsbDtcblxuICAgICAgZm9yIChxID0gaTsgcSA8PSBqOyBxKyspIHtcbiAgICAgICAgaG9yaXpvblBhcnQgPSBob3Jpem9uW3FdO1xuICAgICAgICBhZmZlY3RlZEJvdW5kYXJ5ID0gaG9yaXpvblBhcnQuYm91bmRhcnk7XG4gICAgICAgIHZhciB1c2VCb3VuZGFyeSA9IGFmZmVjdGVkQm91bmRhcnkueDIgPiBib3VuZGFyeS54MiA/IGFmZmVjdGVkQm91bmRhcnkgOiBib3VuZGFyeTtcblxuICAgICAgICBpZiAobGFzdEJvdW5kYXJ5ID09PSB1c2VCb3VuZGFyeSkge1xuICAgICAgICAgIGNoYW5nZWRIb3Jpem9uW2NoYW5nZWRIb3Jpem9uLmxlbmd0aCAtIDFdLmVuZCA9IGhvcml6b25QYXJ0LmVuZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGFuZ2VkSG9yaXpvbi5wdXNoKHtcbiAgICAgICAgICAgIHN0YXJ0OiBob3Jpem9uUGFydC5zdGFydCxcbiAgICAgICAgICAgIGVuZDogaG9yaXpvblBhcnQuZW5kLFxuICAgICAgICAgICAgYm91bmRhcnk6IHVzZUJvdW5kYXJ5XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbGFzdEJvdW5kYXJ5ID0gdXNlQm91bmRhcnk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGhvcml6b25baV0uc3RhcnQgPCBib3VuZGFyeS55MSkge1xuICAgICAgICBjaGFuZ2VkSG9yaXpvblswXS5zdGFydCA9IGJvdW5kYXJ5LnkxO1xuICAgICAgICBjaGFuZ2VkSG9yaXpvbi51bnNoaWZ0KHtcbiAgICAgICAgICBzdGFydDogaG9yaXpvbltpXS5zdGFydCxcbiAgICAgICAgICBlbmQ6IGJvdW5kYXJ5LnkxLFxuICAgICAgICAgIGJvdW5kYXJ5OiBob3Jpem9uW2ldLmJvdW5kYXJ5XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoYm91bmRhcnkueTIgPCBob3Jpem9uW2pdLmVuZCkge1xuICAgICAgICBjaGFuZ2VkSG9yaXpvbltjaGFuZ2VkSG9yaXpvbi5sZW5ndGggLSAxXS5lbmQgPSBib3VuZGFyeS55MjtcbiAgICAgICAgY2hhbmdlZEhvcml6b24ucHVzaCh7XG4gICAgICAgICAgc3RhcnQ6IGJvdW5kYXJ5LnkyLFxuICAgICAgICAgIGVuZDogaG9yaXpvbltqXS5lbmQsXG4gICAgICAgICAgYm91bmRhcnk6IGhvcml6b25bal0uYm91bmRhcnlcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAocSA9IGk7IHEgPD0gajsgcSsrKSB7XG4gICAgICAgIGhvcml6b25QYXJ0ID0gaG9yaXpvbltxXTtcbiAgICAgICAgYWZmZWN0ZWRCb3VuZGFyeSA9IGhvcml6b25QYXJ0LmJvdW5kYXJ5O1xuXG4gICAgICAgIGlmIChhZmZlY3RlZEJvdW5kYXJ5LngyTmV3ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1c2VkID0gZmFsc2U7XG5cbiAgICAgICAgZm9yIChrID0gaSAtIDE7ICF1c2VkICYmIGsgPj0gMCAmJiBob3Jpem9uW2tdLnN0YXJ0ID49IGFmZmVjdGVkQm91bmRhcnkueTE7IGstLSkge1xuICAgICAgICAgIHVzZWQgPSBob3Jpem9uW2tdLmJvdW5kYXJ5ID09PSBhZmZlY3RlZEJvdW5kYXJ5O1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChrID0gaiArIDE7ICF1c2VkICYmIGsgPCBob3Jpem9uLmxlbmd0aCAmJiBob3Jpem9uW2tdLmVuZCA8PSBhZmZlY3RlZEJvdW5kYXJ5LnkyOyBrKyspIHtcbiAgICAgICAgICB1c2VkID0gaG9yaXpvbltrXS5ib3VuZGFyeSA9PT0gYWZmZWN0ZWRCb3VuZGFyeTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoayA9IDA7ICF1c2VkICYmIGsgPCBjaGFuZ2VkSG9yaXpvbi5sZW5ndGg7IGsrKykge1xuICAgICAgICAgIHVzZWQgPSBjaGFuZ2VkSG9yaXpvbltrXS5ib3VuZGFyeSA9PT0gYWZmZWN0ZWRCb3VuZGFyeTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdXNlZCkge1xuICAgICAgICAgIGFmZmVjdGVkQm91bmRhcnkueDJOZXcgPSBtYXhYTmV3O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIEFycmF5LnByb3RvdHlwZS5zcGxpY2UuYXBwbHkoaG9yaXpvbiwgW2ksIGogLSBpICsgMV0uY29uY2F0KGNoYW5nZWRIb3Jpem9uKSk7XG4gICAgfSk7XG4gICAgaG9yaXpvbi5mb3JFYWNoKGZ1bmN0aW9uIChob3Jpem9uUGFydCkge1xuICAgICAgdmFyIGFmZmVjdGVkQm91bmRhcnkgPSBob3Jpem9uUGFydC5ib3VuZGFyeTtcblxuICAgICAgaWYgKGFmZmVjdGVkQm91bmRhcnkueDJOZXcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhZmZlY3RlZEJvdW5kYXJ5LngyTmV3ID0gTWF0aC5tYXgod2lkdGgsIGFmZmVjdGVkQm91bmRhcnkueDIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gVGV4dExheWVyUmVuZGVyVGFzayh7XG4gICAgdGV4dENvbnRlbnQsXG4gICAgdGV4dENvbnRlbnRTdHJlYW0sXG4gICAgY29udGFpbmVyLFxuICAgIHZpZXdwb3J0LFxuICAgIHRleHREaXZzLFxuICAgIHRleHRDb250ZW50SXRlbXNTdHIsXG4gICAgZW5oYW5jZVRleHRTZWxlY3Rpb25cbiAgfSkge1xuICAgIHRoaXMuX3RleHRDb250ZW50ID0gdGV4dENvbnRlbnQ7XG4gICAgdGhpcy5fdGV4dENvbnRlbnRTdHJlYW0gPSB0ZXh0Q29udGVudFN0cmVhbTtcbiAgICB0aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy5fZG9jdW1lbnQgPSBjb250YWluZXIub3duZXJEb2N1bWVudDtcbiAgICB0aGlzLl92aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgIHRoaXMuX3RleHREaXZzID0gdGV4dERpdnMgfHwgW107XG4gICAgdGhpcy5fdGV4dENvbnRlbnRJdGVtc1N0ciA9IHRleHRDb250ZW50SXRlbXNTdHIgfHwgW107XG4gICAgdGhpcy5fZW5oYW5jZVRleHRTZWxlY3Rpb24gPSAhIWVuaGFuY2VUZXh0U2VsZWN0aW9uO1xuICAgIHRoaXMuX2ZvbnRJbnNwZWN0b3JFbmFibGVkID0gISEoZ2xvYmFsVGhpcy5Gb250SW5zcGVjdG9yICYmIGdsb2JhbFRoaXMuRm9udEluc3BlY3Rvci5lbmFibGVkKTtcbiAgICB0aGlzLl9yZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX2xheW91dFRleHRMYXN0Rm9udFNpemUgPSBudWxsO1xuICAgIHRoaXMuX2xheW91dFRleHRMYXN0Rm9udEZhbWlseSA9IG51bGw7XG4gICAgdGhpcy5fbGF5b3V0VGV4dEN0eCA9IG51bGw7XG4gICAgdGhpcy5fdGV4dERpdlByb3BlcnRpZXMgPSBuZXcgV2Vha01hcCgpO1xuICAgIHRoaXMuX3JlbmRlcmluZ0RvbmUgPSBmYWxzZTtcbiAgICB0aGlzLl9jYW5jZWxlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2NhcGFiaWxpdHkgPSAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCk7XG4gICAgdGhpcy5fcmVuZGVyVGltZXIgPSBudWxsO1xuICAgIHRoaXMuX2JvdW5kcyA9IFtdO1xuXG4gICAgdGhpcy5fY2FwYWJpbGl0eS5wcm9taXNlLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX2xheW91dFRleHRDdHgpIHtcbiAgICAgICAgdGhpcy5fbGF5b3V0VGV4dEN0eC5jYW52YXMud2lkdGggPSAwO1xuICAgICAgICB0aGlzLl9sYXlvdXRUZXh0Q3R4LmNhbnZhcy5oZWlnaHQgPSAwO1xuICAgICAgICB0aGlzLl9sYXlvdXRUZXh0Q3R4ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KS5jYXRjaCgoKSA9PiB7fSk7XG4gIH1cblxuICBUZXh0TGF5ZXJSZW5kZXJUYXNrLnByb3RvdHlwZSA9IHtcbiAgICBnZXQgcHJvbWlzZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYXBhYmlsaXR5LnByb21pc2U7XG4gICAgfSxcblxuICAgIGNhbmNlbDogZnVuY3Rpb24gVGV4dExheWVyX2NhbmNlbCgpIHtcbiAgICAgIHRoaXMuX2NhbmNlbGVkID0gdHJ1ZTtcblxuICAgICAgaWYgKHRoaXMuX3JlYWRlcikge1xuICAgICAgICB0aGlzLl9yZWFkZXIuY2FuY2VsKG5ldyBfdXRpbC5BYm9ydEV4Y2VwdGlvbihcIlRleHRMYXllciB0YXNrIGNhbmNlbGxlZC5cIikpO1xuXG4gICAgICAgIHRoaXMuX3JlYWRlciA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9yZW5kZXJUaW1lciAhPT0gbnVsbCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fcmVuZGVyVGltZXIpO1xuICAgICAgICB0aGlzLl9yZW5kZXJUaW1lciA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NhcGFiaWxpdHkucmVqZWN0KG5ldyBFcnJvcihcIlRleHRMYXllciB0YXNrIGNhbmNlbGxlZC5cIikpO1xuICAgIH0sXG5cbiAgICBfcHJvY2Vzc0l0ZW1zKGl0ZW1zLCBzdHlsZUNhY2hlKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdGhpcy5fdGV4dENvbnRlbnRJdGVtc1N0ci5wdXNoKGl0ZW1zW2ldLnN0cik7XG5cbiAgICAgICAgYXBwZW5kVGV4dCh0aGlzLCBpdGVtc1tpXSwgc3R5bGVDYWNoZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9sYXlvdXRUZXh0KHRleHREaXYpIHtcbiAgICAgIGNvbnN0IHRleHREaXZQcm9wZXJ0aWVzID0gdGhpcy5fdGV4dERpdlByb3BlcnRpZXMuZ2V0KHRleHREaXYpO1xuXG4gICAgICBpZiAodGV4dERpdlByb3BlcnRpZXMuaXNXaGl0ZXNwYWNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IHRyYW5zZm9ybSA9IFwiXCI7XG5cbiAgICAgIGlmICh0ZXh0RGl2UHJvcGVydGllcy5jYW52YXNXaWR0aCAhPT0gMCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZm9udFNpemUsXG4gICAgICAgICAgZm9udEZhbWlseVxuICAgICAgICB9ID0gdGV4dERpdi5zdHlsZTtcblxuICAgICAgICBpZiAoZm9udFNpemUgIT09IHRoaXMuX2xheW91dFRleHRMYXN0Rm9udFNpemUgfHwgZm9udEZhbWlseSAhPT0gdGhpcy5fbGF5b3V0VGV4dExhc3RGb250RmFtaWx5KSB7XG4gICAgICAgICAgdGhpcy5fbGF5b3V0VGV4dEN0eC5mb250ID0gYCR7Zm9udFNpemV9ICR7Zm9udEZhbWlseX1gO1xuICAgICAgICAgIHRoaXMuX2xheW91dFRleHRMYXN0Rm9udFNpemUgPSBmb250U2l6ZTtcbiAgICAgICAgICB0aGlzLl9sYXlvdXRUZXh0TGFzdEZvbnRGYW1pbHkgPSBmb250RmFtaWx5O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHdpZHRoXG4gICAgICAgIH0gPSB0aGlzLl9sYXlvdXRUZXh0Q3R4Lm1lYXN1cmVUZXh0KHRleHREaXYudGV4dENvbnRlbnQpO1xuXG4gICAgICAgIGlmICh3aWR0aCA+IDApIHtcbiAgICAgICAgICB0ZXh0RGl2UHJvcGVydGllcy5zY2FsZSA9IHRleHREaXZQcm9wZXJ0aWVzLmNhbnZhc1dpZHRoIC8gd2lkdGg7XG4gICAgICAgICAgdHJhbnNmb3JtID0gYHNjYWxlWCgke3RleHREaXZQcm9wZXJ0aWVzLnNjYWxlfSlgO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZXh0RGl2UHJvcGVydGllcy5hbmdsZSAhPT0gMCkge1xuICAgICAgICB0cmFuc2Zvcm0gPSBgcm90YXRlKCR7dGV4dERpdlByb3BlcnRpZXMuYW5nbGV9ZGVnKSAke3RyYW5zZm9ybX1gO1xuICAgICAgfVxuXG4gICAgICBpZiAodHJhbnNmb3JtLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKHRoaXMuX2VuaGFuY2VUZXh0U2VsZWN0aW9uKSB7XG4gICAgICAgICAgdGV4dERpdlByb3BlcnRpZXMub3JpZ2luYWxUcmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgICAgIH1cblxuICAgICAgICB0ZXh0RGl2LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fdGV4dERpdlByb3BlcnRpZXMuc2V0KHRleHREaXYsIHRleHREaXZQcm9wZXJ0aWVzKTtcblxuICAgICAgdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRleHREaXYpO1xuICAgIH0sXG5cbiAgICBfcmVuZGVyOiBmdW5jdGlvbiBUZXh0TGF5ZXJfcmVuZGVyKHRpbWVvdXQpIHtcbiAgICAgIGNvbnN0IGNhcGFiaWxpdHkgPSAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCk7XG4gICAgICBsZXQgc3R5bGVDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG5cbiAgICAgIGNhbnZhcy5tb3pPcGFxdWUgPSB0cnVlO1xuICAgICAgdGhpcy5fbGF5b3V0VGV4dEN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiwge1xuICAgICAgICBhbHBoYTogZmFsc2VcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5fdGV4dENvbnRlbnQpIHtcbiAgICAgICAgY29uc3QgdGV4dEl0ZW1zID0gdGhpcy5fdGV4dENvbnRlbnQuaXRlbXM7XG4gICAgICAgIGNvbnN0IHRleHRTdHlsZXMgPSB0aGlzLl90ZXh0Q29udGVudC5zdHlsZXM7XG5cbiAgICAgICAgdGhpcy5fcHJvY2Vzc0l0ZW1zKHRleHRJdGVtcywgdGV4dFN0eWxlcyk7XG5cbiAgICAgICAgY2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3RleHRDb250ZW50U3RyZWFtKSB7XG4gICAgICAgIGNvbnN0IHB1bXAgPSAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fcmVhZGVyLnJlYWQoKS50aGVuKCh7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGRvbmVcbiAgICAgICAgICB9KSA9PiB7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICBjYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHN0eWxlQ2FjaGUsIHZhbHVlLnN0eWxlcyk7XG5cbiAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NJdGVtcyh2YWx1ZS5pdGVtcywgc3R5bGVDYWNoZSk7XG5cbiAgICAgICAgICAgIHB1bXAoKTtcbiAgICAgICAgICB9LCBjYXBhYmlsaXR5LnJlamVjdCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fcmVhZGVyID0gdGhpcy5fdGV4dENvbnRlbnRTdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgICAgIHB1bXAoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTmVpdGhlciBcInRleHRDb250ZW50XCIgbm9yIFwidGV4dENvbnRlbnRTdHJlYW1cIicgKyBcIiBwYXJhbWV0ZXJzIHNwZWNpZmllZC5cIik7XG4gICAgICB9XG5cbiAgICAgIGNhcGFiaWxpdHkucHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgICAgc3R5bGVDYWNoZSA9IG51bGw7XG5cbiAgICAgICAgaWYgKCF0aW1lb3V0KSB7XG4gICAgICAgICAgcmVuZGVyKHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3JlbmRlclRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICByZW5kZXIodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJUaW1lciA9IG51bGw7XG4gICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMuX2NhcGFiaWxpdHkucmVqZWN0KTtcbiAgICB9LFxuICAgIGV4cGFuZFRleHREaXZzOiBmdW5jdGlvbiBUZXh0TGF5ZXJfZXhwYW5kVGV4dERpdnMoZXhwYW5kRGl2cykge1xuICAgICAgaWYgKCF0aGlzLl9lbmhhbmNlVGV4dFNlbGVjdGlvbiB8fCAhdGhpcy5fcmVuZGVyaW5nRG9uZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9ib3VuZHMgIT09IG51bGwpIHtcbiAgICAgICAgZXhwYW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9ib3VuZHMgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0cmFuc2Zvcm1CdWYgPSBbXSxcbiAgICAgICAgICAgIHBhZGRpbmdCdWYgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gdGhpcy5fdGV4dERpdnMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBjb25zdCBkaXYgPSB0aGlzLl90ZXh0RGl2c1tpXTtcblxuICAgICAgICBjb25zdCBkaXZQcm9wcyA9IHRoaXMuX3RleHREaXZQcm9wZXJ0aWVzLmdldChkaXYpO1xuXG4gICAgICAgIGlmIChkaXZQcm9wcy5pc1doaXRlc3BhY2UpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleHBhbmREaXZzKSB7XG4gICAgICAgICAgdHJhbnNmb3JtQnVmLmxlbmd0aCA9IDA7XG4gICAgICAgICAgcGFkZGluZ0J1Zi5sZW5ndGggPSAwO1xuXG4gICAgICAgICAgaWYgKGRpdlByb3BzLm9yaWdpbmFsVHJhbnNmb3JtKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1CdWYucHVzaChkaXZQcm9wcy5vcmlnaW5hbFRyYW5zZm9ybSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGRpdlByb3BzLnBhZGRpbmdUb3AgPiAwKSB7XG4gICAgICAgICAgICBwYWRkaW5nQnVmLnB1c2goYCR7ZGl2UHJvcHMucGFkZGluZ1RvcH1weGApO1xuICAgICAgICAgICAgdHJhbnNmb3JtQnVmLnB1c2goYHRyYW5zbGF0ZVkoJHstZGl2UHJvcHMucGFkZGluZ1RvcH1weClgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFkZGluZ0J1Zi5wdXNoKDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChkaXZQcm9wcy5wYWRkaW5nUmlnaHQgPiAwKSB7XG4gICAgICAgICAgICBwYWRkaW5nQnVmLnB1c2goYCR7ZGl2UHJvcHMucGFkZGluZ1JpZ2h0IC8gZGl2UHJvcHMuc2NhbGV9cHhgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFkZGluZ0J1Zi5wdXNoKDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChkaXZQcm9wcy5wYWRkaW5nQm90dG9tID4gMCkge1xuICAgICAgICAgICAgcGFkZGluZ0J1Zi5wdXNoKGAke2RpdlByb3BzLnBhZGRpbmdCb3R0b219cHhgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFkZGluZ0J1Zi5wdXNoKDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChkaXZQcm9wcy5wYWRkaW5nTGVmdCA+IDApIHtcbiAgICAgICAgICAgIHBhZGRpbmdCdWYucHVzaChgJHtkaXZQcm9wcy5wYWRkaW5nTGVmdCAvIGRpdlByb3BzLnNjYWxlfXB4YCk7XG4gICAgICAgICAgICB0cmFuc2Zvcm1CdWYucHVzaChgdHJhbnNsYXRlWCgkey1kaXZQcm9wcy5wYWRkaW5nTGVmdCAvIGRpdlByb3BzLnNjYWxlfXB4KWApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYWRkaW5nQnVmLnB1c2goMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGl2LnN0eWxlLnBhZGRpbmcgPSBwYWRkaW5nQnVmLmpvaW4oXCIgXCIpO1xuXG4gICAgICAgICAgaWYgKHRyYW5zZm9ybUJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRpdi5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1CdWYuam9pbihcIiBcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpdi5zdHlsZS5wYWRkaW5nID0gbnVsbDtcbiAgICAgICAgICBkaXYuc3R5bGUudHJhbnNmb3JtID0gZGl2UHJvcHMub3JpZ2luYWxUcmFuc2Zvcm07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gcmVuZGVyVGV4dExheWVyKHJlbmRlclBhcmFtZXRlcnMpIHtcbiAgICB2YXIgdGFzayA9IG5ldyBUZXh0TGF5ZXJSZW5kZXJUYXNrKHtcbiAgICAgIHRleHRDb250ZW50OiByZW5kZXJQYXJhbWV0ZXJzLnRleHRDb250ZW50LFxuICAgICAgdGV4dENvbnRlbnRTdHJlYW06IHJlbmRlclBhcmFtZXRlcnMudGV4dENvbnRlbnRTdHJlYW0sXG4gICAgICBjb250YWluZXI6IHJlbmRlclBhcmFtZXRlcnMuY29udGFpbmVyLFxuICAgICAgdmlld3BvcnQ6IHJlbmRlclBhcmFtZXRlcnMudmlld3BvcnQsXG4gICAgICB0ZXh0RGl2czogcmVuZGVyUGFyYW1ldGVycy50ZXh0RGl2cyxcbiAgICAgIHRleHRDb250ZW50SXRlbXNTdHI6IHJlbmRlclBhcmFtZXRlcnMudGV4dENvbnRlbnRJdGVtc1N0cixcbiAgICAgIGVuaGFuY2VUZXh0U2VsZWN0aW9uOiByZW5kZXJQYXJhbWV0ZXJzLmVuaGFuY2VUZXh0U2VsZWN0aW9uXG4gICAgfSk7XG5cbiAgICB0YXNrLl9yZW5kZXIocmVuZGVyUGFyYW1ldGVycy50aW1lb3V0KTtcblxuICAgIHJldHVybiB0YXNrO1xuICB9XG5cbiAgcmV0dXJuIHJlbmRlclRleHRMYXllcjtcbn0oKTtcblxuZXhwb3J0cy5yZW5kZXJUZXh0TGF5ZXIgPSByZW5kZXJUZXh0TGF5ZXI7XG5cbi8qKiovIH0pLFxuLyogMjEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuU1ZHR3JhcGhpY3MgPSB2b2lkIDA7XG5cbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMik7XG5cbnZhciBfZGlzcGxheV91dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG5cbnZhciBfaXNfbm9kZSA9IF9fd19wZGZqc19yZXF1aXJlX18oNCk7XG5cbmxldCBTVkdHcmFwaGljcyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkOiBTVkdHcmFwaGljc1wiKTtcbn07XG5cbmV4cG9ydHMuU1ZHR3JhcGhpY3MgPSBTVkdHcmFwaGljcztcbntcbiAgY29uc3QgU1ZHX0RFRkFVTFRTID0ge1xuICAgIGZvbnRTdHlsZTogXCJub3JtYWxcIixcbiAgICBmb250V2VpZ2h0OiBcIm5vcm1hbFwiLFxuICAgIGZpbGxDb2xvcjogXCIjMDAwMDAwXCJcbiAgfTtcbiAgY29uc3QgWE1MX05TID0gXCJodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2VcIjtcbiAgY29uc3QgWExJTktfTlMgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIjtcbiAgY29uc3QgTElORV9DQVBfU1RZTEVTID0gW1wiYnV0dFwiLCBcInJvdW5kXCIsIFwic3F1YXJlXCJdO1xuICBjb25zdCBMSU5FX0pPSU5fU1RZTEVTID0gW1wibWl0ZXJcIiwgXCJyb3VuZFwiLCBcImJldmVsXCJdO1xuXG4gIGNvbnN0IGNvbnZlcnRJbWdEYXRhVG9QbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgUE5HX0hFQURFUiA9IG5ldyBVaW50OEFycmF5KFsweDg5LCAweDUwLCAweDRlLCAweDQ3LCAweDBkLCAweDBhLCAweDFhLCAweDBhXSk7XG4gICAgY29uc3QgQ0hVTktfV1JBUFBFUl9TSVpFID0gMTI7XG4gICAgY29uc3QgY3JjVGFibGUgPSBuZXcgSW50MzJBcnJheSgyNTYpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgbGV0IGMgPSBpO1xuXG4gICAgICBmb3IgKGxldCBoID0gMDsgaCA8IDg7IGgrKykge1xuICAgICAgICBpZiAoYyAmIDEpIHtcbiAgICAgICAgICBjID0gMHhlZGI4ODMyMCBeIGMgPj4gMSAmIDB4N2ZmZmZmZmY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYyA9IGMgPj4gMSAmIDB4N2ZmZmZmZmY7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY3JjVGFibGVbaV0gPSBjO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyYzMyKGRhdGEsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIGxldCBjcmMgPSAtMTtcblxuICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IChjcmMgXiBkYXRhW2ldKSAmIDB4ZmY7XG4gICAgICAgIGNvbnN0IGIgPSBjcmNUYWJsZVthXTtcbiAgICAgICAgY3JjID0gY3JjID4+PiA4IF4gYjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNyYyBeIC0xO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdyaXRlUG5nQ2h1bmsodHlwZSwgYm9keSwgZGF0YSwgb2Zmc2V0KSB7XG4gICAgICBsZXQgcCA9IG9mZnNldDtcbiAgICAgIGNvbnN0IGxlbiA9IGJvZHkubGVuZ3RoO1xuICAgICAgZGF0YVtwXSA9IGxlbiA+PiAyNCAmIDB4ZmY7XG4gICAgICBkYXRhW3AgKyAxXSA9IGxlbiA+PiAxNiAmIDB4ZmY7XG4gICAgICBkYXRhW3AgKyAyXSA9IGxlbiA+PiA4ICYgMHhmZjtcbiAgICAgIGRhdGFbcCArIDNdID0gbGVuICYgMHhmZjtcbiAgICAgIHAgKz0gNDtcbiAgICAgIGRhdGFbcF0gPSB0eXBlLmNoYXJDb2RlQXQoMCkgJiAweGZmO1xuICAgICAgZGF0YVtwICsgMV0gPSB0eXBlLmNoYXJDb2RlQXQoMSkgJiAweGZmO1xuICAgICAgZGF0YVtwICsgMl0gPSB0eXBlLmNoYXJDb2RlQXQoMikgJiAweGZmO1xuICAgICAgZGF0YVtwICsgM10gPSB0eXBlLmNoYXJDb2RlQXQoMykgJiAweGZmO1xuICAgICAgcCArPSA0O1xuICAgICAgZGF0YS5zZXQoYm9keSwgcCk7XG4gICAgICBwICs9IGJvZHkubGVuZ3RoO1xuICAgICAgY29uc3QgY3JjID0gY3JjMzIoZGF0YSwgb2Zmc2V0ICsgNCwgcCk7XG4gICAgICBkYXRhW3BdID0gY3JjID4+IDI0ICYgMHhmZjtcbiAgICAgIGRhdGFbcCArIDFdID0gY3JjID4+IDE2ICYgMHhmZjtcbiAgICAgIGRhdGFbcCArIDJdID0gY3JjID4+IDggJiAweGZmO1xuICAgICAgZGF0YVtwICsgM10gPSBjcmMgJiAweGZmO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkbGVyMzIoZGF0YSwgc3RhcnQsIGVuZCkge1xuICAgICAgbGV0IGEgPSAxO1xuICAgICAgbGV0IGIgPSAwO1xuXG4gICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgICBhID0gKGEgKyAoZGF0YVtpXSAmIDB4ZmYpKSAlIDY1NTIxO1xuICAgICAgICBiID0gKGIgKyBhKSAlIDY1NTIxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYiA8PCAxNiB8IGE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmbGF0ZVN5bmMobGl0ZXJhbHMpIHtcbiAgICAgIGlmICghX2lzX25vZGUuaXNOb2RlSlMpIHtcbiAgICAgICAgcmV0dXJuIGRlZmxhdGVTeW5jVW5jb21wcmVzc2VkKGxpdGVyYWxzKTtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IGlucHV0O1xuXG4gICAgICAgIGlmIChwYXJzZUludChwcm9jZXNzLnZlcnNpb25zLm5vZGUpID49IDgpIHtcbiAgICAgICAgICBpbnB1dCA9IGxpdGVyYWxzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlucHV0ID0gQnVmZmVyLmZyb20obGl0ZXJhbHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gcmVxdWlyZShcInpsaWJcIikuZGVmbGF0ZVN5bmMoaW5wdXQsIHtcbiAgICAgICAgICBsZXZlbDogOVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gb3V0cHV0IGluc3RhbmNlb2YgVWludDhBcnJheSA/IG91dHB1dCA6IG5ldyBVaW50OEFycmF5KG91dHB1dCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICgwLCBfdXRpbC53YXJuKShcIk5vdCBjb21wcmVzc2luZyBQTkcgYmVjYXVzZSB6bGliLmRlZmxhdGVTeW5jIGlzIHVuYXZhaWxhYmxlOiBcIiArIGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVmbGF0ZVN5bmNVbmNvbXByZXNzZWQobGl0ZXJhbHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmxhdGVTeW5jVW5jb21wcmVzc2VkKGxpdGVyYWxzKSB7XG4gICAgICBsZXQgbGVuID0gbGl0ZXJhbHMubGVuZ3RoO1xuICAgICAgY29uc3QgbWF4QmxvY2tMZW5ndGggPSAweGZmZmY7XG4gICAgICBjb25zdCBkZWZsYXRlQmxvY2tzID0gTWF0aC5jZWlsKGxlbiAvIG1heEJsb2NrTGVuZ3RoKTtcbiAgICAgIGNvbnN0IGlkYXQgPSBuZXcgVWludDhBcnJheSgyICsgbGVuICsgZGVmbGF0ZUJsb2NrcyAqIDUgKyA0KTtcbiAgICAgIGxldCBwaSA9IDA7XG4gICAgICBpZGF0W3BpKytdID0gMHg3ODtcbiAgICAgIGlkYXRbcGkrK10gPSAweDljO1xuICAgICAgbGV0IHBvcyA9IDA7XG5cbiAgICAgIHdoaWxlIChsZW4gPiBtYXhCbG9ja0xlbmd0aCkge1xuICAgICAgICBpZGF0W3BpKytdID0gMHgwMDtcbiAgICAgICAgaWRhdFtwaSsrXSA9IDB4ZmY7XG4gICAgICAgIGlkYXRbcGkrK10gPSAweGZmO1xuICAgICAgICBpZGF0W3BpKytdID0gMHgwMDtcbiAgICAgICAgaWRhdFtwaSsrXSA9IDB4MDA7XG4gICAgICAgIGlkYXQuc2V0KGxpdGVyYWxzLnN1YmFycmF5KHBvcywgcG9zICsgbWF4QmxvY2tMZW5ndGgpLCBwaSk7XG4gICAgICAgIHBpICs9IG1heEJsb2NrTGVuZ3RoO1xuICAgICAgICBwb3MgKz0gbWF4QmxvY2tMZW5ndGg7XG4gICAgICAgIGxlbiAtPSBtYXhCbG9ja0xlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWRhdFtwaSsrXSA9IDB4MDE7XG4gICAgICBpZGF0W3BpKytdID0gbGVuICYgMHhmZjtcbiAgICAgIGlkYXRbcGkrK10gPSBsZW4gPj4gOCAmIDB4ZmY7XG4gICAgICBpZGF0W3BpKytdID0gfmxlbiAmIDB4ZmZmZiAmIDB4ZmY7XG4gICAgICBpZGF0W3BpKytdID0gKH5sZW4gJiAweGZmZmYpID4+IDggJiAweGZmO1xuICAgICAgaWRhdC5zZXQobGl0ZXJhbHMuc3ViYXJyYXkocG9zKSwgcGkpO1xuICAgICAgcGkgKz0gbGl0ZXJhbHMubGVuZ3RoIC0gcG9zO1xuICAgICAgY29uc3QgYWRsZXIgPSBhZGxlcjMyKGxpdGVyYWxzLCAwLCBsaXRlcmFscy5sZW5ndGgpO1xuICAgICAgaWRhdFtwaSsrXSA9IGFkbGVyID4+IDI0ICYgMHhmZjtcbiAgICAgIGlkYXRbcGkrK10gPSBhZGxlciA+PiAxNiAmIDB4ZmY7XG4gICAgICBpZGF0W3BpKytdID0gYWRsZXIgPj4gOCAmIDB4ZmY7XG4gICAgICBpZGF0W3BpKytdID0gYWRsZXIgJiAweGZmO1xuICAgICAgcmV0dXJuIGlkYXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5jb2RlKGltZ0RhdGEsIGtpbmQsIGZvcmNlRGF0YVNjaGVtYSwgaXNNYXNrKSB7XG4gICAgICBjb25zdCB3aWR0aCA9IGltZ0RhdGEud2lkdGg7XG4gICAgICBjb25zdCBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodDtcbiAgICAgIGxldCBiaXREZXB0aCwgY29sb3JUeXBlLCBsaW5lU2l6ZTtcbiAgICAgIGNvbnN0IGJ5dGVzID0gaW1nRGF0YS5kYXRhO1xuXG4gICAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgICAgY2FzZSBfdXRpbC5JbWFnZUtpbmQuR1JBWVNDQUxFXzFCUFA6XG4gICAgICAgICAgY29sb3JUeXBlID0gMDtcbiAgICAgICAgICBiaXREZXB0aCA9IDE7XG4gICAgICAgICAgbGluZVNpemUgPSB3aWR0aCArIDcgPj4gMztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIF91dGlsLkltYWdlS2luZC5SR0JfMjRCUFA6XG4gICAgICAgICAgY29sb3JUeXBlID0gMjtcbiAgICAgICAgICBiaXREZXB0aCA9IDg7XG4gICAgICAgICAgbGluZVNpemUgPSB3aWR0aCAqIDM7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBfdXRpbC5JbWFnZUtpbmQuUkdCQV8zMkJQUDpcbiAgICAgICAgICBjb2xvclR5cGUgPSA2O1xuICAgICAgICAgIGJpdERlcHRoID0gODtcbiAgICAgICAgICBsaW5lU2l6ZSA9IHdpZHRoICogNDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZm9ybWF0XCIpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBsaXRlcmFscyA9IG5ldyBVaW50OEFycmF5KCgxICsgbGluZVNpemUpICogaGVpZ2h0KTtcbiAgICAgIGxldCBvZmZzZXRMaXRlcmFscyA9IDAsXG4gICAgICAgICAgb2Zmc2V0Qnl0ZXMgPSAwO1xuXG4gICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgKyt5KSB7XG4gICAgICAgIGxpdGVyYWxzW29mZnNldExpdGVyYWxzKytdID0gMDtcbiAgICAgICAgbGl0ZXJhbHMuc2V0KGJ5dGVzLnN1YmFycmF5KG9mZnNldEJ5dGVzLCBvZmZzZXRCeXRlcyArIGxpbmVTaXplKSwgb2Zmc2V0TGl0ZXJhbHMpO1xuICAgICAgICBvZmZzZXRCeXRlcyArPSBsaW5lU2l6ZTtcbiAgICAgICAgb2Zmc2V0TGl0ZXJhbHMgKz0gbGluZVNpemU7XG4gICAgICB9XG5cbiAgICAgIGlmIChraW5kID09PSBfdXRpbC5JbWFnZUtpbmQuR1JBWVNDQUxFXzFCUFAgJiYgaXNNYXNrKSB7XG4gICAgICAgIG9mZnNldExpdGVyYWxzID0gMDtcblxuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgb2Zmc2V0TGl0ZXJhbHMrKztcblxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZVNpemU7IGkrKykge1xuICAgICAgICAgICAgbGl0ZXJhbHNbb2Zmc2V0TGl0ZXJhbHMrK10gXj0gMHhmZjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgaWhkciA9IG5ldyBVaW50OEFycmF5KFt3aWR0aCA+PiAyNCAmIDB4ZmYsIHdpZHRoID4+IDE2ICYgMHhmZiwgd2lkdGggPj4gOCAmIDB4ZmYsIHdpZHRoICYgMHhmZiwgaGVpZ2h0ID4+IDI0ICYgMHhmZiwgaGVpZ2h0ID4+IDE2ICYgMHhmZiwgaGVpZ2h0ID4+IDggJiAweGZmLCBoZWlnaHQgJiAweGZmLCBiaXREZXB0aCwgY29sb3JUeXBlLCAweDAwLCAweDAwLCAweDAwXSk7XG4gICAgICBjb25zdCBpZGF0ID0gZGVmbGF0ZVN5bmMobGl0ZXJhbHMpO1xuICAgICAgY29uc3QgcG5nTGVuZ3RoID0gUE5HX0hFQURFUi5sZW5ndGggKyBDSFVOS19XUkFQUEVSX1NJWkUgKiAzICsgaWhkci5sZW5ndGggKyBpZGF0Lmxlbmd0aDtcbiAgICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShwbmdMZW5ndGgpO1xuICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICBkYXRhLnNldChQTkdfSEVBREVSLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IFBOR19IRUFERVIubGVuZ3RoO1xuICAgICAgd3JpdGVQbmdDaHVuayhcIklIRFJcIiwgaWhkciwgZGF0YSwgb2Zmc2V0KTtcbiAgICAgIG9mZnNldCArPSBDSFVOS19XUkFQUEVSX1NJWkUgKyBpaGRyLmxlbmd0aDtcbiAgICAgIHdyaXRlUG5nQ2h1bmsoXCJJREFUQVwiLCBpZGF0LCBkYXRhLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IENIVU5LX1dSQVBQRVJfU0laRSArIGlkYXQubGVuZ3RoO1xuICAgICAgd3JpdGVQbmdDaHVuayhcIklFTkRcIiwgbmV3IFVpbnQ4QXJyYXkoMCksIGRhdGEsIG9mZnNldCk7XG4gICAgICByZXR1cm4gKDAsIF91dGlsLmNyZWF0ZU9iamVjdFVSTCkoZGF0YSwgXCJpbWFnZS9wbmdcIiwgZm9yY2VEYXRhU2NoZW1hKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gY29udmVydEltZ0RhdGFUb1BuZyhpbWdEYXRhLCBmb3JjZURhdGFTY2hlbWEsIGlzTWFzaykge1xuICAgICAgY29uc3Qga2luZCA9IGltZ0RhdGEua2luZCA9PT0gdW5kZWZpbmVkID8gX3V0aWwuSW1hZ2VLaW5kLkdSQVlTQ0FMRV8xQlBQIDogaW1nRGF0YS5raW5kO1xuICAgICAgcmV0dXJuIGVuY29kZShpbWdEYXRhLCBraW5kLCBmb3JjZURhdGFTY2hlbWEsIGlzTWFzayk7XG4gICAgfTtcbiAgfSgpO1xuXG4gIGNsYXNzIFNWR0V4dHJhU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgdGhpcy5mb250U2l6ZVNjYWxlID0gMTtcbiAgICAgIHRoaXMuZm9udFdlaWdodCA9IFNWR19ERUZBVUxUUy5mb250V2VpZ2h0O1xuICAgICAgdGhpcy5mb250U2l6ZSA9IDA7XG4gICAgICB0aGlzLnRleHRNYXRyaXggPSBfdXRpbC5JREVOVElUWV9NQVRSSVg7XG4gICAgICB0aGlzLmZvbnRNYXRyaXggPSBfdXRpbC5GT05UX0lERU5USVRZX01BVFJJWDtcbiAgICAgIHRoaXMubGVhZGluZyA9IDA7XG4gICAgICB0aGlzLnRleHRSZW5kZXJpbmdNb2RlID0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTDtcbiAgICAgIHRoaXMudGV4dE1hdHJpeFNjYWxlID0gMTtcbiAgICAgIHRoaXMueCA9IDA7XG4gICAgICB0aGlzLnkgPSAwO1xuICAgICAgdGhpcy5saW5lWCA9IDA7XG4gICAgICB0aGlzLmxpbmVZID0gMDtcbiAgICAgIHRoaXMuY2hhclNwYWNpbmcgPSAwO1xuICAgICAgdGhpcy53b3JkU3BhY2luZyA9IDA7XG4gICAgICB0aGlzLnRleHRIU2NhbGUgPSAxO1xuICAgICAgdGhpcy50ZXh0UmlzZSA9IDA7XG4gICAgICB0aGlzLmZpbGxDb2xvciA9IFNWR19ERUZBVUxUUy5maWxsQ29sb3I7XG4gICAgICB0aGlzLnN0cm9rZUNvbG9yID0gXCIjMDAwMDAwXCI7XG4gICAgICB0aGlzLmZpbGxBbHBoYSA9IDE7XG4gICAgICB0aGlzLnN0cm9rZUFscGhhID0gMTtcbiAgICAgIHRoaXMubGluZVdpZHRoID0gMTtcbiAgICAgIHRoaXMubGluZUpvaW4gPSBcIlwiO1xuICAgICAgdGhpcy5saW5lQ2FwID0gXCJcIjtcbiAgICAgIHRoaXMubWl0ZXJMaW1pdCA9IDA7XG4gICAgICB0aGlzLmRhc2hBcnJheSA9IFtdO1xuICAgICAgdGhpcy5kYXNoUGhhc2UgPSAwO1xuICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBbXTtcbiAgICAgIHRoaXMuYWN0aXZlQ2xpcFVybCA9IG51bGw7XG4gICAgICB0aGlzLmNsaXBHcm91cCA9IG51bGw7XG4gICAgICB0aGlzLm1hc2tJZCA9IFwiXCI7XG4gICAgfVxuXG4gICAgY2xvbmUoKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZSh0aGlzKTtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50UG9pbnQoeCwgeSkge1xuICAgICAgdGhpcy54ID0geDtcbiAgICAgIHRoaXMueSA9IHk7XG4gICAgfVxuXG4gIH1cblxuICBmdW5jdGlvbiBvcExpc3RUb1RyZWUob3BMaXN0KSB7XG4gICAgbGV0IG9wVHJlZSA9IFtdO1xuICAgIGNvbnN0IHRtcCA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBvcExpc3RFbGVtZW50IG9mIG9wTGlzdCkge1xuICAgICAgaWYgKG9wTGlzdEVsZW1lbnQuZm4gPT09IFwic2F2ZVwiKSB7XG4gICAgICAgIG9wVHJlZS5wdXNoKHtcbiAgICAgICAgICBmbklkOiA5MixcbiAgICAgICAgICBmbjogXCJncm91cFwiLFxuICAgICAgICAgIGl0ZW1zOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgdG1wLnB1c2gob3BUcmVlKTtcbiAgICAgICAgb3BUcmVlID0gb3BUcmVlW29wVHJlZS5sZW5ndGggLSAxXS5pdGVtcztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcExpc3RFbGVtZW50LmZuID09PSBcInJlc3RvcmVcIikge1xuICAgICAgICBvcFRyZWUgPSB0bXAucG9wKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcFRyZWUucHVzaChvcExpc3RFbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3BUcmVlO1xuICB9XG5cbiAgZnVuY3Rpb24gcGYodmFsdWUpIHtcbiAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgIH1cblxuICAgIGNvbnN0IHMgPSB2YWx1ZS50b0ZpeGVkKDEwKTtcbiAgICBsZXQgaSA9IHMubGVuZ3RoIC0gMTtcblxuICAgIGlmIChzW2ldICE9PSBcIjBcIikge1xuICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgZG8ge1xuICAgICAgaS0tO1xuICAgIH0gd2hpbGUgKHNbaV0gPT09IFwiMFwiKTtcblxuICAgIHJldHVybiBzLnN1YnN0cmluZygwLCBzW2ldID09PSBcIi5cIiA/IGkgOiBpICsgMSk7XG4gIH1cblxuICBmdW5jdGlvbiBwbShtKSB7XG4gICAgaWYgKG1bNF0gPT09IDAgJiYgbVs1XSA9PT0gMCkge1xuICAgICAgaWYgKG1bMV0gPT09IDAgJiYgbVsyXSA9PT0gMCkge1xuICAgICAgICBpZiAobVswXSA9PT0gMSAmJiBtWzNdID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYHNjYWxlKCR7cGYobVswXSl9ICR7cGYobVszXSl9KWA7XG4gICAgICB9XG5cbiAgICAgIGlmIChtWzBdID09PSBtWzNdICYmIG1bMV0gPT09IC1tWzJdKSB7XG4gICAgICAgIGNvbnN0IGEgPSBNYXRoLmFjb3MobVswXSkgKiAxODAgLyBNYXRoLlBJO1xuICAgICAgICByZXR1cm4gYHJvdGF0ZSgke3BmKGEpfSlgO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobVswXSA9PT0gMSAmJiBtWzFdID09PSAwICYmIG1bMl0gPT09IDAgJiYgbVszXSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gYHRyYW5zbGF0ZSgke3BmKG1bNF0pfSAke3BmKG1bNV0pfSlgO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBgbWF0cml4KCR7cGYobVswXSl9ICR7cGYobVsxXSl9ICR7cGYobVsyXSl9ICR7cGYobVszXSl9ICR7cGYobVs0XSl9IGAgKyBgJHtwZihtWzVdKX0pYDtcbiAgfVxuXG4gIGxldCBjbGlwQ291bnQgPSAwO1xuICBsZXQgbWFza0NvdW50ID0gMDtcbiAgbGV0IHNoYWRpbmdDb3VudCA9IDA7XG4gIGV4cG9ydHMuU1ZHR3JhcGhpY3MgPSBTVkdHcmFwaGljcyA9IGNsYXNzIFNWR0dyYXBoaWNzIHtcbiAgICBjb25zdHJ1Y3Rvcihjb21tb25PYmpzLCBvYmpzLCBmb3JjZURhdGFTY2hlbWEgPSBmYWxzZSkge1xuICAgICAgdGhpcy5zdmdGYWN0b3J5ID0gbmV3IF9kaXNwbGF5X3V0aWxzLkRPTVNWR0ZhY3RvcnkoKTtcbiAgICAgIHRoaXMuY3VycmVudCA9IG5ldyBTVkdFeHRyYVN0YXRlKCk7XG4gICAgICB0aGlzLnRyYW5zZm9ybU1hdHJpeCA9IF91dGlsLklERU5USVRZX01BVFJJWDtcbiAgICAgIHRoaXMudHJhbnNmb3JtU3RhY2sgPSBbXTtcbiAgICAgIHRoaXMuZXh0cmFTdGFjayA9IFtdO1xuICAgICAgdGhpcy5jb21tb25PYmpzID0gY29tbW9uT2JqcztcbiAgICAgIHRoaXMub2JqcyA9IG9ianM7XG4gICAgICB0aGlzLnBlbmRpbmdDbGlwID0gbnVsbDtcbiAgICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IGZhbHNlO1xuICAgICAgdGhpcy5lbWJlZEZvbnRzID0gZmFsc2U7XG4gICAgICB0aGlzLmVtYmVkZGVkRm9udHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdGhpcy5jc3NTdHlsZSA9IG51bGw7XG4gICAgICB0aGlzLmZvcmNlRGF0YVNjaGVtYSA9ICEhZm9yY2VEYXRhU2NoZW1hO1xuICAgICAgdGhpcy5fb3BlcmF0b3JJZE1hcHBpbmcgPSBbXTtcblxuICAgICAgZm9yIChjb25zdCBvcCBpbiBfdXRpbC5PUFMpIHtcbiAgICAgICAgdGhpcy5fb3BlcmF0b3JJZE1hcHBpbmdbX3V0aWwuT1BTW29wXV0gPSBvcDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzYXZlKCkge1xuICAgICAgdGhpcy50cmFuc2Zvcm1TdGFjay5wdXNoKHRoaXMudHJhbnNmb3JtTWF0cml4KTtcbiAgICAgIGNvbnN0IG9sZCA9IHRoaXMuY3VycmVudDtcbiAgICAgIHRoaXMuZXh0cmFTdGFjay5wdXNoKG9sZCk7XG4gICAgICB0aGlzLmN1cnJlbnQgPSBvbGQuY2xvbmUoKTtcbiAgICB9XG5cbiAgICByZXN0b3JlKCkge1xuICAgICAgdGhpcy50cmFuc2Zvcm1NYXRyaXggPSB0aGlzLnRyYW5zZm9ybVN0YWNrLnBvcCgpO1xuICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy5leHRyYVN0YWNrLnBvcCgpO1xuICAgICAgdGhpcy5wZW5kaW5nQ2xpcCA9IG51bGw7XG4gICAgICB0aGlzLnRncnAgPSBudWxsO1xuICAgIH1cblxuICAgIGdyb3VwKGl0ZW1zKSB7XG4gICAgICB0aGlzLnNhdmUoKTtcbiAgICAgIHRoaXMuZXhlY3V0ZU9wVHJlZShpdGVtcyk7XG4gICAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICB9XG5cbiAgICBsb2FkRGVwZW5kZW5jaWVzKG9wZXJhdG9yTGlzdCkge1xuICAgICAgY29uc3QgZm5BcnJheSA9IG9wZXJhdG9yTGlzdC5mbkFycmF5O1xuICAgICAgY29uc3QgYXJnc0FycmF5ID0gb3BlcmF0b3JMaXN0LmFyZ3NBcnJheTtcblxuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZm5BcnJheS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGlmIChmbkFycmF5W2ldICE9PSBfdXRpbC5PUFMuZGVwZW5kZW5jeSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBvYmogb2YgYXJnc0FycmF5W2ldKSB7XG4gICAgICAgICAgY29uc3Qgb2Jqc1Bvb2wgPSBvYmouc3RhcnRzV2l0aChcImdfXCIpID8gdGhpcy5jb21tb25PYmpzIDogdGhpcy5vYmpzO1xuICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIG9ianNQb29sLmdldChvYmosIHJlc29sdmUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuY3VycmVudC5kZXBlbmRlbmNpZXMucHVzaChwcm9taXNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwodGhpcy5jdXJyZW50LmRlcGVuZGVuY2llcyk7XG4gICAgfVxuXG4gICAgdHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybU1hdHJpeCA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHRoaXMudHJhbnNmb3JtTWF0cml4ID0gX3V0aWwuVXRpbC50cmFuc2Zvcm0odGhpcy50cmFuc2Zvcm1NYXRyaXgsIHRyYW5zZm9ybU1hdHJpeCk7XG4gICAgICB0aGlzLnRncnAgPSBudWxsO1xuICAgIH1cblxuICAgIGdldFNWRyhvcGVyYXRvckxpc3QsIHZpZXdwb3J0KSB7XG4gICAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG5cbiAgICAgIGNvbnN0IHN2Z0VsZW1lbnQgPSB0aGlzLl9pbml0aWFsaXplKHZpZXdwb3J0KTtcblxuICAgICAgcmV0dXJuIHRoaXMubG9hZERlcGVuZGVuY2llcyhvcGVyYXRvckxpc3QpLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybU1hdHJpeCA9IF91dGlsLklERU5USVRZX01BVFJJWDtcbiAgICAgICAgdGhpcy5leGVjdXRlT3BUcmVlKHRoaXMuY29udmVydE9wTGlzdChvcGVyYXRvckxpc3QpKTtcbiAgICAgICAgcmV0dXJuIHN2Z0VsZW1lbnQ7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb252ZXJ0T3BMaXN0KG9wZXJhdG9yTGlzdCkge1xuICAgICAgY29uc3Qgb3BlcmF0b3JJZE1hcHBpbmcgPSB0aGlzLl9vcGVyYXRvcklkTWFwcGluZztcbiAgICAgIGNvbnN0IGFyZ3NBcnJheSA9IG9wZXJhdG9yTGlzdC5hcmdzQXJyYXk7XG4gICAgICBjb25zdCBmbkFycmF5ID0gb3BlcmF0b3JMaXN0LmZuQXJyYXk7XG4gICAgICBjb25zdCBvcExpc3QgPSBbXTtcblxuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZm5BcnJheS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGZuSWQgPSBmbkFycmF5W2ldO1xuICAgICAgICBvcExpc3QucHVzaCh7XG4gICAgICAgICAgZm5JZCxcbiAgICAgICAgICBmbjogb3BlcmF0b3JJZE1hcHBpbmdbZm5JZF0sXG4gICAgICAgICAgYXJnczogYXJnc0FycmF5W2ldXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3BMaXN0VG9UcmVlKG9wTGlzdCk7XG4gICAgfVxuXG4gICAgZXhlY3V0ZU9wVHJlZShvcFRyZWUpIHtcbiAgICAgIGZvciAoY29uc3Qgb3BUcmVlRWxlbWVudCBvZiBvcFRyZWUpIHtcbiAgICAgICAgY29uc3QgZm4gPSBvcFRyZWVFbGVtZW50LmZuO1xuICAgICAgICBjb25zdCBmbklkID0gb3BUcmVlRWxlbWVudC5mbklkO1xuICAgICAgICBjb25zdCBhcmdzID0gb3BUcmVlRWxlbWVudC5hcmdzO1xuXG4gICAgICAgIHN3aXRjaCAoZm5JZCB8IDApIHtcbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5iZWdpblRleHQ6XG4gICAgICAgICAgICB0aGlzLmJlZ2luVGV4dCgpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5kZXBlbmRlbmN5OlxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRMZWFkaW5nOlxuICAgICAgICAgICAgdGhpcy5zZXRMZWFkaW5nKGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRMZWFkaW5nTW92ZVRleHQ6XG4gICAgICAgICAgICB0aGlzLnNldExlYWRpbmdNb3ZlVGV4dChhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0Rm9udDpcbiAgICAgICAgICAgIHRoaXMuc2V0Rm9udChhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2hvd1RleHQ6XG4gICAgICAgICAgICB0aGlzLnNob3dUZXh0KGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5zaG93U3BhY2VkVGV4dDpcbiAgICAgICAgICAgIHRoaXMuc2hvd1RleHQoYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLmVuZFRleHQ6XG4gICAgICAgICAgICB0aGlzLmVuZFRleHQoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBfdXRpbC5PUFMubW92ZVRleHQ6XG4gICAgICAgICAgICB0aGlzLm1vdmVUZXh0KGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRDaGFyU3BhY2luZzpcbiAgICAgICAgICAgIHRoaXMuc2V0Q2hhclNwYWNpbmcoYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldFdvcmRTcGFjaW5nOlxuICAgICAgICAgICAgdGhpcy5zZXRXb3JkU3BhY2luZyhhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0SFNjYWxlOlxuICAgICAgICAgICAgdGhpcy5zZXRIU2NhbGUoYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldFRleHRNYXRyaXg6XG4gICAgICAgICAgICB0aGlzLnNldFRleHRNYXRyaXgoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSwgYXJnc1s1XSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldFRleHRSaXNlOlxuICAgICAgICAgICAgdGhpcy5zZXRUZXh0UmlzZShhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0VGV4dFJlbmRlcmluZ01vZGU6XG4gICAgICAgICAgICB0aGlzLnNldFRleHRSZW5kZXJpbmdNb2RlKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRMaW5lV2lkdGg6XG4gICAgICAgICAgICB0aGlzLnNldExpbmVXaWR0aChhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0TGluZUpvaW46XG4gICAgICAgICAgICB0aGlzLnNldExpbmVKb2luKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRMaW5lQ2FwOlxuICAgICAgICAgICAgdGhpcy5zZXRMaW5lQ2FwKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRNaXRlckxpbWl0OlxuICAgICAgICAgICAgdGhpcy5zZXRNaXRlckxpbWl0KGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRGaWxsUkdCQ29sb3I6XG4gICAgICAgICAgICB0aGlzLnNldEZpbGxSR0JDb2xvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0U3Ryb2tlUkdCQ29sb3I6XG4gICAgICAgICAgICB0aGlzLnNldFN0cm9rZVJHQkNvbG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRTdHJva2VDb2xvck46XG4gICAgICAgICAgICB0aGlzLnNldFN0cm9rZUNvbG9yTihhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0RmlsbENvbG9yTjpcbiAgICAgICAgICAgIHRoaXMuc2V0RmlsbENvbG9yTihhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2hhZGluZ0ZpbGw6XG4gICAgICAgICAgICB0aGlzLnNoYWRpbmdGaWxsKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXREYXNoOlxuICAgICAgICAgICAgdGhpcy5zZXREYXNoKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRSZW5kZXJpbmdJbnRlbnQ6XG4gICAgICAgICAgICB0aGlzLnNldFJlbmRlcmluZ0ludGVudChhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0RmxhdG5lc3M6XG4gICAgICAgICAgICB0aGlzLnNldEZsYXRuZXNzKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRHU3RhdGU6XG4gICAgICAgICAgICB0aGlzLnNldEdTdGF0ZShhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBfdXRpbC5PUFMuZmlsbDpcbiAgICAgICAgICAgIHRoaXMuZmlsbCgpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5lb0ZpbGw6XG4gICAgICAgICAgICB0aGlzLmVvRmlsbCgpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5zdHJva2U6XG4gICAgICAgICAgICB0aGlzLnN0cm9rZSgpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5maWxsU3Ryb2tlOlxuICAgICAgICAgICAgdGhpcy5maWxsU3Ryb2tlKCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLmVvRmlsbFN0cm9rZTpcbiAgICAgICAgICAgIHRoaXMuZW9GaWxsU3Ryb2tlKCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLmNsaXA6XG4gICAgICAgICAgICB0aGlzLmNsaXAoXCJub256ZXJvXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5lb0NsaXA6XG4gICAgICAgICAgICB0aGlzLmNsaXAoXCJldmVub2RkXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5wYWludFNvbGlkQ29sb3JJbWFnZU1hc2s6XG4gICAgICAgICAgICB0aGlzLnBhaW50U29saWRDb2xvckltYWdlTWFzaygpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5wYWludEltYWdlWE9iamVjdDpcbiAgICAgICAgICAgIHRoaXMucGFpbnRJbWFnZVhPYmplY3QoYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnBhaW50SW5saW5lSW1hZ2VYT2JqZWN0OlxuICAgICAgICAgICAgdGhpcy5wYWludElubGluZUltYWdlWE9iamVjdChhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBfdXRpbC5PUFMucGFpbnRJbWFnZU1hc2tYT2JqZWN0OlxuICAgICAgICAgICAgdGhpcy5wYWludEltYWdlTWFza1hPYmplY3QoYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnBhaW50Rm9ybVhPYmplY3RCZWdpbjpcbiAgICAgICAgICAgIHRoaXMucGFpbnRGb3JtWE9iamVjdEJlZ2luKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5wYWludEZvcm1YT2JqZWN0RW5kOlxuICAgICAgICAgICAgdGhpcy5wYWludEZvcm1YT2JqZWN0RW5kKCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLmNsb3NlUGF0aDpcbiAgICAgICAgICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLmNsb3NlU3Ryb2tlOlxuICAgICAgICAgICAgdGhpcy5jbG9zZVN0cm9rZSgpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5jbG9zZUZpbGxTdHJva2U6XG4gICAgICAgICAgICB0aGlzLmNsb3NlRmlsbFN0cm9rZSgpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5jbG9zZUVPRmlsbFN0cm9rZTpcbiAgICAgICAgICAgIHRoaXMuY2xvc2VFT0ZpbGxTdHJva2UoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBfdXRpbC5PUFMubmV4dExpbmU6XG4gICAgICAgICAgICB0aGlzLm5leHRMaW5lKCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnRyYW5zZm9ybTpcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0sIGFyZ3NbNV0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5jb25zdHJ1Y3RQYXRoOlxuICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3RQYXRoKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5lbmRQYXRoOlxuICAgICAgICAgICAgdGhpcy5lbmRQYXRoKCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgOTI6XG4gICAgICAgICAgICB0aGlzLmdyb3VwKG9wVHJlZUVsZW1lbnQuaXRlbXMpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgKDAsIF91dGlsLndhcm4pKGBVbmltcGxlbWVudGVkIG9wZXJhdG9yICR7Zm59YCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHNldFdvcmRTcGFjaW5nKHdvcmRTcGFjaW5nKSB7XG4gICAgICB0aGlzLmN1cnJlbnQud29yZFNwYWNpbmcgPSB3b3JkU3BhY2luZztcbiAgICB9XG5cbiAgICBzZXRDaGFyU3BhY2luZyhjaGFyU3BhY2luZykge1xuICAgICAgdGhpcy5jdXJyZW50LmNoYXJTcGFjaW5nID0gY2hhclNwYWNpbmc7XG4gICAgfVxuXG4gICAgbmV4dExpbmUoKSB7XG4gICAgICB0aGlzLm1vdmVUZXh0KDAsIHRoaXMuY3VycmVudC5sZWFkaW5nKTtcbiAgICB9XG5cbiAgICBzZXRUZXh0TWF0cml4KGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICBjdXJyZW50LnRleHRNYXRyaXggPSBjdXJyZW50LmxpbmVNYXRyaXggPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICBjdXJyZW50LnRleHRNYXRyaXhTY2FsZSA9IE1hdGguc3FydChhICogYSArIGIgKiBiKTtcbiAgICAgIGN1cnJlbnQueCA9IGN1cnJlbnQubGluZVggPSAwO1xuICAgICAgY3VycmVudC55ID0gY3VycmVudC5saW5lWSA9IDA7XG4gICAgICBjdXJyZW50Lnhjb29yZHMgPSBbXTtcbiAgICAgIGN1cnJlbnQueWNvb3JkcyA9IFtdO1xuICAgICAgY3VycmVudC50c3BhbiA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnRzcGFuXCIpO1xuICAgICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZvbnQtZmFtaWx5XCIsIGN1cnJlbnQuZm9udEZhbWlseSk7XG4gICAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZm9udC1zaXplXCIsIGAke3BmKGN1cnJlbnQuZm9udFNpemUpfXB4YCk7XG4gICAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieVwiLCBwZigtY3VycmVudC55KSk7XG4gICAgICBjdXJyZW50LnR4dEVsZW1lbnQgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2Zzp0ZXh0XCIpO1xuICAgICAgY3VycmVudC50eHRFbGVtZW50LmFwcGVuZENoaWxkKGN1cnJlbnQudHNwYW4pO1xuICAgIH1cblxuICAgIGJlZ2luVGV4dCgpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICBjdXJyZW50LnggPSBjdXJyZW50LmxpbmVYID0gMDtcbiAgICAgIGN1cnJlbnQueSA9IGN1cnJlbnQubGluZVkgPSAwO1xuICAgICAgY3VycmVudC50ZXh0TWF0cml4ID0gX3V0aWwuSURFTlRJVFlfTUFUUklYO1xuICAgICAgY3VycmVudC5saW5lTWF0cml4ID0gX3V0aWwuSURFTlRJVFlfTUFUUklYO1xuICAgICAgY3VycmVudC50ZXh0TWF0cml4U2NhbGUgPSAxO1xuICAgICAgY3VycmVudC50c3BhbiA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnRzcGFuXCIpO1xuICAgICAgY3VycmVudC50eHRFbGVtZW50ID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6dGV4dFwiKTtcbiAgICAgIGN1cnJlbnQudHh0Z3JwID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6Z1wiKTtcbiAgICAgIGN1cnJlbnQueGNvb3JkcyA9IFtdO1xuICAgICAgY3VycmVudC55Y29vcmRzID0gW107XG4gICAgfVxuXG4gICAgbW92ZVRleHQoeCwgeSkge1xuICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICAgIGN1cnJlbnQueCA9IGN1cnJlbnQubGluZVggKz0geDtcbiAgICAgIGN1cnJlbnQueSA9IGN1cnJlbnQubGluZVkgKz0geTtcbiAgICAgIGN1cnJlbnQueGNvb3JkcyA9IFtdO1xuICAgICAgY3VycmVudC55Y29vcmRzID0gW107XG4gICAgICBjdXJyZW50LnRzcGFuID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6dHNwYW5cIik7XG4gICAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZm9udC1mYW1pbHlcIiwgY3VycmVudC5mb250RmFtaWx5KTtcbiAgICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmb250LXNpemVcIiwgYCR7cGYoY3VycmVudC5mb250U2l6ZSl9cHhgKTtcbiAgICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ5XCIsIHBmKC1jdXJyZW50LnkpKTtcbiAgICB9XG5cbiAgICBzaG93VGV4dChnbHlwaHMpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICBjb25zdCBmb250ID0gY3VycmVudC5mb250O1xuICAgICAgY29uc3QgZm9udFNpemUgPSBjdXJyZW50LmZvbnRTaXplO1xuXG4gICAgICBpZiAoZm9udFNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBmb250U2l6ZVNjYWxlID0gY3VycmVudC5mb250U2l6ZVNjYWxlO1xuICAgICAgY29uc3QgY2hhclNwYWNpbmcgPSBjdXJyZW50LmNoYXJTcGFjaW5nO1xuICAgICAgY29uc3Qgd29yZFNwYWNpbmcgPSBjdXJyZW50LndvcmRTcGFjaW5nO1xuICAgICAgY29uc3QgZm9udERpcmVjdGlvbiA9IGN1cnJlbnQuZm9udERpcmVjdGlvbjtcbiAgICAgIGNvbnN0IHRleHRIU2NhbGUgPSBjdXJyZW50LnRleHRIU2NhbGUgKiBmb250RGlyZWN0aW9uO1xuICAgICAgY29uc3QgdmVydGljYWwgPSBmb250LnZlcnRpY2FsO1xuICAgICAgY29uc3Qgc3BhY2luZ0RpciA9IHZlcnRpY2FsID8gMSA6IC0xO1xuICAgICAgY29uc3QgZGVmYXVsdFZNZXRyaWNzID0gZm9udC5kZWZhdWx0Vk1ldHJpY3M7XG4gICAgICBjb25zdCB3aWR0aEFkdmFuY2VTY2FsZSA9IGZvbnRTaXplICogY3VycmVudC5mb250TWF0cml4WzBdO1xuICAgICAgbGV0IHggPSAwO1xuXG4gICAgICBmb3IgKGNvbnN0IGdseXBoIG9mIGdseXBocykge1xuICAgICAgICBpZiAoZ2x5cGggPT09IG51bGwpIHtcbiAgICAgICAgICB4ICs9IGZvbnREaXJlY3Rpb24gKiB3b3JkU3BhY2luZztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmICgoMCwgX3V0aWwuaXNOdW0pKGdseXBoKSkge1xuICAgICAgICAgIHggKz0gc3BhY2luZ0RpciAqIGdseXBoICogZm9udFNpemUgLyAxMDAwO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3BhY2luZyA9IChnbHlwaC5pc1NwYWNlID8gd29yZFNwYWNpbmcgOiAwKSArIGNoYXJTcGFjaW5nO1xuICAgICAgICBjb25zdCBjaGFyYWN0ZXIgPSBnbHlwaC5mb250Q2hhcjtcbiAgICAgICAgbGV0IHNjYWxlZFgsIHNjYWxlZFk7XG4gICAgICAgIGxldCB3aWR0aCA9IGdseXBoLndpZHRoO1xuXG4gICAgICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgICAgIGxldCB2eDtcbiAgICAgICAgICBjb25zdCB2bWV0cmljID0gZ2x5cGgudm1ldHJpYyB8fCBkZWZhdWx0Vk1ldHJpY3M7XG4gICAgICAgICAgdnggPSBnbHlwaC52bWV0cmljID8gdm1ldHJpY1sxXSA6IHdpZHRoICogMC41O1xuICAgICAgICAgIHZ4ID0gLXZ4ICogd2lkdGhBZHZhbmNlU2NhbGU7XG4gICAgICAgICAgY29uc3QgdnkgPSB2bWV0cmljWzJdICogd2lkdGhBZHZhbmNlU2NhbGU7XG4gICAgICAgICAgd2lkdGggPSB2bWV0cmljID8gLXZtZXRyaWNbMF0gOiB3aWR0aDtcbiAgICAgICAgICBzY2FsZWRYID0gdnggLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICAgIHNjYWxlZFkgPSAoeCArIHZ5KSAvIGZvbnRTaXplU2NhbGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2NhbGVkWCA9IHggLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICAgIHNjYWxlZFkgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdseXBoLmlzSW5Gb250IHx8IGZvbnQubWlzc2luZ0ZpbGUpIHtcbiAgICAgICAgICBjdXJyZW50Lnhjb29yZHMucHVzaChjdXJyZW50LnggKyBzY2FsZWRYKTtcblxuICAgICAgICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgICAgICAgY3VycmVudC55Y29vcmRzLnB1c2goLWN1cnJlbnQueSArIHNjYWxlZFkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGN1cnJlbnQudHNwYW4udGV4dENvbnRlbnQgKz0gY2hhcmFjdGVyO1xuICAgICAgICB9IGVsc2Uge31cblxuICAgICAgICBsZXQgY2hhcldpZHRoO1xuXG4gICAgICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgICAgIGNoYXJXaWR0aCA9IHdpZHRoICogd2lkdGhBZHZhbmNlU2NhbGUgLSBzcGFjaW5nICogZm9udERpcmVjdGlvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGFyV2lkdGggPSB3aWR0aCAqIHdpZHRoQWR2YW5jZVNjYWxlICsgc3BhY2luZyAqIGZvbnREaXJlY3Rpb247XG4gICAgICAgIH1cblxuICAgICAgICB4ICs9IGNoYXJXaWR0aDtcbiAgICAgIH1cblxuICAgICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInhcIiwgY3VycmVudC54Y29vcmRzLm1hcChwZikuam9pbihcIiBcIikpO1xuXG4gICAgICBpZiAodmVydGljYWwpIHtcbiAgICAgICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgY3VycmVudC55Y29vcmRzLm1hcChwZikuam9pbihcIiBcIikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgcGYoLWN1cnJlbnQueSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodmVydGljYWwpIHtcbiAgICAgICAgY3VycmVudC55IC09IHg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50LnggKz0geCAqIHRleHRIU2NhbGU7XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmb250LWZhbWlseVwiLCBjdXJyZW50LmZvbnRGYW1pbHkpO1xuICAgICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZvbnQtc2l6ZVwiLCBgJHtwZihjdXJyZW50LmZvbnRTaXplKX1weGApO1xuXG4gICAgICBpZiAoY3VycmVudC5mb250U3R5bGUgIT09IFNWR19ERUZBVUxUUy5mb250U3R5bGUpIHtcbiAgICAgICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZvbnQtc3R5bGVcIiwgY3VycmVudC5mb250U3R5bGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3VycmVudC5mb250V2VpZ2h0ICE9PSBTVkdfREVGQVVMVFMuZm9udFdlaWdodCkge1xuICAgICAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZm9udC13ZWlnaHRcIiwgY3VycmVudC5mb250V2VpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZmlsbFN0cm9rZU1vZGUgPSBjdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlICYgX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0VfTUFTSztcblxuICAgICAgaWYgKGZpbGxTdHJva2VNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMIHx8IGZpbGxTdHJva2VNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRSkge1xuICAgICAgICBpZiAoY3VycmVudC5maWxsQ29sb3IgIT09IFNWR19ERUZBVUxUUy5maWxsQ29sb3IpIHtcbiAgICAgICAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbFwiLCBjdXJyZW50LmZpbGxDb2xvcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudC5maWxsQWxwaGEgPCAxKSB7XG4gICAgICAgICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZpbGwtb3BhY2l0eVwiLCBjdXJyZW50LmZpbGxBbHBoYSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudC50ZXh0UmVuZGVyaW5nTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuQUREX1RPX1BBVEgpIHtcbiAgICAgICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZpbGxcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsXCIsIFwibm9uZVwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZpbGxTdHJva2VNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5TVFJPS0UgfHwgZmlsbFN0cm9rZU1vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFKSB7XG4gICAgICAgIGNvbnN0IGxpbmVXaWR0aFNjYWxlID0gMSAvIChjdXJyZW50LnRleHRNYXRyaXhTY2FsZSB8fCAxKTtcblxuICAgICAgICB0aGlzLl9zZXRTdHJva2VBdHRyaWJ1dGVzKGN1cnJlbnQudHNwYW4sIGxpbmVXaWR0aFNjYWxlKTtcbiAgICAgIH1cblxuICAgICAgbGV0IHRleHRNYXRyaXggPSBjdXJyZW50LnRleHRNYXRyaXg7XG5cbiAgICAgIGlmIChjdXJyZW50LnRleHRSaXNlICE9PSAwKSB7XG4gICAgICAgIHRleHRNYXRyaXggPSB0ZXh0TWF0cml4LnNsaWNlKCk7XG4gICAgICAgIHRleHRNYXRyaXhbNV0gKz0gY3VycmVudC50ZXh0UmlzZTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudC50eHRFbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwidHJhbnNmb3JtXCIsIGAke3BtKHRleHRNYXRyaXgpfSBzY2FsZSgke3BmKHRleHRIU2NhbGUpfSwgLTEpYCk7XG4gICAgICBjdXJyZW50LnR4dEVsZW1lbnQuc2V0QXR0cmlidXRlTlMoWE1MX05TLCBcInhtbDpzcGFjZVwiLCBcInByZXNlcnZlXCIpO1xuICAgICAgY3VycmVudC50eHRFbGVtZW50LmFwcGVuZENoaWxkKGN1cnJlbnQudHNwYW4pO1xuICAgICAgY3VycmVudC50eHRncnAuYXBwZW5kQ2hpbGQoY3VycmVudC50eHRFbGVtZW50KTtcblxuICAgICAgdGhpcy5fZW5zdXJlVHJhbnNmb3JtR3JvdXAoKS5hcHBlbmRDaGlsZChjdXJyZW50LnR4dEVsZW1lbnQpO1xuICAgIH1cblxuICAgIHNldExlYWRpbmdNb3ZlVGV4dCh4LCB5KSB7XG4gICAgICB0aGlzLnNldExlYWRpbmcoLXkpO1xuICAgICAgdGhpcy5tb3ZlVGV4dCh4LCB5KTtcbiAgICB9XG5cbiAgICBhZGRGb250U3R5bGUoZm9udE9iaikge1xuICAgICAgaWYgKCFmb250T2JqLmRhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWRkRm9udFN0eWxlOiBObyBmb250IGRhdGEgYXZhaWxhYmxlLCBcIiArICdlbnN1cmUgdGhhdCB0aGUgXCJmb250RXh0cmFQcm9wZXJ0aWVzXCIgQVBJIHBhcmFtZXRlciBpcyBzZXQuJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5jc3NTdHlsZSkge1xuICAgICAgICB0aGlzLmNzc1N0eWxlID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6c3R5bGVcIik7XG4gICAgICAgIHRoaXMuY3NzU3R5bGUuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ0eXBlXCIsIFwidGV4dC9jc3NcIik7XG4gICAgICAgIHRoaXMuZGVmcy5hcHBlbmRDaGlsZCh0aGlzLmNzc1N0eWxlKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gKDAsIF91dGlsLmNyZWF0ZU9iamVjdFVSTCkoZm9udE9iai5kYXRhLCBmb250T2JqLm1pbWV0eXBlLCB0aGlzLmZvcmNlRGF0YVNjaGVtYSk7XG4gICAgICB0aGlzLmNzc1N0eWxlLnRleHRDb250ZW50ICs9IGBAZm9udC1mYWNlIHsgZm9udC1mYW1pbHk6IFwiJHtmb250T2JqLmxvYWRlZE5hbWV9XCI7YCArIGAgc3JjOiB1cmwoJHt1cmx9KTsgfVxcbmA7XG4gICAgfVxuXG4gICAgc2V0Rm9udChkZXRhaWxzKSB7XG4gICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgICAgY29uc3QgZm9udE9iaiA9IHRoaXMuY29tbW9uT2Jqcy5nZXQoZGV0YWlsc1swXSk7XG4gICAgICBsZXQgc2l6ZSA9IGRldGFpbHNbMV07XG4gICAgICBjdXJyZW50LmZvbnQgPSBmb250T2JqO1xuXG4gICAgICBpZiAodGhpcy5lbWJlZEZvbnRzICYmICFmb250T2JqLm1pc3NpbmdGaWxlICYmICF0aGlzLmVtYmVkZGVkRm9udHNbZm9udE9iai5sb2FkZWROYW1lXSkge1xuICAgICAgICB0aGlzLmFkZEZvbnRTdHlsZShmb250T2JqKTtcbiAgICAgICAgdGhpcy5lbWJlZGRlZEZvbnRzW2ZvbnRPYmoubG9hZGVkTmFtZV0gPSBmb250T2JqO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50LmZvbnRNYXRyaXggPSBmb250T2JqLmZvbnRNYXRyaXggPyBmb250T2JqLmZvbnRNYXRyaXggOiBfdXRpbC5GT05UX0lERU5USVRZX01BVFJJWDtcbiAgICAgIGxldCBib2xkID0gXCJub3JtYWxcIjtcblxuICAgICAgaWYgKGZvbnRPYmouYmxhY2spIHtcbiAgICAgICAgYm9sZCA9IFwiOTAwXCI7XG4gICAgICB9IGVsc2UgaWYgKGZvbnRPYmouYm9sZCkge1xuICAgICAgICBib2xkID0gXCJib2xkXCI7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGl0YWxpYyA9IGZvbnRPYmouaXRhbGljID8gXCJpdGFsaWNcIiA6IFwibm9ybWFsXCI7XG5cbiAgICAgIGlmIChzaXplIDwgMCkge1xuICAgICAgICBzaXplID0gLXNpemU7XG4gICAgICAgIGN1cnJlbnQuZm9udERpcmVjdGlvbiA9IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudC5mb250RGlyZWN0aW9uID0gMTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudC5mb250U2l6ZSA9IHNpemU7XG4gICAgICBjdXJyZW50LmZvbnRGYW1pbHkgPSBmb250T2JqLmxvYWRlZE5hbWU7XG4gICAgICBjdXJyZW50LmZvbnRXZWlnaHQgPSBib2xkO1xuICAgICAgY3VycmVudC5mb250U3R5bGUgPSBpdGFsaWM7XG4gICAgICBjdXJyZW50LnRzcGFuID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6dHNwYW5cIik7XG4gICAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieVwiLCBwZigtY3VycmVudC55KSk7XG4gICAgICBjdXJyZW50Lnhjb29yZHMgPSBbXTtcbiAgICAgIGN1cnJlbnQueWNvb3JkcyA9IFtdO1xuICAgIH1cblxuICAgIGVuZFRleHQoKSB7XG4gICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuXG4gICAgICBpZiAoY3VycmVudC50ZXh0UmVuZGVyaW5nTW9kZSAmIF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkFERF9UT19QQVRIX0ZMQUcgJiYgY3VycmVudC50eHRFbGVtZW50ICYmIGN1cnJlbnQudHh0RWxlbWVudC5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgY3VycmVudC5lbGVtZW50ID0gY3VycmVudC50eHRFbGVtZW50O1xuICAgICAgICB0aGlzLmNsaXAoXCJub256ZXJvXCIpO1xuICAgICAgICB0aGlzLmVuZFBhdGgoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRMaW5lV2lkdGgod2lkdGgpIHtcbiAgICAgIGlmICh3aWR0aCA+IDApIHtcbiAgICAgICAgdGhpcy5jdXJyZW50LmxpbmVXaWR0aCA9IHdpZHRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNldExpbmVDYXAoc3R5bGUpIHtcbiAgICAgIHRoaXMuY3VycmVudC5saW5lQ2FwID0gTElORV9DQVBfU1RZTEVTW3N0eWxlXTtcbiAgICB9XG5cbiAgICBzZXRMaW5lSm9pbihzdHlsZSkge1xuICAgICAgdGhpcy5jdXJyZW50LmxpbmVKb2luID0gTElORV9KT0lOX1NUWUxFU1tzdHlsZV07XG4gICAgfVxuXG4gICAgc2V0TWl0ZXJMaW1pdChsaW1pdCkge1xuICAgICAgdGhpcy5jdXJyZW50Lm1pdGVyTGltaXQgPSBsaW1pdDtcbiAgICB9XG5cbiAgICBzZXRTdHJva2VBbHBoYShzdHJva2VBbHBoYSkge1xuICAgICAgdGhpcy5jdXJyZW50LnN0cm9rZUFscGhhID0gc3Ryb2tlQWxwaGE7XG4gICAgfVxuXG4gICAgc2V0U3Ryb2tlUkdCQ29sb3IociwgZywgYikge1xuICAgICAgdGhpcy5jdXJyZW50LnN0cm9rZUNvbG9yID0gX3V0aWwuVXRpbC5tYWtlQ3NzUmdiKHIsIGcsIGIpO1xuICAgIH1cblxuICAgIHNldEZpbGxBbHBoYShmaWxsQWxwaGEpIHtcbiAgICAgIHRoaXMuY3VycmVudC5maWxsQWxwaGEgPSBmaWxsQWxwaGE7XG4gICAgfVxuXG4gICAgc2V0RmlsbFJHQkNvbG9yKHIsIGcsIGIpIHtcbiAgICAgIHRoaXMuY3VycmVudC5maWxsQ29sb3IgPSBfdXRpbC5VdGlsLm1ha2VDc3NSZ2IociwgZywgYik7XG4gICAgICB0aGlzLmN1cnJlbnQudHNwYW4gPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2Zzp0c3BhblwiKTtcbiAgICAgIHRoaXMuY3VycmVudC54Y29vcmRzID0gW107XG4gICAgICB0aGlzLmN1cnJlbnQueWNvb3JkcyA9IFtdO1xuICAgIH1cblxuICAgIHNldFN0cm9rZUNvbG9yTihhcmdzKSB7XG4gICAgICB0aGlzLmN1cnJlbnQuc3Ryb2tlQ29sb3IgPSB0aGlzLl9tYWtlQ29sb3JOX1BhdHRlcm4oYXJncyk7XG4gICAgfVxuXG4gICAgc2V0RmlsbENvbG9yTihhcmdzKSB7XG4gICAgICB0aGlzLmN1cnJlbnQuZmlsbENvbG9yID0gdGhpcy5fbWFrZUNvbG9yTl9QYXR0ZXJuKGFyZ3MpO1xuICAgIH1cblxuICAgIHNoYWRpbmdGaWxsKGFyZ3MpIHtcbiAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy52aWV3cG9ydC53aWR0aDtcbiAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMudmlld3BvcnQuaGVpZ2h0O1xuXG4gICAgICBjb25zdCBpbnYgPSBfdXRpbC5VdGlsLmludmVyc2VUcmFuc2Zvcm0odGhpcy50cmFuc2Zvcm1NYXRyaXgpO1xuXG4gICAgICBjb25zdCBibCA9IF91dGlsLlV0aWwuYXBwbHlUcmFuc2Zvcm0oWzAsIDBdLCBpbnYpO1xuXG4gICAgICBjb25zdCBiciA9IF91dGlsLlV0aWwuYXBwbHlUcmFuc2Zvcm0oWzAsIGhlaWdodF0sIGludik7XG5cbiAgICAgIGNvbnN0IHVsID0gX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShbd2lkdGgsIDBdLCBpbnYpO1xuXG4gICAgICBjb25zdCB1ciA9IF91dGlsLlV0aWwuYXBwbHlUcmFuc2Zvcm0oW3dpZHRoLCBoZWlnaHRdLCBpbnYpO1xuXG4gICAgICBjb25zdCB4MCA9IE1hdGgubWluKGJsWzBdLCBiclswXSwgdWxbMF0sIHVyWzBdKTtcbiAgICAgIGNvbnN0IHkwID0gTWF0aC5taW4oYmxbMV0sIGJyWzFdLCB1bFsxXSwgdXJbMV0pO1xuICAgICAgY29uc3QgeDEgPSBNYXRoLm1heChibFswXSwgYnJbMF0sIHVsWzBdLCB1clswXSk7XG4gICAgICBjb25zdCB5MSA9IE1hdGgubWF4KGJsWzFdLCBiclsxXSwgdWxbMV0sIHVyWzFdKTtcbiAgICAgIGNvbnN0IHJlY3QgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpyZWN0XCIpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInhcIiwgeDApO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgeTApO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIndpZHRoXCIsIHgxIC0geDApO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImhlaWdodFwiLCB5MSAtIHkwKTtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsXCIsIHRoaXMuX21ha2VTaGFkaW5nUGF0dGVybihhcmdzKSk7XG5cbiAgICAgIGlmICh0aGlzLmN1cnJlbnQuZmlsbEFscGhhIDwgMSkge1xuICAgICAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbC1vcGFjaXR5XCIsIHRoaXMuY3VycmVudC5maWxsQWxwaGEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9lbnN1cmVUcmFuc2Zvcm1Hcm91cCgpLmFwcGVuZENoaWxkKHJlY3QpO1xuICAgIH1cblxuICAgIF9tYWtlQ29sb3JOX1BhdHRlcm4oYXJncykge1xuICAgICAgaWYgKGFyZ3NbMF0gPT09IFwiVGlsaW5nUGF0dGVyblwiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYWtlVGlsaW5nUGF0dGVybihhcmdzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX21ha2VTaGFkaW5nUGF0dGVybihhcmdzKTtcbiAgICB9XG5cbiAgICBfbWFrZVRpbGluZ1BhdHRlcm4oYXJncykge1xuICAgICAgY29uc3QgY29sb3IgPSBhcmdzWzFdO1xuICAgICAgY29uc3Qgb3BlcmF0b3JMaXN0ID0gYXJnc1syXTtcbiAgICAgIGNvbnN0IG1hdHJpeCA9IGFyZ3NbM10gfHwgX3V0aWwuSURFTlRJVFlfTUFUUklYO1xuICAgICAgY29uc3QgW3gwLCB5MCwgeDEsIHkxXSA9IGFyZ3NbNF07XG4gICAgICBjb25zdCB4c3RlcCA9IGFyZ3NbNV07XG4gICAgICBjb25zdCB5c3RlcCA9IGFyZ3NbNl07XG4gICAgICBjb25zdCBwYWludFR5cGUgPSBhcmdzWzddO1xuICAgICAgY29uc3QgdGlsaW5nSWQgPSBgc2hhZGluZyR7c2hhZGluZ0NvdW50Kyt9YDtcblxuICAgICAgY29uc3QgW3R4MCwgdHkwXSA9IF91dGlsLlV0aWwuYXBwbHlUcmFuc2Zvcm0oW3gwLCB5MF0sIG1hdHJpeCk7XG5cbiAgICAgIGNvbnN0IFt0eDEsIHR5MV0gPSBfdXRpbC5VdGlsLmFwcGx5VHJhbnNmb3JtKFt4MSwgeTFdLCBtYXRyaXgpO1xuXG4gICAgICBjb25zdCBbeHNjYWxlLCB5c2NhbGVdID0gX3V0aWwuVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZShtYXRyaXgpO1xuXG4gICAgICBjb25zdCB0eHN0ZXAgPSB4c3RlcCAqIHhzY2FsZTtcbiAgICAgIGNvbnN0IHR5c3RlcCA9IHlzdGVwICogeXNjYWxlO1xuICAgICAgY29uc3QgdGlsaW5nID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6cGF0dGVyblwiKTtcbiAgICAgIHRpbGluZy5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImlkXCIsIHRpbGluZ0lkKTtcbiAgICAgIHRpbGluZy5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInBhdHRlcm5Vbml0c1wiLCBcInVzZXJTcGFjZU9uVXNlXCIpO1xuICAgICAgdGlsaW5nLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwid2lkdGhcIiwgdHhzdGVwKTtcbiAgICAgIHRpbGluZy5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImhlaWdodFwiLCB0eXN0ZXApO1xuICAgICAgdGlsaW5nLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieFwiLCBgJHt0eDB9YCk7XG4gICAgICB0aWxpbmcuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ5XCIsIGAke3R5MH1gKTtcbiAgICAgIGNvbnN0IHN2ZyA9IHRoaXMuc3ZnO1xuICAgICAgY29uc3QgdHJhbnNmb3JtTWF0cml4ID0gdGhpcy50cmFuc2Zvcm1NYXRyaXg7XG4gICAgICBjb25zdCBmaWxsQ29sb3IgPSB0aGlzLmN1cnJlbnQuZmlsbENvbG9yO1xuICAgICAgY29uc3Qgc3Ryb2tlQ29sb3IgPSB0aGlzLmN1cnJlbnQuc3Ryb2tlQ29sb3I7XG4gICAgICBjb25zdCBiYm94ID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZSh0eDEgLSB0eDAsIHR5MSAtIHR5MCk7XG4gICAgICB0aGlzLnN2ZyA9IGJib3g7XG4gICAgICB0aGlzLnRyYW5zZm9ybU1hdHJpeCA9IG1hdHJpeDtcblxuICAgICAgaWYgKHBhaW50VHlwZSA9PT0gMikge1xuICAgICAgICBjb25zdCBjc3NDb2xvciA9IF91dGlsLlV0aWwubWFrZUNzc1JnYiguLi5jb2xvcik7XG5cbiAgICAgICAgdGhpcy5jdXJyZW50LmZpbGxDb2xvciA9IGNzc0NvbG9yO1xuICAgICAgICB0aGlzLmN1cnJlbnQuc3Ryb2tlQ29sb3IgPSBjc3NDb2xvcjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5leGVjdXRlT3BUcmVlKHRoaXMuY29udmVydE9wTGlzdChvcGVyYXRvckxpc3QpKTtcbiAgICAgIHRoaXMuc3ZnID0gc3ZnO1xuICAgICAgdGhpcy50cmFuc2Zvcm1NYXRyaXggPSB0cmFuc2Zvcm1NYXRyaXg7XG4gICAgICB0aGlzLmN1cnJlbnQuZmlsbENvbG9yID0gZmlsbENvbG9yO1xuICAgICAgdGhpcy5jdXJyZW50LnN0cm9rZUNvbG9yID0gc3Ryb2tlQ29sb3I7XG4gICAgICB0aWxpbmcuYXBwZW5kQ2hpbGQoYmJveC5jaGlsZE5vZGVzWzBdKTtcbiAgICAgIHRoaXMuZGVmcy5hcHBlbmRDaGlsZCh0aWxpbmcpO1xuICAgICAgcmV0dXJuIGB1cmwoIyR7dGlsaW5nSWR9KWA7XG4gICAgfVxuXG4gICAgX21ha2VTaGFkaW5nUGF0dGVybihhcmdzKSB7XG4gICAgICBzd2l0Y2ggKGFyZ3NbMF0pIHtcbiAgICAgICAgY2FzZSBcIlJhZGlhbEF4aWFsXCI6XG4gICAgICAgICAgY29uc3Qgc2hhZGluZ0lkID0gYHNoYWRpbmcke3NoYWRpbmdDb3VudCsrfWA7XG4gICAgICAgICAgY29uc3QgY29sb3JTdG9wcyA9IGFyZ3NbM107XG4gICAgICAgICAgbGV0IGdyYWRpZW50O1xuXG4gICAgICAgICAgc3dpdGNoIChhcmdzWzFdKSB7XG4gICAgICAgICAgICBjYXNlIFwiYXhpYWxcIjpcbiAgICAgICAgICAgICAgY29uc3QgcG9pbnQwID0gYXJnc1s0XTtcbiAgICAgICAgICAgICAgY29uc3QgcG9pbnQxID0gYXJnc1s1XTtcbiAgICAgICAgICAgICAgZ3JhZGllbnQgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpsaW5lYXJHcmFkaWVudFwiKTtcbiAgICAgICAgICAgICAgZ3JhZGllbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJpZFwiLCBzaGFkaW5nSWQpO1xuICAgICAgICAgICAgICBncmFkaWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImdyYWRpZW50VW5pdHNcIiwgXCJ1c2VyU3BhY2VPblVzZVwiKTtcbiAgICAgICAgICAgICAgZ3JhZGllbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ4MVwiLCBwb2ludDBbMF0pO1xuICAgICAgICAgICAgICBncmFkaWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInkxXCIsIHBvaW50MFsxXSk7XG4gICAgICAgICAgICAgIGdyYWRpZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieDJcIiwgcG9pbnQxWzBdKTtcbiAgICAgICAgICAgICAgZ3JhZGllbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ5MlwiLCBwb2ludDFbMV0pO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcInJhZGlhbFwiOlxuICAgICAgICAgICAgICBjb25zdCBmb2NhbFBvaW50ID0gYXJnc1s0XTtcbiAgICAgICAgICAgICAgY29uc3QgY2lyY2xlUG9pbnQgPSBhcmdzWzVdO1xuICAgICAgICAgICAgICBjb25zdCBmb2NhbFJhZGl1cyA9IGFyZ3NbNl07XG4gICAgICAgICAgICAgIGNvbnN0IGNpcmNsZVJhZGl1cyA9IGFyZ3NbN107XG4gICAgICAgICAgICAgIGdyYWRpZW50ID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6cmFkaWFsR3JhZGllbnRcIik7XG4gICAgICAgICAgICAgIGdyYWRpZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiaWRcIiwgc2hhZGluZ0lkKTtcbiAgICAgICAgICAgICAgZ3JhZGllbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJncmFkaWVudFVuaXRzXCIsIFwidXNlclNwYWNlT25Vc2VcIik7XG4gICAgICAgICAgICAgIGdyYWRpZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiY3hcIiwgY2lyY2xlUG9pbnRbMF0pO1xuICAgICAgICAgICAgICBncmFkaWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImN5XCIsIGNpcmNsZVBvaW50WzFdKTtcbiAgICAgICAgICAgICAgZ3JhZGllbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJyXCIsIGNpcmNsZVJhZGl1cyk7XG4gICAgICAgICAgICAgIGdyYWRpZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZnhcIiwgZm9jYWxQb2ludFswXSk7XG4gICAgICAgICAgICAgIGdyYWRpZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZnlcIiwgZm9jYWxQb2ludFsxXSk7XG4gICAgICAgICAgICAgIGdyYWRpZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZnJcIiwgZm9jYWxSYWRpdXMpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIFJhZGlhbEF4aWFsIHR5cGU6ICR7YXJnc1sxXX1gKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKGNvbnN0IGNvbG9yU3RvcCBvZiBjb2xvclN0b3BzKSB7XG4gICAgICAgICAgICBjb25zdCBzdG9wID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6c3RvcFwiKTtcbiAgICAgICAgICAgIHN0b3Auc2V0QXR0cmlidXRlTlMobnVsbCwgXCJvZmZzZXRcIiwgY29sb3JTdG9wWzBdKTtcbiAgICAgICAgICAgIHN0b3Auc2V0QXR0cmlidXRlTlMobnVsbCwgXCJzdG9wLWNvbG9yXCIsIGNvbG9yU3RvcFsxXSk7XG4gICAgICAgICAgICBncmFkaWVudC5hcHBlbmRDaGlsZChzdG9wKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmRlZnMuYXBwZW5kQ2hpbGQoZ3JhZGllbnQpO1xuICAgICAgICAgIHJldHVybiBgdXJsKCMke3NoYWRpbmdJZH0pYDtcblxuICAgICAgICBjYXNlIFwiTWVzaFwiOlxuICAgICAgICAgICgwLCBfdXRpbC53YXJuKShcIlVuaW1wbGVtZW50ZWQgcGF0dGVybiBNZXNoXCIpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgICAgIGNhc2UgXCJEdW1teVwiOlxuICAgICAgICAgIHJldHVybiBcImhvdHBpbmtcIjtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBJUiB0eXBlOiAke2FyZ3NbMF19YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2V0RGFzaChkYXNoQXJyYXksIGRhc2hQaGFzZSkge1xuICAgICAgdGhpcy5jdXJyZW50LmRhc2hBcnJheSA9IGRhc2hBcnJheTtcbiAgICAgIHRoaXMuY3VycmVudC5kYXNoUGhhc2UgPSBkYXNoUGhhc2U7XG4gICAgfVxuXG4gICAgY29uc3RydWN0UGF0aChvcHMsIGFyZ3MpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICBsZXQgeCA9IGN1cnJlbnQueCxcbiAgICAgICAgICB5ID0gY3VycmVudC55O1xuICAgICAgbGV0IGQgPSBbXTtcbiAgICAgIGxldCBqID0gMDtcblxuICAgICAgZm9yIChjb25zdCBvcCBvZiBvcHMpIHtcbiAgICAgICAgc3dpdGNoIChvcCB8IDApIHtcbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5yZWN0YW5nbGU6XG4gICAgICAgICAgICB4ID0gYXJnc1tqKytdO1xuICAgICAgICAgICAgeSA9IGFyZ3NbaisrXTtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gYXJnc1tqKytdO1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gYXJnc1tqKytdO1xuICAgICAgICAgICAgY29uc3QgeHcgPSB4ICsgd2lkdGg7XG4gICAgICAgICAgICBjb25zdCB5aCA9IHkgKyBoZWlnaHQ7XG4gICAgICAgICAgICBkLnB1c2goXCJNXCIsIHBmKHgpLCBwZih5KSwgXCJMXCIsIHBmKHh3KSwgcGYoeSksIFwiTFwiLCBwZih4dyksIHBmKHloKSwgXCJMXCIsIHBmKHgpLCBwZih5aCksIFwiWlwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBfdXRpbC5PUFMubW92ZVRvOlxuICAgICAgICAgICAgeCA9IGFyZ3NbaisrXTtcbiAgICAgICAgICAgIHkgPSBhcmdzW2orK107XG4gICAgICAgICAgICBkLnB1c2goXCJNXCIsIHBmKHgpLCBwZih5KSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLmxpbmVUbzpcbiAgICAgICAgICAgIHggPSBhcmdzW2orK107XG4gICAgICAgICAgICB5ID0gYXJnc1tqKytdO1xuICAgICAgICAgICAgZC5wdXNoKFwiTFwiLCBwZih4KSwgcGYoeSkpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5jdXJ2ZVRvOlxuICAgICAgICAgICAgeCA9IGFyZ3NbaiArIDRdO1xuICAgICAgICAgICAgeSA9IGFyZ3NbaiArIDVdO1xuICAgICAgICAgICAgZC5wdXNoKFwiQ1wiLCBwZihhcmdzW2pdKSwgcGYoYXJnc1tqICsgMV0pLCBwZihhcmdzW2ogKyAyXSksIHBmKGFyZ3NbaiArIDNdKSwgcGYoeCksIHBmKHkpKTtcbiAgICAgICAgICAgIGogKz0gNjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBfdXRpbC5PUFMuY3VydmVUbzI6XG4gICAgICAgICAgICBkLnB1c2goXCJDXCIsIHBmKHgpLCBwZih5KSwgcGYoYXJnc1tqXSksIHBmKGFyZ3NbaiArIDFdKSwgcGYoYXJnc1tqICsgMl0pLCBwZihhcmdzW2ogKyAzXSkpO1xuICAgICAgICAgICAgeCA9IGFyZ3NbaiArIDJdO1xuICAgICAgICAgICAgeSA9IGFyZ3NbaiArIDNdO1xuICAgICAgICAgICAgaiArPSA0O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5jdXJ2ZVRvMzpcbiAgICAgICAgICAgIHggPSBhcmdzW2ogKyAyXTtcbiAgICAgICAgICAgIHkgPSBhcmdzW2ogKyAzXTtcbiAgICAgICAgICAgIGQucHVzaChcIkNcIiwgcGYoYXJnc1tqXSksIHBmKGFyZ3NbaiArIDFdKSwgcGYoeCksIHBmKHkpLCBwZih4KSwgcGYoeSkpO1xuICAgICAgICAgICAgaiArPSA0O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5jbG9zZVBhdGg6XG4gICAgICAgICAgICBkLnB1c2goXCJaXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZCA9IGQuam9pbihcIiBcIik7XG5cbiAgICAgIGlmIChjdXJyZW50LnBhdGggJiYgb3BzLmxlbmd0aCA+IDAgJiYgb3BzWzBdICE9PSBfdXRpbC5PUFMucmVjdGFuZ2xlICYmIG9wc1swXSAhPT0gX3V0aWwuT1BTLm1vdmVUbykge1xuICAgICAgICBkID0gY3VycmVudC5wYXRoLmdldEF0dHJpYnV0ZU5TKG51bGwsIFwiZFwiKSArIGQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50LnBhdGggPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpwYXRoXCIpO1xuXG4gICAgICAgIHRoaXMuX2Vuc3VyZVRyYW5zZm9ybUdyb3VwKCkuYXBwZW5kQ2hpbGQoY3VycmVudC5wYXRoKTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudC5wYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZFwiLCBkKTtcbiAgICAgIGN1cnJlbnQucGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZpbGxcIiwgXCJub25lXCIpO1xuICAgICAgY3VycmVudC5lbGVtZW50ID0gY3VycmVudC5wYXRoO1xuICAgICAgY3VycmVudC5zZXRDdXJyZW50UG9pbnQoeCwgeSk7XG4gICAgfVxuXG4gICAgZW5kUGF0aCgpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICBjdXJyZW50LnBhdGggPSBudWxsO1xuXG4gICAgICBpZiAoIXRoaXMucGVuZGluZ0NsaXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWN1cnJlbnQuZWxlbWVudCkge1xuICAgICAgICB0aGlzLnBlbmRpbmdDbGlwID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjbGlwSWQgPSBgY2xpcHBhdGgke2NsaXBDb3VudCsrfWA7XG4gICAgICBjb25zdCBjbGlwUGF0aCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOmNsaXBQYXRoXCIpO1xuICAgICAgY2xpcFBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgXCJpZFwiLCBjbGlwSWQpO1xuICAgICAgY2xpcFBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ0cmFuc2Zvcm1cIiwgcG0odGhpcy50cmFuc2Zvcm1NYXRyaXgpKTtcbiAgICAgIGNvbnN0IGNsaXBFbGVtZW50ID0gY3VycmVudC5lbGVtZW50LmNsb25lTm9kZSh0cnVlKTtcblxuICAgICAgaWYgKHRoaXMucGVuZGluZ0NsaXAgPT09IFwiZXZlbm9kZFwiKSB7XG4gICAgICAgIGNsaXBFbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiY2xpcC1ydWxlXCIsIFwiZXZlbm9kZFwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsaXBFbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiY2xpcC1ydWxlXCIsIFwibm9uemVyb1wiKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wZW5kaW5nQ2xpcCA9IG51bGw7XG4gICAgICBjbGlwUGF0aC5hcHBlbmRDaGlsZChjbGlwRWxlbWVudCk7XG4gICAgICB0aGlzLmRlZnMuYXBwZW5kQ2hpbGQoY2xpcFBhdGgpO1xuXG4gICAgICBpZiAoY3VycmVudC5hY3RpdmVDbGlwVXJsKSB7XG4gICAgICAgIGN1cnJlbnQuY2xpcEdyb3VwID0gbnVsbDtcbiAgICAgICAgdGhpcy5leHRyYVN0YWNrLmZvckVhY2goZnVuY3Rpb24gKHByZXYpIHtcbiAgICAgICAgICBwcmV2LmNsaXBHcm91cCA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgICBjbGlwUGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImNsaXAtcGF0aFwiLCBjdXJyZW50LmFjdGl2ZUNsaXBVcmwpO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50LmFjdGl2ZUNsaXBVcmwgPSBgdXJsKCMke2NsaXBJZH0pYDtcbiAgICAgIHRoaXMudGdycCA9IG51bGw7XG4gICAgfVxuXG4gICAgY2xpcCh0eXBlKSB7XG4gICAgICB0aGlzLnBlbmRpbmdDbGlwID0gdHlwZTtcbiAgICB9XG5cbiAgICBjbG9zZVBhdGgoKSB7XG4gICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuXG4gICAgICBpZiAoY3VycmVudC5wYXRoKSB7XG4gICAgICAgIGNvbnN0IGQgPSBgJHtjdXJyZW50LnBhdGguZ2V0QXR0cmlidXRlTlMobnVsbCwgXCJkXCIpfVpgO1xuICAgICAgICBjdXJyZW50LnBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgXCJkXCIsIGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNldExlYWRpbmcobGVhZGluZykge1xuICAgICAgdGhpcy5jdXJyZW50LmxlYWRpbmcgPSAtbGVhZGluZztcbiAgICB9XG5cbiAgICBzZXRUZXh0UmlzZSh0ZXh0UmlzZSkge1xuICAgICAgdGhpcy5jdXJyZW50LnRleHRSaXNlID0gdGV4dFJpc2U7XG4gICAgfVxuXG4gICAgc2V0VGV4dFJlbmRlcmluZ01vZGUodGV4dFJlbmRlcmluZ01vZGUpIHtcbiAgICAgIHRoaXMuY3VycmVudC50ZXh0UmVuZGVyaW5nTW9kZSA9IHRleHRSZW5kZXJpbmdNb2RlO1xuICAgIH1cblxuICAgIHNldEhTY2FsZShzY2FsZSkge1xuICAgICAgdGhpcy5jdXJyZW50LnRleHRIU2NhbGUgPSBzY2FsZSAvIDEwMDtcbiAgICB9XG5cbiAgICBzZXRSZW5kZXJpbmdJbnRlbnQoaW50ZW50KSB7fVxuXG4gICAgc2V0RmxhdG5lc3MoZmxhdG5lc3MpIHt9XG5cbiAgICBzZXRHU3RhdGUoc3RhdGVzKSB7XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBzdGF0ZXMpIHtcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICBjYXNlIFwiTFdcIjpcbiAgICAgICAgICAgIHRoaXMuc2V0TGluZVdpZHRoKHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcIkxDXCI6XG4gICAgICAgICAgICB0aGlzLnNldExpbmVDYXAodmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiTEpcIjpcbiAgICAgICAgICAgIHRoaXMuc2V0TGluZUpvaW4odmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiTUxcIjpcbiAgICAgICAgICAgIHRoaXMuc2V0TWl0ZXJMaW1pdCh2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJEXCI6XG4gICAgICAgICAgICB0aGlzLnNldERhc2godmFsdWVbMF0sIHZhbHVlWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcIlJJXCI6XG4gICAgICAgICAgICB0aGlzLnNldFJlbmRlcmluZ0ludGVudCh2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJGTFwiOlxuICAgICAgICAgICAgdGhpcy5zZXRGbGF0bmVzcyh2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJGb250XCI6XG4gICAgICAgICAgICB0aGlzLnNldEZvbnQodmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiQ0FcIjpcbiAgICAgICAgICAgIHRoaXMuc2V0U3Ryb2tlQWxwaGEodmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiY2FcIjpcbiAgICAgICAgICAgIHRoaXMuc2V0RmlsbEFscGhhKHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICgwLCBfdXRpbC53YXJuKShgVW5pbXBsZW1lbnRlZCBncmFwaGljIHN0YXRlIG9wZXJhdG9yICR7a2V5fWApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmaWxsKCkge1xuICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcblxuICAgICAgaWYgKGN1cnJlbnQuZWxlbWVudCkge1xuICAgICAgICBjdXJyZW50LmVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsXCIsIGN1cnJlbnQuZmlsbENvbG9yKTtcbiAgICAgICAgY3VycmVudC5lbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbC1vcGFjaXR5XCIsIGN1cnJlbnQuZmlsbEFscGhhKTtcbiAgICAgICAgdGhpcy5lbmRQYXRoKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3Ryb2tlKCkge1xuICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcblxuICAgICAgaWYgKGN1cnJlbnQuZWxlbWVudCkge1xuICAgICAgICB0aGlzLl9zZXRTdHJva2VBdHRyaWJ1dGVzKGN1cnJlbnQuZWxlbWVudCk7XG5cbiAgICAgICAgY3VycmVudC5lbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbFwiLCBcIm5vbmVcIik7XG4gICAgICAgIHRoaXMuZW5kUGF0aCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9zZXRTdHJva2VBdHRyaWJ1dGVzKGVsZW1lbnQsIGxpbmVXaWR0aFNjYWxlID0gMSkge1xuICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICAgIGxldCBkYXNoQXJyYXkgPSBjdXJyZW50LmRhc2hBcnJheTtcblxuICAgICAgaWYgKGxpbmVXaWR0aFNjYWxlICE9PSAxICYmIGRhc2hBcnJheS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGRhc2hBcnJheSA9IGRhc2hBcnJheS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGxpbmVXaWR0aFNjYWxlICogdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwic3Ryb2tlXCIsIGN1cnJlbnQuc3Ryb2tlQ29sb3IpO1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInN0cm9rZS1vcGFjaXR5XCIsIGN1cnJlbnQuc3Ryb2tlQWxwaGEpO1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInN0cm9rZS1taXRlcmxpbWl0XCIsIHBmKGN1cnJlbnQubWl0ZXJMaW1pdCkpO1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInN0cm9rZS1saW5lY2FwXCIsIGN1cnJlbnQubGluZUNhcCk7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwic3Ryb2tlLWxpbmVqb2luXCIsIGN1cnJlbnQubGluZUpvaW4pO1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInN0cm9rZS13aWR0aFwiLCBwZihsaW5lV2lkdGhTY2FsZSAqIGN1cnJlbnQubGluZVdpZHRoKSArIFwicHhcIik7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwic3Ryb2tlLWRhc2hhcnJheVwiLCBkYXNoQXJyYXkubWFwKHBmKS5qb2luKFwiIFwiKSk7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwic3Ryb2tlLWRhc2hvZmZzZXRcIiwgcGYobGluZVdpZHRoU2NhbGUgKiBjdXJyZW50LmRhc2hQaGFzZSkgKyBcInB4XCIpO1xuICAgIH1cblxuICAgIGVvRmlsbCgpIHtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnQuZWxlbWVudCkge1xuICAgICAgICB0aGlzLmN1cnJlbnQuZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZpbGwtcnVsZVwiLCBcImV2ZW5vZGRcIik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZmlsbCgpO1xuICAgIH1cblxuICAgIGZpbGxTdHJva2UoKSB7XG4gICAgICB0aGlzLnN0cm9rZSgpO1xuICAgICAgdGhpcy5maWxsKCk7XG4gICAgfVxuXG4gICAgZW9GaWxsU3Ryb2tlKCkge1xuICAgICAgaWYgKHRoaXMuY3VycmVudC5lbGVtZW50KSB7XG4gICAgICAgIHRoaXMuY3VycmVudC5lbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbC1ydWxlXCIsIFwiZXZlbm9kZFwiKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5maWxsU3Ryb2tlKCk7XG4gICAgfVxuXG4gICAgY2xvc2VTdHJva2UoKSB7XG4gICAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICAgICAgdGhpcy5zdHJva2UoKTtcbiAgICB9XG5cbiAgICBjbG9zZUZpbGxTdHJva2UoKSB7XG4gICAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICAgICAgdGhpcy5maWxsU3Ryb2tlKCk7XG4gICAgfVxuXG4gICAgY2xvc2VFT0ZpbGxTdHJva2UoKSB7XG4gICAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICAgICAgdGhpcy5lb0ZpbGxTdHJva2UoKTtcbiAgICB9XG5cbiAgICBwYWludFNvbGlkQ29sb3JJbWFnZU1hc2soKSB7XG4gICAgICBjb25zdCByZWN0ID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6cmVjdFwiKTtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ4XCIsIFwiMFwiKTtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ5XCIsIFwiMFwiKTtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ3aWR0aFwiLCBcIjFweFwiKTtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJoZWlnaHRcIiwgXCIxcHhcIik7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbFwiLCB0aGlzLmN1cnJlbnQuZmlsbENvbG9yKTtcblxuICAgICAgdGhpcy5fZW5zdXJlVHJhbnNmb3JtR3JvdXAoKS5hcHBlbmRDaGlsZChyZWN0KTtcbiAgICB9XG5cbiAgICBwYWludEltYWdlWE9iamVjdChvYmpJZCkge1xuICAgICAgY29uc3QgaW1nRGF0YSA9IG9iaklkLnN0YXJ0c1dpdGgoXCJnX1wiKSA/IHRoaXMuY29tbW9uT2Jqcy5nZXQob2JqSWQpIDogdGhpcy5vYmpzLmdldChvYmpJZCk7XG5cbiAgICAgIGlmICghaW1nRGF0YSkge1xuICAgICAgICAoMCwgX3V0aWwud2FybikoYERlcGVuZGVudCBpbWFnZSB3aXRoIG9iamVjdCBJRCAke29iaklkfSBpcyBub3QgcmVhZHkgeWV0YCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wYWludElubGluZUltYWdlWE9iamVjdChpbWdEYXRhKTtcbiAgICB9XG5cbiAgICBwYWludElubGluZUltYWdlWE9iamVjdChpbWdEYXRhLCBtYXNrKSB7XG4gICAgICBjb25zdCB3aWR0aCA9IGltZ0RhdGEud2lkdGg7XG4gICAgICBjb25zdCBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodDtcbiAgICAgIGNvbnN0IGltZ1NyYyA9IGNvbnZlcnRJbWdEYXRhVG9QbmcoaW1nRGF0YSwgdGhpcy5mb3JjZURhdGFTY2hlbWEsICEhbWFzayk7XG4gICAgICBjb25zdCBjbGlwcmVjdCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnJlY3RcIik7XG4gICAgICBjbGlwcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInhcIiwgXCIwXCIpO1xuICAgICAgY2xpcHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ5XCIsIFwiMFwiKTtcbiAgICAgIGNsaXByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwid2lkdGhcIiwgcGYod2lkdGgpKTtcbiAgICAgIGNsaXByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiaGVpZ2h0XCIsIHBmKGhlaWdodCkpO1xuICAgICAgdGhpcy5jdXJyZW50LmVsZW1lbnQgPSBjbGlwcmVjdDtcbiAgICAgIHRoaXMuY2xpcChcIm5vbnplcm9cIik7XG4gICAgICBjb25zdCBpbWdFbCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOmltYWdlXCIpO1xuICAgICAgaW1nRWwuc2V0QXR0cmlidXRlTlMoWExJTktfTlMsIFwieGxpbms6aHJlZlwiLCBpbWdTcmMpO1xuICAgICAgaW1nRWwuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ4XCIsIFwiMFwiKTtcbiAgICAgIGltZ0VsLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieVwiLCBwZigtaGVpZ2h0KSk7XG4gICAgICBpbWdFbC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIndpZHRoXCIsIHBmKHdpZHRoKSArIFwicHhcIik7XG4gICAgICBpbWdFbC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImhlaWdodFwiLCBwZihoZWlnaHQpICsgXCJweFwiKTtcbiAgICAgIGltZ0VsLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwidHJhbnNmb3JtXCIsIGBzY2FsZSgke3BmKDEgLyB3aWR0aCl9ICR7cGYoLTEgLyBoZWlnaHQpfSlgKTtcblxuICAgICAgaWYgKG1hc2spIHtcbiAgICAgICAgbWFzay5hcHBlbmRDaGlsZChpbWdFbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9lbnN1cmVUcmFuc2Zvcm1Hcm91cCgpLmFwcGVuZENoaWxkKGltZ0VsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwYWludEltYWdlTWFza1hPYmplY3QoaW1nRGF0YSkge1xuICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICAgIGNvbnN0IHdpZHRoID0gaW1nRGF0YS53aWR0aDtcbiAgICAgIGNvbnN0IGhlaWdodCA9IGltZ0RhdGEuaGVpZ2h0O1xuICAgICAgY29uc3QgZmlsbENvbG9yID0gY3VycmVudC5maWxsQ29sb3I7XG4gICAgICBjdXJyZW50Lm1hc2tJZCA9IGBtYXNrJHttYXNrQ291bnQrK31gO1xuICAgICAgY29uc3QgbWFzayA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOm1hc2tcIik7XG4gICAgICBtYXNrLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiaWRcIiwgY3VycmVudC5tYXNrSWQpO1xuICAgICAgY29uc3QgcmVjdCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnJlY3RcIik7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieFwiLCBcIjBcIik7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieVwiLCBcIjBcIik7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwid2lkdGhcIiwgcGYod2lkdGgpKTtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJoZWlnaHRcIiwgcGYoaGVpZ2h0KSk7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbFwiLCBmaWxsQ29sb3IpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIm1hc2tcIiwgYHVybCgjJHtjdXJyZW50Lm1hc2tJZH0pYCk7XG4gICAgICB0aGlzLmRlZnMuYXBwZW5kQ2hpbGQobWFzayk7XG5cbiAgICAgIHRoaXMuX2Vuc3VyZVRyYW5zZm9ybUdyb3VwKCkuYXBwZW5kQ2hpbGQocmVjdCk7XG5cbiAgICAgIHRoaXMucGFpbnRJbmxpbmVJbWFnZVhPYmplY3QoaW1nRGF0YSwgbWFzayk7XG4gICAgfVxuXG4gICAgcGFpbnRGb3JtWE9iamVjdEJlZ2luKG1hdHJpeCwgYmJveCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWF0cml4KSAmJiBtYXRyaXgubGVuZ3RoID09PSA2KSB7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtKG1hdHJpeFswXSwgbWF0cml4WzFdLCBtYXRyaXhbMl0sIG1hdHJpeFszXSwgbWF0cml4WzRdLCBtYXRyaXhbNV0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoYmJveCkge1xuICAgICAgICBjb25zdCB3aWR0aCA9IGJib3hbMl0gLSBiYm94WzBdO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBiYm94WzNdIC0gYmJveFsxXTtcbiAgICAgICAgY29uc3QgY2xpcHJlY3QgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpyZWN0XCIpO1xuICAgICAgICBjbGlwcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInhcIiwgYmJveFswXSk7XG4gICAgICAgIGNsaXByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieVwiLCBiYm94WzFdKTtcbiAgICAgICAgY2xpcHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ3aWR0aFwiLCBwZih3aWR0aCkpO1xuICAgICAgICBjbGlwcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImhlaWdodFwiLCBwZihoZWlnaHQpKTtcbiAgICAgICAgdGhpcy5jdXJyZW50LmVsZW1lbnQgPSBjbGlwcmVjdDtcbiAgICAgICAgdGhpcy5jbGlwKFwibm9uemVyb1wiKTtcbiAgICAgICAgdGhpcy5lbmRQYXRoKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcGFpbnRGb3JtWE9iamVjdEVuZCgpIHt9XG5cbiAgICBfaW5pdGlhbGl6ZSh2aWV3cG9ydCkge1xuICAgICAgY29uc3Qgc3ZnID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZSh2aWV3cG9ydC53aWR0aCwgdmlld3BvcnQuaGVpZ2h0KTtcbiAgICAgIGNvbnN0IGRlZmluaXRpb25zID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6ZGVmc1wiKTtcbiAgICAgIHN2Zy5hcHBlbmRDaGlsZChkZWZpbml0aW9ucyk7XG4gICAgICB0aGlzLmRlZnMgPSBkZWZpbml0aW9ucztcbiAgICAgIGNvbnN0IHJvb3RHcm91cCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOmdcIik7XG4gICAgICByb290R3JvdXAuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ0cmFuc2Zvcm1cIiwgcG0odmlld3BvcnQudHJhbnNmb3JtKSk7XG4gICAgICBzdmcuYXBwZW5kQ2hpbGQocm9vdEdyb3VwKTtcbiAgICAgIHRoaXMuc3ZnID0gcm9vdEdyb3VwO1xuICAgICAgcmV0dXJuIHN2ZztcbiAgICB9XG5cbiAgICBfZW5zdXJlQ2xpcEdyb3VwKCkge1xuICAgICAgaWYgKCF0aGlzLmN1cnJlbnQuY2xpcEdyb3VwKSB7XG4gICAgICAgIGNvbnN0IGNsaXBHcm91cCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOmdcIik7XG4gICAgICAgIGNsaXBHcm91cC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImNsaXAtcGF0aFwiLCB0aGlzLmN1cnJlbnQuYWN0aXZlQ2xpcFVybCk7XG4gICAgICAgIHRoaXMuc3ZnLmFwcGVuZENoaWxkKGNsaXBHcm91cCk7XG4gICAgICAgIHRoaXMuY3VycmVudC5jbGlwR3JvdXAgPSBjbGlwR3JvdXA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmN1cnJlbnQuY2xpcEdyb3VwO1xuICAgIH1cblxuICAgIF9lbnN1cmVUcmFuc2Zvcm1Hcm91cCgpIHtcbiAgICAgIGlmICghdGhpcy50Z3JwKSB7XG4gICAgICAgIHRoaXMudGdycCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOmdcIik7XG4gICAgICAgIHRoaXMudGdycC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInRyYW5zZm9ybVwiLCBwbSh0aGlzLnRyYW5zZm9ybU1hdHJpeCkpO1xuXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnQuYWN0aXZlQ2xpcFVybCkge1xuICAgICAgICAgIHRoaXMuX2Vuc3VyZUNsaXBHcm91cCgpLmFwcGVuZENoaWxkKHRoaXMudGdycCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdmcuYXBwZW5kQ2hpbGQodGhpcy50Z3JwKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy50Z3JwO1xuICAgIH1cblxuICB9O1xufVxuXG4vKioqLyB9KSxcbi8qIDIyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlBERk5vZGVTdHJlYW0gPSB2b2lkIDA7XG5cbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMik7XG5cbnZhciBfbmV0d29ya191dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oMjMpO1xuXG47XG5cbmNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xuXG5jb25zdCBodHRwID0gcmVxdWlyZShcImh0dHBcIik7XG5cbmNvbnN0IGh0dHBzID0gcmVxdWlyZShcImh0dHBzXCIpO1xuXG5jb25zdCB1cmwgPSByZXF1aXJlKFwidXJsXCIpO1xuXG5jb25zdCBmaWxlVXJpUmVnZXggPSAvXmZpbGU6XFwvXFwvXFwvW2EtekEtWl06XFwvLztcblxuZnVuY3Rpb24gcGFyc2VVcmwoc291cmNlVXJsKSB7XG4gIGNvbnN0IHBhcnNlZFVybCA9IHVybC5wYXJzZShzb3VyY2VVcmwpO1xuXG4gIGlmIChwYXJzZWRVcmwucHJvdG9jb2wgPT09IFwiZmlsZTpcIiB8fCBwYXJzZWRVcmwuaG9zdCkge1xuICAgIHJldHVybiBwYXJzZWRVcmw7XG4gIH1cblxuICBpZiAoL15bYS16XTpbL1xcXFxdL2kudGVzdChzb3VyY2VVcmwpKSB7XG4gICAgcmV0dXJuIHVybC5wYXJzZShgZmlsZTovLy8ke3NvdXJjZVVybH1gKTtcbiAgfVxuXG4gIGlmICghcGFyc2VkVXJsLmhvc3QpIHtcbiAgICBwYXJzZWRVcmwucHJvdG9jb2wgPSBcImZpbGU6XCI7XG4gIH1cblxuICByZXR1cm4gcGFyc2VkVXJsO1xufVxuXG5jbGFzcyBQREZOb2RlU3RyZWFtIHtcbiAgY29uc3RydWN0b3Ioc291cmNlKSB7XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy51cmwgPSBwYXJzZVVybChzb3VyY2UudXJsKTtcbiAgICB0aGlzLmlzSHR0cCA9IHRoaXMudXJsLnByb3RvY29sID09PSBcImh0dHA6XCIgfHwgdGhpcy51cmwucHJvdG9jb2wgPT09IFwiaHR0cHM6XCI7XG4gICAgdGhpcy5pc0ZzVXJsID0gdGhpcy51cmwucHJvdG9jb2wgPT09IFwiZmlsZTpcIjtcbiAgICB0aGlzLmh0dHBIZWFkZXJzID0gdGhpcy5pc0h0dHAgJiYgc291cmNlLmh0dHBIZWFkZXJzIHx8IHt9O1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzID0gW107XG4gIH1cblxuICBnZXQgX3Byb2dyZXNzaXZlRGF0YUxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPyB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlci5fbG9hZGVkIDogMDtcbiAgfVxuXG4gIGdldEZ1bGxSZWFkZXIoKSB7XG4gICAgKDAsIF91dGlsLmFzc2VydCkoIXRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLCBcIlBERk5vZGVTdHJlYW0uZ2V0RnVsbFJlYWRlciBjYW4gb25seSBiZSBjYWxsZWQgb25jZS5cIik7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSB0aGlzLmlzRnNVcmwgPyBuZXcgUERGTm9kZVN0cmVhbUZzRnVsbFJlYWRlcih0aGlzKSA6IG5ldyBQREZOb2RlU3RyZWFtRnVsbFJlYWRlcih0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI7XG4gIH1cblxuICBnZXRSYW5nZVJlYWRlcihzdGFydCwgZW5kKSB7XG4gICAgaWYgKGVuZCA8PSB0aGlzLl9wcm9ncmVzc2l2ZURhdGFMZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHJhbmdlUmVhZGVyID0gdGhpcy5pc0ZzVXJsID8gbmV3IFBERk5vZGVTdHJlYW1Gc1JhbmdlUmVhZGVyKHRoaXMsIHN0YXJ0LCBlbmQpIDogbmV3IFBERk5vZGVTdHJlYW1SYW5nZVJlYWRlcih0aGlzLCBzdGFydCwgZW5kKTtcblxuICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMucHVzaChyYW5nZVJlYWRlcik7XG5cbiAgICByZXR1cm4gcmFuZ2VSZWFkZXI7XG4gIH1cblxuICBjYW5jZWxBbGxSZXF1ZXN0cyhyZWFzb24pIHtcbiAgICBpZiAodGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIpIHtcbiAgICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLmNhbmNlbChyZWFzb24pO1xuICAgIH1cblxuICAgIGNvbnN0IHJlYWRlcnMgPSB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnNsaWNlKDApO1xuXG4gICAgcmVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChyZWFkZXIpIHtcbiAgICAgIHJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICB9KTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuUERGTm9kZVN0cmVhbSA9IFBERk5vZGVTdHJlYW07XG5cbmNsYXNzIEJhc2VGdWxsUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtKSB7XG4gICAgdGhpcy5fdXJsID0gc3RyZWFtLnVybDtcbiAgICB0aGlzLl9kb25lID0gZmFsc2U7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSBudWxsO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gICAgY29uc3Qgc291cmNlID0gc3RyZWFtLnNvdXJjZTtcbiAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgICB0aGlzLl9sb2FkZWQgPSAwO1xuICAgIHRoaXMuX2ZpbGVuYW1lID0gbnVsbDtcbiAgICB0aGlzLl9kaXNhYmxlUmFuZ2UgPSBzb3VyY2UuZGlzYWJsZVJhbmdlIHx8IGZhbHNlO1xuICAgIHRoaXMuX3JhbmdlQ2h1bmtTaXplID0gc291cmNlLnJhbmdlQ2h1bmtTaXplO1xuXG4gICAgaWYgKCF0aGlzLl9yYW5nZUNodW5rU2l6ZSAmJiAhdGhpcy5fZGlzYWJsZVJhbmdlKSB7XG4gICAgICB0aGlzLl9kaXNhYmxlUmFuZ2UgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkID0gIXNvdXJjZS5kaXNhYmxlU3RyZWFtO1xuICAgIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSAhc291cmNlLmRpc2FibGVSYW5nZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbSA9IG51bGw7XG4gICAgdGhpcy5fcmVhZENhcGFiaWxpdHkgPSAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCk7XG4gICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkgPSAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCk7XG4gIH1cblxuICBnZXQgaGVhZGVyc1JlYWR5KCkge1xuICAgIHJldHVybiB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG5cbiAgZ2V0IGZpbGVuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9maWxlbmFtZTtcbiAgfVxuXG4gIGdldCBjb250ZW50TGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9jb250ZW50TGVuZ3RoO1xuICB9XG5cbiAgZ2V0IGlzUmFuZ2VTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQ7XG4gIH1cblxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkO1xuICB9XG5cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBhd2FpdCB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5wcm9taXNlO1xuXG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3N0b3JlZEVycm9yKSB7XG4gICAgICB0aHJvdyB0aGlzLl9zdG9yZWRFcnJvcjtcbiAgICB9XG5cbiAgICBjb25zdCBjaHVuayA9IHRoaXMuX3JlYWRhYmxlU3RyZWFtLnJlYWQoKTtcblxuICAgIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkgPSAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCk7XG4gICAgICByZXR1cm4gdGhpcy5yZWFkKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fbG9hZGVkICs9IGNodW5rLmxlbmd0aDtcblxuICAgIGlmICh0aGlzLm9uUHJvZ3Jlc3MpIHtcbiAgICAgIHRoaXMub25Qcm9ncmVzcyh7XG4gICAgICAgIGxvYWRlZDogdGhpcy5fbG9hZGVkLFxuICAgICAgICB0b3RhbDogdGhpcy5fY29udGVudExlbmd0aFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmspLmJ1ZmZlcjtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IGJ1ZmZlcixcbiAgICAgIGRvbmU6IGZhbHNlXG4gICAgfTtcbiAgfVxuXG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RyZWFtKSB7XG4gICAgICB0aGlzLl9lcnJvcihyZWFzb24pO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fcmVhZGFibGVTdHJlYW0uZGVzdHJveShyZWFzb24pO1xuICB9XG5cbiAgX2Vycm9yKHJlYXNvbikge1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID0gcmVhc29uO1xuXG4gICAgdGhpcy5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICB9XG5cbiAgX3NldFJlYWRhYmxlU3RyZWFtKHJlYWRhYmxlU3RyZWFtKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdHJlYW0gPSByZWFkYWJsZVN0cmVhbTtcbiAgICByZWFkYWJsZVN0cmVhbS5vbihcInJlYWRhYmxlXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB9KTtcbiAgICByZWFkYWJsZVN0cmVhbS5vbihcImVuZFwiLCAoKSA9PiB7XG4gICAgICByZWFkYWJsZVN0cmVhbS5kZXN0cm95KCk7XG4gICAgICB0aGlzLl9kb25lID0gdHJ1ZTtcblxuICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIH0pO1xuICAgIHJlYWRhYmxlU3RyZWFtLm9uKFwiZXJyb3JcIiwgcmVhc29uID0+IHtcbiAgICAgIHRoaXMuX2Vycm9yKHJlYXNvbik7XG4gICAgfSk7XG5cbiAgICBpZiAoIXRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkICYmIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQpIHtcbiAgICAgIHRoaXMuX2Vycm9yKG5ldyBfdXRpbC5BYm9ydEV4Y2VwdGlvbihcInN0cmVhbWluZyBpcyBkaXNhYmxlZFwiKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3N0b3JlZEVycm9yKSB7XG4gICAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbS5kZXN0cm95KHRoaXMuX3N0b3JlZEVycm9yKTtcbiAgICB9XG4gIH1cblxufVxuXG5jbGFzcyBCYXNlUmFuZ2VSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0pIHtcbiAgICB0aGlzLl91cmwgPSBzdHJlYW0udXJsO1xuICAgIHRoaXMuX2RvbmUgPSBmYWxzZTtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9IG51bGw7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgICB0aGlzLl9sb2FkZWQgPSAwO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtID0gbnVsbDtcbiAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eSA9ICgwLCBfdXRpbC5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSkoKTtcbiAgICBjb25zdCBzb3VyY2UgPSBzdHJlYW0uc291cmNlO1xuICAgIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkID0gIXNvdXJjZS5kaXNhYmxlU3RyZWFtO1xuICB9XG5cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgfVxuXG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgYXdhaXQgdGhpcy5fcmVhZENhcGFiaWxpdHkucHJvbWlzZTtcblxuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zdG9yZWRFcnJvcikge1xuICAgICAgdGhyb3cgdGhpcy5fc3RvcmVkRXJyb3I7XG4gICAgfVxuXG4gICAgY29uc3QgY2h1bmsgPSB0aGlzLl9yZWFkYWJsZVN0cmVhbS5yZWFkKCk7XG5cbiAgICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5ID0gKDAsIF91dGlsLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KSgpO1xuICAgICAgcmV0dXJuIHRoaXMucmVhZCgpO1xuICAgIH1cblxuICAgIHRoaXMuX2xvYWRlZCArPSBjaHVuay5sZW5ndGg7XG5cbiAgICBpZiAodGhpcy5vblByb2dyZXNzKSB7XG4gICAgICB0aGlzLm9uUHJvZ3Jlc3Moe1xuICAgICAgICBsb2FkZWQ6IHRoaXMuX2xvYWRlZFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmspLmJ1ZmZlcjtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IGJ1ZmZlcixcbiAgICAgIGRvbmU6IGZhbHNlXG4gICAgfTtcbiAgfVxuXG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RyZWFtKSB7XG4gICAgICB0aGlzLl9lcnJvcihyZWFzb24pO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fcmVhZGFibGVTdHJlYW0uZGVzdHJveShyZWFzb24pO1xuICB9XG5cbiAgX2Vycm9yKHJlYXNvbikge1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID0gcmVhc29uO1xuXG4gICAgdGhpcy5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICB9XG5cbiAgX3NldFJlYWRhYmxlU3RyZWFtKHJlYWRhYmxlU3RyZWFtKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdHJlYW0gPSByZWFkYWJsZVN0cmVhbTtcbiAgICByZWFkYWJsZVN0cmVhbS5vbihcInJlYWRhYmxlXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB9KTtcbiAgICByZWFkYWJsZVN0cmVhbS5vbihcImVuZFwiLCAoKSA9PiB7XG4gICAgICByZWFkYWJsZVN0cmVhbS5kZXN0cm95KCk7XG4gICAgICB0aGlzLl9kb25lID0gdHJ1ZTtcblxuICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIH0pO1xuICAgIHJlYWRhYmxlU3RyZWFtLm9uKFwiZXJyb3JcIiwgcmVhc29uID0+IHtcbiAgICAgIHRoaXMuX2Vycm9yKHJlYXNvbik7XG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5fc3RvcmVkRXJyb3IpIHtcbiAgICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtLmRlc3Ryb3kodGhpcy5fc3RvcmVkRXJyb3IpO1xuICAgIH1cbiAgfVxuXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlcXVlc3RPcHRpb25zKHBhcnNlZFVybCwgaGVhZGVycykge1xuICByZXR1cm4ge1xuICAgIHByb3RvY29sOiBwYXJzZWRVcmwucHJvdG9jb2wsXG4gICAgYXV0aDogcGFyc2VkVXJsLmF1dGgsXG4gICAgaG9zdDogcGFyc2VkVXJsLmhvc3RuYW1lLFxuICAgIHBvcnQ6IHBhcnNlZFVybC5wb3J0LFxuICAgIHBhdGg6IHBhcnNlZFVybC5wYXRoLFxuICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICBoZWFkZXJzXG4gIH07XG59XG5cbmNsYXNzIFBERk5vZGVTdHJlYW1GdWxsUmVhZGVyIGV4dGVuZHMgQmFzZUZ1bGxSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0pIHtcbiAgICBzdXBlcihzdHJlYW0pO1xuXG4gICAgY29uc3QgaGFuZGxlUmVzcG9uc2UgPSByZXNwb25zZSA9PiB7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gNDA0KSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IF91dGlsLk1pc3NpbmdQREZFeGNlcHRpb24oYE1pc3NpbmcgUERGIFwiJHt0aGlzLl91cmx9XCIuYCk7XG4gICAgICAgIHRoaXMuX3N0b3JlZEVycm9yID0gZXJyb3I7XG5cbiAgICAgICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucmVqZWN0KGVycm9yKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlc29sdmUoKTtcblxuICAgICAgdGhpcy5fc2V0UmVhZGFibGVTdHJlYW0ocmVzcG9uc2UpO1xuXG4gICAgICBjb25zdCBnZXRSZXNwb25zZUhlYWRlciA9IG5hbWUgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdHJlYW0uaGVhZGVyc1tuYW1lLnRvTG93ZXJDYXNlKCldO1xuICAgICAgfTtcblxuICAgICAgY29uc3Qge1xuICAgICAgICBhbGxvd1JhbmdlUmVxdWVzdHMsXG4gICAgICAgIHN1Z2dlc3RlZExlbmd0aFxuICAgICAgfSA9ICgwLCBfbmV0d29ya191dGlscy52YWxpZGF0ZVJhbmdlUmVxdWVzdENhcGFiaWxpdGllcykoe1xuICAgICAgICBnZXRSZXNwb25zZUhlYWRlcixcbiAgICAgICAgaXNIdHRwOiBzdHJlYW0uaXNIdHRwLFxuICAgICAgICByYW5nZUNodW5rU2l6ZTogdGhpcy5fcmFuZ2VDaHVua1NpemUsXG4gICAgICAgIGRpc2FibGVSYW5nZTogdGhpcy5fZGlzYWJsZVJhbmdlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSBhbGxvd1JhbmdlUmVxdWVzdHM7XG4gICAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gc3VnZ2VzdGVkTGVuZ3RoIHx8IHRoaXMuX2NvbnRlbnRMZW5ndGg7XG4gICAgICB0aGlzLl9maWxlbmFtZSA9ICgwLCBfbmV0d29ya191dGlscy5leHRyYWN0RmlsZW5hbWVGcm9tSGVhZGVyKShnZXRSZXNwb25zZUhlYWRlcik7XG4gICAgfTtcblxuICAgIHRoaXMuX3JlcXVlc3QgPSBudWxsO1xuXG4gICAgaWYgKHRoaXMuX3VybC5wcm90b2NvbCA9PT0gXCJodHRwOlwiKSB7XG4gICAgICB0aGlzLl9yZXF1ZXN0ID0gaHR0cC5yZXF1ZXN0KGNyZWF0ZVJlcXVlc3RPcHRpb25zKHRoaXMuX3VybCwgc3RyZWFtLmh0dHBIZWFkZXJzKSwgaGFuZGxlUmVzcG9uc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZXF1ZXN0ID0gaHR0cHMucmVxdWVzdChjcmVhdGVSZXF1ZXN0T3B0aW9ucyh0aGlzLl91cmwsIHN0cmVhbS5odHRwSGVhZGVycyksIGhhbmRsZVJlc3BvbnNlKTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZXF1ZXN0Lm9uKFwiZXJyb3JcIiwgcmVhc29uID0+IHtcbiAgICAgIHRoaXMuX3N0b3JlZEVycm9yID0gcmVhc29uO1xuXG4gICAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZWplY3QocmVhc29uKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX3JlcXVlc3QuZW5kKCk7XG4gIH1cblxufVxuXG5jbGFzcyBQREZOb2RlU3RyZWFtUmFuZ2VSZWFkZXIgZXh0ZW5kcyBCYXNlUmFuZ2VSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0sIHN0YXJ0LCBlbmQpIHtcbiAgICBzdXBlcihzdHJlYW0pO1xuICAgIHRoaXMuX2h0dHBIZWFkZXJzID0ge307XG5cbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5IGluIHN0cmVhbS5odHRwSGVhZGVycykge1xuICAgICAgY29uc3QgdmFsdWUgPSBzdHJlYW0uaHR0cEhlYWRlcnNbcHJvcGVydHldO1xuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9odHRwSGVhZGVyc1twcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICB0aGlzLl9odHRwSGVhZGVycy5SYW5nZSA9IGBieXRlcz0ke3N0YXJ0fS0ke2VuZCAtIDF9YDtcblxuICAgIGNvbnN0IGhhbmRsZVJlc3BvbnNlID0gcmVzcG9uc2UgPT4ge1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDQwNCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBfdXRpbC5NaXNzaW5nUERGRXhjZXB0aW9uKGBNaXNzaW5nIFBERiBcIiR7dGhpcy5fdXJsfVwiLmApO1xuICAgICAgICB0aGlzLl9zdG9yZWRFcnJvciA9IGVycm9yO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3NldFJlYWRhYmxlU3RyZWFtKHJlc3BvbnNlKTtcbiAgICB9O1xuXG4gICAgdGhpcy5fcmVxdWVzdCA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5fdXJsLnByb3RvY29sID09PSBcImh0dHA6XCIpIHtcbiAgICAgIHRoaXMuX3JlcXVlc3QgPSBodHRwLnJlcXVlc3QoY3JlYXRlUmVxdWVzdE9wdGlvbnModGhpcy5fdXJsLCB0aGlzLl9odHRwSGVhZGVycyksIGhhbmRsZVJlc3BvbnNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVxdWVzdCA9IGh0dHBzLnJlcXVlc3QoY3JlYXRlUmVxdWVzdE9wdGlvbnModGhpcy5fdXJsLCB0aGlzLl9odHRwSGVhZGVycyksIGhhbmRsZVJlc3BvbnNlKTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZXF1ZXN0Lm9uKFwiZXJyb3JcIiwgcmVhc29uID0+IHtcbiAgICAgIHRoaXMuX3N0b3JlZEVycm9yID0gcmVhc29uO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fcmVxdWVzdC5lbmQoKTtcbiAgfVxuXG59XG5cbmNsYXNzIFBERk5vZGVTdHJlYW1Gc0Z1bGxSZWFkZXIgZXh0ZW5kcyBCYXNlRnVsbFJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSkge1xuICAgIHN1cGVyKHN0cmVhbSk7XG4gICAgbGV0IHBhdGggPSBkZWNvZGVVUklDb21wb25lbnQodGhpcy5fdXJsLnBhdGgpO1xuXG4gICAgaWYgKGZpbGVVcmlSZWdleC50ZXN0KHRoaXMuX3VybC5ocmVmKSkge1xuICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXlxcLy8sIFwiXCIpO1xuICAgIH1cblxuICAgIGZzLmxzdGF0KHBhdGgsIChlcnJvciwgc3RhdCkgPT4ge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvci5jb2RlID09PSBcIkVOT0VOVFwiKSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgX3V0aWwuTWlzc2luZ1BERkV4Y2VwdGlvbihgTWlzc2luZyBQREYgXCIke3BhdGh9XCIuYCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zdG9yZWRFcnJvciA9IGVycm9yO1xuXG4gICAgICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlamVjdChlcnJvcik7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gc3RhdC5zaXplO1xuXG4gICAgICB0aGlzLl9zZXRSZWFkYWJsZVN0cmVhbShmcy5jcmVhdGVSZWFkU3RyZWFtKHBhdGgpKTtcblxuICAgICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIH0pO1xuICB9XG5cbn1cblxuY2xhc3MgUERGTm9kZVN0cmVhbUZzUmFuZ2VSZWFkZXIgZXh0ZW5kcyBCYXNlUmFuZ2VSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0sIHN0YXJ0LCBlbmQpIHtcbiAgICBzdXBlcihzdHJlYW0pO1xuICAgIGxldCBwYXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KHRoaXMuX3VybC5wYXRoKTtcblxuICAgIGlmIChmaWxlVXJpUmVnZXgudGVzdCh0aGlzLl91cmwuaHJlZikpIHtcbiAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL15cXC8vLCBcIlwiKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zZXRSZWFkYWJsZVN0cmVhbShmcy5jcmVhdGVSZWFkU3RyZWFtKHBhdGgsIHtcbiAgICAgIHN0YXJ0LFxuICAgICAgZW5kOiBlbmQgLSAxXG4gICAgfSkpO1xuICB9XG5cbn1cblxuLyoqKi8gfSksXG4vKiAyMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jcmVhdGVSZXNwb25zZVN0YXR1c0Vycm9yID0gY3JlYXRlUmVzcG9uc2VTdGF0dXNFcnJvcjtcbmV4cG9ydHMuZXh0cmFjdEZpbGVuYW1lRnJvbUhlYWRlciA9IGV4dHJhY3RGaWxlbmFtZUZyb21IZWFkZXI7XG5leHBvcnRzLnZhbGlkYXRlUmFuZ2VSZXF1ZXN0Q2FwYWJpbGl0aWVzID0gdmFsaWRhdGVSYW5nZVJlcXVlc3RDYXBhYmlsaXRpZXM7XG5leHBvcnRzLnZhbGlkYXRlUmVzcG9uc2VTdGF0dXMgPSB2YWxpZGF0ZVJlc3BvbnNlU3RhdHVzO1xuXG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIpO1xuXG52YXIgX2NvbnRlbnRfZGlzcG9zaXRpb24gPSBfX3dfcGRmanNfcmVxdWlyZV9fKDI0KTtcblxuZnVuY3Rpb24gdmFsaWRhdGVSYW5nZVJlcXVlc3RDYXBhYmlsaXRpZXMoe1xuICBnZXRSZXNwb25zZUhlYWRlcixcbiAgaXNIdHRwLFxuICByYW5nZUNodW5rU2l6ZSxcbiAgZGlzYWJsZVJhbmdlXG59KSB7XG4gICgwLCBfdXRpbC5hc3NlcnQpKHJhbmdlQ2h1bmtTaXplID4gMCwgXCJSYW5nZSBjaHVuayBzaXplIG11c3QgYmUgbGFyZ2VyIHRoYW4gemVyb1wiKTtcbiAgY29uc3QgcmV0dXJuVmFsdWVzID0ge1xuICAgIGFsbG93UmFuZ2VSZXF1ZXN0czogZmFsc2UsXG4gICAgc3VnZ2VzdGVkTGVuZ3RoOiB1bmRlZmluZWRcbiAgfTtcbiAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQoZ2V0UmVzcG9uc2VIZWFkZXIoXCJDb250ZW50LUxlbmd0aFwiKSwgMTApO1xuXG4gIGlmICghTnVtYmVyLmlzSW50ZWdlcihsZW5ndGgpKSB7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlcztcbiAgfVxuXG4gIHJldHVyblZhbHVlcy5zdWdnZXN0ZWRMZW5ndGggPSBsZW5ndGg7XG5cbiAgaWYgKGxlbmd0aCA8PSAyICogcmFuZ2VDaHVua1NpemUpIHtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWVzO1xuICB9XG5cbiAgaWYgKGRpc2FibGVSYW5nZSB8fCAhaXNIdHRwKSB7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlcztcbiAgfVxuXG4gIGlmIChnZXRSZXNwb25zZUhlYWRlcihcIkFjY2VwdC1SYW5nZXNcIikgIT09IFwiYnl0ZXNcIikge1xuICAgIHJldHVybiByZXR1cm5WYWx1ZXM7XG4gIH1cblxuICBjb25zdCBjb250ZW50RW5jb2RpbmcgPSBnZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtRW5jb2RpbmdcIikgfHwgXCJpZGVudGl0eVwiO1xuXG4gIGlmIChjb250ZW50RW5jb2RpbmcgIT09IFwiaWRlbnRpdHlcIikge1xuICAgIHJldHVybiByZXR1cm5WYWx1ZXM7XG4gIH1cblxuICByZXR1cm5WYWx1ZXMuYWxsb3dSYW5nZVJlcXVlc3RzID0gdHJ1ZTtcbiAgcmV0dXJuIHJldHVyblZhbHVlcztcbn1cblxuZnVuY3Rpb24gZXh0cmFjdEZpbGVuYW1lRnJvbUhlYWRlcihnZXRSZXNwb25zZUhlYWRlcikge1xuICBjb25zdCBjb250ZW50RGlzcG9zaXRpb24gPSBnZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtRGlzcG9zaXRpb25cIik7XG5cbiAgaWYgKGNvbnRlbnREaXNwb3NpdGlvbikge1xuICAgIGxldCBmaWxlbmFtZSA9ICgwLCBfY29udGVudF9kaXNwb3NpdGlvbi5nZXRGaWxlbmFtZUZyb21Db250ZW50RGlzcG9zaXRpb25IZWFkZXIpKGNvbnRlbnREaXNwb3NpdGlvbik7XG5cbiAgICBpZiAoZmlsZW5hbWUuaW5jbHVkZXMoXCIlXCIpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBmaWxlbmFtZSA9IGRlY29kZVVSSUNvbXBvbmVudChmaWxlbmFtZSk7XG4gICAgICB9IGNhdGNoIChleCkge31cbiAgICB9XG5cbiAgICBpZiAoL1xcLnBkZiQvaS50ZXN0KGZpbGVuYW1lKSkge1xuICAgICAgcmV0dXJuIGZpbGVuYW1lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVSZXNwb25zZVN0YXR1c0Vycm9yKHN0YXR1cywgdXJsKSB7XG4gIGlmIChzdGF0dXMgPT09IDQwNCB8fCBzdGF0dXMgPT09IDAgJiYgdXJsLnN0YXJ0c1dpdGgoXCJmaWxlOlwiKSkge1xuICAgIHJldHVybiBuZXcgX3V0aWwuTWlzc2luZ1BERkV4Y2VwdGlvbignTWlzc2luZyBQREYgXCInICsgdXJsICsgJ1wiLicpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBfdXRpbC5VbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb24oXCJVbmV4cGVjdGVkIHNlcnZlciByZXNwb25zZSAoXCIgKyBzdGF0dXMgKyAnKSB3aGlsZSByZXRyaWV2aW5nIFBERiBcIicgKyB1cmwgKyAnXCIuJywgc3RhdHVzKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVSZXNwb25zZVN0YXR1cyhzdGF0dXMpIHtcbiAgcmV0dXJuIHN0YXR1cyA9PT0gMjAwIHx8IHN0YXR1cyA9PT0gMjA2O1xufVxuXG4vKioqLyB9KSxcbi8qIDI0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmdldEZpbGVuYW1lRnJvbUNvbnRlbnREaXNwb3NpdGlvbkhlYWRlciA9IGdldEZpbGVuYW1lRnJvbUNvbnRlbnREaXNwb3NpdGlvbkhlYWRlcjtcblxuZnVuY3Rpb24gZ2V0RmlsZW5hbWVGcm9tQ29udGVudERpc3Bvc2l0aW9uSGVhZGVyKGNvbnRlbnREaXNwb3NpdGlvbikge1xuICBsZXQgbmVlZHNFbmNvZGluZ0ZpeHVwID0gdHJ1ZTtcbiAgbGV0IHRtcCA9IHRvUGFyYW1SZWdFeHAoXCJmaWxlbmFtZVxcXFwqXCIsIFwiaVwiKS5leGVjKGNvbnRlbnREaXNwb3NpdGlvbik7XG5cbiAgaWYgKHRtcCkge1xuICAgIHRtcCA9IHRtcFsxXTtcbiAgICBsZXQgZmlsZW5hbWUgPSByZmMyNjE2dW5xdW90ZSh0bXApO1xuICAgIGZpbGVuYW1lID0gdW5lc2NhcGUoZmlsZW5hbWUpO1xuICAgIGZpbGVuYW1lID0gcmZjNTk4N2RlY29kZShmaWxlbmFtZSk7XG4gICAgZmlsZW5hbWUgPSByZmMyMDQ3ZGVjb2RlKGZpbGVuYW1lKTtcbiAgICByZXR1cm4gZml4dXBFbmNvZGluZyhmaWxlbmFtZSk7XG4gIH1cblxuICB0bXAgPSByZmMyMjMxZ2V0cGFyYW0oY29udGVudERpc3Bvc2l0aW9uKTtcblxuICBpZiAodG1wKSB7XG4gICAgY29uc3QgZmlsZW5hbWUgPSByZmMyMDQ3ZGVjb2RlKHRtcCk7XG4gICAgcmV0dXJuIGZpeHVwRW5jb2RpbmcoZmlsZW5hbWUpO1xuICB9XG5cbiAgdG1wID0gdG9QYXJhbVJlZ0V4cChcImZpbGVuYW1lXCIsIFwiaVwiKS5leGVjKGNvbnRlbnREaXNwb3NpdGlvbik7XG5cbiAgaWYgKHRtcCkge1xuICAgIHRtcCA9IHRtcFsxXTtcbiAgICBsZXQgZmlsZW5hbWUgPSByZmMyNjE2dW5xdW90ZSh0bXApO1xuICAgIGZpbGVuYW1lID0gcmZjMjA0N2RlY29kZShmaWxlbmFtZSk7XG4gICAgcmV0dXJuIGZpeHVwRW5jb2RpbmcoZmlsZW5hbWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9QYXJhbVJlZ0V4cChhdHRyaWJ1dGVQYXR0ZXJuLCBmbGFncykge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKFwiKD86Xnw7KVxcXFxzKlwiICsgYXR0cmlidXRlUGF0dGVybiArIFwiXFxcXHMqPVxcXFxzKlwiICsgXCIoXCIgKyAnW15cIjtcXFxcc11bXjtcXFxcc10qJyArIFwifFwiICsgJ1wiKD86W15cIlxcXFxcXFxcXXxcXFxcXFxcXFwiPykrXCI/JyArIFwiKVwiLCBmbGFncyk7XG4gIH1cblxuICBmdW5jdGlvbiB0ZXh0ZGVjb2RlKGVuY29kaW5nLCB2YWx1ZSkge1xuICAgIGlmIChlbmNvZGluZykge1xuICAgICAgaWYgKCEvXltcXHgwMC1cXHhGRl0rJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKGVuY29kaW5nLCB7XG4gICAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gQXJyYXkuZnJvbSh2YWx1ZSwgZnVuY3Rpb24gKGNoKSB7XG4gICAgICAgICAgcmV0dXJuIGNoLmNoYXJDb2RlQXQoMCkgJiAweGZmO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFsdWUgPSBkZWNvZGVyLmRlY29kZShuZXcgVWludDhBcnJheShieXRlcykpO1xuICAgICAgICBuZWVkc0VuY29kaW5nRml4dXAgPSBmYWxzZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKC9edXRmLT84JC9pLnRlc3QoZW5jb2RpbmcpKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbHVlID0gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZSh2YWx1ZSkpO1xuICAgICAgICAgICAgbmVlZHNFbmNvZGluZ0ZpeHVwID0gZmFsc2U7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gZml4dXBFbmNvZGluZyh2YWx1ZSkge1xuICAgIGlmIChuZWVkc0VuY29kaW5nRml4dXAgJiYgL1tcXHg4MC1cXHhmZl0vLnRlc3QodmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IHRleHRkZWNvZGUoXCJ1dGYtOFwiLCB2YWx1ZSk7XG5cbiAgICAgIGlmIChuZWVkc0VuY29kaW5nRml4dXApIHtcbiAgICAgICAgdmFsdWUgPSB0ZXh0ZGVjb2RlKFwiaXNvLTg4NTktMVwiLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gcmZjMjIzMWdldHBhcmFtKGNvbnRlbnREaXNwb3NpdGlvblN0cikge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBbXTtcbiAgICBsZXQgbWF0Y2g7XG4gICAgY29uc3QgaXRlciA9IHRvUGFyYW1SZWdFeHAoXCJmaWxlbmFtZVxcXFwqKCg/ITBcXFxcZClcXFxcZCspKFxcXFwqPylcIiwgXCJpZ1wiKTtcblxuICAgIHdoaWxlICgobWF0Y2ggPSBpdGVyLmV4ZWMoY29udGVudERpc3Bvc2l0aW9uU3RyKSkgIT09IG51bGwpIHtcbiAgICAgIGxldCBbLCBuLCBxdW90LCBwYXJ0XSA9IG1hdGNoO1xuICAgICAgbiA9IHBhcnNlSW50KG4sIDEwKTtcblxuICAgICAgaWYgKG4gaW4gbWF0Y2hlcykge1xuICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIG1hdGNoZXNbbl0gPSBbcXVvdCwgcGFydF07XG4gICAgfVxuXG4gICAgY29uc3QgcGFydHMgPSBbXTtcblxuICAgIGZvciAobGV0IG4gPSAwOyBuIDwgbWF0Y2hlcy5sZW5ndGg7ICsrbikge1xuICAgICAgaWYgKCEobiBpbiBtYXRjaGVzKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgbGV0IFtxdW90LCBwYXJ0XSA9IG1hdGNoZXNbbl07XG4gICAgICBwYXJ0ID0gcmZjMjYxNnVucXVvdGUocGFydCk7XG5cbiAgICAgIGlmIChxdW90KSB7XG4gICAgICAgIHBhcnQgPSB1bmVzY2FwZShwYXJ0KTtcblxuICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgIHBhcnQgPSByZmM1OTg3ZGVjb2RlKHBhcnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHBhcnRzLnB1c2gocGFydCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oXCJcIik7XG4gIH1cblxuICBmdW5jdGlvbiByZmMyNjE2dW5xdW90ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKCdcIicpKSB7XG4gICAgICBjb25zdCBwYXJ0cyA9IHZhbHVlLnNsaWNlKDEpLnNwbGl0KCdcXFxcXCInKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBxdW90aW5kZXggPSBwYXJ0c1tpXS5pbmRleE9mKCdcIicpO1xuXG4gICAgICAgIGlmIChxdW90aW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgcGFydHNbaV0gPSBwYXJ0c1tpXS5zbGljZSgwLCBxdW90aW5kZXgpO1xuICAgICAgICAgIHBhcnRzLmxlbmd0aCA9IGkgKyAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFydHNbaV0gPSBwYXJ0c1tpXS5yZXBsYWNlKC9cXFxcKC4pL2csIFwiJDFcIik7XG4gICAgICB9XG5cbiAgICAgIHZhbHVlID0gcGFydHMuam9pbignXCInKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiByZmM1OTg3ZGVjb2RlKGV4dHZhbHVlKSB7XG4gICAgY29uc3QgZW5jb2RpbmdlbmQgPSBleHR2YWx1ZS5pbmRleE9mKFwiJ1wiKTtcblxuICAgIGlmIChlbmNvZGluZ2VuZCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBleHR2YWx1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBlbmNvZGluZyA9IGV4dHZhbHVlLnNsaWNlKDAsIGVuY29kaW5nZW5kKTtcbiAgICBjb25zdCBsYW5ndmFsdWUgPSBleHR2YWx1ZS5zbGljZShlbmNvZGluZ2VuZCArIDEpO1xuICAgIGNvbnN0IHZhbHVlID0gbGFuZ3ZhbHVlLnJlcGxhY2UoL15bXiddKicvLCBcIlwiKTtcbiAgICByZXR1cm4gdGV4dGRlY29kZShlbmNvZGluZywgdmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmZjMjA0N2RlY29kZSh2YWx1ZSkge1xuICAgIGlmICghdmFsdWUuc3RhcnRzV2l0aChcIj0/XCIpIHx8IC9bXFx4MDAtXFx4MTlcXHg4MC1cXHhmZl0vLnRlc3QodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoLz1cXD8oW1xcdy1dKilcXD8oW1FxQmJdKVxcPygoPzpbXj9dfFxcPyg/IT0pKSopXFw/PS9nLCBmdW5jdGlvbiAobWF0Y2hlcywgY2hhcnNldCwgZW5jb2RpbmcsIHRleHQpIHtcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gXCJxXCIgfHwgZW5jb2RpbmcgPT09IFwiUVwiKSB7XG4gICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL18vZywgXCIgXCIpO1xuICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC89KFswLTlhLWZBLUZdezJ9KS9nLCBmdW5jdGlvbiAobWF0Y2gsIGhleCkge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGhleCwgMTYpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0ZXh0ZGVjb2RlKGNoYXJzZXQsIHRleHQpO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICB0ZXh0ID0gYXRvYih0ZXh0KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAgIHJldHVybiB0ZXh0ZGVjb2RlKGNoYXJzZXQsIHRleHQpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIFwiXCI7XG59XG5cbi8qKiovIH0pLFxuLyogMjUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuUERGTmV0d29ya1N0cmVhbSA9IHZvaWQgMDtcblxudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygyKTtcblxudmFyIF9uZXR3b3JrX3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXygyMyk7XG5cbjtcbmNvbnN0IE9LX1JFU1BPTlNFID0gMjAwO1xuY29uc3QgUEFSVElBTF9DT05URU5UX1JFU1BPTlNFID0gMjA2O1xuXG5mdW5jdGlvbiBnZXRBcnJheUJ1ZmZlcih4aHIpIHtcbiAgY29uc3QgZGF0YSA9IHhoci5yZXNwb25zZTtcblxuICBpZiAodHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIGNvbnN0IGFycmF5ID0gKDAsIF91dGlsLnN0cmluZ1RvQnl0ZXMpKGRhdGEpO1xuICByZXR1cm4gYXJyYXkuYnVmZmVyO1xufVxuXG5jbGFzcyBOZXR3b3JrTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKHVybCwgYXJncykge1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIGFyZ3MgPSBhcmdzIHx8IHt9O1xuICAgIHRoaXMuaXNIdHRwID0gL15odHRwcz86L2kudGVzdCh1cmwpO1xuICAgIHRoaXMuaHR0cEhlYWRlcnMgPSB0aGlzLmlzSHR0cCAmJiBhcmdzLmh0dHBIZWFkZXJzIHx8IHt9O1xuICAgIHRoaXMud2l0aENyZWRlbnRpYWxzID0gYXJncy53aXRoQ3JlZGVudGlhbHMgfHwgZmFsc2U7XG5cbiAgICB0aGlzLmdldFhociA9IGFyZ3MuZ2V0WGhyIHx8IGZ1bmN0aW9uIE5ldHdvcmtNYW5hZ2VyX2dldFhocigpIHtcbiAgICAgIHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5jdXJyWGhySWQgPSAwO1xuICAgIHRoaXMucGVuZGluZ1JlcXVlc3RzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuXG4gIHJlcXVlc3RSYW5nZShiZWdpbiwgZW5kLCBsaXN0ZW5lcnMpIHtcbiAgICBjb25zdCBhcmdzID0ge1xuICAgICAgYmVnaW4sXG4gICAgICBlbmRcbiAgICB9O1xuXG4gICAgZm9yIChjb25zdCBwcm9wIGluIGxpc3RlbmVycykge1xuICAgICAgYXJnc1twcm9wXSA9IGxpc3RlbmVyc1twcm9wXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGFyZ3MpO1xuICB9XG5cbiAgcmVxdWVzdEZ1bGwobGlzdGVuZXJzKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChsaXN0ZW5lcnMpO1xuICB9XG5cbiAgcmVxdWVzdChhcmdzKSB7XG4gICAgY29uc3QgeGhyID0gdGhpcy5nZXRYaHIoKTtcbiAgICBjb25zdCB4aHJJZCA9IHRoaXMuY3VyclhocklkKys7XG4gICAgY29uc3QgcGVuZGluZ1JlcXVlc3QgPSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF0gPSB7XG4gICAgICB4aHJcbiAgICB9O1xuICAgIHhoci5vcGVuKFwiR0VUXCIsIHRoaXMudXJsKTtcbiAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdGhpcy53aXRoQ3JlZGVudGlhbHM7XG5cbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5IGluIHRoaXMuaHR0cEhlYWRlcnMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5odHRwSGVhZGVyc1twcm9wZXJ0eV07XG5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNIdHRwICYmIFwiYmVnaW5cIiBpbiBhcmdzICYmIFwiZW5kXCIgaW4gYXJncykge1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJSYW5nZVwiLCBgYnl0ZXM9JHthcmdzLmJlZ2lufS0ke2FyZ3MuZW5kIC0gMX1gKTtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0LmV4cGVjdGVkU3RhdHVzID0gUEFSVElBTF9DT05URU5UX1JFU1BPTlNFO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5leHBlY3RlZFN0YXR1cyA9IE9LX1JFU1BPTlNFO1xuICAgIH1cblxuICAgIHhoci5yZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XG5cbiAgICBpZiAoYXJncy5vbkVycm9yKSB7XG4gICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgYXJncy5vbkVycm9yKHhoci5zdGF0dXMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gdGhpcy5vblN0YXRlQ2hhbmdlLmJpbmQodGhpcywgeGhySWQpO1xuICAgIHhoci5vbnByb2dyZXNzID0gdGhpcy5vblByb2dyZXNzLmJpbmQodGhpcywgeGhySWQpO1xuICAgIHBlbmRpbmdSZXF1ZXN0Lm9uSGVhZGVyc1JlY2VpdmVkID0gYXJncy5vbkhlYWRlcnNSZWNlaXZlZDtcbiAgICBwZW5kaW5nUmVxdWVzdC5vbkRvbmUgPSBhcmdzLm9uRG9uZTtcbiAgICBwZW5kaW5nUmVxdWVzdC5vbkVycm9yID0gYXJncy5vbkVycm9yO1xuICAgIHBlbmRpbmdSZXF1ZXN0Lm9uUHJvZ3Jlc3MgPSBhcmdzLm9uUHJvZ3Jlc3M7XG4gICAgeGhyLnNlbmQobnVsbCk7XG4gICAgcmV0dXJuIHhocklkO1xuICB9XG5cbiAgb25Qcm9ncmVzcyh4aHJJZCwgZXZ0KSB7XG4gICAgY29uc3QgcGVuZGluZ1JlcXVlc3QgPSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF07XG5cbiAgICBpZiAoIXBlbmRpbmdSZXF1ZXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHBlbmRpbmdSZXF1ZXN0Lm9uUHJvZ3Jlc3MpIHtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uUHJvZ3Jlc3MoZXZ0KTtcbiAgICB9XG4gIH1cblxuICBvblN0YXRlQ2hhbmdlKHhocklkLCBldnQpIHtcbiAgICBjb25zdCBwZW5kaW5nUmVxdWVzdCA9IHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXTtcblxuICAgIGlmICghcGVuZGluZ1JlcXVlc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB4aHIgPSBwZW5kaW5nUmVxdWVzdC54aHI7XG5cbiAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPj0gMiAmJiBwZW5kaW5nUmVxdWVzdC5vbkhlYWRlcnNSZWNlaXZlZCkge1xuICAgICAgcGVuZGluZ1JlcXVlc3Qub25IZWFkZXJzUmVjZWl2ZWQoKTtcbiAgICAgIGRlbGV0ZSBwZW5kaW5nUmVxdWVzdC5vbkhlYWRlcnNSZWNlaXZlZDtcbiAgICB9XG5cbiAgICBpZiAoeGhyLnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoISh4aHJJZCBpbiB0aGlzLnBlbmRpbmdSZXF1ZXN0cykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkZWxldGUgdGhpcy5wZW5kaW5nUmVxdWVzdHNbeGhySWRdO1xuXG4gICAgaWYgKHhoci5zdGF0dXMgPT09IDAgJiYgdGhpcy5pc0h0dHApIHtcbiAgICAgIGlmIChwZW5kaW5nUmVxdWVzdC5vbkVycm9yKSB7XG4gICAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uRXJyb3IoeGhyLnN0YXR1cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB4aHJTdGF0dXMgPSB4aHIuc3RhdHVzIHx8IE9LX1JFU1BPTlNFO1xuICAgIGNvbnN0IG9rX3Jlc3BvbnNlX29uX3JhbmdlX3JlcXVlc3QgPSB4aHJTdGF0dXMgPT09IE9LX1JFU1BPTlNFICYmIHBlbmRpbmdSZXF1ZXN0LmV4cGVjdGVkU3RhdHVzID09PSBQQVJUSUFMX0NPTlRFTlRfUkVTUE9OU0U7XG5cbiAgICBpZiAoIW9rX3Jlc3BvbnNlX29uX3JhbmdlX3JlcXVlc3QgJiYgeGhyU3RhdHVzICE9PSBwZW5kaW5nUmVxdWVzdC5leHBlY3RlZFN0YXR1cykge1xuICAgICAgaWYgKHBlbmRpbmdSZXF1ZXN0Lm9uRXJyb3IpIHtcbiAgICAgICAgcGVuZGluZ1JlcXVlc3Qub25FcnJvcih4aHIuc3RhdHVzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNodW5rID0gZ2V0QXJyYXlCdWZmZXIoeGhyKTtcblxuICAgIGlmICh4aHJTdGF0dXMgPT09IFBBUlRJQUxfQ09OVEVOVF9SRVNQT05TRSkge1xuICAgICAgY29uc3QgcmFuZ2VIZWFkZXIgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJDb250ZW50LVJhbmdlXCIpO1xuICAgICAgY29uc3QgbWF0Y2hlcyA9IC9ieXRlcyAoXFxkKyktKFxcZCspXFwvKFxcZCspLy5leGVjKHJhbmdlSGVhZGVyKTtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uRG9uZSh7XG4gICAgICAgIGJlZ2luOiBwYXJzZUludChtYXRjaGVzWzFdLCAxMCksXG4gICAgICAgIGNodW5rXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNodW5rKSB7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5vbkRvbmUoe1xuICAgICAgICBiZWdpbjogMCxcbiAgICAgICAgY2h1bmtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAocGVuZGluZ1JlcXVlc3Qub25FcnJvcikge1xuICAgICAgcGVuZGluZ1JlcXVlc3Qub25FcnJvcih4aHIuc3RhdHVzKTtcbiAgICB9XG4gIH1cblxuICBnZXRSZXF1ZXN0WGhyKHhocklkKSB7XG4gICAgcmV0dXJuIHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXS54aHI7XG4gIH1cblxuICBpc1BlbmRpbmdSZXF1ZXN0KHhocklkKSB7XG4gICAgcmV0dXJuIHhocklkIGluIHRoaXMucGVuZGluZ1JlcXVlc3RzO1xuICB9XG5cbiAgYWJvcnRSZXF1ZXN0KHhocklkKSB7XG4gICAgY29uc3QgeGhyID0gdGhpcy5wZW5kaW5nUmVxdWVzdHNbeGhySWRdLnhocjtcbiAgICBkZWxldGUgdGhpcy5wZW5kaW5nUmVxdWVzdHNbeGhySWRdO1xuICAgIHhoci5hYm9ydCgpO1xuICB9XG5cbn1cblxuY2xhc3MgUERGTmV0d29ya1N0cmVhbSB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgIHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLl9tYW5hZ2VyID0gbmV3IE5ldHdvcmtNYW5hZ2VyKHNvdXJjZS51cmwsIHtcbiAgICAgIGh0dHBIZWFkZXJzOiBzb3VyY2UuaHR0cEhlYWRlcnMsXG4gICAgICB3aXRoQ3JlZGVudGlhbHM6IHNvdXJjZS53aXRoQ3JlZGVudGlhbHNcbiAgICB9KTtcbiAgICB0aGlzLl9yYW5nZUNodW5rU2l6ZSA9IHNvdXJjZS5yYW5nZUNodW5rU2l6ZTtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycyA9IFtdO1xuICB9XG5cbiAgX29uUmFuZ2VSZXF1ZXN0UmVhZGVyQ2xvc2VkKHJlYWRlcikge1xuICAgIGNvbnN0IGkgPSB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLmluZGV4T2YocmVhZGVyKTtcblxuICAgIGlmIChpID49IDApIHtcbiAgICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMuc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgfVxuXG4gIGdldEZ1bGxSZWFkZXIoKSB7XG4gICAgKDAsIF91dGlsLmFzc2VydCkoIXRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLCBcIlBERk5ldHdvcmtTdHJlYW0uZ2V0RnVsbFJlYWRlciBjYW4gb25seSBiZSBjYWxsZWQgb25jZS5cIik7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBuZXcgUERGTmV0d29ya1N0cmVhbUZ1bGxSZXF1ZXN0UmVhZGVyKHRoaXMuX21hbmFnZXIsIHRoaXMuX3NvdXJjZSk7XG4gICAgcmV0dXJuIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyO1xuICB9XG5cbiAgZ2V0UmFuZ2VSZWFkZXIoYmVnaW4sIGVuZCkge1xuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBQREZOZXR3b3JrU3RyZWFtUmFuZ2VSZXF1ZXN0UmVhZGVyKHRoaXMuX21hbmFnZXIsIGJlZ2luLCBlbmQpO1xuICAgIHJlYWRlci5vbkNsb3NlZCA9IHRoaXMuX29uUmFuZ2VSZXF1ZXN0UmVhZGVyQ2xvc2VkLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnB1c2gocmVhZGVyKTtcblxuICAgIHJldHVybiByZWFkZXI7XG4gIH1cblxuICBjYW5jZWxBbGxSZXF1ZXN0cyhyZWFzb24pIHtcbiAgICBpZiAodGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIpIHtcbiAgICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLmNhbmNlbChyZWFzb24pO1xuICAgIH1cblxuICAgIGNvbnN0IHJlYWRlcnMgPSB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnNsaWNlKDApO1xuXG4gICAgcmVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChyZWFkZXIpIHtcbiAgICAgIHJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICB9KTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuUERGTmV0d29ya1N0cmVhbSA9IFBERk5ldHdvcmtTdHJlYW07XG5cbmNsYXNzIFBERk5ldHdvcmtTdHJlYW1GdWxsUmVxdWVzdFJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKG1hbmFnZXIsIHNvdXJjZSkge1xuICAgIHRoaXMuX21hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICBvbkhlYWRlcnNSZWNlaXZlZDogdGhpcy5fb25IZWFkZXJzUmVjZWl2ZWQuYmluZCh0aGlzKSxcbiAgICAgIG9uRG9uZTogdGhpcy5fb25Eb25lLmJpbmQodGhpcyksXG4gICAgICBvbkVycm9yOiB0aGlzLl9vbkVycm9yLmJpbmQodGhpcyksXG4gICAgICBvblByb2dyZXNzOiB0aGlzLl9vblByb2dyZXNzLmJpbmQodGhpcylcbiAgICB9O1xuICAgIHRoaXMuX3VybCA9IHNvdXJjZS51cmw7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RJZCA9IG1hbmFnZXIucmVxdWVzdEZ1bGwoYXJncyk7XG4gICAgdGhpcy5faGVhZGVyc1JlY2VpdmVkQ2FwYWJpbGl0eSA9ICgwLCBfdXRpbC5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSkoKTtcbiAgICB0aGlzLl9kaXNhYmxlUmFuZ2UgPSBzb3VyY2UuZGlzYWJsZVJhbmdlIHx8IGZhbHNlO1xuICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICAgIHRoaXMuX3JhbmdlQ2h1bmtTaXplID0gc291cmNlLnJhbmdlQ2h1bmtTaXplO1xuXG4gICAgaWYgKCF0aGlzLl9yYW5nZUNodW5rU2l6ZSAmJiAhdGhpcy5fZGlzYWJsZVJhbmdlKSB7XG4gICAgICB0aGlzLl9kaXNhYmxlUmFuZ2UgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2NhY2hlZENodW5rcyA9IFtdO1xuICAgIHRoaXMuX3JlcXVlc3RzID0gW107XG4gICAgdGhpcy5fZG9uZSA9IGZhbHNlO1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2ZpbGVuYW1lID0gbnVsbDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICB9XG5cbiAgX29uSGVhZGVyc1JlY2VpdmVkKCkge1xuICAgIGNvbnN0IGZ1bGxSZXF1ZXN0WGhySWQgPSB0aGlzLl9mdWxsUmVxdWVzdElkO1xuXG4gICAgY29uc3QgZnVsbFJlcXVlc3RYaHIgPSB0aGlzLl9tYW5hZ2VyLmdldFJlcXVlc3RYaHIoZnVsbFJlcXVlc3RYaHJJZCk7XG5cbiAgICBjb25zdCBnZXRSZXNwb25zZUhlYWRlciA9IG5hbWUgPT4ge1xuICAgICAgcmV0dXJuIGZ1bGxSZXF1ZXN0WGhyLmdldFJlc3BvbnNlSGVhZGVyKG5hbWUpO1xuICAgIH07XG5cbiAgICBjb25zdCB7XG4gICAgICBhbGxvd1JhbmdlUmVxdWVzdHMsXG4gICAgICBzdWdnZXN0ZWRMZW5ndGhcbiAgICB9ID0gKDAsIF9uZXR3b3JrX3V0aWxzLnZhbGlkYXRlUmFuZ2VSZXF1ZXN0Q2FwYWJpbGl0aWVzKSh7XG4gICAgICBnZXRSZXNwb25zZUhlYWRlcixcbiAgICAgIGlzSHR0cDogdGhpcy5fbWFuYWdlci5pc0h0dHAsXG4gICAgICByYW5nZUNodW5rU2l6ZTogdGhpcy5fcmFuZ2VDaHVua1NpemUsXG4gICAgICBkaXNhYmxlUmFuZ2U6IHRoaXMuX2Rpc2FibGVSYW5nZVxuICAgIH0pO1xuXG4gICAgaWYgKGFsbG93UmFuZ2VSZXF1ZXN0cykge1xuICAgICAgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5fY29udGVudExlbmd0aCA9IHN1Z2dlc3RlZExlbmd0aCB8fCB0aGlzLl9jb250ZW50TGVuZ3RoO1xuICAgIHRoaXMuX2ZpbGVuYW1lID0gKDAsIF9uZXR3b3JrX3V0aWxzLmV4dHJhY3RGaWxlbmFtZUZyb21IZWFkZXIpKGdldFJlc3BvbnNlSGVhZGVyKTtcblxuICAgIGlmICh0aGlzLl9pc1JhbmdlU3VwcG9ydGVkKSB7XG4gICAgICB0aGlzLl9tYW5hZ2VyLmFib3J0UmVxdWVzdChmdWxsUmVxdWVzdFhocklkKTtcbiAgICB9XG5cbiAgICB0aGlzLl9oZWFkZXJzUmVjZWl2ZWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgfVxuXG4gIF9vbkRvbmUoYXJncykge1xuICAgIGlmIChhcmdzKSB7XG4gICAgICBpZiAodGhpcy5fcmVxdWVzdHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSA9IHRoaXMuX3JlcXVlc3RzLnNoaWZ0KCk7XG5cbiAgICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgICAgdmFsdWU6IGFyZ3MuY2h1bmssXG4gICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jYWNoZWRDaHVua3MucHVzaChhcmdzLmNodW5rKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcblxuICAgIGlmICh0aGlzLl9jYWNoZWRDaHVua3MubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3JlcXVlc3RzLmZvckVhY2goZnVuY3Rpb24gKHJlcXVlc3RDYXBhYmlsaXR5KSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9yZXF1ZXN0cyA9IFtdO1xuICB9XG5cbiAgX29uRXJyb3Ioc3RhdHVzKSB7XG4gICAgY29uc3QgdXJsID0gdGhpcy5fdXJsO1xuICAgIGNvbnN0IGV4Y2VwdGlvbiA9ICgwLCBfbmV0d29ya191dGlscy5jcmVhdGVSZXNwb25zZVN0YXR1c0Vycm9yKShzdGF0dXMsIHVybCk7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSBleGNlcHRpb247XG5cbiAgICB0aGlzLl9oZWFkZXJzUmVjZWl2ZWRDYXBhYmlsaXR5LnJlamVjdChleGNlcHRpb24pO1xuXG4gICAgdGhpcy5fcmVxdWVzdHMuZm9yRWFjaChmdW5jdGlvbiAocmVxdWVzdENhcGFiaWxpdHkpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlamVjdChleGNlcHRpb24pO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fcmVxdWVzdHMgPSBbXTtcbiAgICB0aGlzLl9jYWNoZWRDaHVua3MgPSBbXTtcbiAgfVxuXG4gIF9vblByb2dyZXNzKGRhdGEpIHtcbiAgICBpZiAodGhpcy5vblByb2dyZXNzKSB7XG4gICAgICB0aGlzLm9uUHJvZ3Jlc3Moe1xuICAgICAgICBsb2FkZWQ6IGRhdGEubG9hZGVkLFxuICAgICAgICB0b3RhbDogZGF0YS5sZW5ndGhDb21wdXRhYmxlID8gZGF0YS50b3RhbCA6IHRoaXMuX2NvbnRlbnRMZW5ndGhcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGdldCBmaWxlbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsZW5hbWU7XG4gIH1cblxuICBnZXQgaXNSYW5nZVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNSYW5nZVN1cHBvcnRlZDtcbiAgfVxuXG4gIGdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQ7XG4gIH1cblxuICBnZXQgY29udGVudExlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGVudExlbmd0aDtcbiAgfVxuXG4gIGdldCBoZWFkZXJzUmVhZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlYWRlcnNSZWNlaXZlZENhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuXG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgaWYgKHRoaXMuX3N0b3JlZEVycm9yKSB7XG4gICAgICB0aHJvdyB0aGlzLl9zdG9yZWRFcnJvcjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fY2FjaGVkQ2h1bmtzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fY2FjaGVkQ2h1bmtzLnNoaWZ0KCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgPSAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCk7XG5cbiAgICB0aGlzLl9yZXF1ZXN0cy5wdXNoKHJlcXVlc3RDYXBhYmlsaXR5KTtcblxuICAgIHJldHVybiByZXF1ZXN0Q2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG5cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuXG4gICAgdGhpcy5faGVhZGVyc1JlY2VpdmVkQ2FwYWJpbGl0eS5yZWplY3QocmVhc29uKTtcblxuICAgIHRoaXMuX3JlcXVlc3RzLmZvckVhY2goZnVuY3Rpb24gKHJlcXVlc3RDYXBhYmlsaXR5KSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9yZXF1ZXN0cyA9IFtdO1xuXG4gICAgaWYgKHRoaXMuX21hbmFnZXIuaXNQZW5kaW5nUmVxdWVzdCh0aGlzLl9mdWxsUmVxdWVzdElkKSkge1xuICAgICAgdGhpcy5fbWFuYWdlci5hYm9ydFJlcXVlc3QodGhpcy5fZnVsbFJlcXVlc3RJZCk7XG4gICAgfVxuXG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBudWxsO1xuICB9XG5cbn1cblxuY2xhc3MgUERGTmV0d29ya1N0cmVhbVJhbmdlUmVxdWVzdFJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKG1hbmFnZXIsIGJlZ2luLCBlbmQpIHtcbiAgICB0aGlzLl9tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICBjb25zdCBhcmdzID0ge1xuICAgICAgb25Eb25lOiB0aGlzLl9vbkRvbmUuYmluZCh0aGlzKSxcbiAgICAgIG9uUHJvZ3Jlc3M6IHRoaXMuX29uUHJvZ3Jlc3MuYmluZCh0aGlzKVxuICAgIH07XG4gICAgdGhpcy5fcmVxdWVzdElkID0gbWFuYWdlci5yZXF1ZXN0UmFuZ2UoYmVnaW4sIGVuZCwgYXJncyk7XG4gICAgdGhpcy5fcmVxdWVzdHMgPSBbXTtcbiAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IG51bGw7XG4gICAgdGhpcy5fZG9uZSA9IGZhbHNlO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gICAgdGhpcy5vbkNsb3NlZCA9IG51bGw7XG4gIH1cblxuICBfY2xvc2UoKSB7XG4gICAgaWYgKHRoaXMub25DbG9zZWQpIHtcbiAgICAgIHRoaXMub25DbG9zZWQodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgX29uRG9uZShkYXRhKSB7XG4gICAgY29uc3QgY2h1bmsgPSBkYXRhLmNodW5rO1xuXG4gICAgaWYgKHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5ID0gdGhpcy5fcmVxdWVzdHMuc2hpZnQoKTtcblxuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IGNodW5rO1xuICAgIH1cblxuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuXG4gICAgdGhpcy5fcmVxdWVzdHMuZm9yRWFjaChmdW5jdGlvbiAocmVxdWVzdENhcGFiaWxpdHkpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRoaXMuX3JlcXVlc3RzID0gW107XG5cbiAgICB0aGlzLl9jbG9zZSgpO1xuICB9XG5cbiAgX29uUHJvZ3Jlc3MoZXZ0KSB7XG4gICAgaWYgKCF0aGlzLmlzU3RyZWFtaW5nU3VwcG9ydGVkICYmIHRoaXMub25Qcm9ncmVzcykge1xuICAgICAgdGhpcy5vblByb2dyZXNzKHtcbiAgICAgICAgbG9hZGVkOiBldnQubG9hZGVkXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBpZiAodGhpcy5fcXVldWVkQ2h1bmsgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fcXVldWVkQ2h1bms7XG4gICAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IG51bGw7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5ID0gKDAsIF91dGlsLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KSgpO1xuXG4gICAgdGhpcy5fcmVxdWVzdHMucHVzaChyZXF1ZXN0Q2FwYWJpbGl0eSk7XG5cbiAgICByZXR1cm4gcmVxdWVzdENhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuXG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcblxuICAgIHRoaXMuX3JlcXVlc3RzLmZvckVhY2goZnVuY3Rpb24gKHJlcXVlc3RDYXBhYmlsaXR5KSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9yZXF1ZXN0cyA9IFtdO1xuXG4gICAgaWYgKHRoaXMuX21hbmFnZXIuaXNQZW5kaW5nUmVxdWVzdCh0aGlzLl9yZXF1ZXN0SWQpKSB7XG4gICAgICB0aGlzLl9tYW5hZ2VyLmFib3J0UmVxdWVzdCh0aGlzLl9yZXF1ZXN0SWQpO1xuICAgIH1cblxuICAgIHRoaXMuX2Nsb3NlKCk7XG4gIH1cblxufVxuXG4vKioqLyB9KSxcbi8qIDI2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlBERkZldGNoU3RyZWFtID0gdm9pZCAwO1xuXG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIpO1xuXG52YXIgX25ldHdvcmtfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIzKTtcblxuO1xuXG5mdW5jdGlvbiBjcmVhdGVGZXRjaE9wdGlvbnMoaGVhZGVycywgd2l0aENyZWRlbnRpYWxzLCBhYm9ydENvbnRyb2xsZXIpIHtcbiAgcmV0dXJuIHtcbiAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgaGVhZGVycyxcbiAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlciAmJiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgIG1vZGU6IFwiY29yc1wiLFxuICAgIGNyZWRlbnRpYWxzOiB3aXRoQ3JlZGVudGlhbHMgPyBcImluY2x1ZGVcIiA6IFwic2FtZS1vcmlnaW5cIixcbiAgICByZWRpcmVjdDogXCJmb2xsb3dcIlxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVIZWFkZXJzKGh0dHBIZWFkZXJzKSB7XG4gIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuXG4gIGZvciAoY29uc3QgcHJvcGVydHkgaW4gaHR0cEhlYWRlcnMpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGh0dHBIZWFkZXJzW3Byb3BlcnR5XTtcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGhlYWRlcnMuYXBwZW5kKHByb3BlcnR5LCB2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gaGVhZGVycztcbn1cblxuY2xhc3MgUERGRmV0Y2hTdHJlYW0ge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLmlzSHR0cCA9IC9eaHR0cHM/Oi9pLnRlc3Qoc291cmNlLnVybCk7XG4gICAgdGhpcy5odHRwSGVhZGVycyA9IHRoaXMuaXNIdHRwICYmIHNvdXJjZS5odHRwSGVhZGVycyB8fCB7fTtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycyA9IFtdO1xuICB9XG5cbiAgZ2V0IF9wcm9ncmVzc2l2ZURhdGFMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID8gdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIuX2xvYWRlZCA6IDA7XG4gIH1cblxuICBnZXRGdWxsUmVhZGVyKCkge1xuICAgICgwLCBfdXRpbC5hc3NlcnQpKCF0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciwgXCJQREZGZXRjaFN0cmVhbS5nZXRGdWxsUmVhZGVyIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlLlwiKTtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG5ldyBQREZGZXRjaFN0cmVhbVJlYWRlcih0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI7XG4gIH1cblxuICBnZXRSYW5nZVJlYWRlcihiZWdpbiwgZW5kKSB7XG4gICAgaWYgKGVuZCA8PSB0aGlzLl9wcm9ncmVzc2l2ZURhdGFMZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBQREZGZXRjaFN0cmVhbVJhbmdlUmVhZGVyKHRoaXMsIGJlZ2luLCBlbmQpO1xuXG4gICAgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5wdXNoKHJlYWRlcik7XG5cbiAgICByZXR1cm4gcmVhZGVyO1xuICB9XG5cbiAgY2FuY2VsQWxsUmVxdWVzdHMocmVhc29uKSB7XG4gICAgaWYgKHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyKSB7XG4gICAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICB9XG5cbiAgICBjb25zdCByZWFkZXJzID0gdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5zbGljZSgwKTtcblxuICAgIHJlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAocmVhZGVyKSB7XG4gICAgICByZWFkZXIuY2FuY2VsKHJlYXNvbik7XG4gICAgfSk7XG4gIH1cblxufVxuXG5leHBvcnRzLlBERkZldGNoU3RyZWFtID0gUERGRmV0Y2hTdHJlYW07XG5cbmNsYXNzIFBERkZldGNoU3RyZWFtUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtKSB7XG4gICAgdGhpcy5fc3RyZWFtID0gc3RyZWFtO1xuICAgIHRoaXMuX3JlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fbG9hZGVkID0gMDtcbiAgICB0aGlzLl9maWxlbmFtZSA9IG51bGw7XG4gICAgY29uc3Qgc291cmNlID0gc3RyZWFtLnNvdXJjZTtcbiAgICB0aGlzLl93aXRoQ3JlZGVudGlhbHMgPSBzb3VyY2Uud2l0aENyZWRlbnRpYWxzIHx8IGZhbHNlO1xuICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5ID0gKDAsIF91dGlsLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KSgpO1xuICAgIHRoaXMuX2Rpc2FibGVSYW5nZSA9IHNvdXJjZS5kaXNhYmxlUmFuZ2UgfHwgZmFsc2U7XG4gICAgdGhpcy5fcmFuZ2VDaHVua1NpemUgPSBzb3VyY2UucmFuZ2VDaHVua1NpemU7XG5cbiAgICBpZiAoIXRoaXMuX3JhbmdlQ2h1bmtTaXplICYmICF0aGlzLl9kaXNhYmxlUmFuZ2UpIHtcbiAgICAgIHRoaXMuX2Rpc2FibGVSYW5nZSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBBYm9ydENvbnRyb2xsZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRoaXMuX2Fib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCA9ICFzb3VyY2UuZGlzYWJsZVN0cmVhbTtcbiAgICB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkID0gIXNvdXJjZS5kaXNhYmxlUmFuZ2U7XG4gICAgdGhpcy5faGVhZGVycyA9IGNyZWF0ZUhlYWRlcnModGhpcy5fc3RyZWFtLmh0dHBIZWFkZXJzKTtcbiAgICBjb25zdCB1cmwgPSBzb3VyY2UudXJsO1xuICAgIGZldGNoKHVybCwgY3JlYXRlRmV0Y2hPcHRpb25zKHRoaXMuX2hlYWRlcnMsIHRoaXMuX3dpdGhDcmVkZW50aWFscywgdGhpcy5fYWJvcnRDb250cm9sbGVyKSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICBpZiAoISgwLCBfbmV0d29ya191dGlscy52YWxpZGF0ZVJlc3BvbnNlU3RhdHVzKShyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgICAgIHRocm93ICgwLCBfbmV0d29ya191dGlscy5jcmVhdGVSZXNwb25zZVN0YXR1c0Vycm9yKShyZXNwb25zZS5zdGF0dXMsIHVybCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3JlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG5cbiAgICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlc29sdmUoKTtcblxuICAgICAgY29uc3QgZ2V0UmVzcG9uc2VIZWFkZXIgPSBuYW1lID0+IHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmhlYWRlcnMuZ2V0KG5hbWUpO1xuICAgICAgfTtcblxuICAgICAgY29uc3Qge1xuICAgICAgICBhbGxvd1JhbmdlUmVxdWVzdHMsXG4gICAgICAgIHN1Z2dlc3RlZExlbmd0aFxuICAgICAgfSA9ICgwLCBfbmV0d29ya191dGlscy52YWxpZGF0ZVJhbmdlUmVxdWVzdENhcGFiaWxpdGllcykoe1xuICAgICAgICBnZXRSZXNwb25zZUhlYWRlcixcbiAgICAgICAgaXNIdHRwOiB0aGlzLl9zdHJlYW0uaXNIdHRwLFxuICAgICAgICByYW5nZUNodW5rU2l6ZTogdGhpcy5fcmFuZ2VDaHVua1NpemUsXG4gICAgICAgIGRpc2FibGVSYW5nZTogdGhpcy5fZGlzYWJsZVJhbmdlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSBhbGxvd1JhbmdlUmVxdWVzdHM7XG4gICAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gc3VnZ2VzdGVkTGVuZ3RoIHx8IHRoaXMuX2NvbnRlbnRMZW5ndGg7XG4gICAgICB0aGlzLl9maWxlbmFtZSA9ICgwLCBfbmV0d29ya191dGlscy5leHRyYWN0RmlsZW5hbWVGcm9tSGVhZGVyKShnZXRSZXNwb25zZUhlYWRlcik7XG5cbiAgICAgIGlmICghdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgJiYgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCkge1xuICAgICAgICB0aGlzLmNhbmNlbChuZXcgX3V0aWwuQWJvcnRFeGNlcHRpb24oXCJTdHJlYW1pbmcgaXMgZGlzYWJsZWQuXCIpKTtcbiAgICAgIH1cbiAgICB9KS5jYXRjaCh0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZWplY3QpO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gIH1cblxuICBnZXQgaGVhZGVyc1JlYWR5KCkge1xuICAgIHJldHVybiB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG5cbiAgZ2V0IGZpbGVuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9maWxlbmFtZTtcbiAgfVxuXG4gIGdldCBjb250ZW50TGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9jb250ZW50TGVuZ3RoO1xuICB9XG5cbiAgZ2V0IGlzUmFuZ2VTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQ7XG4gIH1cblxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkO1xuICB9XG5cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBhd2FpdCB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIGNvbnN0IHtcbiAgICAgIHZhbHVlLFxuICAgICAgZG9uZVxuICAgIH0gPSBhd2FpdCB0aGlzLl9yZWFkZXIucmVhZCgpO1xuXG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICBkb25lXG4gICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMuX2xvYWRlZCArPSB2YWx1ZS5ieXRlTGVuZ3RoO1xuXG4gICAgaWYgKHRoaXMub25Qcm9ncmVzcykge1xuICAgICAgdGhpcy5vblByb2dyZXNzKHtcbiAgICAgICAgbG9hZGVkOiB0aGlzLl9sb2FkZWQsXG4gICAgICAgIHRvdGFsOiB0aGlzLl9jb250ZW50TGVuZ3RoXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheSh2YWx1ZSkuYnVmZmVyO1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogYnVmZmVyLFxuICAgICAgZG9uZTogZmFsc2VcbiAgICB9O1xuICB9XG5cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIGlmICh0aGlzLl9yZWFkZXIpIHtcbiAgICAgIHRoaXMuX3JlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fYWJvcnRDb250cm9sbGVyKSB7XG4gICAgICB0aGlzLl9hYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICB9XG4gIH1cblxufVxuXG5jbGFzcyBQREZGZXRjaFN0cmVhbVJhbmdlUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtLCBiZWdpbiwgZW5kKSB7XG4gICAgdGhpcy5fc3RyZWFtID0gc3RyZWFtO1xuICAgIHRoaXMuX3JlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fbG9hZGVkID0gMDtcbiAgICBjb25zdCBzb3VyY2UgPSBzdHJlYW0uc291cmNlO1xuICAgIHRoaXMuX3dpdGhDcmVkZW50aWFscyA9IHNvdXJjZS53aXRoQ3JlZGVudGlhbHMgfHwgZmFsc2U7XG4gICAgdGhpcy5fcmVhZENhcGFiaWxpdHkgPSAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCk7XG4gICAgdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgPSAhc291cmNlLmRpc2FibGVTdHJlYW07XG5cbiAgICBpZiAodHlwZW9mIEFib3J0Q29udHJvbGxlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdGhpcy5fYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIH1cblxuICAgIHRoaXMuX2hlYWRlcnMgPSBjcmVhdGVIZWFkZXJzKHRoaXMuX3N0cmVhbS5odHRwSGVhZGVycyk7XG5cbiAgICB0aGlzLl9oZWFkZXJzLmFwcGVuZChcIlJhbmdlXCIsIGBieXRlcz0ke2JlZ2lufS0ke2VuZCAtIDF9YCk7XG5cbiAgICBjb25zdCB1cmwgPSBzb3VyY2UudXJsO1xuICAgIGZldGNoKHVybCwgY3JlYXRlRmV0Y2hPcHRpb25zKHRoaXMuX2hlYWRlcnMsIHRoaXMuX3dpdGhDcmVkZW50aWFscywgdGhpcy5fYWJvcnRDb250cm9sbGVyKSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICBpZiAoISgwLCBfbmV0d29ya191dGlscy52YWxpZGF0ZVJlc3BvbnNlU3RhdHVzKShyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgICAgIHRocm93ICgwLCBfbmV0d29ya191dGlscy5jcmVhdGVSZXNwb25zZVN0YXR1c0Vycm9yKShyZXNwb25zZS5zdGF0dXMsIHVybCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcblxuICAgICAgdGhpcy5fcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcbiAgICB9KS5jYXRjaChyZWFzb24gPT4ge1xuICAgICAgaWYgKHJlYXNvbiAmJiByZWFzb24ubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyByZWFzb247XG4gICAgfSk7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgfVxuXG4gIGdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQ7XG4gIH1cblxuICBhc3luYyByZWFkKCkge1xuICAgIGF3YWl0IHRoaXMuX3JlYWRDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgY29uc3Qge1xuICAgICAgdmFsdWUsXG4gICAgICBkb25lXG4gICAgfSA9IGF3YWl0IHRoaXMuX3JlYWRlci5yZWFkKCk7XG5cbiAgICBpZiAoZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGRvbmVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy5fbG9hZGVkICs9IHZhbHVlLmJ5dGVMZW5ndGg7XG5cbiAgICBpZiAodGhpcy5vblByb2dyZXNzKSB7XG4gICAgICB0aGlzLm9uUHJvZ3Jlc3Moe1xuICAgICAgICBsb2FkZWQ6IHRoaXMuX2xvYWRlZFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkodmFsdWUpLmJ1ZmZlcjtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IGJ1ZmZlcixcbiAgICAgIGRvbmU6IGZhbHNlXG4gICAgfTtcbiAgfVxuXG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICBpZiAodGhpcy5fcmVhZGVyKSB7XG4gICAgICB0aGlzLl9yZWFkZXIuY2FuY2VsKHJlYXNvbik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2Fib3J0Q29udHJvbGxlcikge1xuICAgICAgdGhpcy5fYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgfVxuICB9XG5cbn1cblxuLyoqKi8gfSlcbi8qKioqKiovIF0pO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wZGYuanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///299\n')},703:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactPropTypesSecret = __webpack_require__(268);\n\nfunction emptyFunction() {}\nfunction emptyFunctionWithReset() {}\nemptyFunctionWithReset.resetWarningCache = emptyFunction;\n\nmodule.exports = function() {\n  function shim(props, propName, componentName, location, propFullName, secret) {\n    if (secret === ReactPropTypesSecret) {\n      // It is still safe when called from React.\n      return;\n    }\n    var err = new Error(\n      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n      'Use PropTypes.checkPropTypes() to call them. ' +\n      'Read more at http://fb.me/use-check-prop-types'\n    );\n    err.name = 'Invariant Violation';\n    throw err;\n  };\n  shim.isRequired = shim;\n  function getShim() {\n    return shim;\n  };\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.\n  var ReactPropTypes = {\n    array: shim,\n    bool: shim,\n    func: shim,\n    number: shim,\n    object: shim,\n    string: shim,\n    symbol: shim,\n\n    any: shim,\n    arrayOf: getShim,\n    element: shim,\n    elementType: shim,\n    instanceOf: getShim,\n    node: shim,\n    objectOf: getShim,\n    oneOf: getShim,\n    oneOfType: getShim,\n    shape: getShim,\n    exact: getShim,\n\n    checkPropTypes: emptyFunctionWithReset,\n    resetWarningCache: emptyFunction\n  };\n\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9QZGZDb21wb25lbnRzLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzP2Q3YTAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLDJCQUEyQixtQkFBTyxDQUFDLEdBQTRCOztBQUUvRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSIsImZpbGUiOiI3MDMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcblxuZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9XG5mdW5jdGlvbiBlbXB0eUZ1bmN0aW9uV2l0aFJlc2V0KCkge31cbmVtcHR5RnVuY3Rpb25XaXRoUmVzZXQucmVzZXRXYXJuaW5nQ2FjaGUgPSBlbXB0eUZ1bmN0aW9uO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBzaGltKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgaWYgKHNlY3JldCA9PT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcbiAgICAgIC8vIEl0IGlzIHN0aWxsIHNhZmUgd2hlbiBjYWxsZWQgZnJvbSBSZWFjdC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcihcbiAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICdVc2UgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCkgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICk7XG4gICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgdGhyb3cgZXJyO1xuICB9O1xuICBzaGltLmlzUmVxdWlyZWQgPSBzaGltO1xuICBmdW5jdGlvbiBnZXRTaGltKCkge1xuICAgIHJldHVybiBzaGltO1xuICB9O1xuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IHNoaW0sXG4gICAgYm9vbDogc2hpbSxcbiAgICBmdW5jOiBzaGltLFxuICAgIG51bWJlcjogc2hpbSxcbiAgICBvYmplY3Q6IHNoaW0sXG4gICAgc3RyaW5nOiBzaGltLFxuICAgIHN5bWJvbDogc2hpbSxcblxuICAgIGFueTogc2hpbSxcbiAgICBhcnJheU9mOiBnZXRTaGltLFxuICAgIGVsZW1lbnQ6IHNoaW0sXG4gICAgZWxlbWVudFR5cGU6IHNoaW0sXG4gICAgaW5zdGFuY2VPZjogZ2V0U2hpbSxcbiAgICBub2RlOiBzaGltLFxuICAgIG9iamVjdE9mOiBnZXRTaGltLFxuICAgIG9uZU9mOiBnZXRTaGltLFxuICAgIG9uZU9mVHlwZTogZ2V0U2hpbSxcbiAgICBzaGFwZTogZ2V0U2hpbSxcbiAgICBleGFjdDogZ2V0U2hpbSxcblxuICAgIGNoZWNrUHJvcFR5cGVzOiBlbXB0eUZ1bmN0aW9uV2l0aFJlc2V0LFxuICAgIHJlc2V0V2FybmluZ0NhY2hlOiBlbXB0eUZ1bmN0aW9uXG4gIH07XG5cbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///703\n")},697:(module,__unused_webpack_exports,__webpack_require__)=>{eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nif (false) { var throwOnDirectAccess, ReactIs; } else {\n  // By explicitly using `prop-types` you are opting into new production behavior.\n  // http://fb.me/prop-types-in-prod\n  module.exports = __webpack_require__(703)();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9QZGZDb21wb25lbnRzLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvaW5kZXguanM/ZDdiYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxLQUFxQyxFQUFFLHFDQU8xQztBQUNEO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQyxHQUE0QjtBQUN2RCIsImZpbGUiOiI2OTcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcblxuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBkZXZlbG9wbWVudCBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICB2YXIgdGhyb3dPbkRpcmVjdEFjY2VzcyA9IHRydWU7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFR5cGVDaGVja2VycycpKFJlYWN0SXMuaXNFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKTtcbn0gZWxzZSB7XG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IHByb2R1Y3Rpb24gYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcycpKCk7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///697\n")},268:module=>{"use strict";eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nmodule.exports = ReactPropTypesSecret;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9QZGZDb21wb25lbnRzLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzPzU5YjAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViOztBQUVBIiwiZmlsZSI6IjI2OC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///268\n")},666:module=>{eval('/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  "use strict";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === "function" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || "@@iterator";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";\n  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, "");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there\'s no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don\'t have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: "normal", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: "throw", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = "suspendedStart";\n  var GenStateSuspendedYield = "suspendedYield";\n  var GenStateExecuting = "executing";\n  var GenStateCompleted = "completed";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don\'t natively support it.\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  define(Gp, "constructor", GeneratorFunctionPrototype);\n  define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    "GeneratorFunction"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    ["next", "throw", "return"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === "function" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === "GeneratorFunction"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, "GeneratorFunction");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, "__await")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === "throw") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === "object" &&\n            hasOwn.call(value, "__await")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke("next", value, resolve, reject);\n          }, function(err) {\n            invoke("throw", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke("throw", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error("Generator is already running");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === "throw") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === "next") {\n          // Setting context._sent for legacy support of Babel\'s\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === "throw") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === "return") {\n          context.abrupt("return", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === "normal") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === "throw") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = "throw";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === "throw") {\n        // Note: ["return"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator["return"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = "return";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === "throw") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // "return" to "throw", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = "throw";\n        context.arg = new TypeError(\n          "The iterator does not provide a \'throw\' method");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === "throw") {\n      context.method = "throw";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = "throw";\n      context.arg = new TypeError("iterator result is not an object");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was "throw" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was "next", forget context.arg since it has been\n      // "consumed" by the delegate iterator. If context.method was\n      // "return", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== "return") {\n        context.method = "next";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, "Generator");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers\' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn\'t happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  define(Gp, iteratorSymbol, function() {\n    return this;\n  });\n\n  define(Gp, "toString", function() {\n    return "[object Generator]";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = "normal";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: "root" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === "function") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel\'s\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = "next";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === "t" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === "throw") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = "throw";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = "next";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === "root") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle("end");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, "catchLoc");\n          var hasFinally = hasOwn.call(entry, "finallyLoc");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error("try statement without catch or finally");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, "finallyLoc") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === "break" ||\n           type === "continue") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = "next";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === "throw") {\n        throw record.arg;\n      }\n\n      if (record.type === "break" ||\n          record.type === "continue") {\n        this.next = record.arg;\n      } else if (record.type === "return") {\n        this.rval = this.arg = record.arg;\n        this.method = "return";\n        this.next = "end";\n      } else if (record.type === "normal" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    "catch": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === "throw") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error("illegal catch attempt");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === "next") {\n        // Deliberately forget the last sent value so that we don\'t\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n   true ? module.exports : 0\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you\'ve misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you\'re not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === "object") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function("r", "regeneratorRuntime = r")(runtime);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9QZGZDb21wb25lbnRzLy4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcz85NmNmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLEtBQUs7QUFDTCxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxLQUEwQixvQkFBb0IsQ0FBRTtBQUNsRDs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EiLCJmaWxlIjoiNjY2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgcnVudGltZSA9IChmdW5jdGlvbiAoZXhwb3J0cykge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBvYmpba2V5XTtcbiAgfVxuICB0cnkge1xuICAgIC8vIElFIDggaGFzIGEgYnJva2VuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0aGF0IG9ubHkgd29ya3Mgb24gRE9NIG9iamVjdHMuXG4gICAgZGVmaW5lKHt9LCBcIlwiKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZGVmaW5lID0gZnVuY3Rpb24ob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgZXhwb3J0cy53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgZGVmaW5lKEl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KTtcblxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBkZWZpbmUoR3AsIFwiY29uc3RydWN0b3JcIiwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICBkZWZpbmUoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwgR2VuZXJhdG9yRnVuY3Rpb24pO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRlZmluZShcbiAgICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSxcbiAgICB0b1N0cmluZ1RhZ1N5bWJvbCxcbiAgICBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgKTtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBkZWZpbmUocHJvdG90eXBlLCBtZXRob2QsIGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBkZWZpbmUoZ2VuRnVuLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKTtcbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgZXhwb3J0cy5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yLCBQcm9taXNlSW1wbCkge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAvLyBJZiBhIHJlamVjdGVkIFByb21pc2Ugd2FzIHlpZWxkZWQsIHRocm93IHRoZSByZWplY3Rpb24gYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBzbyBpdCBjYW4gYmUgaGFuZGxlZCB0aGVyZS5cbiAgICAgICAgICByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlSW1wbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIGRlZmluZShBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSwgYXN5bmNJdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KTtcbiAgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0LCBQcm9taXNlSW1wbCkge1xuICAgIGlmIChQcm9taXNlSW1wbCA9PT0gdm9pZCAwKSBQcm9taXNlSW1wbCA9IFByb21pc2U7XG5cbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksXG4gICAgICBQcm9taXNlSW1wbFxuICAgICk7XG5cbiAgICByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgLy8gTm90ZTogW1wicmV0dXJuXCJdIG11c3QgYmUgdXNlZCBmb3IgRVMzIHBhcnNpbmcgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgZGVmaW5lKEdwLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JcIik7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBkZWZpbmUoR3AsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG5cbiAgZGVmaW5lKEdwLCBcInRvU3RyaW5nXCIsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9KTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBleHBvcnRzLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGVcbiAgLy8gb3Igbm90LCByZXR1cm4gdGhlIHJ1bnRpbWUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGRlY2xhcmUgdGhlIHZhcmlhYmxlXG4gIC8vIHJlZ2VuZXJhdG9yUnVudGltZSBpbiB0aGUgb3V0ZXIgc2NvcGUsIHdoaWNoIGFsbG93cyB0aGlzIG1vZHVsZSB0byBiZVxuICAvLyBpbmplY3RlZCBlYXNpbHkgYnkgYGJpbi9yZWdlbmVyYXRvciAtLWluY2x1ZGUtcnVudGltZSBzY3JpcHQuanNgLlxuICByZXR1cm4gZXhwb3J0cztcblxufShcbiAgLy8gSWYgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlLCB1c2UgbW9kdWxlLmV4cG9ydHNcbiAgLy8gYXMgdGhlIHJlZ2VuZXJhdG9yUnVudGltZSBuYW1lc3BhY2UuIE90aGVyd2lzZSBjcmVhdGUgYSBuZXcgZW1wdHlcbiAgLy8gb2JqZWN0LiBFaXRoZXIgd2F5LCB0aGUgcmVzdWx0aW5nIG9iamVjdCB3aWxsIGJlIHVzZWQgdG8gaW5pdGlhbGl6ZVxuICAvLyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIHZhcmlhYmxlIGF0IHRoZSB0b3Agb2YgdGhpcyBmaWxlLlxuICB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiID8gbW9kdWxlLmV4cG9ydHMgOiB7fVxuKSk7XG5cbnRyeSB7XG4gIHJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG59IGNhdGNoIChhY2NpZGVudGFsU3RyaWN0TW9kZSkge1xuICAvLyBUaGlzIG1vZHVsZSBzaG91bGQgbm90IGJlIHJ1bm5pbmcgaW4gc3RyaWN0IG1vZGUsIHNvIHRoZSBhYm92ZVxuICAvLyBhc3NpZ25tZW50IHNob3VsZCBhbHdheXMgd29yayB1bmxlc3Mgc29tZXRoaW5nIGlzIG1pc2NvbmZpZ3VyZWQuIEp1c3RcbiAgLy8gaW4gY2FzZSBydW50aW1lLmpzIGFjY2lkZW50YWxseSBydW5zIGluIHN0cmljdCBtb2RlLCBpbiBtb2Rlcm4gZW5naW5lc1xuICAvLyB3ZSBjYW4gZXhwbGljaXRseSBhY2Nlc3MgZ2xvYmFsVGhpcy4gSW4gb2xkZXIgZW5naW5lcyB3ZSBjYW4gZXNjYXBlXG4gIC8vIHN0cmljdCBtb2RlIHVzaW5nIGEgZ2xvYmFsIEZ1bmN0aW9uIGNhbGwuIFRoaXMgY291bGQgY29uY2VpdmFibHkgZmFpbFxuICAvLyBpZiBhIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IGZvcmJpZHMgdXNpbmcgRnVuY3Rpb24sIGJ1dCBpbiB0aGF0IGNhc2VcbiAgLy8gdGhlIHByb3BlciBzb2x1dGlvbiBpcyB0byBmaXggdGhlIGFjY2lkZW50YWwgc3RyaWN0IG1vZGUgcHJvYmxlbS4gSWZcbiAgLy8geW91J3ZlIG1pc2NvbmZpZ3VyZWQgeW91ciBidW5kbGVyIHRvIGZvcmNlIHN0cmljdCBtb2RlIGFuZCBhcHBsaWVkIGFcbiAgLy8gQ1NQIHRvIGZvcmJpZCBGdW5jdGlvbiwgYW5kIHlvdSdyZSBub3Qgd2lsbGluZyB0byBmaXggZWl0aGVyIG9mIHRob3NlXG4gIC8vIHByb2JsZW1zLCBwbGVhc2UgZGV0YWlsIHlvdXIgdW5pcXVlIHByZWRpY2FtZW50IGluIGEgR2l0SHViIGlzc3VlLlxuICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09IFwib2JqZWN0XCIpIHtcbiAgICBnbG9iYWxUaGlzLnJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG4gIH0gZWxzZSB7XG4gICAgRnVuY3Rpb24oXCJyXCIsIFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShydW50aW1lKTtcbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///666\n')},14:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "default": () => (/* binding */ index)\n});\n\n// UNUSED EXPORTS: BoundingBox, ContextProvider, DocumentContext, DocumentWrapper, DownloadButton, HighlightOverlay, Outline, OutlineItem, Overlay, PageWrapper, TransformContext, UiContext, ZoomInButton, ZoomOutButton, computeBoundingBoxStyle, computePageStyle, generatePageIdFromIndex, getPageHeight, getPageWidth, isSideways, rotateClockwise, rotateCounterClockwise, scrollToId, scrollToPdfPageIndex\n\n// EXTERNAL MODULE: ./node_modules/classnames/index.js\nvar classnames = __webpack_require__(184);\nvar classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);\n// EXTERNAL MODULE: external {"commonjs":"react","commonjs2":"react","amd":"react","root":"React"}\nvar external_commonjs_react_commonjs2_react_amd_react_root_React_ = __webpack_require__(888);\nvar external_commonjs_react_commonjs2_react_amd_react_root_React_default = /*#__PURE__*/__webpack_require__.n(external_commonjs_react_commonjs2_react_amd_react_root_React_);\n;// CONCATENATED MODULE: ./src/utils/provider.ts\nfunction logProviderWarning(functionName, providerName) {\n    console.warn(`Unable to call ${functionName}. The ${providerName} Provider may not be set up correctly.`);\n}\n\n;// CONCATENATED MODULE: ./src/context/DocumentContext.ts\n\n\nconst DocumentContext_DocumentContext = external_commonjs_react_commonjs2_react_amd_react_root_React_.createContext({\n    numPages: 0,\n    pageDimensions: { height: 0, width: 0 },\n    pdfDocProxy: undefined,\n    setNumPages: numPages => {\n        logProviderWarning(`setNumPages(${numPages})`, \'DocumentContext\');\n    },\n    setPageDimensions: pageDimensions => {\n        logProviderWarning(`setPageDimensions(${pageDimensions})`, \'DocumentContext\');\n    },\n    setPdfDocProxy: pdfDocProxy => {\n        logProviderWarning(`setPdfDocProxy(${pdfDocProxy})`, \'DocumentContext\');\n    },\n});\n\n;// CONCATENATED MODULE: ./src/utils/rotate.ts\nvar PageRotation;\n(function (PageRotation) {\n    PageRotation[PageRotation["Rotate0"] = 0] = "Rotate0";\n    PageRotation[PageRotation["Rotate90"] = 90] = "Rotate90";\n    PageRotation[PageRotation["Rotate180"] = 180] = "Rotate180";\n    PageRotation[PageRotation["Rotate270"] = 270] = "Rotate270";\n})(PageRotation || (PageRotation = {}));\nfunction rotateClockwise(rotation) {\n    switch (rotation) {\n        case PageRotation.Rotate0:\n            return PageRotation.Rotate90;\n        case PageRotation.Rotate90:\n            return PageRotation.Rotate180;\n        case PageRotation.Rotate180:\n            return PageRotation.Rotate270;\n        default:\n            return PageRotation.Rotate0;\n    }\n}\nfunction rotateCounterClockwise(rotation) {\n    switch (rotation) {\n        case PageRotation.Rotate0:\n            return PageRotation.Rotate270;\n        case PageRotation.Rotate90:\n            return PageRotation.Rotate0;\n        case PageRotation.Rotate180:\n            return PageRotation.Rotate90;\n        default:\n            return PageRotation.Rotate180;\n    }\n}\n/**\n * Tests whether the page is rotated 90 degrees clockwise or counterclockwise from zero,\n * e.g. whether the page "is rotated sideways."\n */\nfunction isSideways(rotation) {\n    return rotation === PageRotation.Rotate90 || rotation === PageRotation.Rotate270;\n}\n\n;// CONCATENATED MODULE: ./src/context/TransformContext.ts\n\n\n\nconst TransformContext = external_commonjs_react_commonjs2_react_amd_react_root_React_.createContext({\n    rotation: PageRotation.Rotate0,\n    scale: 1,\n    zoomMultiplier: 1.2,\n    setRotation: rotation => {\n        logProviderWarning(`setRotation(${rotation})`, \'TransformContext\');\n    },\n    setScale: scale => {\n        logProviderWarning(`setScale(${scale})`, \'TransformContext\');\n    },\n    setZoomMultiplier: zoom => {\n        logProviderWarning(`setZoomMultiplier(${zoom})`, \'TransformContext\');\n    },\n});\n\n;// CONCATENATED MODULE: ./src/utils/style.ts\n\n// Computes the style for a bounding box, accounting for page roation and page scaling/zoom\nfunction computeBoundingBoxStyle(boundingBoxSize, pageDimensions, rotation, scale) {\n    const { top, left, height, width } = boundingBoxSize;\n    switch (rotation) {\n        case PageRotation.Rotate90:\n            return {\n                top: left * scale,\n                left: (pageDimensions.height - height - top) * scale,\n                height: width * scale,\n                width: height * scale,\n            };\n        case PageRotation.Rotate180:\n            return {\n                top: (pageDimensions.height - height - top) * scale,\n                left: (pageDimensions.width - width - left) * scale,\n                height: height * scale,\n                width: width * scale,\n            };\n        case PageRotation.Rotate270:\n            return {\n                top: (pageDimensions.width - width - left) * scale,\n                left: top * scale,\n                height: width * scale,\n                width: height * scale,\n            };\n        default:\n            return {\n                top: top * scale,\n                left: left * scale,\n                height: height * scale,\n                width: width * scale,\n            };\n    }\n}\n// Compute the style for a page, accounting for page rotation and page scaling/zoom\nfunction computePageStyle(pageDimensions, rotation, scale) {\n    return {\n        height: getPageHeight(pageDimensions, rotation) * scale,\n        width: getPageWidth(pageDimensions, rotation) * scale,\n        left: 0,\n        top: 0,\n    };\n}\n// Get page height accounting for page rotation- if the page is rotated on its side, its width becomes its height\nfunction getPageHeight(pageDimensions, rotation) {\n    return isSideways(rotation) ? pageDimensions.width : pageDimensions.height;\n}\n// Get page width accounting for page rotation- if the page is rotated on its side, its height becomes its width\nfunction getPageWidth(pageDimensions, rotation) {\n    return isSideways(rotation) ? pageDimensions.height : pageDimensions.width;\n}\n\n;// CONCATENATED MODULE: ./src/components/BoundingBox.tsx\n\n\n\n\n\nconst BoundingBox = ({ top, left, height, width, className, id, isHighlighted, onClick, }) => {\n    const { pageDimensions } = external_commonjs_react_commonjs2_react_amd_react_root_React_.useContext(DocumentContext_DocumentContext);\n    const { rotation, scale } = external_commonjs_react_commonjs2_react_amd_react_root_React_.useContext(TransformContext);\n    const boxSize = { top, left, height, width };\n    const componentClassName = classnames_default()(\'reader__page-overlay__bounding-box\', isHighlighted === true ? \'reader__page-overlay__bounding-box-highlighted\' : \'\', className);\n    const getBoundingBoxStyle = external_commonjs_react_commonjs2_react_amd_react_root_React_.useCallback(() => {\n        return computeBoundingBoxStyle(boxSize, pageDimensions, rotation, scale);\n    }, [pageDimensions, rotation, scale]);\n    return (external_commonjs_react_commonjs2_react_amd_react_root_React_.createElement("div", { id: id, className: componentClassName, style: getBoundingBoxStyle(), onClick: onClick }));\n};\n\n// EXTERNAL MODULE: ./node_modules/pdfjs-dist/build/pdf.js\nvar build_pdf = __webpack_require__(299);\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js\nfunction extends_extends() {\n  extends_extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return extends_extends.apply(this, arguments);\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/typeof.js\nfunction _typeof(obj) {\n  "@babel/helpers - typeof";\n\n  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/regenerator/index.js\nvar regenerator = __webpack_require__(757);\nvar regenerator_default = /*#__PURE__*/__webpack_require__.n(regenerator);\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError("Cannot call a class as a function");\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/createClass.js\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if ("value" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called");\n  }\n\n  return self;\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/inherits.js\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== "function" && superClass !== null) {\n    throw new TypeError("Super expression must either be null or a function");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\n\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === "object" || typeof call === "function")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError("Derived constructors may only return object or undefined");\n  }\n\n  return _assertThisInitialized(self);\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n// EXTERNAL MODULE: ./node_modules/prop-types/index.js\nvar prop_types = __webpack_require__(697);\nvar prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);\n;// CONCATENATED MODULE: ./node_modules/make-event-props/dist/esm/index.js\n// As defined on the list of supported events: https://reactjs.org/docs/events.html\nvar clipboardEvents = [\'onCopy\', \'onCut\', \'onPaste\'];\nvar compositionEvents = [\'onCompositionEnd\', \'onCompositionStart\', \'onCompositionUpdate\'];\nvar keyboardEvents = [\'onKeyDown\', \'onKeyPress\', \'onKeyUp\'];\nvar focusEvents = [\'onFocus\', \'onBlur\'];\nvar formEvents = [\'onChange\', \'onInput\', \'onInvalid\', \'onReset\', \'onSubmit\'];\nvar genericEvents = [\'onError\', \'onLoad\'];\nvar mouseEvents = [\'onClick\', \'onContextMenu\', \'onDoubleClick\', \'onDrag\', \'onDragEnd\', \'onDragEnter\', \'onDragExit\', \'onDragLeave\', \'onDragOver\', \'onDragStart\', \'onDrop\', \'onMouseDown\', \'onMouseEnter\', \'onMouseLeave\', \'onMouseMove\', \'onMouseOut\', \'onMouseOver\', \'onMouseUp\'];\nvar pointerEvents = [\'onPointerDown\', \'onPointerMove\', \'onPointerUp\', \'onPointerCancel\', \'onGotPointerCapture\', \'onLostPointerCapture\', \'onPointerEnter\', \'onPointerLeave\', \'onPointerOver\', \'onPointerOut\'];\nvar selectionEvents = [\'onSelect\'];\nvar touchEvents = [\'onTouchCancel\', \'onTouchEnd\', \'onTouchMove\', \'onTouchStart\'];\nvar uiEvents = [\'onScroll\'];\nvar wheelEvents = [\'onWheel\'];\nvar mediaEvents = [\'onAbort\', \'onCanPlay\', \'onCanPlayThrough\', \'onDurationChange\', \'onEmptied\', \'onEncrypted\', \'onEnded\', \'onError\', \'onLoadedData\', \'onLoadedMetadata\', \'onLoadStart\', \'onPause\', \'onPlay\', \'onPlaying\', \'onProgress\', \'onRateChange\', \'onSeeked\', \'onSeeking\', \'onStalled\', \'onSuspend\', \'onTimeUpdate\', \'onVolumeChange\', \'onWaiting\'];\nvar imageEvents = [\'onLoad\', \'onError\'];\nvar animationEvents = [\'onAnimationStart\', \'onAnimationEnd\', \'onAnimationIteration\'];\nvar transitionEvents = [\'onTransitionEnd\'];\nvar otherEvents = [\'onToggle\'];\nvar allEvents = [].concat(clipboardEvents, compositionEvents, keyboardEvents, focusEvents, formEvents, genericEvents, mouseEvents, pointerEvents, selectionEvents, touchEvents, uiEvents, wheelEvents, mediaEvents, imageEvents, animationEvents, transitionEvents, otherEvents);\n/**\n * Returns an object with on-event callback props curried with provided args.\n * @param {Object} props Props passed to a component.\n * @param {Function=} getArgs A function that returns argument(s) on-event callbacks\n *   shall be curried with.\n */\n\nvar makeEventProps = function makeEventProps(props, getArgs) {\n  var eventProps = {};\n  allEvents.forEach(function (eventName) {\n    if (!(eventName in props)) {\n      return;\n    }\n\n    if (!getArgs) {\n      eventProps[eventName] = props[eventName];\n      return;\n    }\n\n    eventProps[eventName] = function (event) {\n      return props[eventName](event, getArgs(eventName));\n    };\n  });\n  return eventProps;\n};\n\n/* harmony default export */ const esm = (makeEventProps);\n;// CONCATENATED MODULE: ./node_modules/make-cancellable-promise/dist/esm/index.js\nfunction makeCancellablePromise(promise) {\n  var isCancelled = false;\n  var wrappedPromise = new Promise(function (resolve, reject) {\n    promise.then(function () {\n      return !isCancelled && resolve.apply(void 0, arguments);\n    })["catch"](function (error) {\n      return !isCancelled && reject(error);\n    });\n  });\n  return {\n    promise: wrappedPromise,\n    cancel: function cancel() {\n      isCancelled = true;\n    }\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/merge-class-names/dist/esm/index.js\nfunction mergeClassNames() {\n  return Array.prototype.slice.call(arguments).reduce(function (classList, arg) {\n    return classList.concat(arg);\n  }, []).filter(function (arg) {\n    return typeof arg === \'string\';\n  }).join(\' \');\n}\n;// CONCATENATED MODULE: ./node_modules/react-pdf/dist/esm/DocumentContext.js\n\n/* harmony default export */ const esm_DocumentContext = (/*#__PURE__*/(0,external_commonjs_react_commonjs2_react_amd_react_root_React_.createContext)(null));\n;// CONCATENATED MODULE: ./node_modules/react-pdf/dist/esm/Message.js\n\n\nfunction Message(_ref) {\n  var children = _ref.children,\n      type = _ref.type;\n  return /*#__PURE__*/external_commonjs_react_commonjs2_react_amd_react_root_React_default().createElement("div", {\n    className: "react-pdf__message react-pdf__message--".concat(type)\n  }, children);\n}\nMessage.propTypes = {\n  children: (prop_types_default()).node,\n  type: prop_types_default().oneOf([\'error\', \'loading\', \'no-data\']).isRequired\n};\n;// CONCATENATED MODULE: ./node_modules/react-pdf/dist/esm/LinkService.js\n\n\n\n\n\n/* Copyright 2015 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* eslint-disable class-methods-use-this, no-empty-function */\nvar SimpleLinkService = /*#__PURE__*/function () {\n  function SimpleLinkService() {\n    _classCallCheck(this, SimpleLinkService);\n\n    this.externalLinkTarget = null;\n    this.externalLinkRel = null;\n    this.externalLinkEnabled = true;\n  }\n\n  _createClass(SimpleLinkService, [{\n    key: "setDocument",\n    value: function setDocument(pdfDocument) {\n      this.pdfDocument = pdfDocument;\n    }\n  }, {\n    key: "setViewer",\n    value: function setViewer(pdfViewer) {\n      this.pdfViewer = pdfViewer;\n    }\n  }, {\n    key: "setHistory",\n    value: function setHistory() {}\n  }, {\n    key: "goToDestination",\n    value: function () {\n      var _goToDestination = _asyncToGenerator( /*#__PURE__*/regenerator_default().mark(function _callee(dest) {\n        var destRef, pageNumber, pageIndex;\n        return regenerator_default().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                destRef = dest[0];\n\n                if (!(destRef instanceof Object)) {\n                  _context.next = 14;\n                  break;\n                }\n\n                _context.prev = 2;\n                _context.next = 5;\n                return this.pdfDocument.getPageIndex(destRef);\n\n              case 5:\n                pageIndex = _context.sent;\n                pageNumber = pageIndex + 1;\n                _context.next = 12;\n                break;\n\n              case 9:\n                _context.prev = 9;\n                _context.t0 = _context["catch"](2);\n                throw new Error("\\"".concat(destRef, "\\" is not a valid destination reference."));\n\n              case 12:\n                _context.next = 19;\n                break;\n\n              case 14:\n                if (!(typeof destRef === \'number\')) {\n                  _context.next = 18;\n                  break;\n                }\n\n                pageNumber = destRef + 1;\n                _context.next = 19;\n                break;\n\n              case 18:\n                throw new Error("\\"".concat(destRef, "\\" is not a valid destination reference."));\n\n              case 19:\n                if (!(!pageNumber || pageNumber < 1 || pageNumber > this.pagesCount)) {\n                  _context.next = 21;\n                  break;\n                }\n\n                throw new Error("\\"".concat(pageNumber, "\\" is not a valid page number."));\n\n              case 21:\n                this.pdfViewer.scrollPageIntoView({\n                  pageNumber: pageNumber\n                });\n\n              case 22:\n              case "end":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[2, 9]]);\n      }));\n\n      function goToDestination(_x) {\n        return _goToDestination.apply(this, arguments);\n      }\n\n      return goToDestination;\n    }()\n  }, {\n    key: "navigateTo",\n    value: function navigateTo(dest) {\n      this.goToDestination(dest);\n    }\n  }, {\n    key: "goToPage",\n    value: function goToPage() {}\n  }, {\n    key: "getDestinationHash",\n    value: function getDestinationHash() {\n      return \'#\';\n    }\n  }, {\n    key: "getAnchorUrl",\n    value: function getAnchorUrl() {\n      return \'#\';\n    }\n  }, {\n    key: "setHash",\n    value: function setHash() {}\n  }, {\n    key: "executeNamedAction",\n    value: function executeNamedAction() {}\n  }, {\n    key: "cachePageRef",\n    value: function cachePageRef() {}\n  }, {\n    key: "isPageVisible",\n    value: function isPageVisible() {\n      return true;\n    }\n  }, {\n    key: "isPageCached",\n    value: function isPageCached() {\n      return true;\n    }\n  }, {\n    key: "pagesCount",\n    get: function get() {\n      return this.pdfDocument ? this.pdfDocument.numPages : 0;\n    }\n  }, {\n    key: "page",\n    get: function get() {\n      return this.pdfViewer.currentPageNumber;\n    },\n    set: function set(value) {\n      this.pdfViewer.currentPageNumber = value;\n    }\n  }, {\n    key: "rotation",\n    get: function get() {\n      return 0;\n    },\n    set: function set(value) {}\n  }]);\n\n  return SimpleLinkService;\n}();\n\n\n;// CONCATENATED MODULE: ./node_modules/react-pdf/dist/esm/PasswordResponses.js\n// As defined in https://github.com/mozilla/pdf.js/blob/master/src/shared/util.js#L378-L381\nvar PasswordResponses = {\n  NEED_PASSWORD: 1,\n  INCORRECT_PASSWORD: 2\n};\n/* harmony default export */ const esm_PasswordResponses = (PasswordResponses);\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i["return"] != null) _i["return"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === "string") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === "Object" && o.constructor) n = o.constructor.name;\n  if (n === "Map" || n === "Set") return Array.from(o);\n  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js\nfunction _nonIterableRest() {\n  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js\n\n\n\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n;// CONCATENATED MODULE: ./node_modules/react-pdf/dist/esm/shared/utils.js\n\n\n/**\n * Checks if we\'re running in a browser environment.\n */\nvar isBrowser = typeof window !== \'undefined\';\n/**\n * Checks whether we\'re running from a local file system.\n */\n\nvar isLocalFileSystem = isBrowser && window.location.protocol === \'file:\';\n/**\n * Checks whether we\'re running on a production build or not.\n */\n\nvar isProduction = "production" === \'production\';\n/**\n * Checks whether a variable is defined.\n *\n * @param {*} variable Variable to check\n */\n\nfunction isDefined(variable) {\n  return typeof variable !== \'undefined\';\n}\n/**\n * Checks whether a variable is defined and not null.\n *\n * @param {*} variable Variable to check\n */\n\nfunction isProvided(variable) {\n  return isDefined(variable) && variable !== null;\n}\n/**\n * Checkes whether a variable provided is a string.\n *\n * @param {*} variable Variable to check\n */\n\nfunction isString(variable) {\n  return typeof variable === \'string\';\n}\n/**\n * Checks whether a variable provided is an ArrayBuffer.\n *\n * @param {*} variable Variable to check\n */\n\nfunction isArrayBuffer(variable) {\n  return variable instanceof ArrayBuffer;\n}\n/**\n * Checkes whether a variable provided is a Blob.\n *\n * @param {*} variable Variable to check\n */\n\nfunction isBlob(variable) {\n  if (!isBrowser) {\n    throw new Error(\'Attempted to check if a variable is a Blob on a non-browser environment.\');\n  }\n\n  return variable instanceof Blob;\n}\n/**\n * Checkes whether a variable provided is a File.\n *\n * @param {*} variable Variable to check\n */\n\nfunction isFile(variable) {\n  if (!isBrowser) {\n    throw new Error(\'Attempted to check if a variable is a File on a non-browser environment.\');\n  }\n\n  return variable instanceof File;\n}\n/**\n * Checks whether a string provided is a data URI.\n *\n * @param {string} str String to check\n */\n\nfunction isDataURI(str) {\n  return isString(str) && /^data:/.test(str);\n}\nfunction dataURItoByteString(dataURI) {\n  if (!isDataURI(dataURI)) {\n    throw new Error(\'Invalid data URI.\');\n  }\n\n  var _dataURI$split = dataURI.split(\',\'),\n      _dataURI$split2 = _slicedToArray(_dataURI$split, 2),\n      headersString = _dataURI$split2[0],\n      dataString = _dataURI$split2[1];\n\n  var headers = headersString.split(\';\');\n\n  if (headers.indexOf(\'base64\') !== -1) {\n    return atob(dataString);\n  }\n\n  return unescape(dataString);\n}\nfunction getPixelRatio() {\n  return isBrowser && window.devicePixelRatio || 1;\n}\n\nfunction consoleOnDev(method) {\n  if (!isProduction) {\n    var _console;\n\n    for (var _len = arguments.length, message = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      message[_key - 1] = arguments[_key];\n    }\n\n    // eslint-disable-next-line no-console\n    (_console = console)[method].apply(_console, message);\n  }\n}\n\nfunction warnOnDev() {\n  for (var _len2 = arguments.length, message = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    message[_key2] = arguments[_key2];\n  }\n\n  consoleOnDev.apply(void 0, [\'warn\'].concat(message));\n}\nfunction errorOnDev() {\n  for (var _len3 = arguments.length, message = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    message[_key3] = arguments[_key3];\n  }\n\n  consoleOnDev.apply(void 0, [\'error\'].concat(message));\n}\nfunction displayCORSWarning() {\n  if (isLocalFileSystem) {\n    warnOnDev(\'Loading PDF as base64 strings/URLs might not work on protocols other than HTTP/HTTPS. On Google Chrome, you can use --allow-file-access-from-files flag for debugging purposes.\');\n  }\n}\nfunction cancelRunningTask(runningTask) {\n  if (runningTask && runningTask.cancel) runningTask.cancel();\n}\nfunction makePageCallback(page, scale) {\n  Object.defineProperty(page, \'width\', {\n    get: function get() {\n      return this.view[2] * scale;\n    },\n    configurable: true\n  });\n  Object.defineProperty(page, \'height\', {\n    get: function get() {\n      return this.view[3] * scale;\n    },\n    configurable: true\n  });\n  Object.defineProperty(page, \'originalWidth\', {\n    get: function get() {\n      return this.view[2];\n    },\n    configurable: true\n  });\n  Object.defineProperty(page, \'originalHeight\', {\n    get: function get() {\n      return this.view[3];\n    },\n    configurable: true\n  });\n  return page;\n}\nfunction isCancelException(error) {\n  return error.name === \'RenderingCancelledException\';\n}\nfunction loadFromFile(file) {\n  return new Promise(function (resolve, reject) {\n    var reader = new FileReader();\n\n    reader.onload = function () {\n      return resolve(new Uint8Array(reader.result));\n    };\n\n    reader.onerror = function (event) {\n      switch (event.target.error.code) {\n        case event.target.error.NOT_FOUND_ERR:\n          return reject(new Error(\'Error while reading a file: File not found.\'));\n\n        case event.target.error.NOT_READABLE_ERR:\n          return reject(new Error(\'Error while reading a file: File not readable.\'));\n\n        case event.target.error.SECURITY_ERR:\n          return reject(new Error(\'Error while reading a file: Security error.\'));\n\n        case event.target.error.ABORT_ERR:\n          return reject(new Error(\'Error while reading a file: Aborted.\'));\n\n        default:\n          return reject(new Error(\'Error while reading a file.\'));\n      }\n    };\n\n    reader.readAsArrayBuffer(file);\n    return null;\n  });\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js\nfunction _nonIterableSpread() {\n  throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\n\n\n\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n;// CONCATENATED MODULE: ./node_modules/react-pdf/dist/esm/shared/propTypes.js\n\n\n\n\n\n\nvar eventProps = function () {\n  var result = {};\n  [].concat(_toConsumableArray(mouseEvents), _toConsumableArray(touchEvents), _toConsumableArray(keyboardEvents)).forEach(function (eventName) {\n    result[eventName] = (prop_types_default()).func;\n  });\n  return result;\n}();\n/* eslint-disable react/forbid-prop-types */\n\nvar fileTypes = [(prop_types_default()).string, prop_types_default().instanceOf(ArrayBuffer), prop_types_default().shape({\n  data: prop_types_default().oneOfType([(prop_types_default()).object, (prop_types_default()).string]),\n  httpHeaders: (prop_types_default()).object,\n  range: (prop_types_default()).object,\n  url: (prop_types_default()).string,\n  withCredentials: (prop_types_default()).bool\n})];\n\nif (typeof File !== \'undefined\') {\n  fileTypes.push(prop_types_default().instanceOf(File));\n}\n\nif (typeof Blob !== \'undefined\') {\n  fileTypes.push(prop_types_default().instanceOf(Blob));\n}\n\nvar isClassName = prop_types_default().oneOfType([(prop_types_default()).string, prop_types_default().arrayOf((prop_types_default()).string)]);\nvar propTypes_isFile = prop_types_default().oneOfType(fileTypes);\nvar isLinkService = prop_types_default().instanceOf(SimpleLinkService);\nvar isLinkTarget = prop_types_default().oneOf([\'_self\', \'_blank\', \'_parent\', \'_top\']);\nvar isPage = prop_types_default().shape({\n  _transport: prop_types_default().shape({\n    fontLoader: (prop_types_default()).object.isRequired\n  }).isRequired,\n  commonObjs: prop_types_default().shape({\n    _objs: (prop_types_default()).object.isRequired\n  }).isRequired,\n  getAnnotations: (prop_types_default()).func.isRequired,\n  getTextContent: (prop_types_default()).func.isRequired,\n  getViewport: (prop_types_default()).func.isRequired,\n  render: (prop_types_default()).func.isRequired\n});\nvar isPageIndex = function isPageIndex(props, propName, componentName) {\n  var pageIndex = props[propName],\n      pageNumber = props.pageNumber,\n      pdf = props.pdf;\n\n  if (!isDefined(pdf)) {\n    return null;\n  }\n\n  if (isDefined(pageIndex)) {\n    if (typeof pageIndex !== \'number\') {\n      return new Error("`".concat(propName, "` of type `").concat(_typeof(pageIndex), "` supplied to `").concat(componentName, "`, expected `number`."));\n    }\n\n    if (pageIndex < 0) {\n      return new Error("Expected `".concat(propName, "` to be greater or equal to 0."));\n    }\n\n    var numPages = pdf.numPages;\n\n    if (pageIndex + 1 > numPages) {\n      return new Error("Expected `".concat(propName, "` to be less or equal to ").concat(numPages - 1, "."));\n    }\n  } else if (!isDefined(pageNumber)) {\n    return new Error("`".concat(propName, "` not supplied. Either pageIndex or pageNumber must be supplied to `").concat(componentName, "`."));\n  } // Everything is fine\n\n\n  return null;\n};\nvar isPageNumber = function isPageNumber(props, propName, componentName) {\n  var pageNumber = props[propName],\n      pageIndex = props.pageIndex,\n      pdf = props.pdf;\n\n  if (!isDefined(pdf)) {\n    return null;\n  }\n\n  if (isDefined(pageNumber)) {\n    if (typeof pageNumber !== \'number\') {\n      return new Error("`".concat(propName, "` of type `").concat(_typeof(pageNumber), "` supplied to `").concat(componentName, "`, expected `number`."));\n    }\n\n    if (pageNumber < 1) {\n      return new Error("Expected `".concat(propName, "` to be greater or equal to 1."));\n    }\n\n    var numPages = pdf.numPages;\n\n    if (pageNumber > numPages) {\n      return new Error("Expected `".concat(propName, "` to be less or equal to ").concat(numPages, "."));\n    }\n  } else if (!isDefined(pageIndex)) {\n    return new Error("`".concat(propName, "` not supplied. Either pageIndex or pageNumber must be supplied to `").concat(componentName, "`."));\n  } // Everything is fine\n\n\n  return null;\n};\nvar isPdf = prop_types_default().oneOfType([prop_types_default().shape({\n  getDestination: (prop_types_default()).func.isRequired,\n  getOutline: (prop_types_default()).func.isRequired,\n  getPage: (prop_types_default()).func.isRequired,\n  numPages: (prop_types_default()).number.isRequired\n}), (prop_types_default()).bool]);\nvar isRef = prop_types_default().oneOfType([(prop_types_default()).func, prop_types_default().shape({\n  current: (prop_types_default()).any\n})]);\nvar isRenderMode = prop_types_default().oneOf([\'canvas\', \'none\', \'svg\']);\nvar isRotate = prop_types_default().oneOf([0, 90, 180, 270]);\n;// CONCATENATED MODULE: ./node_modules/react-pdf/dist/esm/Document.js\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * Loads a PDF document. Passes it to all children.\n */\n\n\n\n\n\n\n\n\n\n\n\n\nvar PDFDataRangeTransport = build_pdf.PDFDataRangeTransport;\n\nvar Document = /*#__PURE__*/function (_PureComponent) {\n  _inherits(Document, _PureComponent);\n\n  var _super = _createSuper(Document);\n\n  function Document() {\n    var _this;\n\n    _classCallCheck(this, Document);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), "state", {\n      pdf: null\n    });\n\n    _defineProperty(_assertThisInitialized(_this), "viewer", {\n      scrollPageIntoView: function scrollPageIntoView(_ref) {\n        var pageNumber = _ref.pageNumber;\n        // Handling jumping to internal links target\n        var onItemClick = _this.props.onItemClick; // First, check if custom handling of onItemClick was provided\n\n        if (onItemClick) {\n          onItemClick({\n            pageNumber: pageNumber\n          });\n          return;\n        } // If not, try to look for target page within the <Document>.\n\n\n        var page = _this.pages[pageNumber - 1];\n\n        if (page) {\n          // Scroll to the page automatically\n          page.scrollIntoView();\n          return;\n        }\n\n        warnOnDev("Warning: An internal link leading to page ".concat(pageNumber, " was clicked, but neither <Document> was provided with onItemClick nor it was able to find the page within itself. Either provide onItemClick to <Document> and handle navigating by yourself or ensure that all pages are rendered within <Document>."));\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), "linkService", new SimpleLinkService());\n\n    _defineProperty(_assertThisInitialized(_this), "loadDocument", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regenerator_default().mark(function _callee() {\n      var source, _this$props, options, onLoadProgress, onPassword, cancellable, pdf;\n\n      return regenerator_default().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              source = null;\n              _context.prev = 1;\n              _context.next = 4;\n              return _this.findDocumentSource();\n\n            case 4:\n              source = _context.sent;\n\n              _this.onSourceSuccess();\n\n              _context.next = 11;\n              break;\n\n            case 8:\n              _context.prev = 8;\n              _context.t0 = _context["catch"](1);\n\n              _this.onSourceError(_context.t0);\n\n            case 11:\n              if (source) {\n                _context.next = 13;\n                break;\n              }\n\n              return _context.abrupt("return");\n\n            case 13:\n              _this.setState(function (prevState) {\n                if (!prevState.pdf) {\n                  return null;\n                }\n\n                return {\n                  pdf: null\n                };\n              });\n\n              _this$props = _this.props, options = _this$props.options, onLoadProgress = _this$props.onLoadProgress, onPassword = _this$props.onPassword;\n              _context.prev = 15;\n              // If another rendering is in progress, let\'s cancel it\n              cancelRunningTask(_this.runningTask); // If another loading is in progress, let\'s destroy it\n\n              if (_this.loadingTask) _this.loadingTask.destroy();\n              _this.loadingTask = build_pdf.getDocument(_objectSpread(_objectSpread({}, source), options));\n              _this.loadingTask.onPassword = onPassword;\n\n              if (onLoadProgress) {\n                _this.loadingTask.onProgress = onLoadProgress;\n              }\n\n              cancellable = makeCancellablePromise(_this.loadingTask.promise);\n              _this.runningTask = cancellable;\n              _context.next = 25;\n              return cancellable.promise;\n\n            case 25:\n              pdf = _context.sent;\n\n              _this.setState(function (prevState) {\n                if (prevState.pdf && prevState.pdf.fingerprint === pdf.fingerprint) {\n                  return null;\n                }\n\n                return {\n                  pdf: pdf\n                };\n              }, _this.onLoadSuccess);\n\n              _context.next = 32;\n              break;\n\n            case 29:\n              _context.prev = 29;\n              _context.t1 = _context["catch"](15);\n\n              _this.onLoadError(_context.t1);\n\n            case 32:\n            case "end":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[1, 8], [15, 29]]);\n    })));\n\n    _defineProperty(_assertThisInitialized(_this), "setupLinkService", function () {\n      _this.linkService.setViewer(_this.viewer);\n\n      var documentInstance = _assertThisInitialized(_this);\n\n      Object.defineProperty(_this.linkService, \'externalLinkTarget\', {\n        get: function get() {\n          var externalLinkTarget = documentInstance.props.externalLinkTarget;\n\n          switch (externalLinkTarget) {\n            case \'_self\':\n              return 1;\n\n            case \'_blank\':\n              return 2;\n\n            case \'_parent\':\n              return 3;\n\n            case \'_top\':\n              return 4;\n\n            default:\n              return 0;\n          }\n        }\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), "onSourceSuccess", function () {\n      var onSourceSuccess = _this.props.onSourceSuccess;\n      if (onSourceSuccess) onSourceSuccess();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), "onSourceError", function (error) {\n      errorOnDev(error);\n      var onSourceError = _this.props.onSourceError;\n      if (onSourceError) onSourceError(error);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), "onLoadSuccess", function () {\n      var onLoadSuccess = _this.props.onLoadSuccess;\n      var pdf = _this.state.pdf;\n      if (onLoadSuccess) onLoadSuccess(pdf);\n      _this.pages = new Array(pdf.numPages);\n\n      _this.linkService.setDocument(pdf);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), "onLoadError", function (error) {\n      _this.setState({\n        pdf: false\n      });\n\n      errorOnDev(error);\n      var onLoadError = _this.props.onLoadError;\n      if (onLoadError) onLoadError(error);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), "findDocumentSource", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regenerator_default().mark(function _callee2() {\n      var file, fileByteString, url, otherParams, _fileByteString;\n\n      return regenerator_default().wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              file = _this.props.file;\n\n              if (file) {\n                _context2.next = 3;\n                break;\n              }\n\n              return _context2.abrupt("return", null);\n\n            case 3:\n              if (!(typeof file === \'string\')) {\n                _context2.next = 9;\n                break;\n              }\n\n              if (!isDataURI(file)) {\n                _context2.next = 7;\n                break;\n              }\n\n              fileByteString = dataURItoByteString(file);\n              return _context2.abrupt("return", {\n                data: fileByteString\n              });\n\n            case 7:\n              displayCORSWarning();\n              return _context2.abrupt("return", {\n                url: file\n              });\n\n            case 9:\n              if (!(file instanceof PDFDataRangeTransport)) {\n                _context2.next = 11;\n                break;\n              }\n\n              return _context2.abrupt("return", {\n                range: file\n              });\n\n            case 11:\n              if (!isArrayBuffer(file)) {\n                _context2.next = 13;\n                break;\n              }\n\n              return _context2.abrupt("return", {\n                data: file\n              });\n\n            case 13:\n              if (!isBrowser) {\n                _context2.next = 19;\n                break;\n              }\n\n              if (!(isBlob(file) || isFile(file))) {\n                _context2.next = 19;\n                break;\n              }\n\n              _context2.next = 17;\n              return loadFromFile(file);\n\n            case 17:\n              _context2.t0 = _context2.sent;\n              return _context2.abrupt("return", {\n                data: _context2.t0\n              });\n\n            case 19:\n              if (!(_typeof(file) !== \'object\')) {\n                _context2.next = 21;\n                break;\n              }\n\n              throw new Error(\'Invalid parameter in file, need either Uint8Array, string or a parameter object\');\n\n            case 21:\n              if (!(!file.url && !file.data && !file.range)) {\n                _context2.next = 23;\n                break;\n              }\n\n              throw new Error(\'Invalid parameter object: need either .data, .range or .url\');\n\n            case 23:\n              if (!(typeof file.url === \'string\')) {\n                _context2.next = 29;\n                break;\n              }\n\n              if (!isDataURI(file.url)) {\n                _context2.next = 28;\n                break;\n              }\n\n              url = file.url, otherParams = _objectWithoutProperties(file, ["url"]);\n              _fileByteString = dataURItoByteString(url);\n              return _context2.abrupt("return", _objectSpread({\n                data: _fileByteString\n              }, otherParams));\n\n            case 28:\n              displayCORSWarning();\n\n            case 29:\n              return _context2.abrupt("return", file);\n\n            case 30:\n            case "end":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    })));\n\n    _defineProperty(_assertThisInitialized(_this), "registerPage", function (pageIndex, ref) {\n      _this.pages[pageIndex] = ref;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), "unregisterPage", function (pageIndex) {\n      delete _this.pages[pageIndex];\n    });\n\n    return _this;\n  }\n\n  _createClass(Document, [{\n    key: "componentDidMount",\n    value: function componentDidMount() {\n      this.loadDocument();\n      this.setupLinkService();\n    }\n  }, {\n    key: "componentDidUpdate",\n    value: function componentDidUpdate(prevProps) {\n      var file = this.props.file;\n\n      if (file !== prevProps.file) {\n        this.loadDocument();\n      }\n    }\n  }, {\n    key: "componentWillUnmount",\n    value: function componentWillUnmount() {\n      // If rendering is in progress, let\'s cancel it\n      cancelRunningTask(this.runningTask); // If loading is in progress, let\'s destroy it\n\n      if (this.loadingTask) this.loadingTask.destroy();\n    }\n  }, {\n    key: "renderChildren",\n    value: function renderChildren() {\n      var children = this.props.children;\n      return /*#__PURE__*/external_commonjs_react_commonjs2_react_amd_react_root_React_default().createElement(esm_DocumentContext.Provider, {\n        value: this.childContext\n      }, children);\n    }\n  }, {\n    key: "renderContent",\n    value: function renderContent() {\n      var file = this.props.file;\n      var pdf = this.state.pdf;\n\n      if (!file) {\n        var noData = this.props.noData;\n        return /*#__PURE__*/external_commonjs_react_commonjs2_react_amd_react_root_React_default().createElement(Message, {\n          type: "no-data"\n        }, typeof noData === \'function\' ? noData() : noData);\n      }\n\n      if (pdf === null) {\n        var loading = this.props.loading;\n        return /*#__PURE__*/external_commonjs_react_commonjs2_react_amd_react_root_React_default().createElement(Message, {\n          type: "loading"\n        }, typeof loading === \'function\' ? loading() : loading);\n      }\n\n      if (pdf === false) {\n        var error = this.props.error;\n        return /*#__PURE__*/external_commonjs_react_commonjs2_react_amd_react_root_React_default().createElement(Message, {\n          type: "error"\n        }, typeof error === \'function\' ? error() : error);\n      }\n\n      return this.renderChildren();\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      var _this$props2 = this.props,\n          className = _this$props2.className,\n          inputRef = _this$props2.inputRef;\n      return /*#__PURE__*/external_commonjs_react_commonjs2_react_amd_react_root_React_default().createElement("div", extends_extends({\n        className: mergeClassNames(\'react-pdf__Document\', className),\n        ref: inputRef\n      }, this.eventProps), this.renderContent());\n    }\n  }, {\n    key: "childContext",\n    get: function get() {\n      var linkService = this.linkService,\n          registerPage = this.registerPage,\n          unregisterPage = this.unregisterPage;\n      var _this$props3 = this.props,\n          imageResourcesPath = _this$props3.imageResourcesPath,\n          renderMode = _this$props3.renderMode,\n          rotate = _this$props3.rotate;\n      var pdf = this.state.pdf;\n      return {\n        imageResourcesPath: imageResourcesPath,\n        linkService: linkService,\n        pdf: pdf,\n        registerPage: registerPage,\n        renderMode: renderMode,\n        rotate: rotate,\n        unregisterPage: unregisterPage\n      };\n    }\n  }, {\n    key: "eventProps",\n    get: function get() {\n      var _this2 = this;\n\n      // eslint-disable-next-line react/destructuring-assignment\n      return esm(this.props, function () {\n        return _this2.state.pdf;\n      });\n    }\n    /**\n     * Called when a document source is resolved correctly\n     */\n\n  }]);\n\n  return Document;\n}(external_commonjs_react_commonjs2_react_amd_react_root_React_.PureComponent);\n\n\nDocument.defaultProps = {\n  error: \'Failed to load PDF file.\',\n  loading: \'Loading PDF\',\n  noData: \'No PDF file specified.\',\n  onPassword: function onPassword(callback, reason) {\n    switch (reason) {\n      case esm_PasswordResponses.NEED_PASSWORD:\n        {\n          // eslint-disable-next-line no-alert\n          var password = prompt(\'Enter the password to open this PDF file.\');\n          callback(password);\n          break;\n        }\n\n      case esm_PasswordResponses.INCORRECT_PASSWORD:\n        {\n          // eslint-disable-next-line no-alert\n          var _password = prompt(\'Invalid password. Please try again.\');\n\n          callback(_password);\n          break;\n        }\n\n      default:\n    }\n  }\n};\nvar isFunctionOrNode = prop_types_default().oneOfType([(prop_types_default()).func, (prop_types_default()).node]);\nDocument.propTypes = _objectSpread(_objectSpread({}, eventProps), {}, {\n  children: (prop_types_default()).node,\n  className: isClassName,\n  error: isFunctionOrNode,\n  file: propTypes_isFile,\n  imageResourcesPath: (prop_types_default()).string,\n  inputRef: isRef,\n  loading: isFunctionOrNode,\n  noData: isFunctionOrNode,\n  onItemClick: (prop_types_default()).func,\n  onLoadError: (prop_types_default()).func,\n  onLoadProgress: (prop_types_default()).func,\n  onLoadSuccess: (prop_types_default()).func,\n  onPassword: (prop_types_default()).func,\n  onSourceError: (prop_types_default()).func,\n  onSourceSuccess: (prop_types_default()).func,\n  rotate: (prop_types_default()).number\n});\n;// CONCATENATED MODULE: ./node_modules/react-pdf/dist/esm/OutlineContext.js\n\n/* harmony default export */ const OutlineContext = (/*#__PURE__*/(0,external_commonjs_react_commonjs2_react_amd_react_root_React_.createContext)(null));\n;// CONCATENATED MODULE: ./node_modules/react-pdf/dist/esm/Ref.js\n\n\n\nvar Ref = /*#__PURE__*/function () {\n  function Ref(_ref) {\n    var num = _ref.num,\n        gen = _ref.gen;\n\n    _classCallCheck(this, Ref);\n\n    this.num = num;\n    this.gen = gen;\n  }\n\n  _createClass(Ref, [{\n    key: "toString",\n    value: function toString() {\n      var str = "".concat(this.num, "R");\n\n      if (this.gen !== 0) {\n        str += this.gen;\n      }\n\n      return str;\n    }\n  }]);\n\n  return Ref;\n}();\n\n\n;// CONCATENATED MODULE: ./node_modules/react-pdf/dist/esm/OutlineItem.js\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction OutlineItem_createSuper(Derived) { var hasNativeReflectConstruct = OutlineItem_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction OutlineItem_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\n\n\n\n\n\n\n\nvar OutlineItemInternal = /*#__PURE__*/function (_PureComponent) {\n  _inherits(OutlineItemInternal, _PureComponent);\n\n  var _super = OutlineItem_createSuper(OutlineItemInternal);\n\n  function OutlineItemInternal() {\n    var _this;\n\n    _classCallCheck(this, OutlineItemInternal);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), "getDestination", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regenerator_default().mark(function _callee() {\n      var _this$props, item, pdf;\n\n      return regenerator_default().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _this$props = _this.props, item = _this$props.item, pdf = _this$props.pdf;\n\n              if (isDefined(_this.destination)) {\n                _context.next = 9;\n                break;\n              }\n\n              if (!(typeof item.dest === \'string\')) {\n                _context.next = 8;\n                break;\n              }\n\n              _context.next = 5;\n              return pdf.getDestination(item.dest);\n\n            case 5:\n              _this.destination = _context.sent;\n              _context.next = 9;\n              break;\n\n            case 8:\n              _this.destination = item.dest;\n\n            case 9:\n              return _context.abrupt("return", _this.destination);\n\n            case 10:\n            case "end":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    })));\n\n    _defineProperty(_assertThisInitialized(_this), "getPageIndex", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regenerator_default().mark(function _callee2() {\n      var pdf, destination, _destination, ref;\n\n      return regenerator_default().wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              pdf = _this.props.pdf;\n\n              if (isDefined(_this.pageIndex)) {\n                _context2.next = 10;\n                break;\n              }\n\n              _context2.next = 4;\n              return _this.getDestination();\n\n            case 4:\n              destination = _context2.sent;\n\n              if (!destination) {\n                _context2.next = 10;\n                break;\n              }\n\n              _destination = _slicedToArray(destination, 1), ref = _destination[0];\n              _context2.next = 9;\n              return pdf.getPageIndex(new Ref(ref));\n\n            case 9:\n              _this.pageIndex = _context2.sent;\n\n            case 10:\n              return _context2.abrupt("return", _this.pageIndex);\n\n            case 11:\n            case "end":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    })));\n\n    _defineProperty(_assertThisInitialized(_this), "getPageNumber", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regenerator_default().mark(function _callee3() {\n      return regenerator_default().wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              if (isDefined(_this.pageNumber)) {\n                _context3.next = 5;\n                break;\n              }\n\n              _context3.next = 3;\n              return _this.getPageIndex();\n\n            case 3:\n              _context3.t0 = _context3.sent;\n              _this.pageNumber = _context3.t0 + 1;\n\n            case 5:\n              return _context3.abrupt("return", _this.pageNumber);\n\n            case 6:\n            case "end":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    })));\n\n    _defineProperty(_assertThisInitialized(_this), "onClick", /*#__PURE__*/function () {\n      var _ref4 = _asyncToGenerator( /*#__PURE__*/regenerator_default().mark(function _callee4(event) {\n        var onClick, pageIndex, pageNumber;\n        return regenerator_default().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                onClick = _this.props.onClick;\n                event.preventDefault();\n                _context4.next = 4;\n                return _this.getPageIndex();\n\n              case 4:\n                pageIndex = _context4.sent;\n                _context4.next = 7;\n                return _this.getPageNumber();\n\n              case 7:\n                pageNumber = _context4.sent;\n\n                if (onClick) {\n                  onClick({\n                    pageIndex: pageIndex,\n                    pageNumber: pageNumber\n                  });\n                }\n\n              case 9:\n              case "end":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n\n      return function (_x) {\n        return _ref4.apply(this, arguments);\n      };\n    }());\n\n    return _this;\n  }\n\n  _createClass(OutlineItemInternal, [{\n    key: "renderSubitems",\n    value: function renderSubitems() {\n      var _this$props2 = this.props,\n          item = _this$props2.item,\n          otherProps = _objectWithoutProperties(_this$props2, ["item"]);\n\n      if (!item.items || !item.items.length) {\n        return null;\n      }\n\n      var subitems = item.items;\n      return /*#__PURE__*/external_commonjs_react_commonjs2_react_amd_react_root_React_default().createElement("ul", null, subitems.map(function (subitem, subitemIndex) {\n        return /*#__PURE__*/external_commonjs_react_commonjs2_react_amd_react_root_React_default().createElement(OutlineItemInternal, extends_extends({\n          key: typeof subitem.destination === \'string\' ? subitem.destination : subitemIndex,\n          item: subitem\n        }, otherProps));\n      }));\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      var item = this.props.item;\n      /* eslint-disable jsx-a11y/anchor-is-valid */\n\n      return /*#__PURE__*/external_commonjs_react_commonjs2_react_amd_react_root_React_default().createElement("li", null, /*#__PURE__*/external_commonjs_react_commonjs2_react_amd_react_root_React_default().createElement("a", {\n        href: "#",\n        onClick: this.onClick\n      }, item.title), this.renderSubitems());\n    }\n  }]);\n\n  return OutlineItemInternal;\n}(external_commonjs_react_commonjs2_react_amd_react_root_React_.PureComponent);\nvar isDestination = prop_types_default().oneOfType([(prop_types_default()).string, prop_types_default().arrayOf((prop_types_default()).any)]);\nOutlineItemInternal.propTypes = {\n  item: prop_types_default().shape({\n    dest: isDestination,\n    items: prop_types_default().arrayOf(prop_types_default().shape({\n      dest: isDestination,\n      title: (prop_types_default()).string\n    })),\n    title: (prop_types_default()).string\n  }).isRequired,\n  onClick: (prop_types_default()).func,\n  pdf: isPdf.isRequired\n};\n\nvar OutlineItem = function OutlineItem(props) {\n  return /*#__PURE__*/external_commonjs_react_commonjs2_react_amd_react_root_React_default().createElement(esm_DocumentContext.Consumer, null, function (documentContext) {\n    return /*#__PURE__*/external_commonjs_react_commonjs2_react_amd_react_root_React_default().createElement(OutlineContext.Consumer, null, function (outlineContext) {\n      return /*#__PURE__*/external_commonjs_react_commonjs2_react_amd_react_root_React_default().createElement(OutlineItemInternal, extends_extends({}, documentContext, outlineContext, props));\n    });\n  });\n};\n\n/* harmony default export */ const esm_OutlineItem = (OutlineItem);\n;// CONCATENATED MODULE: ./node_modules/react-pdf/dist/esm/Outline.js\n\n\n\n\n\n\n\n\n\n\n\nfunction Outline_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction Outline_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Outline_ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Outline_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Outline_createSuper(Derived) { var hasNativeReflectConstruct = Outline_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction Outline_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\n\n\n\n\n\n\n\n\n\n\nvar OutlineInternal = /*#__PURE__*/function (_PureComponent) {\n  _inherits(OutlineInternal, _PureComponent);\n\n  var _super = Outline_createSuper(OutlineInternal);\n\n  function OutlineInternal() {\n    var _this;\n\n    _classCallCheck(this, OutlineInternal);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), "state", {\n      outline: null\n    });\n\n    _defineProperty(_assertThisInitialized(_this), "loadOutline", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regenerator_default().mark(function _callee() {\n      var pdf, cancellable, outline;\n      return regenerator_default().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              pdf = _this.props.pdf;\n\n              _this.setState(function (prevState) {\n                if (!prevState.outline) {\n                  return null;\n                }\n\n                return {\n                  outline: null\n                };\n              });\n\n              _context.prev = 2;\n              cancellable = makeCancellablePromise(pdf.getOutline());\n              _this.runningTask = cancellable;\n              _context.next = 7;\n              return cancellable.promise;\n\n            case 7:\n              outline = _context.sent;\n\n              _this.setState({\n                outline: outline\n              }, _this.onLoadSuccess);\n\n              _context.next = 14;\n              break;\n\n            case 11:\n              _context.prev = 11;\n              _context.t0 = _context["catch"](2);\n\n              _this.onLoadError(_context.t0);\n\n            case 14:\n            case "end":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[2, 11]]);\n    })));\n\n    _defineProperty(_assertThisInitialized(_this), "onLoadSuccess", function () {\n      var onLoadSuccess = _this.props.onLoadSuccess;\n      var outline = _this.state.outline;\n      if (onLoadSuccess) onLoadSuccess(outline);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), "onLoadError", function (error) {\n      _this.setState({\n        outline: false\n      });\n\n      errorOnDev(error);\n      var onLoadError = _this.props.onLoadError;\n      if (onLoadError) onLoadError(error);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), "onItemClick", function (_ref2) {\n      var pageIndex = _ref2.pageIndex,\n          pageNumber = _ref2.pageNumber;\n      var onItemClick = _this.props.onItemClick;\n\n      if (onItemClick) {\n        onItemClick({\n          pageIndex: pageIndex,\n          pageNumber: pageNumber\n        });\n      }\n    });\n\n    return _this;\n  }\n\n  _createClass(OutlineInternal, [{\n    key: "componentDidMount",\n    value: function componentDidMount() {\n      var pdf = this.props.pdf;\n\n      if (!pdf) {\n        throw new Error(\'Attempted to load an outline, but no document was specified.\');\n      }\n\n      this.loadOutline();\n    }\n  }, {\n    key: "componentDidUpdate",\n    value: function componentDidUpdate(prevProps) {\n      var pdf = this.props.pdf;\n\n      if (prevProps.pdf && pdf !== prevProps.pdf) {\n        this.loadOutline();\n      }\n    }\n  }, {\n    key: "componentWillUnmount",\n    value: function componentWillUnmount() {\n      cancelRunningTask(this.runningTask);\n    }\n  }, {\n    key: "renderOutline",\n    value: function renderOutline() {\n      var outline = this.state.outline;\n      return /*#__PURE__*/external_commonjs_react_commonjs2_react_amd_react_root_React_default().createElement("ul", null, outline.map(function (item, itemIndex) {\n        return /*#__PURE__*/external_commonjs_react_commonjs2_react_amd_react_root_React_default().createElement(esm_OutlineItem, {\n          key: typeof item.destination === \'string\' ? item.destination : itemIndex,\n          item: item\n        });\n      }));\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      var pdf = this.props.pdf;\n      var outline = this.state.outline;\n\n      if (!pdf || !outline) {\n        return null;\n      }\n\n      var _this$props = this.props,\n          className = _this$props.className,\n          inputRef = _this$props.inputRef;\n      return /*#__PURE__*/external_commonjs_react_commonjs2_react_amd_react_root_React_default().createElement("div", extends_extends({\n        className: mergeClassNames(\'react-pdf__Outline\', className),\n        ref: inputRef\n      }, this.eventProps), /*#__PURE__*/external_commonjs_react_commonjs2_react_amd_react_root_React_default().createElement(OutlineContext.Provider, {\n        value: this.childContext\n      }, this.renderOutline()));\n    }\n  }, {\n    key: "childContext",\n    get: function get() {\n      return {\n        onClick: this.onItemClick\n      };\n    }\n  }, {\n    key: "eventProps",\n    get: function get() {\n      var _this2 = this;\n\n      // eslint-disable-next-line react/destructuring-assignment\n      return esm(this.props, function () {\n        return _this2.state.outline;\n      });\n    }\n    /**\n     * Called when an outline is read successfully\n     */\n\n  }]);\n\n  return OutlineInternal;\n}(external_commonjs_react_commonjs2_react_amd_react_root_React_.PureComponent);\nOutlineInternal.propTypes = Outline_objectSpread({\n  className: isClassName,\n  inputRef: isRef,\n  onItemClick: (prop_types_default()).func,\n  onLoadError: (prop_types_default()).func,\n  onLoadSuccess: (prop_types_default()).func,\n  pdf: isPdf\n}, eventProps);\n\nfunction Outline(props, ref) {\n  return /*#__PURE__*/React.createElement(DocumentContext.Consumer, null, function (context) {\n    return /*#__PURE__*/React.createElement(OutlineInternal, _extends({\n      ref: ref\n    }, context, props));\n  });\n}\n\n/* harmony default export */ const esm_Outline = (/*#__PURE__*/(/* unused pure expression or super */ null && (React.forwardRef(Outline))));\n;// CONCATENATED MODULE: ./node_modules/merge-refs/dist/esm/index.js\n/**\n * A function that merges React refs into one.\n * Supports both functions and ref objects created using createRef() and useRef().\n *\n * Usage:\n * ```jsx\n * <div ref={mergeRefs(ref1, ref2, ref3)} />\n * ```\n *\n * @param {...Array<Function|object>} inputRefs Array of refs\n * @returns {Function} Merged refs\n */\nfunction mergeRefs() {\n  for (var _len = arguments.length, inputRefs = new Array(_len), _key = 0; _key < _len; _key++) {\n    inputRefs[_key] = arguments[_key];\n  }\n\n  var filteredInputRefs = inputRefs.filter(Boolean);\n\n  if (filteredInputRefs.length <= 1) {\n    return filteredInputRefs[0];\n  }\n\n  return function mergedRefs(ref) {\n    filteredInputRefs.forEach(function (inputRef) {\n      if (typeof inputRef === \'function\') {\n        inputRef(ref);\n      } else {\n        // eslint-disable-next-line no-param-reassign\n        inputRef.current = ref;\n      }\n    });\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/react-pdf/dist/esm/PageContext.js\n\n/* harmony default export */ const PageContext = (/*#__PURE__*/(0,external_commonjs_react_commonjs2_react_amd_react_root_React_.createContext)(null));\n;// CONCATENATED MODULE: ./node_modules/react-pdf/dist/esm/Page/PageCanvas.js\n\n\n\n\n\n\n\n\n\nfunction PageCanvas_createSuper(Derived) { var hasNativeReflectConstruct = PageCanvas_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction PageCanvas_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\n\n\n\n\n\n\nvar PageCanvasInternal = /*#__PURE__*/function (_PureComponent) {\n  _inherits(PageCanvasInternal, _PureComponent);\n\n  var _super = PageCanvas_createSuper(PageCanvasInternal);\n\n  function PageCanvasInternal() {\n    var _this;\n\n    _classCallCheck(this, PageCanvasInternal);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), "onRenderSuccess", function () {\n      _this.renderer = null;\n      var _this$props = _this.props,\n          onRenderSuccess = _this$props.onRenderSuccess,\n          page = _this$props.page,\n          scale = _this$props.scale;\n      if (onRenderSuccess) onRenderSuccess(makePageCallback(page, scale));\n    });\n\n    _defineProperty(_assertThisInitialized(_this), "onRenderError", function (error) {\n      if (isCancelException(error)) {\n        return;\n      }\n\n      errorOnDev(error);\n      var onRenderError = _this.props.onRenderError;\n      if (onRenderError) onRenderError(error);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), "drawPageOnCanvas", function () {\n      var _assertThisInitialize = _assertThisInitialized(_this),\n          canvas = _assertThisInitialize.canvasLayer;\n\n      if (!canvas) {\n        return null;\n      }\n\n      var _assertThisInitialize2 = _assertThisInitialized(_this),\n          renderViewport = _assertThisInitialize2.renderViewport,\n          viewport = _assertThisInitialize2.viewport;\n\n      var _this$props2 = _this.props,\n          page = _this$props2.page,\n          renderInteractiveForms = _this$props2.renderInteractiveForms;\n      canvas.width = renderViewport.width;\n      canvas.height = renderViewport.height;\n      canvas.style.width = "".concat(Math.floor(viewport.width), "px");\n      canvas.style.height = "".concat(Math.floor(viewport.height), "px");\n      var renderContext = {\n        get canvasContext() {\n          return canvas.getContext(\'2d\');\n        },\n\n        viewport: renderViewport,\n        renderInteractiveForms: renderInteractiveForms\n      }; // If another render is in progress, let\'s cancel it\n\n      _this.cancelRenderingTask();\n\n      _this.renderer = page.render(renderContext);\n      return _this.renderer.promise.then(_this.onRenderSuccess)["catch"](_this.onRenderError);\n    });\n\n    return _this;\n  }\n\n  _createClass(PageCanvasInternal, [{\n    key: "componentDidMount",\n    value: function componentDidMount() {\n      this.drawPageOnCanvas();\n    }\n  }, {\n    key: "componentDidUpdate",\n    value: function componentDidUpdate(prevProps) {\n      var _this$props3 = this.props,\n          page = _this$props3.page,\n          renderInteractiveForms = _this$props3.renderInteractiveForms;\n\n      if (renderInteractiveForms !== prevProps.renderInteractiveForms) {\n        // Ensures the canvas will be re-rendered from scratch. Otherwise all form data will stay.\n        page.cleanup();\n        this.drawPageOnCanvas();\n      }\n    }\n  }, {\n    key: "componentWillUnmount",\n    value: function componentWillUnmount() {\n      this.cancelRenderingTask();\n      /**\n       * Zeroing the width and height cause most browsers to release graphics\n       * resources immediately, which can greatly reduce memory consumption.\n       */\n\n      if (this.canvasLayer) {\n        this.canvasLayer.width = 0;\n        this.canvasLayer.height = 0;\n        this.canvasLayer = null;\n      }\n    }\n  }, {\n    key: "cancelRenderingTask",\n    value: function cancelRenderingTask() {\n      if (this.renderer) {\n        this.renderer.cancel();\n        this.renderer = null;\n      }\n    }\n    /**\n     * Called when a page is rendered successfully.\n     */\n\n  }, {\n    key: "render",\n    value: function render() {\n      var _this2 = this;\n\n      var canvasRef = this.props.canvasRef;\n      return /*#__PURE__*/external_commonjs_react_commonjs2_react_amd_react_root_React_default().createElement("canvas", {\n        className: "react-pdf__Page__canvas",\n        dir: "ltr",\n        ref: mergeRefs(canvasRef, function (ref) {\n          _this2.canvasLayer = ref;\n        }),\n        style: {\n          display: \'block\',\n          userSelect: \'none\'\n        }\n      });\n    }\n  }, {\n    key: "renderViewport",\n    get: function get() {\n      var _this$props4 = this.props,\n          page = _this$props4.page,\n          rotate = _this$props4.rotate,\n          scale = _this$props4.scale;\n      var pixelRatio = getPixelRatio();\n      return page.getViewport({\n        scale: scale * pixelRatio,\n        rotation: rotate\n      });\n    }\n  }, {\n    key: "viewport",\n    get: function get() {\n      var _this$props5 = this.props,\n          page = _this$props5.page,\n          rotate = _this$props5.rotate,\n          scale = _this$props5.scale;\n      return page.getViewport({\n        scale: scale,\n        rotation: rotate\n      });\n    }\n  }]);\n\n  return PageCanvasInternal;\n}(external_commonjs_react_commonjs2_react_amd_react_root_React_.PureComponent);\nPageCanvasInternal.propTypes = {\n  canvasRef: isRef,\n  onRenderError: (prop_types_default()).func,\n  onRenderSuccess: (prop_types_default()).func,\n  page: isPage.isRequired,\n  renderInteractiveForms: (prop_types_default()).bool,\n  rotate: isRotate,\n  scale: (prop_types_default()).number.isRequired\n};\nfunction PageCanvas(props) {\n  return /*#__PURE__*/external_commonjs_react_commonjs2_react_amd_react_root_React_default().createElement(PageContext.Consumer, null, function (context) {\n    return /*#__PURE__*/external_commonjs_react_commonjs2_react_amd_react_root_React_default().createElement(PageCanvasInternal, extends_extends({}, context, props));\n  });\n}\n;// CONCATENATED MODULE: ./node_modules/react-pdf/dist/esm/Page/PageSVG.js\n\n\n\n\n\n\n\n\n\nfunction PageSVG_createSuper(Derived) { var hasNativeReflectConstruct = PageSVG_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction PageSVG_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\n\n\n\n\n\n\nvar PageSVGInternal = /*#__PURE__*/function (_PureComponent) {\n  _inherits(PageSVGInternal, _PureComponent);\n\n  var _super = PageSVG_createSuper(PageSVGInternal);\n\n  function PageSVGInternal() {\n    var _this;\n\n    _classCallCheck(this, PageSVGInternal);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), "state", {\n      svg: null\n    });\n\n    _defineProperty(_assertThisInitialized(_this), "onRenderSuccess", function () {\n      _this.renderer = null;\n      var _this$props = _this.props,\n          onRenderSuccess = _this$props.onRenderSuccess,\n          page = _this$props.page,\n          scale = _this$props.scale;\n      if (onRenderSuccess) onRenderSuccess(makePageCallback(page, scale));\n    });\n\n    _defineProperty(_assertThisInitialized(_this), "onRenderError", function (error) {\n      if (isCancelException(error)) {\n        return;\n      }\n\n      errorOnDev(error);\n      var onRenderError = _this.props.onRenderError;\n      if (onRenderError) onRenderError(error);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), "renderSVG", function () {\n      var page = _this.props.page;\n      _this.renderer = page.getOperatorList();\n      return _this.renderer.then(function (operatorList) {\n        var svgGfx = new build_pdf.SVGGraphics(page.commonObjs, page.objs);\n        _this.renderer = svgGfx.getSVG(operatorList, _this.viewport).then(function (svg) {\n          _this.setState({\n            svg: svg\n          }, _this.onRenderSuccess);\n        })["catch"](_this.onRenderError);\n      })["catch"](_this.onRenderError);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), "drawPageOnContainer", function (element) {\n      var svg = _this.state.svg;\n\n      if (!element || !svg) {\n        return;\n      } // Append SVG element to the main container, if this hasn\'t been done already\n\n\n      if (!element.firstElementChild) {\n        element.appendChild(svg);\n      }\n\n      var _this$viewport = _this.viewport,\n          width = _this$viewport.width,\n          height = _this$viewport.height;\n      svg.setAttribute(\'width\', width);\n      svg.setAttribute(\'height\', height);\n    });\n\n    return _this;\n  }\n\n  _createClass(PageSVGInternal, [{\n    key: "componentDidMount",\n    value: function componentDidMount() {\n      this.renderSVG();\n    }\n    /**\n     * Called when a page is rendered successfully.\n     */\n\n  }, {\n    key: "render",\n    value: function render() {\n      var _this2 = this;\n\n      var _this$viewport2 = this.viewport,\n          width = _this$viewport2.width,\n          height = _this$viewport2.height;\n      return /*#__PURE__*/external_commonjs_react_commonjs2_react_amd_react_root_React_default().createElement("div", {\n        className: "react-pdf__Page__svg" // Note: This cannot be shortened, as we need this function to be called with each render.\n        ,\n        ref: function ref(_ref) {\n          return _this2.drawPageOnContainer(_ref);\n        },\n        style: {\n          display: \'block\',\n          backgroundColor: \'white\',\n          overflow: \'hidden\',\n          width: width,\n          height: height,\n          userSelect: \'none\'\n        }\n      });\n    }\n  }, {\n    key: "viewport",\n    get: function get() {\n      var _this$props2 = this.props,\n          page = _this$props2.page,\n          rotate = _this$props2.rotate,\n          scale = _this$props2.scale;\n      return page.getViewport({\n        scale: scale,\n        rotation: rotate\n      });\n    }\n  }]);\n\n  return PageSVGInternal;\n}(external_commonjs_react_commonjs2_react_amd_react_root_React_.PureComponent);\nPageSVGInternal.propTypes = {\n  onRenderError: (prop_types_default()).func,\n  onRenderSuccess: (prop_types_default()).func,\n  page: isPage.isRequired,\n  rotate: isRotate,\n  scale: (prop_types_default()).number.isRequired\n};\nfunction PageSVG(props) {\n  return /*#__PURE__*/external_commonjs_react_commonjs2_react_amd_react_root_React_default().createElement(PageContext.Consumer, null, function (context) {\n    return /*#__PURE__*/external_commonjs_react_commonjs2_react_amd_react_root_React_default().createElement(PageSVGInternal, extends_extends({}, context, props));\n  });\n}\n;// CONCATENATED MODULE: ./node_modules/react-pdf/dist/esm/Page/TextLayerItem.js\n\n\n\n\n\n\n\n\n\n\n\n\nfunction TextLayerItem_createSuper(Derived) { var hasNativeReflectConstruct = TextLayerItem_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction TextLayerItem_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\n\n\n\n\nvar TextLayerItemInternal = /*#__PURE__*/function (_PureComponent) {\n  _inherits(TextLayerItemInternal, _PureComponent);\n\n  var _super = TextLayerItem_createSuper(TextLayerItemInternal);\n\n  function TextLayerItemInternal() {\n    var _this;\n\n    _classCallCheck(this, TextLayerItemInternal);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), "getElementWidth", function (element) {\n      var _assertThisInitialize = _assertThisInitialized(_this),\n          sideways = _assertThisInitialize.sideways;\n\n      return element.getBoundingClientRect()[sideways ? \'height\' : \'width\'];\n    });\n\n    return _this;\n  }\n\n  _createClass(TextLayerItemInternal, [{\n    key: "componentDidMount",\n    value: function componentDidMount() {\n      this.alignTextItem();\n    }\n  }, {\n    key: "componentDidUpdate",\n    value: function componentDidUpdate() {\n      this.alignTextItem();\n    }\n  }, {\n    key: "getFontData",\n    value: function () {\n      var _getFontData = _asyncToGenerator( /*#__PURE__*/regenerator_default().mark(function _callee(fontName) {\n        var page, font;\n        return regenerator_default().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                page = this.props.page;\n                _context.next = 3;\n                return new Promise(function (resolve) {\n                  page.commonObjs.get(fontName, resolve);\n                });\n\n              case 3:\n                font = _context.sent;\n                return _context.abrupt("return", font);\n\n              case 5:\n              case "end":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getFontData(_x) {\n        return _getFontData.apply(this, arguments);\n      }\n\n      return getFontData;\n    }()\n  }, {\n    key: "alignTextItem",\n    value: function () {\n      var _alignTextItem = _asyncToGenerator( /*#__PURE__*/regenerator_default().mark(function _callee2() {\n        var element, _this$props, fontName, scale, width, fontData, fallbackFontName, targetWidth, actualWidth, transform, ascent;\n\n        return regenerator_default().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                element = this.item;\n\n                if (element) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                return _context2.abrupt("return");\n\n              case 3:\n                element.style.transform = \'\';\n                _this$props = this.props, fontName = _this$props.fontName, scale = _this$props.scale, width = _this$props.width;\n                element.style.fontFamily = "".concat(fontName, ", sans-serif");\n                _context2.next = 8;\n                return this.getFontData(fontName);\n\n              case 8:\n                fontData = _context2.sent;\n                fallbackFontName = fontData ? fontData.fallbackName : \'sans-serif\';\n                element.style.fontFamily = "".concat(fontName, ", ").concat(fallbackFontName);\n                targetWidth = width * scale;\n                actualWidth = this.getElementWidth(element);\n                transform = "scaleX(".concat(targetWidth / actualWidth, ")");\n                ascent = fontData ? fontData.ascent : 0;\n\n                if (ascent) {\n                  transform += " translateY(".concat((1 - ascent) * 100, "%)");\n                }\n\n                element.style.transform = transform;\n                element.style.WebkitTransform = transform;\n\n              case 18:\n              case "end":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function alignTextItem() {\n        return _alignTextItem.apply(this, arguments);\n      }\n\n      return alignTextItem;\n    }()\n  }, {\n    key: "render",\n    value: function render() {\n      var _this2 = this;\n\n      var fontSize = this.fontSize,\n          top = this.top,\n          left = this.left;\n      var _this$props2 = this.props,\n          customTextRenderer = _this$props2.customTextRenderer,\n          scale = _this$props2.scale,\n          text = _this$props2.str;\n      return /*#__PURE__*/external_commonjs_react_commonjs2_react_amd_react_root_React_default().createElement("span", {\n        ref: function ref(_ref) {\n          _this2.item = _ref;\n        },\n        style: {\n          height: \'1em\',\n          fontFamily: \'sans-serif\',\n          fontSize: "".concat(fontSize * scale, "px"),\n          position: \'absolute\',\n          top: "".concat(top * scale, "px"),\n          left: "".concat(left * scale, "px"),\n          transformOrigin: \'left bottom\',\n          whiteSpace: \'pre\',\n          pointerEvents: \'all\'\n        }\n      }, customTextRenderer ? customTextRenderer(this.props) : text);\n    }\n  }, {\n    key: "unrotatedViewport",\n    get: function get() {\n      var _this$props3 = this.props,\n          page = _this$props3.page,\n          scale = _this$props3.scale;\n      return page.getViewport({\n        scale: scale\n      });\n    }\n    /**\n     * It might happen that the page is rotated by default. In such cases, we shouldn\'t rotate\n     * text content.\n     */\n\n  }, {\n    key: "rotate",\n    get: function get() {\n      var _this$props4 = this.props,\n          page = _this$props4.page,\n          rotate = _this$props4.rotate;\n      return rotate - page.rotate;\n    }\n  }, {\n    key: "sideways",\n    get: function get() {\n      var rotate = this.rotate;\n      return rotate % 180 !== 0;\n    }\n  }, {\n    key: "defaultSideways",\n    get: function get() {\n      var rotation = this.unrotatedViewport.rotation;\n      return rotation % 180 !== 0;\n    }\n  }, {\n    key: "fontSize",\n    get: function get() {\n      var transform = this.props.transform;\n      var defaultSideways = this.defaultSideways;\n\n      var _transform = _slicedToArray(transform, 2),\n          fontHeightPx = _transform[0],\n          fontWidthPx = _transform[1];\n\n      return defaultSideways ? fontWidthPx : fontHeightPx;\n    }\n  }, {\n    key: "top",\n    get: function get() {\n      var transform = this.props.transform;\n      var viewport = this.unrotatedViewport,\n          defaultSideways = this.defaultSideways;\n\n      var _transform2 = _slicedToArray(transform, 6),\n\n      /* fontHeightPx */\n\n      /* fontWidthPx */\n      offsetX = _transform2[2],\n          offsetY = _transform2[3],\n          x = _transform2[4],\n          y = _transform2[5];\n\n      var _viewport$viewBox = _slicedToArray(viewport.viewBox, 4),\n\n      /* xMin */\n      yMin = _viewport$viewBox[1],\n\n      /* xMax */\n      yMax = _viewport$viewBox[3];\n\n      return defaultSideways ? x + offsetX + yMin : yMax - (y + offsetY);\n    }\n  }, {\n    key: "left",\n    get: function get() {\n      var transform = this.props.transform;\n      var viewport = this.unrotatedViewport,\n          defaultSideways = this.defaultSideways;\n\n      var _transform3 = _slicedToArray(transform, 6),\n\n      /* fontHeightPx */\n\n      /* fontWidthPx */\n\n      /* offsetX */\n\n      /* offsetY */\n      x = _transform3[4],\n          y = _transform3[5];\n\n      var _viewport$viewBox2 = _slicedToArray(viewport.viewBox, 1),\n          xMin = _viewport$viewBox2[0];\n\n      return defaultSideways ? y - xMin : x - xMin;\n    }\n  }]);\n\n  return TextLayerItemInternal;\n}(external_commonjs_react_commonjs2_react_amd_react_root_React_.PureComponent);\nTextLayerItemInternal.propTypes = {\n  customTextRenderer: (prop_types_default()).func,\n  fontName: (prop_types_default()).string.isRequired,\n  itemIndex: (prop_types_default()).number.isRequired,\n  // eslint-disable-line react/no-unused-prop-types\n  page: isPage.isRequired,\n  rotate: isRotate,\n  scale: (prop_types_default()).number,\n  str: (prop_types_default()).string.isRequired,\n  transform: prop_types_default().arrayOf((prop_types_default()).number).isRequired,\n  width: (prop_types_default()).number.isRequired\n};\nfunction TextLayerItem(props) {\n  return /*#__PURE__*/external_commonjs_react_commonjs2_react_amd_react_root_React_default().createElement(PageContext.Consumer, null, function (context) {\n    return /*#__PURE__*/external_commonjs_react_commonjs2_react_amd_react_root_React_default().createElement(TextLayerItemInternal, extends_extends({}, context, props));\n  });\n}\n;// CONCATENATED MODULE: ./node_modules/react-pdf/dist/esm/Page/TextLayer.js\n\n\n\n\n\n\n\n\n\n\n\nfunction TextLayer_createSuper(Derived) { var hasNativeReflectConstruct = TextLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction TextLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\n\n\n\n\n\n\n\nvar TextLayerInternal = /*#__PURE__*/function (_PureComponent) {\n  _inherits(TextLayerInternal, _PureComponent);\n\n  var _super = TextLayer_createSuper(TextLayerInternal);\n\n  function TextLayerInternal() {\n    var _this;\n\n    _classCallCheck(this, TextLayerInternal);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), "state", {\n      textItems: null\n    });\n\n    _defineProperty(_assertThisInitialized(_this), "loadTextItems", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regenerator_default().mark(function _callee() {\n      var page, cancellable, _yield$cancellable$pr, textItems;\n\n      return regenerator_default().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              page = _this.props.page;\n              _context.prev = 1;\n              cancellable = makeCancellablePromise(page.getTextContent());\n              _this.runningTask = cancellable;\n              _context.next = 6;\n              return cancellable.promise;\n\n            case 6:\n              _yield$cancellable$pr = _context.sent;\n              textItems = _yield$cancellable$pr.items;\n\n              _this.setState({\n                textItems: textItems\n              }, _this.onLoadSuccess);\n\n              _context.next = 14;\n              break;\n\n            case 11:\n              _context.prev = 11;\n              _context.t0 = _context["catch"](1);\n\n              _this.onLoadError(_context.t0);\n\n            case 14:\n            case "end":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[1, 11]]);\n    })));\n\n    _defineProperty(_assertThisInitialized(_this), "onLoadSuccess", function () {\n      var onGetTextSuccess = _this.props.onGetTextSuccess;\n      var textItems = _this.state.textItems;\n      if (onGetTextSuccess) onGetTextSuccess(textItems);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), "onLoadError", function (error) {\n      _this.setState({\n        textItems: false\n      });\n\n      errorOnDev(error);\n      var onGetTextError = _this.props.onGetTextError;\n      if (onGetTextError) onGetTextError(error);\n    });\n\n    return _this;\n  }\n\n  _createClass(TextLayerInternal, [{\n    key: "componentDidMount",\n    value: function componentDidMount() {\n      var page = this.props.page;\n\n      if (!page) {\n        throw new Error(\'Attempted to load page text content, but no page was specified.\');\n      }\n\n      this.loadTextItems();\n    }\n  }, {\n    key: "componentDidUpdate",\n    value: function componentDidUpdate(prevProps) {\n      var page = this.props.page;\n\n      if (prevProps.page && page !== prevProps.page) {\n        this.loadTextItems();\n      }\n    }\n  }, {\n    key: "componentWillUnmount",\n    value: function componentWillUnmount() {\n      cancelRunningTask(this.runningTask);\n    }\n  }, {\n    key: "renderTextItems",\n    value: function renderTextItems() {\n      var textItems = this.state.textItems;\n\n      if (!textItems) {\n        return null;\n      }\n\n      return textItems.map(function (textItem, itemIndex) {\n        return /*#__PURE__*/external_commonjs_react_commonjs2_react_amd_react_root_React_default().createElement(TextLayerItem // eslint-disable-next-line react/no-array-index-key\n        , extends_extends({\n          key: itemIndex,\n          itemIndex: itemIndex\n        }, textItem));\n      });\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      var viewport = this.unrotatedViewport,\n          rotate = this.rotate;\n      return /*#__PURE__*/external_commonjs_react_commonjs2_react_amd_react_root_React_default().createElement("div", {\n        className: "react-pdf__Page__textContent",\n        style: {\n          position: \'absolute\',\n          top: \'50%\',\n          left: \'50%\',\n          width: "".concat(viewport.width, "px"),\n          height: "".concat(viewport.height, "px"),\n          color: \'transparent\',\n          transform: "translate(-50%, -50%) rotate(".concat(rotate, "deg)"),\n          WebkitTransform: "translate(-50%, -50%) rotate(".concat(rotate, "deg)"),\n          pointerEvents: \'none\'\n        }\n      }, this.renderTextItems());\n    }\n  }, {\n    key: "unrotatedViewport",\n    get: function get() {\n      var _this$props = this.props,\n          page = _this$props.page,\n          scale = _this$props.scale;\n      return page.getViewport({\n        scale: scale\n      });\n    }\n    /**\n     * It might happen that the page is rotated by default. In such cases, we shouldn\'t rotate\n     * text content.\n     */\n\n  }, {\n    key: "rotate",\n    get: function get() {\n      var _this$props2 = this.props,\n          page = _this$props2.page,\n          rotate = _this$props2.rotate;\n      return rotate - page.rotate;\n    }\n  }]);\n\n  return TextLayerInternal;\n}(external_commonjs_react_commonjs2_react_amd_react_root_React_.PureComponent);\nTextLayerInternal.propTypes = {\n  onGetTextError: (prop_types_default()).func,\n  onGetTextSuccess: (prop_types_default()).func,\n  page: isPage.isRequired,\n  rotate: isRotate,\n  scale: (prop_types_default()).number\n};\nfunction TextLayer(props) {\n  return /*#__PURE__*/external_commonjs_react_commonjs2_react_amd_react_root_React_default().createElement(PageContext.Consumer, null, function (context) {\n    return /*#__PURE__*/external_commonjs_react_commonjs2_react_amd_react_root_React_default().createElement(TextLayerInternal, extends_extends({}, context, props));\n  });\n}\n;// CONCATENATED MODULE: ./node_modules/react-pdf/dist/esm/Page/AnnotationLayer.js\n\n\n\n\n\n\n\n\n\n\n\nfunction AnnotationLayer_createSuper(Derived) { var hasNativeReflectConstruct = AnnotationLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction AnnotationLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\n\n\n\n\n\n\n\n\nvar AnnotationLayerInternal = /*#__PURE__*/function (_PureComponent) {\n  _inherits(AnnotationLayerInternal, _PureComponent);\n\n  var _super = AnnotationLayer_createSuper(AnnotationLayerInternal);\n\n  function AnnotationLayerInternal() {\n    var _this;\n\n    _classCallCheck(this, AnnotationLayerInternal);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), "state", {\n      annotations: null\n    });\n\n    _defineProperty(_assertThisInitialized(_this), "loadAnnotations", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regenerator_default().mark(function _callee() {\n      var page, cancellable, annotations;\n      return regenerator_default().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              page = _this.props.page;\n              _context.prev = 1;\n              cancellable = makeCancellablePromise(page.getAnnotations());\n              _this.runningTask = cancellable;\n              _context.next = 6;\n              return cancellable.promise;\n\n            case 6:\n              annotations = _context.sent;\n\n              _this.setState({\n                annotations: annotations\n              }, _this.onLoadSuccess);\n\n              _context.next = 13;\n              break;\n\n            case 10:\n              _context.prev = 10;\n              _context.t0 = _context["catch"](1);\n\n              _this.onLoadError(_context.t0);\n\n            case 13:\n            case "end":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[1, 10]]);\n    })));\n\n    _defineProperty(_assertThisInitialized(_this), "onLoadSuccess", function () {\n      var onGetAnnotationsSuccess = _this.props.onGetAnnotationsSuccess;\n      var annotations = _this.state.annotations;\n      if (onGetAnnotationsSuccess) onGetAnnotationsSuccess(annotations);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), "onLoadError", function (error) {\n      _this.setState({\n        annotations: false\n      });\n\n      errorOnDev(error);\n      var onGetAnnotationsError = _this.props.onGetAnnotationsError;\n      if (onGetAnnotationsError) onGetAnnotationsError(error);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), "onRenderSuccess", function () {\n      var onRenderAnnotationLayerSuccess = _this.props.onRenderAnnotationLayerSuccess;\n      if (onRenderAnnotationLayerSuccess) onRenderAnnotationLayerSuccess();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), "onRenderError", function (error) {\n      errorOnDev(error);\n      var onRenderAnnotationLayerError = _this.props.onRenderAnnotationLayerError;\n      if (onRenderAnnotationLayerError) onRenderAnnotationLayerError(error);\n    });\n\n    return _this;\n  }\n\n  _createClass(AnnotationLayerInternal, [{\n    key: "componentDidMount",\n    value: function componentDidMount() {\n      var page = this.props.page;\n\n      if (!page) {\n        throw new Error(\'Attempted to load page annotations, but no page was specified.\');\n      }\n\n      this.loadAnnotations();\n    }\n  }, {\n    key: "componentDidUpdate",\n    value: function componentDidUpdate(prevProps) {\n      var _this$props = this.props,\n          page = _this$props.page,\n          renderInteractiveForms = _this$props.renderInteractiveForms;\n\n      if (prevProps.page && page !== prevProps.page || renderInteractiveForms !== prevProps.renderInteractiveForms) {\n        this.loadAnnotations();\n      }\n    }\n  }, {\n    key: "componentWillUnmount",\n    value: function componentWillUnmount() {\n      cancelRunningTask(this.runningTask);\n    }\n  }, {\n    key: "renderAnnotationLayer",\n    value: function renderAnnotationLayer() {\n      var annotations = this.state.annotations;\n\n      if (!annotations) {\n        return;\n      }\n\n      var _this$props2 = this.props,\n          imageResourcesPath = _this$props2.imageResourcesPath,\n          linkService = _this$props2.linkService,\n          page = _this$props2.page,\n          renderInteractiveForms = _this$props2.renderInteractiveForms;\n      var viewport = this.viewport.clone({\n        dontFlip: true\n      });\n      var parameters = {\n        annotations: annotations,\n        div: this.annotationLayer,\n        imageResourcesPath: imageResourcesPath,\n        linkService: linkService,\n        page: page,\n        renderInteractiveForms: renderInteractiveForms,\n        viewport: viewport\n      };\n      this.annotationLayer.innerHTML = \'\';\n\n      try {\n        build_pdf.AnnotationLayer.render(parameters);\n        this.onRenderSuccess();\n      } catch (error) {\n        this.onRenderError(error);\n      }\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      var _this2 = this;\n\n      return /*#__PURE__*/external_commonjs_react_commonjs2_react_amd_react_root_React_default().createElement("div", {\n        className: "react-pdf__Page__annotations annotationLayer",\n        ref: function ref(_ref2) {\n          _this2.annotationLayer = _ref2;\n        }\n      }, this.renderAnnotationLayer());\n    }\n  }, {\n    key: "viewport",\n    get: function get() {\n      var _this$props3 = this.props,\n          page = _this$props3.page,\n          rotate = _this$props3.rotate,\n          scale = _this$props3.scale;\n      return page.getViewport({\n        scale: scale,\n        rotation: rotate\n      });\n    }\n  }]);\n\n  return AnnotationLayerInternal;\n}(external_commonjs_react_commonjs2_react_amd_react_root_React_.PureComponent);\nAnnotationLayerInternal.propTypes = {\n  imageResourcesPath: (prop_types_default()).string,\n  linkService: isLinkService.isRequired,\n  onGetAnnotationsError: (prop_types_default()).func,\n  onGetAnnotationsSuccess: (prop_types_default()).func,\n  onRenderAnnotationLayerError: (prop_types_default()).func,\n  onRenderAnnotationLayerSuccess: (prop_types_default()).func,\n  page: isPage,\n  renderInteractiveForms: (prop_types_default()).bool,\n  rotate: isRotate,\n  scale: (prop_types_default()).number\n};\n\nvar AnnotationLayer = function AnnotationLayer(props) {\n  return /*#__PURE__*/external_commonjs_react_commonjs2_react_amd_react_root_React_default().createElement(esm_DocumentContext.Consumer, null, function (documentContext) {\n    return /*#__PURE__*/external_commonjs_react_commonjs2_react_amd_react_root_React_default().createElement(PageContext.Consumer, null, function (pageContext) {\n      return /*#__PURE__*/external_commonjs_react_commonjs2_react_amd_react_root_React_default().createElement(AnnotationLayerInternal, extends_extends({}, documentContext, pageContext, props));\n    });\n  });\n};\n\n/* harmony default export */ const Page_AnnotationLayer = (AnnotationLayer);\n;// CONCATENATED MODULE: ./node_modules/react-pdf/dist/esm/Page.js\n\n\n\n\n\n\n\n\n\n\n\nfunction Page_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction Page_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Page_ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Page_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Page_createSuper(Derived) { var hasNativeReflectConstruct = Page_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction Page_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar defaultScale = 1;\nvar PageInternal = /*#__PURE__*/function (_PureComponent) {\n  _inherits(PageInternal, _PureComponent);\n\n  var _super = Page_createSuper(PageInternal);\n\n  function PageInternal() {\n    var _this;\n\n    _classCallCheck(this, PageInternal);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), "state", {\n      page: null\n    });\n\n    _defineProperty(_assertThisInitialized(_this), "onLoadSuccess", function () {\n      var _this$props = _this.props,\n          onLoadSuccess = _this$props.onLoadSuccess,\n          registerPage = _this$props.registerPage;\n      var page = _this.state.page;\n      if (onLoadSuccess) onLoadSuccess(makePageCallback(page, _this.scale));\n      if (registerPage) registerPage(_this.pageIndex, _this.ref);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), "onLoadError", function (error) {\n      errorOnDev(error);\n      var onLoadError = _this.props.onLoadError;\n      if (onLoadError) onLoadError(error);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), "loadPage", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regenerator_default().mark(function _callee() {\n      var pdf, pageNumber, cancellable, page;\n      return regenerator_default().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              pdf = _this.props.pdf;\n              pageNumber = _this.getPageNumber();\n\n              if (pageNumber) {\n                _context.next = 4;\n                break;\n              }\n\n              return _context.abrupt("return");\n\n            case 4:\n              _this.setState(function (prevState) {\n                if (!prevState.page) {\n                  return null;\n                }\n\n                return {\n                  page: null\n                };\n              });\n\n              _context.prev = 5;\n              cancellable = makeCancellablePromise(pdf.getPage(pageNumber));\n              _this.runningTask = cancellable;\n              _context.next = 10;\n              return cancellable.promise;\n\n            case 10:\n              page = _context.sent;\n\n              _this.setState({\n                page: page\n              }, _this.onLoadSuccess);\n\n              _context.next = 18;\n              break;\n\n            case 14:\n              _context.prev = 14;\n              _context.t0 = _context["catch"](5);\n\n              _this.setState({\n                page: false\n              });\n\n              _this.onLoadError(_context.t0);\n\n            case 18:\n            case "end":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[5, 14]]);\n    })));\n\n    return _this;\n  }\n\n  _createClass(PageInternal, [{\n    key: "componentDidMount",\n    value: function componentDidMount() {\n      var pdf = this.props.pdf;\n\n      if (!pdf) {\n        throw new Error(\'Attempted to load a page, but no document was specified.\');\n      }\n\n      this.loadPage();\n    }\n  }, {\n    key: "componentDidUpdate",\n    value: function componentDidUpdate(prevProps) {\n      var pdf = this.props.pdf;\n\n      if (prevProps.pdf && pdf !== prevProps.pdf || this.getPageNumber() !== this.getPageNumber(prevProps)) {\n        var unregisterPage = this.props.unregisterPage;\n        if (unregisterPage) unregisterPage(this.getPageIndex(prevProps));\n        this.loadPage();\n      }\n    }\n  }, {\n    key: "componentWillUnmount",\n    value: function componentWillUnmount() {\n      var unregisterPage = this.props.unregisterPage;\n      if (unregisterPage) unregisterPage(this.pageIndex);\n      cancelRunningTask(this.runningTask);\n    }\n  }, {\n    key: "getPageIndex",\n    value: function getPageIndex() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n\n      if (isProvided(props.pageNumber)) {\n        return props.pageNumber - 1;\n      }\n\n      if (isProvided(props.pageIndex)) {\n        return props.pageIndex;\n      }\n\n      return null;\n    }\n  }, {\n    key: "getPageNumber",\n    value: function getPageNumber() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n\n      if (isProvided(props.pageNumber)) {\n        return props.pageNumber;\n      }\n\n      if (isProvided(props.pageIndex)) {\n        return props.pageIndex + 1;\n      }\n\n      return null;\n    }\n  }, {\n    key: "renderMainLayer",\n    value: function renderMainLayer() {\n      var _this$props2 = this.props,\n          canvasRef = _this$props2.canvasRef,\n          renderMode = _this$props2.renderMode;\n\n      switch (renderMode) {\n        case \'none\':\n          return null;\n\n        case \'svg\':\n          return /*#__PURE__*/external_commonjs_react_commonjs2_react_amd_react_root_React_default().createElement(PageSVG, {\n            key: "".concat(this.pageKeyNoScale, "_svg")\n          });\n\n        case \'canvas\':\n        default:\n          return /*#__PURE__*/external_commonjs_react_commonjs2_react_amd_react_root_React_default().createElement(PageCanvas, {\n            key: "".concat(this.pageKey, "_canvas"),\n            canvasRef: canvasRef\n          });\n      }\n    }\n  }, {\n    key: "renderTextLayer",\n    value: function renderTextLayer() {\n      var renderTextLayer = this.props.renderTextLayer;\n\n      if (!renderTextLayer) {\n        return null;\n      }\n\n      return /*#__PURE__*/external_commonjs_react_commonjs2_react_amd_react_root_React_default().createElement(TextLayer, {\n        key: "".concat(this.pageKey, "_text")\n      });\n    }\n  }, {\n    key: "renderAnnotationLayer",\n    value: function renderAnnotationLayer() {\n      var renderAnnotationLayer = this.props.renderAnnotationLayer;\n\n      if (!renderAnnotationLayer) {\n        return null;\n      }\n      /**\n       * As of now, PDF.js 2.0.943 returns warnings on unimplemented annotations in SVG mode.\n       * Therefore, as a fallback, we render "traditional" AnnotationLayer component.\n       */\n\n\n      return /*#__PURE__*/external_commonjs_react_commonjs2_react_amd_react_root_React_default().createElement(Page_AnnotationLayer, {\n        key: "".concat(this.pageKey, "_annotations")\n      });\n    }\n  }, {\n    key: "renderChildren",\n    value: function renderChildren() {\n      var children = this.props.children;\n      return /*#__PURE__*/external_commonjs_react_commonjs2_react_amd_react_root_React_default().createElement(PageContext.Provider, {\n        value: this.childContext\n      }, this.renderMainLayer(), this.renderTextLayer(), this.renderAnnotationLayer(), children);\n    }\n  }, {\n    key: "renderContent",\n    value: function renderContent() {\n      var pageNumber = this.pageNumber;\n      var pdf = this.props.pdf;\n      var page = this.state.page;\n\n      if (!pageNumber) {\n        var noData = this.props.noData;\n        return /*#__PURE__*/external_commonjs_react_commonjs2_react_amd_react_root_React_default().createElement(Message, {\n          type: "no-data"\n        }, typeof noData === \'function\' ? noData() : noData);\n      }\n\n      if (pdf === null || page === null) {\n        var loading = this.props.loading;\n        return /*#__PURE__*/external_commonjs_react_commonjs2_react_amd_react_root_React_default().createElement(Message, {\n          type: "loading"\n        }, typeof loading === \'function\' ? loading() : loading);\n      }\n\n      if (pdf === false || page === false) {\n        var error = this.props.error;\n        return /*#__PURE__*/external_commonjs_react_commonjs2_react_amd_react_root_React_default().createElement(Message, {\n          type: "error"\n        }, typeof error === \'function\' ? error() : error);\n      }\n\n      return this.renderChildren();\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      var pageNumber = this.pageNumber;\n      var _this$props3 = this.props,\n          className = _this$props3.className,\n          inputRef = _this$props3.inputRef;\n      return /*#__PURE__*/external_commonjs_react_commonjs2_react_amd_react_root_React_default().createElement("div", extends_extends({\n        className: mergeClassNames(\'react-pdf__Page\', className),\n        "data-page-number": pageNumber,\n        ref: mergeRefs(inputRef, this.ref),\n        style: {\n          position: \'relative\'\n        }\n      }, this.eventProps), this.renderContent());\n    }\n  }, {\n    key: "childContext",\n    get: function get() {\n      var page = this.state.page;\n\n      if (!page) {\n        return {};\n      }\n\n      var _this$props4 = this.props,\n          customTextRenderer = _this$props4.customTextRenderer,\n          onGetAnnotationsError = _this$props4.onGetAnnotationsError,\n          onGetAnnotationsSuccess = _this$props4.onGetAnnotationsSuccess,\n          onGetTextError = _this$props4.onGetTextError,\n          onGetTextSuccess = _this$props4.onGetTextSuccess,\n          onRenderAnnotationLayerError = _this$props4.onRenderAnnotationLayerError,\n          onRenderAnnotationLayerSuccess = _this$props4.onRenderAnnotationLayerSuccess,\n          onRenderError = _this$props4.onRenderError,\n          onRenderSuccess = _this$props4.onRenderSuccess,\n          renderInteractiveForms = _this$props4.renderInteractiveForms;\n      return {\n        customTextRenderer: customTextRenderer,\n        onGetAnnotationsError: onGetAnnotationsError,\n        onGetAnnotationsSuccess: onGetAnnotationsSuccess,\n        onGetTextError: onGetTextError,\n        onGetTextSuccess: onGetTextSuccess,\n        onRenderAnnotationLayerError: onRenderAnnotationLayerError,\n        onRenderAnnotationLayerSuccess: onRenderAnnotationLayerSuccess,\n        onRenderError: onRenderError,\n        onRenderSuccess: onRenderSuccess,\n        page: page,\n        renderInteractiveForms: renderInteractiveForms,\n        rotate: this.rotate,\n        scale: this.scale\n      };\n    }\n    /**\n     * Called when a page is loaded successfully\n     */\n\n  }, {\n    key: "pageIndex",\n    get: function get() {\n      return this.getPageIndex();\n    }\n  }, {\n    key: "pageNumber",\n    get: function get() {\n      return this.getPageNumber();\n    }\n  }, {\n    key: "rotate",\n    get: function get() {\n      var rotate = this.props.rotate;\n\n      if (isProvided(rotate)) {\n        return rotate;\n      }\n\n      var page = this.state.page;\n\n      if (!page) {\n        return null;\n      }\n\n      return page.rotate;\n    }\n  }, {\n    key: "scale",\n    get: function get() {\n      var page = this.state.page;\n\n      if (!page) {\n        return null;\n      }\n\n      var _this$props5 = this.props,\n          scale = _this$props5.scale,\n          width = _this$props5.width,\n          height = _this$props5.height;\n      var rotate = this.rotate; // Be default, we\'ll render page at 100% * scale width.\n\n      var pageScale = 1; // Passing scale explicitly null would cause the page not to render\n\n      var scaleWithDefault = scale === null ? defaultScale : scale; // If width/height is defined, calculate the scale of the page so it could be of desired width.\n\n      if (width || height) {\n        var viewport = page.getViewport({\n          scale: 1,\n          rotation: rotate\n        });\n        pageScale = width ? width / viewport.width : height / viewport.height;\n      }\n\n      return scaleWithDefault * pageScale;\n    }\n  }, {\n    key: "eventProps",\n    get: function get() {\n      var _this2 = this;\n\n      return esm(this.props, function () {\n        var page = _this2.state.page;\n\n        if (!page) {\n          return page;\n        }\n\n        return makePageCallback(page, _this2.scale);\n      });\n    }\n  }, {\n    key: "pageKey",\n    get: function get() {\n      var page = this.state.page;\n      return "".concat(page.pageIndex, "@").concat(this.scale, "/").concat(this.rotate);\n    }\n  }, {\n    key: "pageKeyNoScale",\n    get: function get() {\n      var page = this.state.page;\n      return "".concat(page.pageIndex, "/").concat(this.rotate);\n    }\n  }]);\n\n  return PageInternal;\n}(external_commonjs_react_commonjs2_react_amd_react_root_React_.PureComponent);\nPageInternal.defaultProps = {\n  error: \'Failed to load the page.\',\n  loading: \'Loading page\',\n  noData: \'No page specified.\',\n  renderAnnotationLayer: true,\n  renderInteractiveForms: false,\n  renderMode: \'canvas\',\n  renderTextLayer: true,\n  scale: defaultScale\n};\nvar Page_isFunctionOrNode = prop_types_default().oneOfType([(prop_types_default()).func, (prop_types_default()).node]);\nPageInternal.propTypes = Page_objectSpread(Page_objectSpread({}, eventProps), {}, {\n  children: (prop_types_default()).node,\n  className: isClassName,\n  customTextRenderer: (prop_types_default()).func,\n  error: Page_isFunctionOrNode,\n  height: (prop_types_default()).number,\n  imageResourcesPath: (prop_types_default()).string,\n  inputRef: isRef,\n  loading: Page_isFunctionOrNode,\n  noData: Page_isFunctionOrNode,\n  onGetTextError: (prop_types_default()).func,\n  onGetTextSuccess: (prop_types_default()).func,\n  onLoadError: (prop_types_default()).func,\n  onLoadSuccess: (prop_types_default()).func,\n  onRenderError: (prop_types_default()).func,\n  onRenderSuccess: (prop_types_default()).func,\n  pageIndex: isPageIndex,\n  pageNumber: isPageNumber,\n  pdf: isPdf,\n  registerPage: (prop_types_default()).func,\n  renderAnnotationLayer: (prop_types_default()).bool,\n  renderInteractiveForms: (prop_types_default()).bool,\n  renderMode: isRenderMode,\n  renderTextLayer: (prop_types_default()).bool,\n  rotate: isRotate,\n  scale: (prop_types_default()).number,\n  unregisterPage: (prop_types_default()).func,\n  width: (prop_types_default()).number\n});\n\nfunction Page(props, ref) {\n  return /*#__PURE__*/external_commonjs_react_commonjs2_react_amd_react_root_React_default().createElement(esm_DocumentContext.Consumer, null, function (context) {\n    return /*#__PURE__*/external_commonjs_react_commonjs2_react_amd_react_root_React_default().createElement(PageInternal, extends_extends({\n      ref: ref\n    }, context, props));\n  });\n}\n\n/* harmony default export */ const esm_Page = (/*#__PURE__*/external_commonjs_react_commonjs2_react_amd_react_root_React_default().forwardRef(Page));\n;// CONCATENATED MODULE: ./node_modules/react-pdf/dist/esm/entry.js\n\n\n\n\n\n\nif (isLocalFileSystem) {\n  warnOnDev(\'You are running React-PDF from your local file system. PDF.js Worker may fail to load due to browser\\\'s security policies. If you\\\'re on Google Chrome, you can use --allow-file-access-from-files flag for debugging purposes.\');\n}\n\nbuild_pdf.GlobalWorkerOptions.workerSrc = \'pdf.worker.js\';\n\n;// CONCATENATED MODULE: ./src/context/UiContext.ts\n\n\nconst UiContext = external_commonjs_react_commonjs2_react_amd_react_root_React_.createContext({\n    errorMessage: null,\n    isLoading: false,\n    isShowingHighlightOverlay: false,\n    isShowingOutline: false,\n    isShowingTextHighlight: false,\n    setErrorMessage: errorMessage => {\n        logProviderWarning(`setErrorMessage(${errorMessage})`, \'UiContext\');\n    },\n    setIsShowingOutline: isShowingOutline => {\n        logProviderWarning(`setIsShowingOutline(${isShowingOutline})`, \'UiContext\');\n    },\n    setIsLoading: isLoading => {\n        logProviderWarning(`setIsLoading(${isLoading})`, \'UiContext\');\n    },\n    setIsShowingHighlightOverlay: isShowingHighlightOverlay => {\n        logProviderWarning(`setIsShowingHighlightOverlay(${isShowingHighlightOverlay})`, \'UiContext\');\n    },\n    setIsShowingTextHighlight: isShowingTextHighlight => {\n        logProviderWarning(`setIsShowingTextHighlight(${isShowingTextHighlight})`, \'UiContext\');\n    },\n});\n\n;// CONCATENATED MODULE: ./src/utils/errorMessage.ts\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction getErrorMessage(error) {\n    if (!error) {\n        return \'Unknown error\';\n    }\n    if (typeof error === \'string\') {\n        return error;\n    }\n    if (error instanceof Error) {\n        return error.message;\n    }\n    if (typeof error.error === \'string\') {\n        return error.error;\n    }\n    return error.toString();\n}\n\n;// CONCATENATED MODULE: ./src/utils/pdfWorker.ts\n\n// Set PDFjs worker source or else PDF will not load when this library is imported as a package.\nfunction initPdfWorker() {\n    build_pdf.GlobalWorkerOptions.workerSrc = `//cdnjs.cloudflare.com/ajax/libs/pdf.js/${build_pdf.version}/pdf.worker.min.js`;\n}\n\n;// CONCATENATED MODULE: ./src/utils/scale.ts\n// We assume 96 DPI for display\n// TODO: There are more accurate ways to do this, but this is what ScholarPhi does now\nconst DPI = 96;\n// PDF units are in 1/72nds of an inch\nconst USER_UNIT_DENOMINATOR = 72;\n/**\n * Given a PDFPageProxy, calculates the screen pixel size of the PDF page at 100% scale\n * @param page The PDFPageProxy to calculate size for\n * @returns Pixel size of a page at 100% scale assuming 96DPI display\n */\nfunction computePageDimensions(page) {\n    const [leftPx, topPx, rightPx, bottomPx] = page.view;\n    const PPI = (page.userUnit / USER_UNIT_DENOMINATOR) * DPI;\n    return {\n        height: (bottomPx - topPx) * PPI,\n        width: (rightPx - leftPx) * PPI,\n    };\n}\n\n;// CONCATENATED MODULE: ./src/components/DocumentWrapper.tsx\nvar __rest = (undefined && undefined.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === "function")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n\n\n\n\n\n\n\nconst DocumentWrapper = (_a) => {\n    var { children } = _a, rest = __rest(_a, ["children"]);\n    initPdfWorker();\n    const { pdfDocProxy, setNumPages, setPageDimensions, setPdfDocProxy } = external_commonjs_react_commonjs2_react_amd_react_root_React_.useContext(DocumentContext_DocumentContext);\n    const { setErrorMessage, setIsLoading } = external_commonjs_react_commonjs2_react_amd_react_root_React_.useContext(UiContext);\n    function getFirstPage(pdfDoc) {\n        // getPage uses 1-indexed pageNumber, not 0-indexed pageIndex\n        return pdfDoc.getPage(1);\n    }\n    const onPdfLoadSuccess = external_commonjs_react_commonjs2_react_amd_react_root_React_.useCallback((pdfDoc) => {\n        setNumPages(pdfDoc.numPages);\n        getFirstPage(pdfDoc)\n            .then(page => {\n            setPageDimensions(computePageDimensions(page));\n            setErrorMessage(null);\n        })\n            .catch(error => {\n            setErrorMessage(getErrorMessage(error));\n        })\n            .finally(() => {\n            setIsLoading(false);\n        });\n        if (!pdfDocProxy) {\n            setPdfDocProxy(pdfDoc);\n        }\n    }, []);\n    const onPdfLoadError = external_commonjs_react_commonjs2_react_amd_react_root_React_.useCallback((error) => {\n        setErrorMessage(getErrorMessage(error));\n        setIsLoading(false);\n    }, []);\n    return (external_commonjs_react_commonjs2_react_amd_react_root_React_.createElement(Document, Object.assign({ options: { cMapUrl: \'cmaps/\', cMapPacked: true }, onLoadError: onPdfLoadError, onLoadSuccess: onPdfLoadSuccess }, rest), children));\n};\n\n;// CONCATENATED MODULE: ./src/components/DownloadButton.tsx\n\n/**\n * HTML anchor tag allows you to download a file from the same origin.\n * This is a workaround to download a file served from a different origin\n */\nconst DownloadButton = ({ pdfUrl }) => {\n    const [fetching, setFetching] = external_commonjs_react_commonjs2_react_amd_react_root_React_.useState(false);\n    const download = () => {\n        setFetching(true);\n        fetch(pdfUrl)\n            .then(response => response.blob())\n            .then(blob => {\n            setFetching(false);\n            const blobURL = URL.createObjectURL(blob);\n            const a = document.createElement(\'a\');\n            a.href = blobURL;\n            a.download = pdfUrl.split(\'/\').pop() || pdfUrl;\n            document.body.appendChild(a);\n            a.click();\n        });\n    };\n    return (external_commonjs_react_commonjs2_react_amd_react_root_React_.createElement("button", { disabled: fetching, onClick: () => download(), "aria-label": "Download PDF" }, "Download"));\n};\n\n;// CONCATENATED MODULE: ./src/components/HighlightOverlay.tsx\n\n\n\n\nconst HighlightOverlay = ({ children, pageIndex, }) => {\n    const { pageDimensions } = external_commonjs_react_commonjs2_react_amd_react_root_React_.useContext(DocumentContext_DocumentContext);\n    const { rotation, scale } = external_commonjs_react_commonjs2_react_amd_react_root_React_.useContext(TransformContext);\n    const maskId = `highlight-overlay-mask-${pageIndex}`;\n    const getPageStyle = external_commonjs_react_commonjs2_react_amd_react_root_React_.useCallback(() => {\n        return computePageStyle(pageDimensions, rotation, scale);\n    }, [pageDimensions, rotation, scale]);\n    const getUnmaskedArea = external_commonjs_react_commonjs2_react_amd_react_root_React_.useCallback((boundingBoxes) => {\n        const boxes = Array.isArray(boundingBoxes) ? boundingBoxes : [boundingBoxes];\n        return boxes.map((box, i) => {\n            const boxStyle = computeBoundingBoxStyle(box.props, pageDimensions, rotation, scale);\n            return (external_commonjs_react_commonjs2_react_amd_react_root_React_.createElement("rect", { style: boxStyle, x: boxStyle.left, y: boxStyle.top, key: i, fill: "black" }));\n        });\n    }, [pageDimensions, rotation, scale]);\n    return (external_commonjs_react_commonjs2_react_amd_react_root_React_.createElement("div", { className: "reader__page-highlight-overlay", style: getPageStyle() },\n        external_commonjs_react_commonjs2_react_amd_react_root_React_.createElement("svg", { className: "page-mask", style: getPageStyle() },\n            external_commonjs_react_commonjs2_react_amd_react_root_React_.createElement("mask", { id: maskId },\n                external_commonjs_react_commonjs2_react_amd_react_root_React_.createElement("rect", { style: getPageStyle(), fill: "white" }),\n                children && getUnmaskedArea(children)),\n            external_commonjs_react_commonjs2_react_amd_react_root_React_.createElement("rect", { style: getPageStyle(), fill: "white", opacity: "0.6", mask: `url(#${maskId})` }))));\n};\n\n;// CONCATENATED MODULE: ./src/utils/scroll.ts\n\n// Each page div is ID\'d according to page index\n// e.g. reader_pg_0, reader_pg_1, etc.\nconst PAGE_NAV_TARGET_ID_ROOT = \'reader_pg_\';\nconst SCROLLABLE_TARGET_DIV_CLASSNAME = \'reader__page-list\';\nconst PDF_HEIGHT_POINTS = 792;\nconst PDF_WIDTH_POINTS = 612;\nfunction generatePageIdFromIndex(pageIndex) {\n    return `${PAGE_NAV_TARGET_ID_ROOT}${pageIndex}`;\n}\nfunction scrollToId(id) {\n    const element = document.getElementById(id);\n    if (element) {\n        element.scrollIntoView({ behavior: \'smooth\', block: \'start\', inline: \'center\' });\n    }\n    else {\n        console.error(`Could not find scroll target with ID #${id}`);\n    }\n}\nfunction scrollToPdfPageIndex(pageIndex) {\n    scrollToId(generatePageIdFromIndex(pageIndex));\n}\n/**\n * Scroll PDF document to a specific position.\n * @param pageIndex The index of the page where the position locates at\n * @param leftPoints The horizontal distance between the origin and the position (in PDF coordinates)\n * @param bottomPoints The vertical distance between the origin and the position (in PDF coordinates)\n */\nfunction scrollToPosition(pageIndex, leftPoints, bottomPoints, rotation = PageRotation.Rotate0) {\n    const targetDiv = document\n        .getElementsByClassName(SCROLLABLE_TARGET_DIV_CLASSNAME)\n        .item(0);\n    if (!targetDiv) {\n        console.error(`Cannot find scroll target with classname ${SCROLLABLE_TARGET_DIV_CLASSNAME}`);\n        return;\n    }\n    /*\n      Vertical scroll distance is calculated as\n      = total number of previous pages * page height including top/down margins\n      + the margin top of current page\n      + the distance from the page top to the specified position\n  \n      Notice that the scroll distance is measured in pixels,\n      so leftPoints/bottomPoints has to be transformed from points to pixels first.\n    */\n    const { width, height, marginTop, marginBottom, marginLeft, marginRight } = getPagePropertiesInPixels();\n    const heightWithMargins = height + marginTop + marginBottom;\n    // When a paper is rotated, its height and width would be switched automatically. However, leftPoints and bottomPoints remain the same.\n    let marginTopPixels = marginTop;\n    let bottomPixels = (height * bottomPoints) / PDF_HEIGHT_POINTS;\n    let leftPixels = (width * leftPoints) / PDF_WIDTH_POINTS;\n    if (rotation == PageRotation.Rotate90) {\n        marginTopPixels = marginLeft;\n        bottomPixels = (height * (PDF_WIDTH_POINTS - leftPoints)) / PDF_WIDTH_POINTS;\n        leftPixels = (width * bottomPoints) / PDF_HEIGHT_POINTS;\n    }\n    else if (rotation == PageRotation.Rotate180) {\n        marginTopPixels = marginBottom;\n        bottomPixels = (height * (PDF_HEIGHT_POINTS - bottomPoints)) / PDF_HEIGHT_POINTS;\n        leftPixels = (width * (PDF_WIDTH_POINTS - leftPoints)) / PDF_WIDTH_POINTS;\n    }\n    else if (rotation == PageRotation.Rotate270) {\n        marginTopPixels = marginRight;\n        bottomPixels = (height * leftPoints) / PDF_WIDTH_POINTS;\n        leftPixels = (width * (PDF_HEIGHT_POINTS - bottomPoints)) / PDF_HEIGHT_POINTS;\n    }\n    targetDiv.scrollTo({\n        top: Math.floor(heightWithMargins * pageIndex + marginTopPixels + (height - bottomPixels)),\n        left: Math.floor(leftPixels),\n        behavior: \'smooth\',\n    });\n}\n/**\n * Get lengths, widths, and margins of a page.\n * @returns a PageProperties object\n */\nfunction getPagePropertiesInPixels() {\n    const firstPage = document.getElementById(generatePageIdFromIndex(0));\n    if (!firstPage) {\n        console.error(`Cannot get the first page of this document.`);\n        const emptyPageProperties = {\n            width: 0,\n            height: 0,\n            marginTop: 0,\n            marginBottom: 0,\n            marginLeft: 0,\n            marginRight: 0,\n        };\n        return emptyPageProperties;\n    }\n    const style = getComputedStyle(firstPage);\n    const pageProperties = {\n        width: parseInt(style.width),\n        height: parseInt(style.height),\n        marginTop: parseInt(style.marginTop),\n        marginBottom: parseInt(style.marginBottom),\n        marginLeft: parseInt(style.marginLeft),\n        marginRight: parseInt(style.marginRight),\n    };\n    return pageProperties;\n}\n\n;// CONCATENATED MODULE: ./src/components/outline/OutlineItem.tsx\n\nconst OutlineItem_OutlineItem = ({ items, onClick }) => {\n    if (!items || !items.length) {\n        return null;\n    }\n    function renderItem(item) {\n        const clickHandler = (event) => {\n            event.preventDefault();\n            if (onClick) {\n                onClick(item.dest);\n            }\n        };\n        // If an item has sub titles, render <OutlineItem />\n        return (external_commonjs_react_commonjs2_react_amd_react_root_React_.createElement("li", { key: item.title },\n            external_commonjs_react_commonjs2_react_amd_react_root_React_.createElement("a", { href: "#", onClick: clickHandler }, item.title),\n            external_commonjs_react_commonjs2_react_amd_react_root_React_.createElement(OutlineItem_OutlineItem, { items: item.items, onClick: onClick })));\n    }\n    return external_commonjs_react_commonjs2_react_amd_react_root_React_.createElement("ul", null, items.map(item => renderItem(item)));\n};\n\n;// CONCATENATED MODULE: ./src/components/outline/Ref.ts\n/**\n * This class is the definition of the first item when Destination is returned as an array.\n * It is created based on the same class in \'react-pdf\' library:\n * https://github.com/wojtekmaj/react-pdf/blob/ca4453f123af51e2faed39a8a62800901030459a/src/Ref.js\n */\nclass Ref_Ref {\n    constructor({ num, gen }) {\n        this.num = num;\n        this.gen = gen;\n    }\n    toString() {\n        return this.gen !== 0 ? `${this.num}R${this.gen}` : `${this.num}R`;\n    }\n}\n\n;// CONCATENATED MODULE: ./src/components/outline/Outline.tsx\n\n\n\n\n\n\nconst Outline_Outline = () => {\n    const { pdfDocProxy } = external_commonjs_react_commonjs2_react_amd_react_root_React_.useContext(DocumentContext_DocumentContext);\n    const { rotation } = external_commonjs_react_commonjs2_react_amd_react_root_React_.useContext(TransformContext);\n    const [outline, setOutline] = external_commonjs_react_commonjs2_react_amd_react_root_React_.useState();\n    if (!pdfDocProxy) {\n        return null;\n    }\n    if (!outline) {\n        pdfDocProxy.getOutline().then((outlineArray) => {\n            setOutline(outlineArray);\n        });\n    }\n    const clickHandler = (dest) => {\n        if (!dest) {\n            return;\n        }\n        pdfDocProxy.getDestination(dest.toString()).then(destArray => {\n            /*\n              destArray returned by getDestination contains 5 items:\n              1. Reference to the page where dest locates at\n              2. Types of dest; currently only "XYZ" is handled\n              3. X -- the distance from the left edge of a page to dest, measured in points\n              4. Y -- the distance from the bottom edge of a page to dest, measured in points\n              5. Scale\n              \n              Reference: https://github.com/mozilla/pdf.js/blob/d3e1d7090ac6f582d0c277e8768ac63bbbaa1134/web/base_viewer.js#L1152\n            */\n            // The second and the fifth items are left out intentionally for not being used in scrolling function.\n            const [ref, , leftPoints, bottomPoints] = destArray;\n            pdfDocProxy.getPageIndex(new Ref_Ref(ref)).then(refInfo => {\n                scrollToPosition(parseInt(refInfo.toString()), leftPoints, bottomPoints, rotation);\n            });\n        });\n    };\n    return external_commonjs_react_commonjs2_react_amd_react_root_React_.createElement("div", null, !!outline && external_commonjs_react_commonjs2_react_amd_react_root_React_.createElement(OutlineItem_OutlineItem, { items: outline, onClick: clickHandler }));\n};\n\n;// CONCATENATED MODULE: ./src/components/Overlay.tsx\n\n\n\n\nconst Overlay = ({ children }) => {\n    const { pageDimensions } = external_commonjs_react_commonjs2_react_amd_react_root_React_.useContext(DocumentContext_DocumentContext);\n    const { rotation, scale } = external_commonjs_react_commonjs2_react_amd_react_root_React_.useContext(TransformContext);\n    const getOverlayStyle = external_commonjs_react_commonjs2_react_amd_react_root_React_.useCallback(() => {\n        return computePageStyle(pageDimensions, rotation, scale);\n    }, [pageDimensions, rotation, scale]);\n    return (external_commonjs_react_commonjs2_react_amd_react_root_React_.createElement("div", { className: "reader__page-overlay", style: getOverlayStyle() }, children));\n};\n\n;// CONCATENATED MODULE: ./src/components/PageWrapper.tsx\n\n\n\n\n\n\nconst PageWrapper = ({ children, error, loading, noData, pageIndex, }) => {\n    const { rotation, scale } = external_commonjs_react_commonjs2_react_amd_react_root_React_.useContext(TransformContext);\n    const { pageDimensions } = external_commonjs_react_commonjs2_react_amd_react_root_React_.useContext(DocumentContext_DocumentContext);\n    // Don\'t display until we have page size data\n    // TODO: Handle this nicer so we display either the loading or error treatment\n    if (!pageDimensions) {\n        return null;\n    }\n    const onClick = external_commonjs_react_commonjs2_react_amd_react_root_React_.useCallback((e) => {\n        console.log(e);\n    }, []);\n    const getWidth = external_commonjs_react_commonjs2_react_amd_react_root_React_.useCallback(() => {\n        return getPageWidth(pageDimensions, rotation);\n    }, [pageDimensions, rotation]);\n    const getPageStyle = external_commonjs_react_commonjs2_react_amd_react_root_React_.useCallback(() => {\n        return computePageStyle(pageDimensions, rotation, scale);\n    }, [pageDimensions, rotation, scale]);\n    // Width needs to be set to prevent the outermost Page div from extending to fit the parent,\n    // and mis-aligning the text layer.\n    // TODO: Can we CSS this to auto-shrink?\n    return (external_commonjs_react_commonjs2_react_amd_react_root_React_.createElement("div", { id: generatePageIdFromIndex(pageIndex), className: "reader__page", style: getPageStyle() },\n        children,\n        external_commonjs_react_commonjs2_react_amd_react_root_React_.createElement(esm_Page, { width: getWidth(), error: error, loading: loading, noData: noData, pageIndex: pageIndex, scale: scale, onClick: onClick, rotate: rotation, renderAnnotationLayer: false })));\n};\n\n;// CONCATENATED MODULE: ./src/components/ZoomInButton.tsx\n\n\nconst ZoomInButton = ({ children }) => {\n    const { scale, setScale, zoomMultiplier } = external_commonjs_react_commonjs2_react_amd_react_root_React_.useContext(TransformContext);\n    const handleZoomIn = external_commonjs_react_commonjs2_react_amd_react_root_React_.useCallback(() => {\n        setScale(scale * zoomMultiplier);\n    }, [scale, zoomMultiplier]);\n    return (external_commonjs_react_commonjs2_react_amd_react_root_React_.createElement("button", { className: "reader__zoom-btn zoom-in", onClick: handleZoomIn }, children ? children : \'+\'));\n};\n\n;// CONCATENATED MODULE: ./src/components/ZoomOutButton.tsx\n\n\nconst ZoomOutButton = ({ children }) => {\n    const { scale, setScale, zoomMultiplier } = external_commonjs_react_commonjs2_react_amd_react_root_React_.useContext(TransformContext);\n    const handleZoomOut = external_commonjs_react_commonjs2_react_amd_react_root_React_.useCallback(() => {\n        setScale(scale / zoomMultiplier);\n    }, [scale, zoomMultiplier]);\n    return (external_commonjs_react_commonjs2_react_amd_react_root_React_.createElement("button", { className: "reader__zoom-btn zoom-out", onClick: handleZoomOut }, children ? children : \'-\'));\n};\n\n;// CONCATENATED MODULE: ./src/context/ContextProvider.tsx\n\n\n\n\n\nfunction useDocumentContextProps() {\n    const [numPages, setNumPages] = external_commonjs_react_commonjs2_react_amd_react_root_React_.useState(0);\n    const [pageDimensions, setPageDimensions] = external_commonjs_react_commonjs2_react_amd_react_root_React_.useState({ height: 0, width: 0 });\n    const [pdfDocProxy, setPdfDocProxy] = external_commonjs_react_commonjs2_react_amd_react_root_React_.useState();\n    return {\n        numPages,\n        pageDimensions: pageDimensions,\n        pdfDocProxy,\n        setNumPages,\n        setPageDimensions: setPageDimensions,\n        setPdfDocProxy,\n    };\n}\nfunction useTransformContextProps() {\n    const [rotation, setRotation] = external_commonjs_react_commonjs2_react_amd_react_root_React_.useState(PageRotation.Rotate0);\n    const [scale, setScale] = external_commonjs_react_commonjs2_react_amd_react_root_React_.useState(1.0);\n    const [zoomMultiplier, setZoomMultiplier] = external_commonjs_react_commonjs2_react_amd_react_root_React_.useState(1.2);\n    return {\n        rotation,\n        scale,\n        setRotation,\n        setScale,\n        setZoomMultiplier,\n        zoomMultiplier,\n    };\n}\nfunction useUiContextProps() {\n    const [errorMessage, setErrorMessage] = external_commonjs_react_commonjs2_react_amd_react_root_React_.useState(null);\n    const [isLoading, setIsLoading] = external_commonjs_react_commonjs2_react_amd_react_root_React_.useState(true);\n    const [isShowingHighlightOverlay, setIsShowingHighlightOverlay] = external_commonjs_react_commonjs2_react_amd_react_root_React_.useState(false);\n    const [isShowingOutline, setIsShowingOutline] = external_commonjs_react_commonjs2_react_amd_react_root_React_.useState(false);\n    const [isShowingTextHighlight, setIsShowingTextHighlight] = external_commonjs_react_commonjs2_react_amd_react_root_React_.useState(false);\n    return {\n        errorMessage,\n        isLoading,\n        isShowingHighlightOverlay,\n        isShowingOutline,\n        isShowingTextHighlight,\n        setErrorMessage,\n        setIsLoading,\n        setIsShowingHighlightOverlay,\n        setIsShowingOutline,\n        setIsShowingTextHighlight,\n    };\n}\nconst ContextProvider = ({ children }) => {\n    const documentProps = useDocumentContextProps();\n    const transformProps = useTransformContextProps();\n    const uiProps = useUiContextProps();\n    return (external_commonjs_react_commonjs2_react_amd_react_root_React_.createElement(DocumentContext_DocumentContext.Provider, { value: documentProps },\n        external_commonjs_react_commonjs2_react_amd_react_root_React_.createElement(TransformContext.Provider, { value: transformProps },\n            external_commonjs_react_commonjs2_react_amd_react_root_React_.createElement(UiContext.Provider, { value: uiProps }, children))));\n};\n\n;// CONCATENATED MODULE: ./index.ts\n/*\n * PDF Component Library exports\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/* harmony default export */ const index = ({\n    BoundingBox: BoundingBox,\n    computeBoundingBoxStyle: computeBoundingBoxStyle,\n    computePageStyle: computePageStyle,\n    ContextProvider: ContextProvider,\n    DocumentContext: DocumentContext_DocumentContext,\n    DocumentWrapper: DocumentWrapper,\n    DownloadButton: DownloadButton,\n    generatePageIdFromIndex: generatePageIdFromIndex,\n    getPageHeight: getPageHeight,\n    getPageWidth: getPageWidth,\n    HighlightOverlay: HighlightOverlay,\n    isSideways: isSideways,\n    Outline: Outline_Outline,\n    OutlineItem: OutlineItem_OutlineItem,\n    Overlay: Overlay,\n    PageRotation: PageRotation,\n    PageWrapper: PageWrapper,\n    rotateClockwise: rotateClockwise,\n    rotateCounterClockwise: rotateCounterClockwise,\n    scrollToId: scrollToId,\n    scrollToPdfPageIndex: scrollToPdfPageIndex,\n    TransformContext: TransformContext,\n    UiContext: UiContext,\n    ZoomInButton: ZoomInButton,\n    ZoomOutButton: ZoomOutButton,\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9QZGZDb21wb25lbnRzLy4vc3JjL3V0aWxzL3Byb3ZpZGVyLnRzPzg1YWEiLCJ3ZWJwYWNrOi8vUGRmQ29tcG9uZW50cy8uL3NyYy9jb250ZXh0L0RvY3VtZW50Q29udGV4dC50cz8yZjAzIiwid2VicGFjazovL1BkZkNvbXBvbmVudHMvLi9zcmMvdXRpbHMvcm90YXRlLnRzP2NkYmIiLCJ3ZWJwYWNrOi8vUGRmQ29tcG9uZW50cy8uL3NyYy9jb250ZXh0L1RyYW5zZm9ybUNvbnRleHQudHM/YmU2NCIsIndlYnBhY2s6Ly9QZGZDb21wb25lbnRzLy4vc3JjL3V0aWxzL3N0eWxlLnRzP2UzMWIiLCJ3ZWJwYWNrOi8vUGRmQ29tcG9uZW50cy8uL3NyYy9jb21wb25lbnRzL0JvdW5kaW5nQm94LnRzeD81NmNmIiwid2VicGFjazovL1BkZkNvbXBvbmVudHMvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcy5qcz9jMzFkIiwid2VicGFjazovL1BkZkNvbXBvbmVudHMvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZS5qcz9jY2I1Iiwid2VicGFjazovL1BkZkNvbXBvbmVudHMvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXMuanM/MTVmZCIsIndlYnBhY2s6Ly9QZGZDb21wb25lbnRzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3R5cGVvZi5qcz81M2NhIiwid2VicGFjazovL1BkZkNvbXBvbmVudHMvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXN5bmNUb0dlbmVyYXRvci5qcz8xZGExIiwid2VicGFjazovL1BkZkNvbXBvbmVudHMvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2suanM/ZDRlYyIsIndlYnBhY2s6Ly9QZGZDb21wb25lbnRzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzLmpzP2JlZTIiLCJ3ZWJwYWNrOi8vUGRmQ29tcG9uZW50cy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanM/MjU3ZSIsIndlYnBhY2s6Ly9QZGZDb21wb25lbnRzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NldFByb3RvdHlwZU9mLmpzP2IzODAiLCJ3ZWJwYWNrOi8vUGRmQ29tcG9uZW50cy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pbmhlcml0cy5qcz8yNjJlIiwid2VicGFjazovL1BkZkNvbXBvbmVudHMvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcz85OWRlIiwid2VicGFjazovL1BkZkNvbXBvbmVudHMvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZ2V0UHJvdG90eXBlT2YuanM/N2U4NCIsIndlYnBhY2s6Ly9QZGZDb21wb25lbnRzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5LmpzP2FkZTMiLCJ3ZWJwYWNrOi8vUGRmQ29tcG9uZW50cy8uL25vZGVfbW9kdWxlcy9tYWtlLWV2ZW50LXByb3BzL2Rpc3QvZXNtL2luZGV4LmpzPzU0MDciLCJ3ZWJwYWNrOi8vUGRmQ29tcG9uZW50cy8uL25vZGVfbW9kdWxlcy9tYWtlLWNhbmNlbGxhYmxlLXByb21pc2UvZGlzdC9lc20vaW5kZXguanM/YWNmNCIsIndlYnBhY2s6Ly9QZGZDb21wb25lbnRzLy4vbm9kZV9tb2R1bGVzL21lcmdlLWNsYXNzLW5hbWVzL2Rpc3QvZXNtL2luZGV4LmpzP2EyMWMiLCJ3ZWJwYWNrOi8vUGRmQ29tcG9uZW50cy8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9lc20vRG9jdW1lbnRDb250ZXh0LmpzPzJlMjEiLCJ3ZWJwYWNrOi8vUGRmQ29tcG9uZW50cy8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9lc20vTWVzc2FnZS5qcz9jZjZmIiwid2VicGFjazovL1BkZkNvbXBvbmVudHMvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvZXNtL0xpbmtTZXJ2aWNlLmpzPzk3NzgiLCJ3ZWJwYWNrOi8vUGRmQ29tcG9uZW50cy8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9lc20vUGFzc3dvcmRSZXNwb25zZXMuanM/MTVmNSIsIndlYnBhY2s6Ly9QZGZDb21wb25lbnRzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FycmF5V2l0aEhvbGVzLmpzPzBkMjEiLCJ3ZWJwYWNrOi8vUGRmQ29tcG9uZW50cy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qcz8wOWYwIiwid2VicGFjazovL1BkZkNvbXBvbmVudHMvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXJyYXlMaWtlVG9BcnJheS5qcz82Yjc1Iiwid2VicGFjazovL1BkZkNvbXBvbmVudHMvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkuanM/MDZjNSIsIndlYnBhY2s6Ly9QZGZDb21wb25lbnRzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL25vbkl0ZXJhYmxlUmVzdC5qcz8zZDhjIiwid2VicGFjazovL1BkZkNvbXBvbmVudHMvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheS5qcz8zODM1Iiwid2VicGFjazovL1BkZkNvbXBvbmVudHMvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvZXNtL3NoYXJlZC91dGlscy5qcz8zN2NiIiwid2VicGFjazovL1BkZkNvbXBvbmVudHMvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXJyYXlXaXRob3V0SG9sZXMuanM/NjAwNSIsIndlYnBhY2s6Ly9QZGZDb21wb25lbnRzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2l0ZXJhYmxlVG9BcnJheS5qcz9kYjkwIiwid2VicGFjazovL1BkZkNvbXBvbmVudHMvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vbm9uSXRlcmFibGVTcHJlYWQuanM/MzQyNyIsIndlYnBhY2s6Ly9QZGZDb21wb25lbnRzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3RvQ29uc3VtYWJsZUFycmF5LmpzPzI5MDkiLCJ3ZWJwYWNrOi8vUGRmQ29tcG9uZW50cy8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9lc20vc2hhcmVkL3Byb3BUeXBlcy5qcz84YjA1Iiwid2VicGFjazovL1BkZkNvbXBvbmVudHMvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvZXNtL0RvY3VtZW50LmpzPzgyYmQiLCJ3ZWJwYWNrOi8vUGRmQ29tcG9uZW50cy8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9lc20vT3V0bGluZUNvbnRleHQuanM/Y2RhNiIsIndlYnBhY2s6Ly9QZGZDb21wb25lbnRzLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXBkZi9kaXN0L2VzbS9SZWYuanM/MzYwYiIsIndlYnBhY2s6Ly9QZGZDb21wb25lbnRzLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXBkZi9kaXN0L2VzbS9PdXRsaW5lSXRlbS5qcz81Njg3Iiwid2VicGFjazovL1BkZkNvbXBvbmVudHMvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvZXNtL091dGxpbmUuanM/Y2QzNSIsIndlYnBhY2s6Ly9QZGZDb21wb25lbnRzLy4vbm9kZV9tb2R1bGVzL21lcmdlLXJlZnMvZGlzdC9lc20vaW5kZXguanM/YWMwOSIsIndlYnBhY2s6Ly9QZGZDb21wb25lbnRzLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXBkZi9kaXN0L2VzbS9QYWdlQ29udGV4dC5qcz84ODdlIiwid2VicGFjazovL1BkZkNvbXBvbmVudHMvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvZXNtL1BhZ2UvUGFnZUNhbnZhcy5qcz9jZTJlIiwid2VicGFjazovL1BkZkNvbXBvbmVudHMvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvZXNtL1BhZ2UvUGFnZVNWRy5qcz80MGVkIiwid2VicGFjazovL1BkZkNvbXBvbmVudHMvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvZXNtL1BhZ2UvVGV4dExheWVySXRlbS5qcz9lODlmIiwid2VicGFjazovL1BkZkNvbXBvbmVudHMvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvZXNtL1BhZ2UvVGV4dExheWVyLmpzPzgzMDIiLCJ3ZWJwYWNrOi8vUGRmQ29tcG9uZW50cy8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9lc20vUGFnZS9Bbm5vdGF0aW9uTGF5ZXIuanM/MmNlYyIsIndlYnBhY2s6Ly9QZGZDb21wb25lbnRzLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXBkZi9kaXN0L2VzbS9QYWdlLmpzPzg1YWIiLCJ3ZWJwYWNrOi8vUGRmQ29tcG9uZW50cy8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9lc20vZW50cnkuanM/ZjU2NCIsIndlYnBhY2s6Ly9QZGZDb21wb25lbnRzLy4vc3JjL2NvbnRleHQvVWlDb250ZXh0LnRzPzZiYjMiLCJ3ZWJwYWNrOi8vUGRmQ29tcG9uZW50cy8uL3NyYy91dGlscy9lcnJvck1lc3NhZ2UudHM/MzBhNSIsIndlYnBhY2s6Ly9QZGZDb21wb25lbnRzLy4vc3JjL3V0aWxzL3BkZldvcmtlci50cz9hNWRlIiwid2VicGFjazovL1BkZkNvbXBvbmVudHMvLi9zcmMvdXRpbHMvc2NhbGUudHM/YTAwNSIsIndlYnBhY2s6Ly9QZGZDb21wb25lbnRzLy4vc3JjL2NvbXBvbmVudHMvRG9jdW1lbnRXcmFwcGVyLnRzeD81MjA0Iiwid2VicGFjazovL1BkZkNvbXBvbmVudHMvLi9zcmMvY29tcG9uZW50cy9Eb3dubG9hZEJ1dHRvbi50c3g/ZTIzNSIsIndlYnBhY2s6Ly9QZGZDb21wb25lbnRzLy4vc3JjL2NvbXBvbmVudHMvSGlnaGxpZ2h0T3ZlcmxheS50c3g/MjIxYSIsIndlYnBhY2s6Ly9QZGZDb21wb25lbnRzLy4vc3JjL3V0aWxzL3Njcm9sbC50cz83YjA1Iiwid2VicGFjazovL1BkZkNvbXBvbmVudHMvLi9zcmMvY29tcG9uZW50cy9vdXRsaW5lL091dGxpbmVJdGVtLnRzeD82YTczIiwid2VicGFjazovL1BkZkNvbXBvbmVudHMvLi9zcmMvY29tcG9uZW50cy9vdXRsaW5lL1JlZi50cz9hNzdiIiwid2VicGFjazovL1BkZkNvbXBvbmVudHMvLi9zcmMvY29tcG9uZW50cy9vdXRsaW5lL091dGxpbmUudHN4PzMzY2EiLCJ3ZWJwYWNrOi8vUGRmQ29tcG9uZW50cy8uL3NyYy9jb21wb25lbnRzL092ZXJsYXkudHN4P2U5ZjMiLCJ3ZWJwYWNrOi8vUGRmQ29tcG9uZW50cy8uL3NyYy9jb21wb25lbnRzL1BhZ2VXcmFwcGVyLnRzeD9jOWM1Iiwid2VicGFjazovL1BkZkNvbXBvbmVudHMvLi9zcmMvY29tcG9uZW50cy9ab29tSW5CdXR0b24udHN4Pzg2YjkiLCJ3ZWJwYWNrOi8vUGRmQ29tcG9uZW50cy8uL3NyYy9jb21wb25lbnRzL1pvb21PdXRCdXR0b24udHN4PzZiZjMiLCJ3ZWJwYWNrOi8vUGRmQ29tcG9uZW50cy8uL3NyYy9jb250ZXh0L0NvbnRleHRQcm92aWRlci50c3g/YmM4YiIsIndlYnBhY2s6Ly9QZGZDb21w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QUFFMkQ7QUFDWTtBQUNIO0FBSXBEO0FBQ2dCO0FBQ1E7QUFDTztBQUN1QjtBQVVwQztBQUNFO0FBQ2dDO0FBQ2I7QUFDRztBQUNyQjtBQU1wQztBQUNtRTtBQU1wRTtBQW1EekI7QUFFRiw0Q0FBZTtJQUNiLFdBQVc7SUFDWCx1QkFBdUI7SUFDdkIsZ0JBQWdCO0lBQ2hCLGVBQWU7SUFDZixlQUFlO0lBQ2YsZUFBZTtJQUNmLGNBQWM7SUFDZCx1QkFBdUI7SUFDdkIsYUFBYTtJQUNiLFlBQVk7SUFDWixnQkFBZ0I7SUFDaEIsVUFBVTtJQUNWLE9BQU87SUFDUCxXQUFXO0lBQ1gsT0FBTztJQUNQLFlBQVk7SUFDWixXQUFXO0lBQ1gsZUFBZTtJQUNmLHNCQUFzQjtJQUN0QixVQUFVO0lBQ1Ysb0JBQW9CO0lBQ3BCLGdCQUFnQjtJQUNoQixTQUFTO0lBQ1QsWUFBWTtJQUNaLGFBQWE7Q0FDZCxFQUFDIiwiZmlsZSI6IjE0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGxvZ1Byb3ZpZGVyV2FybmluZyhmdW5jdGlvbk5hbWU6IHN0cmluZywgcHJvdmlkZXJOYW1lOiBzdHJpbmcpOiB2b2lkIHtcbiAgY29uc29sZS53YXJuKFxuICAgIGBVbmFibGUgdG8gY2FsbCAke2Z1bmN0aW9uTmFtZX0uIFRoZSAke3Byb3ZpZGVyTmFtZX0gUHJvdmlkZXIgbWF5IG5vdCBiZSBzZXQgdXAgY29ycmVjdGx5LmBcbiAgKTtcbn1cbiIsImltcG9ydCB7IFBERkRvY3VtZW50UHJveHkgfSBmcm9tICdwZGZqcy1kaXN0L3R5cGVzL2Rpc3BsYXkvYXBpJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgRGltZW5zaW9ucyB9IGZyb20gJy4uL2NvbXBvbmVudHMvdHlwZXMvdHlwZXMnO1xuaW1wb3J0IHsgbG9nUHJvdmlkZXJXYXJuaW5nIH0gZnJvbSAnLi4vdXRpbHMvcHJvdmlkZXInO1xuXG5leHBvcnQgaW50ZXJmYWNlIElEb2N1bWVudENvbnRleHQge1xuICBudW1QYWdlczogbnVtYmVyO1xuICBwYWdlRGltZW5zaW9uczogRGltZW5zaW9uczsgLy8gU2NhbGVkIGF0IDEwMCVcbiAgcGRmRG9jUHJveHk/OiBQREZEb2N1bWVudFByb3h5O1xuICBzZXROdW1QYWdlczogKG51bVBhZ2VzOiBudW1iZXIpID0+IHZvaWQ7XG4gIHNldFBhZ2VEaW1lbnNpb25zOiAocGFnZURpbWVuc2lvbnM6IERpbWVuc2lvbnMpID0+IHZvaWQ7XG4gIHNldFBkZkRvY1Byb3h5OiAocGRmRG9jUHJveHk6IFBERkRvY3VtZW50UHJveHkpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBjb25zdCBEb2N1bWVudENvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0PElEb2N1bWVudENvbnRleHQ+KHtcbiAgbnVtUGFnZXM6IDAsXG4gIHBhZ2VEaW1lbnNpb25zOiB7IGhlaWdodDogMCwgd2lkdGg6IDAgfSxcbiAgcGRmRG9jUHJveHk6IHVuZGVmaW5lZCxcbiAgc2V0TnVtUGFnZXM6IG51bVBhZ2VzID0+IHtcbiAgICBsb2dQcm92aWRlcldhcm5pbmcoYHNldE51bVBhZ2VzKCR7bnVtUGFnZXN9KWAsICdEb2N1bWVudENvbnRleHQnKTtcbiAgfSxcbiAgc2V0UGFnZURpbWVuc2lvbnM6IHBhZ2VEaW1lbnNpb25zID0+IHtcbiAgICBsb2dQcm92aWRlcldhcm5pbmcoYHNldFBhZ2VEaW1lbnNpb25zKCR7cGFnZURpbWVuc2lvbnN9KWAsICdEb2N1bWVudENvbnRleHQnKTtcbiAgfSxcbiAgc2V0UGRmRG9jUHJveHk6IHBkZkRvY1Byb3h5ID0+IHtcbiAgICBsb2dQcm92aWRlcldhcm5pbmcoYHNldFBkZkRvY1Byb3h5KCR7cGRmRG9jUHJveHl9KWAsICdEb2N1bWVudENvbnRleHQnKTtcbiAgfSxcbn0pO1xuIiwiZXhwb3J0IGVudW0gUGFnZVJvdGF0aW9uIHtcbiAgUm90YXRlMCA9IDAsXG4gIFJvdGF0ZTkwID0gOTAsXG4gIFJvdGF0ZTE4MCA9IDE4MCxcbiAgUm90YXRlMjcwID0gMjcwLFxufVxuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlQ2xvY2t3aXNlKHJvdGF0aW9uOiBQYWdlUm90YXRpb24pOiBQYWdlUm90YXRpb24ge1xuICBzd2l0Y2ggKHJvdGF0aW9uKSB7XG4gICAgY2FzZSBQYWdlUm90YXRpb24uUm90YXRlMDpcbiAgICAgIHJldHVybiBQYWdlUm90YXRpb24uUm90YXRlOTA7XG4gICAgY2FzZSBQYWdlUm90YXRpb24uUm90YXRlOTA6XG4gICAgICByZXR1cm4gUGFnZVJvdGF0aW9uLlJvdGF0ZTE4MDtcbiAgICBjYXNlIFBhZ2VSb3RhdGlvbi5Sb3RhdGUxODA6XG4gICAgICByZXR1cm4gUGFnZVJvdGF0aW9uLlJvdGF0ZTI3MDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFBhZ2VSb3RhdGlvbi5Sb3RhdGUwO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVDb3VudGVyQ2xvY2t3aXNlKHJvdGF0aW9uOiBQYWdlUm90YXRpb24pOiBQYWdlUm90YXRpb24ge1xuICBzd2l0Y2ggKHJvdGF0aW9uKSB7XG4gICAgY2FzZSBQYWdlUm90YXRpb24uUm90YXRlMDpcbiAgICAgIHJldHVybiBQYWdlUm90YXRpb24uUm90YXRlMjcwO1xuICAgIGNhc2UgUGFnZVJvdGF0aW9uLlJvdGF0ZTkwOlxuICAgICAgcmV0dXJuIFBhZ2VSb3RhdGlvbi5Sb3RhdGUwO1xuICAgIGNhc2UgUGFnZVJvdGF0aW9uLlJvdGF0ZTE4MDpcbiAgICAgIHJldHVybiBQYWdlUm90YXRpb24uUm90YXRlOTA7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBQYWdlUm90YXRpb24uUm90YXRlMTgwO1xuICB9XG59XG5cbi8qKlxuICogVGVzdHMgd2hldGhlciB0aGUgcGFnZSBpcyByb3RhdGVkIDkwIGRlZ3JlZXMgY2xvY2t3aXNlIG9yIGNvdW50ZXJjbG9ja3dpc2UgZnJvbSB6ZXJvLFxuICogZS5nLiB3aGV0aGVyIHRoZSBwYWdlIFwiaXMgcm90YXRlZCBzaWRld2F5cy5cIlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTaWRld2F5cyhyb3RhdGlvbjogUGFnZVJvdGF0aW9uKTogYm9vbGVhbiB7XG4gIHJldHVybiByb3RhdGlvbiA9PT0gUGFnZVJvdGF0aW9uLlJvdGF0ZTkwIHx8IHJvdGF0aW9uID09PSBQYWdlUm90YXRpb24uUm90YXRlMjcwO1xufVxuIiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBsb2dQcm92aWRlcldhcm5pbmcgfSBmcm9tICcuLi91dGlscy9wcm92aWRlcic7XG5pbXBvcnQgeyBQYWdlUm90YXRpb24gfSBmcm9tICcuLi91dGlscy9yb3RhdGUnO1xuXG5leHBvcnQgaW50ZXJmYWNlIElUcmFuc2Zvcm1Db250ZXh0IHtcbiAgcm90YXRpb246IFBhZ2VSb3RhdGlvbjtcbiAgc2NhbGU6IG51bWJlcjtcbiAgem9vbU11bHRpcGxpZXI6IG51bWJlcjtcbiAgc2V0Um90YXRpb246IChyb3RhdGlvbjogUGFnZVJvdGF0aW9uKSA9PiB2b2lkO1xuICBzZXRTY2FsZTogKHNjYWxlOiBudW1iZXIpID0+IHZvaWQ7XG4gIHNldFpvb21NdWx0aXBsaWVyOiAoem9vbTogbnVtYmVyKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgY29uc3QgVHJhbnNmb3JtQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8SVRyYW5zZm9ybUNvbnRleHQ+KHtcbiAgcm90YXRpb246IFBhZ2VSb3RhdGlvbi5Sb3RhdGUwLFxuICBzY2FsZTogMSxcbiAgem9vbU11bHRpcGxpZXI6IDEuMixcbiAgc2V0Um90YXRpb246IHJvdGF0aW9uID0+IHtcbiAgICBsb2dQcm92aWRlcldhcm5pbmcoYHNldFJvdGF0aW9uKCR7cm90YXRpb259KWAsICdUcmFuc2Zvcm1Db250ZXh0Jyk7XG4gIH0sXG4gIHNldFNjYWxlOiBzY2FsZSA9PiB7XG4gICAgbG9nUHJvdmlkZXJXYXJuaW5nKGBzZXRTY2FsZSgke3NjYWxlfSlgLCAnVHJhbnNmb3JtQ29udGV4dCcpO1xuICB9LFxuICBzZXRab29tTXVsdGlwbGllcjogem9vbSA9PiB7XG4gICAgbG9nUHJvdmlkZXJXYXJuaW5nKGBzZXRab29tTXVsdGlwbGllcigke3pvb219KWAsICdUcmFuc2Zvcm1Db250ZXh0Jyk7XG4gIH0sXG59KTtcbiIsImltcG9ydCB7IERpbWVuc2lvbnMsIFNpemUgfSBmcm9tICcuLi9jb21wb25lbnRzL3R5cGVzL3R5cGVzJztcbmltcG9ydCB7IGlzU2lkZXdheXMsIFBhZ2VSb3RhdGlvbiB9IGZyb20gJy4vcm90YXRlJztcblxuLy8gQ29tcHV0ZXMgdGhlIHN0eWxlIGZvciBhIGJvdW5kaW5nIGJveCwgYWNjb3VudGluZyBmb3IgcGFnZSByb2F0aW9uIGFuZCBwYWdlIHNjYWxpbmcvem9vbVxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVCb3VuZGluZ0JveFN0eWxlKFxuICBib3VuZGluZ0JveFNpemU6IFNpemUsXG4gIHBhZ2VEaW1lbnNpb25zOiBEaW1lbnNpb25zLFxuICByb3RhdGlvbjogUGFnZVJvdGF0aW9uLFxuICBzY2FsZTogbnVtYmVyXG4pOiBTaXplIHtcbiAgY29uc3QgeyB0b3AsIGxlZnQsIGhlaWdodCwgd2lkdGggfSA9IGJvdW5kaW5nQm94U2l6ZTtcblxuICBzd2l0Y2ggKHJvdGF0aW9uKSB7XG4gICAgY2FzZSBQYWdlUm90YXRpb24uUm90YXRlOTA6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IGxlZnQgKiBzY2FsZSxcbiAgICAgICAgbGVmdDogKHBhZ2VEaW1lbnNpb25zLmhlaWdodCAtIGhlaWdodCAtIHRvcCkgKiBzY2FsZSxcbiAgICAgICAgaGVpZ2h0OiB3aWR0aCAqIHNjYWxlLFxuICAgICAgICB3aWR0aDogaGVpZ2h0ICogc2NhbGUsXG4gICAgICB9O1xuICAgIGNhc2UgUGFnZVJvdGF0aW9uLlJvdGF0ZTE4MDpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogKHBhZ2VEaW1lbnNpb25zLmhlaWdodCAtIGhlaWdodCAtIHRvcCkgKiBzY2FsZSxcbiAgICAgICAgbGVmdDogKHBhZ2VEaW1lbnNpb25zLndpZHRoIC0gd2lkdGggLSBsZWZ0KSAqIHNjYWxlLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCAqIHNjYWxlLFxuICAgICAgICB3aWR0aDogd2lkdGggKiBzY2FsZSxcbiAgICAgIH07XG4gICAgY2FzZSBQYWdlUm90YXRpb24uUm90YXRlMjcwOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiAocGFnZURpbWVuc2lvbnMud2lkdGggLSB3aWR0aCAtIGxlZnQpICogc2NhbGUsXG4gICAgICAgIGxlZnQ6IHRvcCAqIHNjYWxlLFxuICAgICAgICBoZWlnaHQ6IHdpZHRoICogc2NhbGUsXG4gICAgICAgIHdpZHRoOiBoZWlnaHQgKiBzY2FsZSxcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogdG9wICogc2NhbGUsXG4gICAgICAgIGxlZnQ6IGxlZnQgKiBzY2FsZSxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQgKiBzY2FsZSxcbiAgICAgICAgd2lkdGg6IHdpZHRoICogc2NhbGUsXG4gICAgICB9O1xuICB9XG59XG5cbi8vIENvbXB1dGUgdGhlIHN0eWxlIGZvciBhIHBhZ2UsIGFjY291bnRpbmcgZm9yIHBhZ2Ugcm90YXRpb24gYW5kIHBhZ2Ugc2NhbGluZy96b29tXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZVBhZ2VTdHlsZShcbiAgcGFnZURpbWVuc2lvbnM6IERpbWVuc2lvbnMsXG4gIHJvdGF0aW9uOiBQYWdlUm90YXRpb24sXG4gIHNjYWxlOiBudW1iZXJcbik6IFNpemUge1xuICByZXR1cm4ge1xuICAgIGhlaWdodDogZ2V0UGFnZUhlaWdodChwYWdlRGltZW5zaW9ucywgcm90YXRpb24pICogc2NhbGUsXG4gICAgd2lkdGg6IGdldFBhZ2VXaWR0aChwYWdlRGltZW5zaW9ucywgcm90YXRpb24pICogc2NhbGUsXG4gICAgbGVmdDogMCxcbiAgICB0b3A6IDAsXG4gIH07XG59XG5cbi8vIEdldCBwYWdlIGhlaWdodCBhY2NvdW50aW5nIGZvciBwYWdlIHJvdGF0aW9uLSBpZiB0aGUgcGFnZSBpcyByb3RhdGVkIG9uIGl0cyBzaWRlLCBpdHMgd2lkdGggYmVjb21lcyBpdHMgaGVpZ2h0XG5leHBvcnQgZnVuY3Rpb24gZ2V0UGFnZUhlaWdodChwYWdlRGltZW5zaW9uczogRGltZW5zaW9ucywgcm90YXRpb246IFBhZ2VSb3RhdGlvbik6IG51bWJlciB7XG4gIHJldHVybiBpc1NpZGV3YXlzKHJvdGF0aW9uKSA/IHBhZ2VEaW1lbnNpb25zLndpZHRoIDogcGFnZURpbWVuc2lvbnMuaGVpZ2h0O1xufVxuXG4vLyBHZXQgcGFnZSB3aWR0aCBhY2NvdW50aW5nIGZvciBwYWdlIHJvdGF0aW9uLSBpZiB0aGUgcGFnZSBpcyByb3RhdGVkIG9uIGl0cyBzaWRlLCBpdHMgaGVpZ2h0IGJlY29tZXMgaXRzIHdpZHRoXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGFnZVdpZHRoKHBhZ2VEaW1lbnNpb25zOiBEaW1lbnNpb25zLCByb3RhdGlvbjogUGFnZVJvdGF0aW9uKTogbnVtYmVyIHtcbiAgcmV0dXJuIGlzU2lkZXdheXMocm90YXRpb24pID8gcGFnZURpbWVuc2lvbnMuaGVpZ2h0IDogcGFnZURpbWVuc2lvbnMud2lkdGg7XG59XG4iLCJpbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgRG9jdW1lbnRDb250ZXh0IH0gZnJvbSAnLi4vY29udGV4dC9Eb2N1bWVudENvbnRleHQnO1xuaW1wb3J0IHsgVHJhbnNmb3JtQ29udGV4dCB9IGZyb20gJy4uL2NvbnRleHQvVHJhbnNmb3JtQ29udGV4dCc7XG5pbXBvcnQgeyBjb21wdXRlQm91bmRpbmdCb3hTdHlsZSB9IGZyb20gJy4uL3V0aWxzL3N0eWxlJztcbmltcG9ydCB7IEJvdW5kaW5nQm94IGFzIEJvdW5kaW5nQm94VHlwZSB9IGZyb20gJy4vdHlwZXMvdHlwZXMnO1xuXG5leHBvcnQgdHlwZSBQcm9wcyA9IHtcbiAgY2xhc3NOYW1lPzogc3RyaW5nO1xuICBpZD86IHN0cmluZztcbiAgaXNIaWdobGlnaHRlZD86IGJvb2xlYW47XG4gIG9uQ2xpY2s/OiAoKSA9PiB2b2lkO1xufSAmIEJvdW5kaW5nQm94VHlwZTtcblxuZXhwb3J0IGNvbnN0IEJvdW5kaW5nQm94OiBSZWFjdC5GdW5jdGlvbkNvbXBvbmVudDxQcm9wcz4gPSAoe1xuICB0b3AsXG4gIGxlZnQsXG4gIGhlaWdodCxcbiAgd2lkdGgsXG4gIGNsYXNzTmFtZSxcbiAgaWQsXG4gIGlzSGlnaGxpZ2h0ZWQsXG4gIG9uQ2xpY2ssXG59OiBQcm9wcykgPT4ge1xuICBjb25zdCB7IHBhZ2VEaW1lbnNpb25zIH0gPSBSZWFjdC51c2VDb250ZXh0KERvY3VtZW50Q29udGV4dCk7XG4gIGNvbnN0IHsgcm90YXRpb24sIHNjYWxlIH0gPSBSZWFjdC51c2VDb250ZXh0KFRyYW5zZm9ybUNvbnRleHQpO1xuICBjb25zdCBib3hTaXplID0geyB0b3AsIGxlZnQsIGhlaWdodCwgd2lkdGggfTtcbiAgY29uc3QgY29tcG9uZW50Q2xhc3NOYW1lID0gY2xhc3NOYW1lcyhcbiAgICAncmVhZGVyX19wYWdlLW92ZXJsYXlfX2JvdW5kaW5nLWJveCcsXG4gICAgaXNIaWdobGlnaHRlZCA9PT0gdHJ1ZSA/ICdyZWFkZXJfX3BhZ2Utb3ZlcmxheV9fYm91bmRpbmctYm94LWhpZ2hsaWdodGVkJyA6ICcnLFxuICAgIGNsYXNzTmFtZVxuICApO1xuXG4gIGNvbnN0IGdldEJvdW5kaW5nQm94U3R5bGUgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgcmV0dXJuIGNvbXB1dGVCb3VuZGluZ0JveFN0eWxlKGJveFNpemUsIHBhZ2VEaW1lbnNpb25zLCByb3RhdGlvbiwgc2NhbGUpO1xuICB9LCBbcGFnZURpbWVuc2lvbnMsIHJvdGF0aW9uLCBzY2FsZV0pO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBpZD17aWR9IGNsYXNzTmFtZT17Y29tcG9uZW50Q2xhc3NOYW1lfSBzdHlsZT17Z2V0Qm91bmRpbmdCb3hTdHlsZSgpfSBvbkNsaWNrPXtvbkNsaWNrfSAvPlxuICApO1xufTtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59IiwiaW1wb3J0IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UgZnJvbSBcIi4vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZS5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSBvYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xuICB2YXIga2V5LCBpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTtcbiAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn0iLCJmdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gIHRyeSB7XG4gICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVqZWN0KGVycm9yKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaW5mby5kb25lKSB7XG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cbiAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTtcbiAgICAgIH1cblxuICAgICAgX25leHQodW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgfTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufSIsImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufSIsImltcG9ydCBzZXRQcm90b3R5cGVPZiBmcm9tIFwiLi9zZXRQcm90b3R5cGVPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufSIsImltcG9ydCBfdHlwZW9mIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiO1xuaW1wb3J0IGFzc2VydFRoaXNJbml0aWFsaXplZCBmcm9tIFwiLi9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7XG4gIH1cblxuICByZXR1cm4gYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn0iLCIvLyBBcyBkZWZpbmVkIG9uIHRoZSBsaXN0IG9mIHN1cHBvcnRlZCBldmVudHM6IGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9ldmVudHMuaHRtbFxuZXhwb3J0IHZhciBjbGlwYm9hcmRFdmVudHMgPSBbJ29uQ29weScsICdvbkN1dCcsICdvblBhc3RlJ107XG5leHBvcnQgdmFyIGNvbXBvc2l0aW9uRXZlbnRzID0gWydvbkNvbXBvc2l0aW9uRW5kJywgJ29uQ29tcG9zaXRpb25TdGFydCcsICdvbkNvbXBvc2l0aW9uVXBkYXRlJ107XG5leHBvcnQgdmFyIGtleWJvYXJkRXZlbnRzID0gWydvbktleURvd24nLCAnb25LZXlQcmVzcycsICdvbktleVVwJ107XG5leHBvcnQgdmFyIGZvY3VzRXZlbnRzID0gWydvbkZvY3VzJywgJ29uQmx1ciddO1xuZXhwb3J0IHZhciBmb3JtRXZlbnRzID0gWydvbkNoYW5nZScsICdvbklucHV0JywgJ29uSW52YWxpZCcsICdvblJlc2V0JywgJ29uU3VibWl0J107XG5leHBvcnQgdmFyIGdlbmVyaWNFdmVudHMgPSBbJ29uRXJyb3InLCAnb25Mb2FkJ107XG5leHBvcnQgdmFyIG1vdXNlRXZlbnRzID0gWydvbkNsaWNrJywgJ29uQ29udGV4dE1lbnUnLCAnb25Eb3VibGVDbGljaycsICdvbkRyYWcnLCAnb25EcmFnRW5kJywgJ29uRHJhZ0VudGVyJywgJ29uRHJhZ0V4aXQnLCAnb25EcmFnTGVhdmUnLCAnb25EcmFnT3ZlcicsICdvbkRyYWdTdGFydCcsICdvbkRyb3AnLCAnb25Nb3VzZURvd24nLCAnb25Nb3VzZUVudGVyJywgJ29uTW91c2VMZWF2ZScsICdvbk1vdXNlTW92ZScsICdvbk1vdXNlT3V0JywgJ29uTW91c2VPdmVyJywgJ29uTW91c2VVcCddO1xuZXhwb3J0IHZhciBwb2ludGVyRXZlbnRzID0gWydvblBvaW50ZXJEb3duJywgJ29uUG9pbnRlck1vdmUnLCAnb25Qb2ludGVyVXAnLCAnb25Qb2ludGVyQ2FuY2VsJywgJ29uR290UG9pbnRlckNhcHR1cmUnLCAnb25Mb3N0UG9pbnRlckNhcHR1cmUnLCAnb25Qb2ludGVyRW50ZXInLCAnb25Qb2ludGVyTGVhdmUnLCAnb25Qb2ludGVyT3ZlcicsICdvblBvaW50ZXJPdXQnXTtcbmV4cG9ydCB2YXIgc2VsZWN0aW9uRXZlbnRzID0gWydvblNlbGVjdCddO1xuZXhwb3J0IHZhciB0b3VjaEV2ZW50cyA9IFsnb25Ub3VjaENhbmNlbCcsICdvblRvdWNoRW5kJywgJ29uVG91Y2hNb3ZlJywgJ29uVG91Y2hTdGFydCddO1xuZXhwb3J0IHZhciB1aUV2ZW50cyA9IFsnb25TY3JvbGwnXTtcbmV4cG9ydCB2YXIgd2hlZWxFdmVudHMgPSBbJ29uV2hlZWwnXTtcbmV4cG9ydCB2YXIgbWVkaWFFdmVudHMgPSBbJ29uQWJvcnQnLCAnb25DYW5QbGF5JywgJ29uQ2FuUGxheVRocm91Z2gnLCAnb25EdXJhdGlvbkNoYW5nZScsICdvbkVtcHRpZWQnLCAnb25FbmNyeXB0ZWQnLCAnb25FbmRlZCcsICdvbkVycm9yJywgJ29uTG9hZGVkRGF0YScsICdvbkxvYWRlZE1ldGFkYXRhJywgJ29uTG9hZFN0YXJ0JywgJ29uUGF1c2UnLCAnb25QbGF5JywgJ29uUGxheWluZycsICdvblByb2dyZXNzJywgJ29uUmF0ZUNoYW5nZScsICdvblNlZWtlZCcsICdvblNlZWtpbmcnLCAnb25TdGFsbGVkJywgJ29uU3VzcGVuZCcsICdvblRpbWVVcGRhdGUnLCAnb25Wb2x1bWVDaGFuZ2UnLCAnb25XYWl0aW5nJ107XG5leHBvcnQgdmFyIGltYWdlRXZlbnRzID0gWydvbkxvYWQnLCAnb25FcnJvciddO1xuZXhwb3J0IHZhciBhbmltYXRpb25FdmVudHMgPSBbJ29uQW5pbWF0aW9uU3RhcnQnLCAnb25BbmltYXRpb25FbmQnLCAnb25BbmltYXRpb25JdGVyYXRpb24nXTtcbmV4cG9ydCB2YXIgdHJhbnNpdGlvbkV2ZW50cyA9IFsnb25UcmFuc2l0aW9uRW5kJ107XG5leHBvcnQgdmFyIG90aGVyRXZlbnRzID0gWydvblRvZ2dsZSddO1xuZXhwb3J0IHZhciBhbGxFdmVudHMgPSBbXS5jb25jYXQoY2xpcGJvYXJkRXZlbnRzLCBjb21wb3NpdGlvbkV2ZW50cywga2V5Ym9hcmRFdmVudHMsIGZvY3VzRXZlbnRzLCBmb3JtRXZlbnRzLCBnZW5lcmljRXZlbnRzLCBtb3VzZUV2ZW50cywgcG9pbnRlckV2ZW50cywgc2VsZWN0aW9uRXZlbnRzLCB0b3VjaEV2ZW50cywgdWlFdmVudHMsIHdoZWVsRXZlbnRzLCBtZWRpYUV2ZW50cywgaW1hZ2VFdmVudHMsIGFuaW1hdGlvbkV2ZW50cywgdHJhbnNpdGlvbkV2ZW50cywgb3RoZXJFdmVudHMpO1xuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIG9uLWV2ZW50IGNhbGxiYWNrIHByb3BzIGN1cnJpZWQgd2l0aCBwcm92aWRlZCBhcmdzLlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIFByb3BzIHBhc3NlZCB0byBhIGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7RnVuY3Rpb249fSBnZXRBcmdzIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFyZ3VtZW50KHMpIG9uLWV2ZW50IGNhbGxiYWNrc1xuICogICBzaGFsbCBiZSBjdXJyaWVkIHdpdGguXG4gKi9cblxudmFyIG1ha2VFdmVudFByb3BzID0gZnVuY3Rpb24gbWFrZUV2ZW50UHJvcHMocHJvcHMsIGdldEFyZ3MpIHtcbiAgdmFyIGV2ZW50UHJvcHMgPSB7fTtcbiAgYWxsRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgIGlmICghKGV2ZW50TmFtZSBpbiBwcm9wcykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWdldEFyZ3MpIHtcbiAgICAgIGV2ZW50UHJvcHNbZXZlbnROYW1lXSA9IHByb3BzW2V2ZW50TmFtZV07XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXZlbnRQcm9wc1tldmVudE5hbWVdID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICByZXR1cm4gcHJvcHNbZXZlbnROYW1lXShldmVudCwgZ2V0QXJncyhldmVudE5hbWUpKTtcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIGV2ZW50UHJvcHM7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBtYWtlRXZlbnRQcm9wczsiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtYWtlQ2FuY2VsbGFibGVQcm9taXNlKHByb21pc2UpIHtcbiAgdmFyIGlzQ2FuY2VsbGVkID0gZmFsc2U7XG4gIHZhciB3cmFwcGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICFpc0NhbmNlbGxlZCAmJiByZXNvbHZlLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgcmV0dXJuICFpc0NhbmNlbGxlZCAmJiByZWplY3QoZXJyb3IpO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBwcm9taXNlOiB3cmFwcGVkUHJvbWlzZSxcbiAgICBjYW5jZWw6IGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgIGlzQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICB9XG4gIH07XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWVyZ2VDbGFzc05hbWVzKCkge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5yZWR1Y2UoZnVuY3Rpb24gKGNsYXNzTGlzdCwgYXJnKSB7XG4gICAgcmV0dXJuIGNsYXNzTGlzdC5jb25jYXQoYXJnKTtcbiAgfSwgW10pLmZpbHRlcihmdW5jdGlvbiAoYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xuICB9KS5qb2luKCcgJyk7XG59IiwiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcbmV4cG9ydCBkZWZhdWx0IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KG51bGwpOyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTWVzc2FnZShfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICB0eXBlID0gX3JlZi50eXBlO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogXCJyZWFjdC1wZGZfX21lc3NhZ2UgcmVhY3QtcGRmX19tZXNzYWdlLS1cIi5jb25jYXQodHlwZSlcbiAgfSwgY2hpbGRyZW4pO1xufVxuTWVzc2FnZS5wcm9wVHlwZXMgPSB7XG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgdHlwZTogUHJvcFR5cGVzLm9uZU9mKFsnZXJyb3InLCAnbG9hZGluZycsICduby1kYXRhJ10pLmlzUmVxdWlyZWRcbn07IiwiaW1wb3J0IF9yZWdlbmVyYXRvclJ1bnRpbWUgZnJvbSBcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCI7XG5pbXBvcnQgX2FzeW5jVG9HZW5lcmF0b3IgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FzeW5jVG9HZW5lcmF0b3JcIjtcbmltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrXCI7XG5pbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzc1wiO1xuXG4vKiBDb3B5cmlnaHQgMjAxNSBNb3ppbGxhIEZvdW5kYXRpb25cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgY2xhc3MtbWV0aG9kcy11c2UtdGhpcywgbm8tZW1wdHktZnVuY3Rpb24gKi9cbnZhciBTaW1wbGVMaW5rU2VydmljZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNpbXBsZUxpbmtTZXJ2aWNlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTaW1wbGVMaW5rU2VydmljZSk7XG5cbiAgICB0aGlzLmV4dGVybmFsTGlua1RhcmdldCA9IG51bGw7XG4gICAgdGhpcy5leHRlcm5hbExpbmtSZWwgPSBudWxsO1xuICAgIHRoaXMuZXh0ZXJuYWxMaW5rRW5hYmxlZCA9IHRydWU7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU2ltcGxlTGlua1NlcnZpY2UsIFt7XG4gICAga2V5OiBcInNldERvY3VtZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldERvY3VtZW50KHBkZkRvY3VtZW50KSB7XG4gICAgICB0aGlzLnBkZkRvY3VtZW50ID0gcGRmRG9jdW1lbnQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFZpZXdlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWaWV3ZXIocGRmVmlld2VyKSB7XG4gICAgICB0aGlzLnBkZlZpZXdlciA9IHBkZlZpZXdlcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0SGlzdG9yeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRIaXN0b3J5KCkge31cbiAgfSwge1xuICAgIGtleTogXCJnb1RvRGVzdGluYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nb1RvRGVzdGluYXRpb24gPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKGRlc3QpIHtcbiAgICAgICAgdmFyIGRlc3RSZWYsIHBhZ2VOdW1iZXIsIHBhZ2VJbmRleDtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBkZXN0UmVmID0gZGVzdFswXTtcblxuICAgICAgICAgICAgICAgIGlmICghKGRlc3RSZWYgaW5zdGFuY2VvZiBPYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMjtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wZGZEb2N1bWVudC5nZXRQYWdlSW5kZXgoZGVzdFJlZik7XG5cbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIHBhZ2VJbmRleCA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICAgICAgcGFnZU51bWJlciA9IHBhZ2VJbmRleCArIDE7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gOTtcbiAgICAgICAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oMik7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXFxcIlwiLmNvbmNhdChkZXN0UmVmLCBcIlxcXCIgaXMgbm90IGEgdmFsaWQgZGVzdGluYXRpb24gcmVmZXJlbmNlLlwiKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICBpZiAoISh0eXBlb2YgZGVzdFJlZiA9PT0gJ251bWJlcicpKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTg7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwYWdlTnVtYmVyID0gZGVzdFJlZiArIDE7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXFxcIlwiLmNvbmNhdChkZXN0UmVmLCBcIlxcXCIgaXMgbm90IGEgdmFsaWQgZGVzdGluYXRpb24gcmVmZXJlbmNlLlwiKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICAgICBpZiAoISghcGFnZU51bWJlciB8fCBwYWdlTnVtYmVyIDwgMSB8fCBwYWdlTnVtYmVyID4gdGhpcy5wYWdlc0NvdW50KSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDIxO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXFxcIlwiLmNvbmNhdChwYWdlTnVtYmVyLCBcIlxcXCIgaXMgbm90IGEgdmFsaWQgcGFnZSBudW1iZXIuXCIpKTtcblxuICAgICAgICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgICAgICAgIHRoaXMucGRmVmlld2VyLnNjcm9sbFBhZ2VJbnRvVmlldyh7XG4gICAgICAgICAgICAgICAgICBwYWdlTnVtYmVyOiBwYWdlTnVtYmVyXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlLCB0aGlzLCBbWzIsIDldXSk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGdvVG9EZXN0aW5hdGlvbihfeCkge1xuICAgICAgICByZXR1cm4gX2dvVG9EZXN0aW5hdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ29Ub0Rlc3RpbmF0aW9uO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcIm5hdmlnYXRlVG9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmF2aWdhdGVUbyhkZXN0KSB7XG4gICAgICB0aGlzLmdvVG9EZXN0aW5hdGlvbihkZXN0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ29Ub1BhZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ29Ub1BhZ2UoKSB7fVxuICB9LCB7XG4gICAga2V5OiBcImdldERlc3RpbmF0aW9uSGFzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZXN0aW5hdGlvbkhhc2goKSB7XG4gICAgICByZXR1cm4gJyMnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRBbmNob3JVcmxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QW5jaG9yVXJsKCkge1xuICAgICAgcmV0dXJuICcjJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0SGFzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRIYXNoKCkge31cbiAgfSwge1xuICAgIGtleTogXCJleGVjdXRlTmFtZWRBY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXhlY3V0ZU5hbWVkQWN0aW9uKCkge31cbiAgfSwge1xuICAgIGtleTogXCJjYWNoZVBhZ2VSZWZcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FjaGVQYWdlUmVmKCkge31cbiAgfSwge1xuICAgIGtleTogXCJpc1BhZ2VWaXNpYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzUGFnZVZpc2libGUoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNQYWdlQ2FjaGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzUGFnZUNhY2hlZCgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYWdlc0NvdW50XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wZGZEb2N1bWVudCA/IHRoaXMucGRmRG9jdW1lbnQubnVtUGFnZXMgOiAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYWdlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wZGZWaWV3ZXIuY3VycmVudFBhZ2VOdW1iZXI7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgdGhpcy5wZGZWaWV3ZXIuY3VycmVudFBhZ2VOdW1iZXIgPSB2YWx1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicm90YXRpb25cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHt9XG4gIH1dKTtcblxuICByZXR1cm4gU2ltcGxlTGlua1NlcnZpY2U7XG59KCk7XG5cbmV4cG9ydCB7IFNpbXBsZUxpbmtTZXJ2aWNlIGFzIGRlZmF1bHQgfTsiLCIvLyBBcyBkZWZpbmVkIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3BkZi5qcy9ibG9iL21hc3Rlci9zcmMvc2hhcmVkL3V0aWwuanMjTDM3OC1MMzgxXG52YXIgUGFzc3dvcmRSZXNwb25zZXMgPSB7XG4gIE5FRURfUEFTU1dPUkQ6IDEsXG4gIElOQ09SUkVDVF9QQVNTV09SRDogMlxufTtcbmV4cG9ydCBkZWZhdWx0IFBhc3N3b3JkUmVzcG9uc2VzOyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gIHZhciBfaSA9IGFyciA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXTtcblxuICBpZiAoX2kgPT0gbnVsbCkgcmV0dXJuO1xuICB2YXIgX2FyciA9IFtdO1xuICB2YXIgX24gPSB0cnVlO1xuICB2YXIgX2QgPSBmYWxzZTtcblxuICB2YXIgX3MsIF9lO1xuXG4gIHRyeSB7XG4gICAgZm9yIChfaSA9IF9pLmNhbGwoYXJyKTsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2QgPSB0cnVlO1xuICAgIF9lID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9hcnI7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXJyMltpXSA9IGFycltpXTtcbiAgfVxuXG4gIHJldHVybiBhcnIyO1xufSIsImltcG9ydCBhcnJheUxpa2VUb0FycmF5IGZyb20gXCIuL2FycmF5TGlrZVRvQXJyYXkuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn0iLCJpbXBvcnQgYXJyYXlXaXRoSG9sZXMgZnJvbSBcIi4vYXJyYXlXaXRoSG9sZXMuanNcIjtcbmltcG9ydCBpdGVyYWJsZVRvQXJyYXlMaW1pdCBmcm9tIFwiLi9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qc1wiO1xuaW1wb3J0IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IGZyb20gXCIuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzXCI7XG5pbXBvcnQgbm9uSXRlcmFibGVSZXN0IGZyb20gXCIuL25vbkl0ZXJhYmxlUmVzdC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gIHJldHVybiBhcnJheVdpdGhIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBub25JdGVyYWJsZVJlc3QoKTtcbn0iLCJpbXBvcnQgX3NsaWNlZFRvQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXlcIjtcblxuLyoqXG4gKiBDaGVja3MgaWYgd2UncmUgcnVubmluZyBpbiBhIGJyb3dzZXIgZW52aXJvbm1lbnQuXG4gKi9cbmV4cG9ydCB2YXIgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHdlJ3JlIHJ1bm5pbmcgZnJvbSBhIGxvY2FsIGZpbGUgc3lzdGVtLlxuICovXG5cbmV4cG9ydCB2YXIgaXNMb2NhbEZpbGVTeXN0ZW0gPSBpc0Jyb3dzZXIgJiYgd2luZG93LmxvY2F0aW9uLnByb3RvY29sID09PSAnZmlsZTonO1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB3ZSdyZSBydW5uaW5nIG9uIGEgcHJvZHVjdGlvbiBidWlsZCBvciBub3QuXG4gKi9cblxuZXhwb3J0IHZhciBpc1Byb2R1Y3Rpb24gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nO1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIHZhcmlhYmxlIGlzIGRlZmluZWQuXG4gKlxuICogQHBhcmFtIHsqfSB2YXJpYWJsZSBWYXJpYWJsZSB0byBjaGVja1xuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0RlZmluZWQodmFyaWFibGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YXJpYWJsZSAhPT0gJ3VuZGVmaW5lZCc7XG59XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgdmFyaWFibGUgaXMgZGVmaW5lZCBhbmQgbm90IG51bGwuXG4gKlxuICogQHBhcmFtIHsqfSB2YXJpYWJsZSBWYXJpYWJsZSB0byBjaGVja1xuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpc1Byb3ZpZGVkKHZhcmlhYmxlKSB7XG4gIHJldHVybiBpc0RlZmluZWQodmFyaWFibGUpICYmIHZhcmlhYmxlICE9PSBudWxsO1xufVxuLyoqXG4gKiBDaGVja2VzIHdoZXRoZXIgYSB2YXJpYWJsZSBwcm92aWRlZCBpcyBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0geyp9IHZhcmlhYmxlIFZhcmlhYmxlIHRvIGNoZWNrXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU3RyaW5nKHZhcmlhYmxlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFyaWFibGUgPT09ICdzdHJpbmcnO1xufVxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIHZhcmlhYmxlIHByb3ZpZGVkIGlzIGFuIEFycmF5QnVmZmVyLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFyaWFibGUgVmFyaWFibGUgdG8gY2hlY2tcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YXJpYWJsZSkge1xuICByZXR1cm4gdmFyaWFibGUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcjtcbn1cbi8qKlxuICogQ2hlY2tlcyB3aGV0aGVyIGEgdmFyaWFibGUgcHJvdmlkZWQgaXMgYSBCbG9iLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFyaWFibGUgVmFyaWFibGUgdG8gY2hlY2tcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaXNCbG9iKHZhcmlhYmxlKSB7XG4gIGlmICghaXNCcm93c2VyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0ZWQgdG8gY2hlY2sgaWYgYSB2YXJpYWJsZSBpcyBhIEJsb2Igb24gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudC4nKTtcbiAgfVxuXG4gIHJldHVybiB2YXJpYWJsZSBpbnN0YW5jZW9mIEJsb2I7XG59XG4vKipcbiAqIENoZWNrZXMgd2hldGhlciBhIHZhcmlhYmxlIHByb3ZpZGVkIGlzIGEgRmlsZS5cbiAqXG4gKiBAcGFyYW0geyp9IHZhcmlhYmxlIFZhcmlhYmxlIHRvIGNoZWNrXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRmlsZSh2YXJpYWJsZSkge1xuICBpZiAoIWlzQnJvd3Nlcikge1xuICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHRvIGNoZWNrIGlmIGEgdmFyaWFibGUgaXMgYSBGaWxlIG9uIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnQuJyk7XG4gIH1cblxuICByZXR1cm4gdmFyaWFibGUgaW5zdGFuY2VvZiBGaWxlO1xufVxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIHN0cmluZyBwcm92aWRlZCBpcyBhIGRhdGEgVVJJLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIGNoZWNrXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRGF0YVVSSShzdHIpIHtcbiAgcmV0dXJuIGlzU3RyaW5nKHN0cikgJiYgL15kYXRhOi8udGVzdChzdHIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRhdGFVUkl0b0J5dGVTdHJpbmcoZGF0YVVSSSkge1xuICBpZiAoIWlzRGF0YVVSSShkYXRhVVJJKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkYXRhIFVSSS4nKTtcbiAgfVxuXG4gIHZhciBfZGF0YVVSSSRzcGxpdCA9IGRhdGFVUkkuc3BsaXQoJywnKSxcbiAgICAgIF9kYXRhVVJJJHNwbGl0MiA9IF9zbGljZWRUb0FycmF5KF9kYXRhVVJJJHNwbGl0LCAyKSxcbiAgICAgIGhlYWRlcnNTdHJpbmcgPSBfZGF0YVVSSSRzcGxpdDJbMF0sXG4gICAgICBkYXRhU3RyaW5nID0gX2RhdGFVUkkkc3BsaXQyWzFdO1xuXG4gIHZhciBoZWFkZXJzID0gaGVhZGVyc1N0cmluZy5zcGxpdCgnOycpO1xuXG4gIGlmIChoZWFkZXJzLmluZGV4T2YoJ2Jhc2U2NCcpICE9PSAtMSkge1xuICAgIHJldHVybiBhdG9iKGRhdGFTdHJpbmcpO1xuICB9XG5cbiAgcmV0dXJuIHVuZXNjYXBlKGRhdGFTdHJpbmcpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFBpeGVsUmF0aW8oKSB7XG4gIHJldHVybiBpc0Jyb3dzZXIgJiYgd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbn1cblxuZnVuY3Rpb24gY29uc29sZU9uRGV2KG1ldGhvZCkge1xuICBpZiAoIWlzUHJvZHVjdGlvbikge1xuICAgIHZhciBfY29uc29sZTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBtZXNzYWdlID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIG1lc3NhZ2VbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgKF9jb25zb2xlID0gY29uc29sZSlbbWV0aG9kXS5hcHBseShfY29uc29sZSwgbWVzc2FnZSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdhcm5PbkRldigpIHtcbiAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBtZXNzYWdlID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgbWVzc2FnZVtfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICB9XG5cbiAgY29uc29sZU9uRGV2LmFwcGx5KHZvaWQgMCwgWyd3YXJuJ10uY29uY2F0KG1lc3NhZ2UpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlcnJvck9uRGV2KCkge1xuICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIG1lc3NhZ2UgPSBuZXcgQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICBtZXNzYWdlW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gIH1cblxuICBjb25zb2xlT25EZXYuYXBwbHkodm9pZCAwLCBbJ2Vycm9yJ10uY29uY2F0KG1lc3NhZ2UpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkaXNwbGF5Q09SU1dhcm5pbmcoKSB7XG4gIGlmIChpc0xvY2FsRmlsZVN5c3RlbSkge1xuICAgIHdhcm5PbkRldignTG9hZGluZyBQREYgYXMgYmFzZTY0IHN0cmluZ3MvVVJMcyBtaWdodCBub3Qgd29yayBvbiBwcm90b2NvbHMgb3RoZXIgdGhhbiBIVFRQL0hUVFBTLiBPbiBHb29nbGUgQ2hyb21lLCB5b3UgY2FuIHVzZSAtLWFsbG93LWZpbGUtYWNjZXNzLWZyb20tZmlsZXMgZmxhZyBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLicpO1xuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gY2FuY2VsUnVubmluZ1Rhc2socnVubmluZ1Rhc2spIHtcbiAgaWYgKHJ1bm5pbmdUYXNrICYmIHJ1bm5pbmdUYXNrLmNhbmNlbCkgcnVubmluZ1Rhc2suY2FuY2VsKCk7XG59XG5leHBvcnQgZnVuY3Rpb24gbWFrZVBhZ2VDYWxsYmFjayhwYWdlLCBzY2FsZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGFnZSwgJ3dpZHRoJywge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMudmlld1syXSAqIHNjYWxlO1xuICAgIH0sXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGFnZSwgJ2hlaWdodCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnZpZXdbM10gKiBzY2FsZTtcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBhZ2UsICdvcmlnaW5hbFdpZHRoJywge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMudmlld1syXTtcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBhZ2UsICdvcmlnaW5hbEhlaWdodCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnZpZXdbM107XG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIHJldHVybiBwYWdlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQ2FuY2VsRXhjZXB0aW9uKGVycm9yKSB7XG4gIHJldHVybiBlcnJvci5uYW1lID09PSAnUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uJztcbn1cbmV4cG9ydCBmdW5jdGlvbiBsb2FkRnJvbUZpbGUoZmlsZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXG4gICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByZXNvbHZlKG5ldyBVaW50OEFycmF5KHJlYWRlci5yZXN1bHQpKTtcbiAgICB9O1xuXG4gICAgcmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHN3aXRjaCAoZXZlbnQudGFyZ2V0LmVycm9yLmNvZGUpIHtcbiAgICAgICAgY2FzZSBldmVudC50YXJnZXQuZXJyb3IuTk9UX0ZPVU5EX0VSUjpcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignRXJyb3Igd2hpbGUgcmVhZGluZyBhIGZpbGU6IEZpbGUgbm90IGZvdW5kLicpKTtcblxuICAgICAgICBjYXNlIGV2ZW50LnRhcmdldC5lcnJvci5OT1RfUkVBREFCTEVfRVJSOlxuICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdFcnJvciB3aGlsZSByZWFkaW5nIGEgZmlsZTogRmlsZSBub3QgcmVhZGFibGUuJykpO1xuXG4gICAgICAgIGNhc2UgZXZlbnQudGFyZ2V0LmVycm9yLlNFQ1VSSVRZX0VSUjpcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignRXJyb3Igd2hpbGUgcmVhZGluZyBhIGZpbGU6IFNlY3VyaXR5IGVycm9yLicpKTtcblxuICAgICAgICBjYXNlIGV2ZW50LnRhcmdldC5lcnJvci5BQk9SVF9FUlI6XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ0Vycm9yIHdoaWxlIHJlYWRpbmcgYSBmaWxlOiBBYm9ydGVkLicpKTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdFcnJvciB3aGlsZSByZWFkaW5nIGEgZmlsZS4nKSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihmaWxlKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSk7XG59IiwiaW1wb3J0IGFycmF5TGlrZVRvQXJyYXkgZnJvbSBcIi4vYXJyYXlMaWtlVG9BcnJheS5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufSIsImltcG9ydCBhcnJheVdpdGhvdXRIb2xlcyBmcm9tIFwiLi9hcnJheVdpdGhvdXRIb2xlcy5qc1wiO1xuaW1wb3J0IGl0ZXJhYmxlVG9BcnJheSBmcm9tIFwiLi9pdGVyYWJsZVRvQXJyYXkuanNcIjtcbmltcG9ydCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSBmcm9tIFwiLi91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qc1wiO1xuaW1wb3J0IG5vbkl0ZXJhYmxlU3ByZWFkIGZyb20gXCIuL25vbkl0ZXJhYmxlU3ByZWFkLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBhcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgbm9uSXRlcmFibGVTcHJlYWQoKTtcbn0iLCJpbXBvcnQgX3R5cGVvZiBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdHlwZW9mXCI7XG5pbXBvcnQgX3RvQ29uc3VtYWJsZUFycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90b0NvbnN1bWFibGVBcnJheVwiO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IG1vdXNlRXZlbnRzLCB0b3VjaEV2ZW50cywga2V5Ym9hcmRFdmVudHMgfSBmcm9tICdtYWtlLWV2ZW50LXByb3BzJztcbmltcG9ydCB7IGlzRGVmaW5lZCB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IExpbmtTZXJ2aWNlIGZyb20gJy4uL0xpbmtTZXJ2aWNlJztcbmV4cG9ydCB2YXIgZXZlbnRQcm9wcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KG1vdXNlRXZlbnRzKSwgX3RvQ29uc3VtYWJsZUFycmF5KHRvdWNoRXZlbnRzKSwgX3RvQ29uc3VtYWJsZUFycmF5KGtleWJvYXJkRXZlbnRzKSkuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgcmVzdWx0W2V2ZW50TmFtZV0gPSBQcm9wVHlwZXMuZnVuYztcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KCk7XG4vKiBlc2xpbnQtZGlzYWJsZSByZWFjdC9mb3JiaWQtcHJvcC10eXBlcyAqL1xuXG52YXIgZmlsZVR5cGVzID0gW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5pbnN0YW5jZU9mKEFycmF5QnVmZmVyKSwgUHJvcFR5cGVzLnNoYXBlKHtcbiAgZGF0YTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm9iamVjdCwgUHJvcFR5cGVzLnN0cmluZ10pLFxuICBodHRwSGVhZGVyczogUHJvcFR5cGVzLm9iamVjdCxcbiAgcmFuZ2U6IFByb3BUeXBlcy5vYmplY3QsXG4gIHVybDogUHJvcFR5cGVzLnN0cmluZyxcbiAgd2l0aENyZWRlbnRpYWxzOiBQcm9wVHlwZXMuYm9vbFxufSldO1xuXG5pZiAodHlwZW9mIEZpbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gIGZpbGVUeXBlcy5wdXNoKFByb3BUeXBlcy5pbnN0YW5jZU9mKEZpbGUpKTtcbn1cblxuaWYgKHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJykge1xuICBmaWxlVHlwZXMucHVzaChQcm9wVHlwZXMuaW5zdGFuY2VPZihCbG9iKSk7XG59XG5cbmV4cG9ydCB2YXIgaXNDbGFzc05hbWUgPSBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc3RyaW5nKV0pO1xuZXhwb3J0IHZhciBpc0ZpbGUgPSBQcm9wVHlwZXMub25lT2ZUeXBlKGZpbGVUeXBlcyk7XG5leHBvcnQgdmFyIGlzTGlua1NlcnZpY2UgPSBQcm9wVHlwZXMuaW5zdGFuY2VPZihMaW5rU2VydmljZSk7XG5leHBvcnQgdmFyIGlzTGlua1RhcmdldCA9IFByb3BUeXBlcy5vbmVPZihbJ19zZWxmJywgJ19ibGFuaycsICdfcGFyZW50JywgJ190b3AnXSk7XG5leHBvcnQgdmFyIGlzUGFnZSA9IFByb3BUeXBlcy5zaGFwZSh7XG4gIF90cmFuc3BvcnQ6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgZm9udExvYWRlcjogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkXG4gIH0pLmlzUmVxdWlyZWQsXG4gIGNvbW1vbk9ianM6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgX29ianM6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZFxuICB9KS5pc1JlcXVpcmVkLFxuICBnZXRBbm5vdGF0aW9uczogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgZ2V0VGV4dENvbnRlbnQ6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIGdldFZpZXdwb3J0OiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICByZW5kZXI6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbn0pO1xuZXhwb3J0IHZhciBpc1BhZ2VJbmRleCA9IGZ1bmN0aW9uIGlzUGFnZUluZGV4KHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICB2YXIgcGFnZUluZGV4ID0gcHJvcHNbcHJvcE5hbWVdLFxuICAgICAgcGFnZU51bWJlciA9IHByb3BzLnBhZ2VOdW1iZXIsXG4gICAgICBwZGYgPSBwcm9wcy5wZGY7XG5cbiAgaWYgKCFpc0RlZmluZWQocGRmKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGlzRGVmaW5lZChwYWdlSW5kZXgpKSB7XG4gICAgaWYgKHR5cGVvZiBwYWdlSW5kZXggIT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKFwiYFwiLmNvbmNhdChwcm9wTmFtZSwgXCJgIG9mIHR5cGUgYFwiKS5jb25jYXQoX3R5cGVvZihwYWdlSW5kZXgpLCBcImAgc3VwcGxpZWQgdG8gYFwiKS5jb25jYXQoY29tcG9uZW50TmFtZSwgXCJgLCBleHBlY3RlZCBgbnVtYmVyYC5cIikpO1xuICAgIH1cblxuICAgIGlmIChwYWdlSW5kZXggPCAwKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKFwiRXhwZWN0ZWQgYFwiLmNvbmNhdChwcm9wTmFtZSwgXCJgIHRvIGJlIGdyZWF0ZXIgb3IgZXF1YWwgdG8gMC5cIikpO1xuICAgIH1cblxuICAgIHZhciBudW1QYWdlcyA9IHBkZi5udW1QYWdlcztcblxuICAgIGlmIChwYWdlSW5kZXggKyAxID4gbnVtUGFnZXMpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoXCJFeHBlY3RlZCBgXCIuY29uY2F0KHByb3BOYW1lLCBcImAgdG8gYmUgbGVzcyBvciBlcXVhbCB0byBcIikuY29uY2F0KG51bVBhZ2VzIC0gMSwgXCIuXCIpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWlzRGVmaW5lZChwYWdlTnVtYmVyKSkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoXCJgXCIuY29uY2F0KHByb3BOYW1lLCBcImAgbm90IHN1cHBsaWVkLiBFaXRoZXIgcGFnZUluZGV4IG9yIHBhZ2VOdW1iZXIgbXVzdCBiZSBzdXBwbGllZCB0byBgXCIpLmNvbmNhdChjb21wb25lbnROYW1lLCBcImAuXCIpKTtcbiAgfSAvLyBFdmVyeXRoaW5nIGlzIGZpbmVcblxuXG4gIHJldHVybiBudWxsO1xufTtcbmV4cG9ydCB2YXIgaXNQYWdlTnVtYmVyID0gZnVuY3Rpb24gaXNQYWdlTnVtYmVyKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICB2YXIgcGFnZU51bWJlciA9IHByb3BzW3Byb3BOYW1lXSxcbiAgICAgIHBhZ2VJbmRleCA9IHByb3BzLnBhZ2VJbmRleCxcbiAgICAgIHBkZiA9IHByb3BzLnBkZjtcblxuICBpZiAoIWlzRGVmaW5lZChwZGYpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoaXNEZWZpbmVkKHBhZ2VOdW1iZXIpKSB7XG4gICAgaWYgKHR5cGVvZiBwYWdlTnVtYmVyICE9PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcihcImBcIi5jb25jYXQocHJvcE5hbWUsIFwiYCBvZiB0eXBlIGBcIikuY29uY2F0KF90eXBlb2YocGFnZU51bWJlciksIFwiYCBzdXBwbGllZCB0byBgXCIpLmNvbmNhdChjb21wb25lbnROYW1lLCBcImAsIGV4cGVjdGVkIGBudW1iZXJgLlwiKSk7XG4gICAgfVxuXG4gICAgaWYgKHBhZ2VOdW1iZXIgPCAxKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKFwiRXhwZWN0ZWQgYFwiLmNvbmNhdChwcm9wTmFtZSwgXCJgIHRvIGJlIGdyZWF0ZXIgb3IgZXF1YWwgdG8gMS5cIikpO1xuICAgIH1cblxuICAgIHZhciBudW1QYWdlcyA9IHBkZi5udW1QYWdlcztcblxuICAgIGlmIChwYWdlTnVtYmVyID4gbnVtUGFnZXMpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoXCJFeHBlY3RlZCBgXCIuY29uY2F0KHByb3BOYW1lLCBcImAgdG8gYmUgbGVzcyBvciBlcXVhbCB0byBcIikuY29uY2F0KG51bVBhZ2VzLCBcIi5cIikpO1xuICAgIH1cbiAgfSBlbHNlIGlmICghaXNEZWZpbmVkKHBhZ2VJbmRleCkpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKFwiYFwiLmNvbmNhdChwcm9wTmFtZSwgXCJgIG5vdCBzdXBwbGllZC4gRWl0aGVyIHBhZ2VJbmRleCBvciBwYWdlTnVtYmVyIG11c3QgYmUgc3VwcGxpZWQgdG8gYFwiKS5jb25jYXQoY29tcG9uZW50TmFtZSwgXCJgLlwiKSk7XG4gIH0gLy8gRXZlcnl0aGluZyBpcyBmaW5lXG5cblxuICByZXR1cm4gbnVsbDtcbn07XG5leHBvcnQgdmFyIGlzUGRmID0gUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnNoYXBlKHtcbiAgZ2V0RGVzdGluYXRpb246IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIGdldE91dGxpbmU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIGdldFBhZ2U6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIG51bVBhZ2VzOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWRcbn0pLCBQcm9wVHlwZXMuYm9vbF0pO1xuZXhwb3J0IHZhciBpc1JlZiA9IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMuc2hhcGUoe1xuICBjdXJyZW50OiBQcm9wVHlwZXMuYW55XG59KV0pO1xuZXhwb3J0IHZhciBpc1JlbmRlck1vZGUgPSBQcm9wVHlwZXMub25lT2YoWydjYW52YXMnLCAnbm9uZScsICdzdmcnXSk7XG5leHBvcnQgdmFyIGlzUm90YXRlID0gUHJvcFR5cGVzLm9uZU9mKFswLCA5MCwgMTgwLCAyNzBdKTsiLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzXCI7XG5pbXBvcnQgX3R5cGVvZiBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdHlwZW9mXCI7XG5pbXBvcnQgX3JlZ2VuZXJhdG9yUnVudGltZSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIjtcbmltcG9ydCBfYXN5bmNUb0dlbmVyYXRvciBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXN5bmNUb0dlbmVyYXRvclwiO1xuaW1wb3J0IF9jbGFzc0NhbGxDaGVjayBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2tcIjtcbmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzXCI7XG5pbXBvcnQgX2Fzc2VydFRoaXNJbml0aWFsaXplZCBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXNzZXJ0VGhpc0luaXRpYWxpemVkXCI7XG5pbXBvcnQgX2luaGVyaXRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pbmhlcml0c1wiO1xuaW1wb3J0IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCI7XG5pbXBvcnQgX2dldFByb3RvdHlwZU9mIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9nZXRQcm90b3R5cGVPZlwiO1xuaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuLyoqXG4gKiBMb2FkcyBhIFBERiBkb2N1bWVudC4gUGFzc2VzIGl0IHRvIGFsbCBjaGlsZHJlbi5cbiAqL1xuaW1wb3J0IFJlYWN0LCB7IFB1cmVDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IG1ha2VFdmVudFByb3BzIGZyb20gJ21ha2UtZXZlbnQtcHJvcHMnO1xuaW1wb3J0IG1ha2VDYW5jZWxsYWJsZSBmcm9tICdtYWtlLWNhbmNlbGxhYmxlLXByb21pc2UnO1xuaW1wb3J0IG1lcmdlQ2xhc3NOYW1lcyBmcm9tICdtZXJnZS1jbGFzcy1uYW1lcyc7XG5pbXBvcnQgKiBhcyBwZGZqcyBmcm9tICdwZGZqcy1kaXN0JztcbmltcG9ydCBEb2N1bWVudENvbnRleHQgZnJvbSAnLi9Eb2N1bWVudENvbnRleHQnO1xuaW1wb3J0IE1lc3NhZ2UgZnJvbSAnLi9NZXNzYWdlJztcbmltcG9ydCBMaW5rU2VydmljZSBmcm9tICcuL0xpbmtTZXJ2aWNlJztcbmltcG9ydCBQYXNzd29yZFJlc3BvbnNlcyBmcm9tICcuL1Bhc3N3b3JkUmVzcG9uc2VzJztcbmltcG9ydCB7IGNhbmNlbFJ1bm5pbmdUYXNrLCBkYXRhVVJJdG9CeXRlU3RyaW5nLCBkaXNwbGF5Q09SU1dhcm5pbmcsIGVycm9yT25EZXYsIGlzQXJyYXlCdWZmZXIsIGlzQmxvYiwgaXNCcm93c2VyLCBpc0RhdGFVUkksIGlzRmlsZSwgbG9hZEZyb21GaWxlLCB3YXJuT25EZXYgfSBmcm9tICcuL3NoYXJlZC91dGlscyc7XG5pbXBvcnQgeyBldmVudFByb3BzLCBpc0NsYXNzTmFtZSwgaXNGaWxlIGFzIGlzRmlsZVByb3AsIGlzUmVmIH0gZnJvbSAnLi9zaGFyZWQvcHJvcFR5cGVzJztcbnZhciBQREZEYXRhUmFuZ2VUcmFuc3BvcnQgPSBwZGZqcy5QREZEYXRhUmFuZ2VUcmFuc3BvcnQ7XG5cbnZhciBEb2N1bWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1B1cmVDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKERvY3VtZW50LCBfUHVyZUNvbXBvbmVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihEb2N1bWVudCk7XG5cbiAgZnVuY3Rpb24gRG9jdW1lbnQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERvY3VtZW50KTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsLmFwcGx5KF9zdXBlciwgW3RoaXNdLmNvbmNhdChhcmdzKSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwic3RhdGVcIiwge1xuICAgICAgcGRmOiBudWxsXG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwidmlld2VyXCIsIHtcbiAgICAgIHNjcm9sbFBhZ2VJbnRvVmlldzogZnVuY3Rpb24gc2Nyb2xsUGFnZUludG9WaWV3KF9yZWYpIHtcbiAgICAgICAgdmFyIHBhZ2VOdW1iZXIgPSBfcmVmLnBhZ2VOdW1iZXI7XG4gICAgICAgIC8vIEhhbmRsaW5nIGp1bXBpbmcgdG8gaW50ZXJuYWwgbGlua3MgdGFyZ2V0XG4gICAgICAgIHZhciBvbkl0ZW1DbGljayA9IF90aGlzLnByb3BzLm9uSXRlbUNsaWNrOyAvLyBGaXJzdCwgY2hlY2sgaWYgY3VzdG9tIGhhbmRsaW5nIG9mIG9uSXRlbUNsaWNrIHdhcyBwcm92aWRlZFxuXG4gICAgICAgIGlmIChvbkl0ZW1DbGljaykge1xuICAgICAgICAgIG9uSXRlbUNsaWNrKHtcbiAgICAgICAgICAgIHBhZ2VOdW1iZXI6IHBhZ2VOdW1iZXJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gSWYgbm90LCB0cnkgdG8gbG9vayBmb3IgdGFyZ2V0IHBhZ2Ugd2l0aGluIHRoZSA8RG9jdW1lbnQ+LlxuXG5cbiAgICAgICAgdmFyIHBhZ2UgPSBfdGhpcy5wYWdlc1twYWdlTnVtYmVyIC0gMV07XG5cbiAgICAgICAgaWYgKHBhZ2UpIHtcbiAgICAgICAgICAvLyBTY3JvbGwgdG8gdGhlIHBhZ2UgYXV0b21hdGljYWxseVxuICAgICAgICAgIHBhZ2Uuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB3YXJuT25EZXYoXCJXYXJuaW5nOiBBbiBpbnRlcm5hbCBsaW5rIGxlYWRpbmcgdG8gcGFnZSBcIi5jb25jYXQocGFnZU51bWJlciwgXCIgd2FzIGNsaWNrZWQsIGJ1dCBuZWl0aGVyIDxEb2N1bWVudD4gd2FzIHByb3ZpZGVkIHdpdGggb25JdGVtQ2xpY2sgbm9yIGl0IHdhcyBhYmxlIHRvIGZpbmQgdGhlIHBhZ2Ugd2l0aGluIGl0c2VsZi4gRWl0aGVyIHByb3ZpZGUgb25JdGVtQ2xpY2sgdG8gPERvY3VtZW50PiBhbmQgaGFuZGxlIG5hdmlnYXRpbmcgYnkgeW91cnNlbGYgb3IgZW5zdXJlIHRoYXQgYWxsIHBhZ2VzIGFyZSByZW5kZXJlZCB3aXRoaW4gPERvY3VtZW50Pi5cIikpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImxpbmtTZXJ2aWNlXCIsIG5ldyBMaW5rU2VydmljZSgpKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJsb2FkRG9jdW1lbnRcIiwgLyojX19QVVJFX18qL19hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICB2YXIgc291cmNlLCBfdGhpcyRwcm9wcywgb3B0aW9ucywgb25Mb2FkUHJvZ3Jlc3MsIG9uUGFzc3dvcmQsIGNhbmNlbGxhYmxlLCBwZGY7XG5cbiAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxO1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmZpbmREb2N1bWVudFNvdXJjZSgpO1xuXG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIHNvdXJjZSA9IF9jb250ZXh0LnNlbnQ7XG5cbiAgICAgICAgICAgICAgX3RoaXMub25Tb3VyY2VTdWNjZXNzKCk7XG5cbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDExO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gODtcbiAgICAgICAgICAgICAgX2NvbnRleHQudDAgPSBfY29udGV4dFtcImNhdGNoXCJdKDEpO1xuXG4gICAgICAgICAgICAgIF90aGlzLm9uU291cmNlRXJyb3IoX2NvbnRleHQudDApO1xuXG4gICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiKTtcblxuICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKHByZXZTdGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmICghcHJldlN0YXRlLnBkZikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIHBkZjogbnVsbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIF90aGlzJHByb3BzID0gX3RoaXMucHJvcHMsIG9wdGlvbnMgPSBfdGhpcyRwcm9wcy5vcHRpb25zLCBvbkxvYWRQcm9ncmVzcyA9IF90aGlzJHByb3BzLm9uTG9hZFByb2dyZXNzLCBvblBhc3N3b3JkID0gX3RoaXMkcHJvcHMub25QYXNzd29yZDtcbiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDE1O1xuICAgICAgICAgICAgICAvLyBJZiBhbm90aGVyIHJlbmRlcmluZyBpcyBpbiBwcm9ncmVzcywgbGV0J3MgY2FuY2VsIGl0XG4gICAgICAgICAgICAgIGNhbmNlbFJ1bm5pbmdUYXNrKF90aGlzLnJ1bm5pbmdUYXNrKTsgLy8gSWYgYW5vdGhlciBsb2FkaW5nIGlzIGluIHByb2dyZXNzLCBsZXQncyBkZXN0cm95IGl0XG5cbiAgICAgICAgICAgICAgaWYgKF90aGlzLmxvYWRpbmdUYXNrKSBfdGhpcy5sb2FkaW5nVGFzay5kZXN0cm95KCk7XG4gICAgICAgICAgICAgIF90aGlzLmxvYWRpbmdUYXNrID0gcGRmanMuZ2V0RG9jdW1lbnQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBzb3VyY2UpLCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgIF90aGlzLmxvYWRpbmdUYXNrLm9uUGFzc3dvcmQgPSBvblBhc3N3b3JkO1xuXG4gICAgICAgICAgICAgIGlmIChvbkxvYWRQcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIF90aGlzLmxvYWRpbmdUYXNrLm9uUHJvZ3Jlc3MgPSBvbkxvYWRQcm9ncmVzcztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNhbmNlbGxhYmxlID0gbWFrZUNhbmNlbGxhYmxlKF90aGlzLmxvYWRpbmdUYXNrLnByb21pc2UpO1xuICAgICAgICAgICAgICBfdGhpcy5ydW5uaW5nVGFzayA9IGNhbmNlbGxhYmxlO1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjU7XG4gICAgICAgICAgICAgIHJldHVybiBjYW5jZWxsYWJsZS5wcm9taXNlO1xuXG4gICAgICAgICAgICBjYXNlIDI1OlxuICAgICAgICAgICAgICBwZGYgPSBfY29udGV4dC5zZW50O1xuXG4gICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChwcmV2U3RhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJldlN0YXRlLnBkZiAmJiBwcmV2U3RhdGUucGRmLmZpbmdlcnByaW50ID09PSBwZGYuZmluZ2VycHJpbnQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICBwZGY6IHBkZlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0sIF90aGlzLm9uTG9hZFN1Y2Nlc3MpO1xuXG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMjk6XG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAyOTtcbiAgICAgICAgICAgICAgX2NvbnRleHQudDEgPSBfY29udGV4dFtcImNhdGNoXCJdKDE1KTtcblxuICAgICAgICAgICAgICBfdGhpcy5vbkxvYWRFcnJvcihfY29udGV4dC50MSk7XG5cbiAgICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlLCBudWxsLCBbWzEsIDhdLCBbMTUsIDI5XV0pO1xuICAgIH0pKSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwic2V0dXBMaW5rU2VydmljZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5saW5rU2VydmljZS5zZXRWaWV3ZXIoX3RoaXMudmlld2VyKTtcblxuICAgICAgdmFyIGRvY3VtZW50SW5zdGFuY2UgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLmxpbmtTZXJ2aWNlLCAnZXh0ZXJuYWxMaW5rVGFyZ2V0Jywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICB2YXIgZXh0ZXJuYWxMaW5rVGFyZ2V0ID0gZG9jdW1lbnRJbnN0YW5jZS5wcm9wcy5leHRlcm5hbExpbmtUYXJnZXQ7XG5cbiAgICAgICAgICBzd2l0Y2ggKGV4dGVybmFsTGlua1RhcmdldCkge1xuICAgICAgICAgICAgY2FzZSAnX3NlbGYnOlxuICAgICAgICAgICAgICByZXR1cm4gMTtcblxuICAgICAgICAgICAgY2FzZSAnX2JsYW5rJzpcbiAgICAgICAgICAgICAgcmV0dXJuIDI7XG5cbiAgICAgICAgICAgIGNhc2UgJ19wYXJlbnQnOlxuICAgICAgICAgICAgICByZXR1cm4gMztcblxuICAgICAgICAgICAgY2FzZSAnX3RvcCc6XG4gICAgICAgICAgICAgIHJldHVybiA0O1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm9uU291cmNlU3VjY2Vzc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgb25Tb3VyY2VTdWNjZXNzID0gX3RoaXMucHJvcHMub25Tb3VyY2VTdWNjZXNzO1xuICAgICAgaWYgKG9uU291cmNlU3VjY2Vzcykgb25Tb3VyY2VTdWNjZXNzKCk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwib25Tb3VyY2VFcnJvclwiLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIGVycm9yT25EZXYoZXJyb3IpO1xuICAgICAgdmFyIG9uU291cmNlRXJyb3IgPSBfdGhpcy5wcm9wcy5vblNvdXJjZUVycm9yO1xuICAgICAgaWYgKG9uU291cmNlRXJyb3IpIG9uU291cmNlRXJyb3IoZXJyb3IpO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm9uTG9hZFN1Y2Nlc3NcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG9uTG9hZFN1Y2Nlc3MgPSBfdGhpcy5wcm9wcy5vbkxvYWRTdWNjZXNzO1xuICAgICAgdmFyIHBkZiA9IF90aGlzLnN0YXRlLnBkZjtcbiAgICAgIGlmIChvbkxvYWRTdWNjZXNzKSBvbkxvYWRTdWNjZXNzKHBkZik7XG4gICAgICBfdGhpcy5wYWdlcyA9IG5ldyBBcnJheShwZGYubnVtUGFnZXMpO1xuXG4gICAgICBfdGhpcy5saW5rU2VydmljZS5zZXREb2N1bWVudChwZGYpO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm9uTG9hZEVycm9yXCIsIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICBwZGY6IGZhbHNlXG4gICAgICB9KTtcblxuICAgICAgZXJyb3JPbkRldihlcnJvcik7XG4gICAgICB2YXIgb25Mb2FkRXJyb3IgPSBfdGhpcy5wcm9wcy5vbkxvYWRFcnJvcjtcbiAgICAgIGlmIChvbkxvYWRFcnJvcikgb25Mb2FkRXJyb3IoZXJyb3IpO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImZpbmREb2N1bWVudFNvdXJjZVwiLCAvKiNfX1BVUkVfXyovX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoKSB7XG4gICAgICB2YXIgZmlsZSwgZmlsZUJ5dGVTdHJpbmcsIHVybCwgb3RoZXJQYXJhbXMsIF9maWxlQnl0ZVN0cmluZztcblxuICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGZpbGUgPSBfdGhpcy5wcm9wcy5maWxlO1xuXG4gICAgICAgICAgICAgIGlmIChmaWxlKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgbnVsbCk7XG5cbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgaWYgKCEodHlwZW9mIGZpbGUgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghaXNEYXRhVVJJKGZpbGUpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA3O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZmlsZUJ5dGVTdHJpbmcgPSBkYXRhVVJJdG9CeXRlU3RyaW5nKGZpbGUpO1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgZGF0YTogZmlsZUJ5dGVTdHJpbmdcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgZGlzcGxheUNPUlNXYXJuaW5nKCk7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICB1cmw6IGZpbGVcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgaWYgKCEoZmlsZSBpbnN0YW5jZW9mIFBERkRhdGFSYW5nZVRyYW5zcG9ydCkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDExO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgIHJhbmdlOiBmaWxlXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICBpZiAoIWlzQXJyYXlCdWZmZXIoZmlsZSkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDEzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgIGRhdGE6IGZpbGVcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgIGlmICghaXNCcm93c2VyKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxOTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghKGlzQmxvYihmaWxlKSB8fCBpc0ZpbGUoZmlsZSkpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxOTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTc7XG4gICAgICAgICAgICAgIHJldHVybiBsb2FkRnJvbUZpbGUoZmlsZSk7XG5cbiAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi50MCA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgZGF0YTogX2NvbnRleHQyLnQwXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgICBpZiAoIShfdHlwZW9mKGZpbGUpICE9PSAnb2JqZWN0JykpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDIxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBhcmFtZXRlciBpbiBmaWxlLCBuZWVkIGVpdGhlciBVaW50OEFycmF5LCBzdHJpbmcgb3IgYSBwYXJhbWV0ZXIgb2JqZWN0Jyk7XG5cbiAgICAgICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgICAgIGlmICghKCFmaWxlLnVybCAmJiAhZmlsZS5kYXRhICYmICFmaWxlLnJhbmdlKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGFyYW1ldGVyIG9iamVjdDogbmVlZCBlaXRoZXIgLmRhdGEsIC5yYW5nZSBvciAudXJsJyk7XG5cbiAgICAgICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgICAgIGlmICghKHR5cGVvZiBmaWxlLnVybCA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyOTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghaXNEYXRhVVJJKGZpbGUudXJsKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB1cmwgPSBmaWxlLnVybCwgb3RoZXJQYXJhbXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoZmlsZSwgW1widXJsXCJdKTtcbiAgICAgICAgICAgICAgX2ZpbGVCeXRlU3RyaW5nID0gZGF0YVVSSXRvQnl0ZVN0cmluZyh1cmwpO1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBfZmlsZUJ5dGVTdHJpbmdcbiAgICAgICAgICAgICAgfSwgb3RoZXJQYXJhbXMpKTtcblxuICAgICAgICAgICAgY2FzZSAyODpcbiAgICAgICAgICAgICAgZGlzcGxheUNPUlNXYXJuaW5nKCk7XG5cbiAgICAgICAgICAgIGNhc2UgMjk6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIGZpbGUpO1xuXG4gICAgICAgICAgICBjYXNlIDMwOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUyKTtcbiAgICB9KSkpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInJlZ2lzdGVyUGFnZVwiLCBmdW5jdGlvbiAocGFnZUluZGV4LCByZWYpIHtcbiAgICAgIF90aGlzLnBhZ2VzW3BhZ2VJbmRleF0gPSByZWY7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwidW5yZWdpc3RlclBhZ2VcIiwgZnVuY3Rpb24gKHBhZ2VJbmRleCkge1xuICAgICAgZGVsZXRlIF90aGlzLnBhZ2VzW3BhZ2VJbmRleF07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRG9jdW1lbnQsIFt7XG4gICAga2V5OiBcImNvbXBvbmVudERpZE1vdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgdGhpcy5sb2FkRG9jdW1lbnQoKTtcbiAgICAgIHRoaXMuc2V0dXBMaW5rU2VydmljZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wb25lbnREaWRVcGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgdmFyIGZpbGUgPSB0aGlzLnByb3BzLmZpbGU7XG5cbiAgICAgIGlmIChmaWxlICE9PSBwcmV2UHJvcHMuZmlsZSkge1xuICAgICAgICB0aGlzLmxvYWREb2N1bWVudCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wb25lbnRXaWxsVW5tb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgIC8vIElmIHJlbmRlcmluZyBpcyBpbiBwcm9ncmVzcywgbGV0J3MgY2FuY2VsIGl0XG4gICAgICBjYW5jZWxSdW5uaW5nVGFzayh0aGlzLnJ1bm5pbmdUYXNrKTsgLy8gSWYgbG9hZGluZyBpcyBpbiBwcm9ncmVzcywgbGV0J3MgZGVzdHJveSBpdFxuXG4gICAgICBpZiAodGhpcy5sb2FkaW5nVGFzaykgdGhpcy5sb2FkaW5nVGFzay5kZXN0cm95KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlckNoaWxkcmVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckNoaWxkcmVuKCkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChEb2N1bWVudENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHRoaXMuY2hpbGRDb250ZXh0XG4gICAgICB9LCBjaGlsZHJlbik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlckNvbnRlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyQ29udGVudCgpIHtcbiAgICAgIHZhciBmaWxlID0gdGhpcy5wcm9wcy5maWxlO1xuICAgICAgdmFyIHBkZiA9IHRoaXMuc3RhdGUucGRmO1xuXG4gICAgICBpZiAoIWZpbGUpIHtcbiAgICAgICAgdmFyIG5vRGF0YSA9IHRoaXMucHJvcHMubm9EYXRhO1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTWVzc2FnZSwge1xuICAgICAgICAgIHR5cGU6IFwibm8tZGF0YVwiXG4gICAgICAgIH0sIHR5cGVvZiBub0RhdGEgPT09ICdmdW5jdGlvbicgPyBub0RhdGEoKSA6IG5vRGF0YSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwZGYgPT09IG51bGwpIHtcbiAgICAgICAgdmFyIGxvYWRpbmcgPSB0aGlzLnByb3BzLmxvYWRpbmc7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChNZXNzYWdlLCB7XG4gICAgICAgICAgdHlwZTogXCJsb2FkaW5nXCJcbiAgICAgICAgfSwgdHlwZW9mIGxvYWRpbmcgPT09ICdmdW5jdGlvbicgPyBsb2FkaW5nKCkgOiBsb2FkaW5nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBkZiA9PT0gZmFsc2UpIHtcbiAgICAgICAgdmFyIGVycm9yID0gdGhpcy5wcm9wcy5lcnJvcjtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KE1lc3NhZ2UsIHtcbiAgICAgICAgICB0eXBlOiBcImVycm9yXCJcbiAgICAgICAgfSwgdHlwZW9mIGVycm9yID09PSAnZnVuY3Rpb24nID8gZXJyb3IoKSA6IGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyQ2hpbGRyZW4oKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczIgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGNsYXNzTmFtZSA9IF90aGlzJHByb3BzMi5jbGFzc05hbWUsXG4gICAgICAgICAgaW5wdXRSZWYgPSBfdGhpcyRwcm9wczIuaW5wdXRSZWY7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX2V4dGVuZHMoe1xuICAgICAgICBjbGFzc05hbWU6IG1lcmdlQ2xhc3NOYW1lcygncmVhY3QtcGRmX19Eb2N1bWVudCcsIGNsYXNzTmFtZSksXG4gICAgICAgIHJlZjogaW5wdXRSZWZcbiAgICAgIH0sIHRoaXMuZXZlbnRQcm9wcyksIHRoaXMucmVuZGVyQ29udGVudCgpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2hpbGRDb250ZXh0XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgbGlua1NlcnZpY2UgPSB0aGlzLmxpbmtTZXJ2aWNlLFxuICAgICAgICAgIHJlZ2lzdGVyUGFnZSA9IHRoaXMucmVnaXN0ZXJQYWdlLFxuICAgICAgICAgIHVucmVnaXN0ZXJQYWdlID0gdGhpcy51bnJlZ2lzdGVyUGFnZTtcbiAgICAgIHZhciBfdGhpcyRwcm9wczMgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGltYWdlUmVzb3VyY2VzUGF0aCA9IF90aGlzJHByb3BzMy5pbWFnZVJlc291cmNlc1BhdGgsXG4gICAgICAgICAgcmVuZGVyTW9kZSA9IF90aGlzJHByb3BzMy5yZW5kZXJNb2RlLFxuICAgICAgICAgIHJvdGF0ZSA9IF90aGlzJHByb3BzMy5yb3RhdGU7XG4gICAgICB2YXIgcGRmID0gdGhpcy5zdGF0ZS5wZGY7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbWFnZVJlc291cmNlc1BhdGg6IGltYWdlUmVzb3VyY2VzUGF0aCxcbiAgICAgICAgbGlua1NlcnZpY2U6IGxpbmtTZXJ2aWNlLFxuICAgICAgICBwZGY6IHBkZixcbiAgICAgICAgcmVnaXN0ZXJQYWdlOiByZWdpc3RlclBhZ2UsXG4gICAgICAgIHJlbmRlck1vZGU6IHJlbmRlck1vZGUsXG4gICAgICAgIHJvdGF0ZTogcm90YXRlLFxuICAgICAgICB1bnJlZ2lzdGVyUGFnZTogdW5yZWdpc3RlclBhZ2VcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImV2ZW50UHJvcHNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvZGVzdHJ1Y3R1cmluZy1hc3NpZ25tZW50XG4gICAgICByZXR1cm4gbWFrZUV2ZW50UHJvcHModGhpcy5wcm9wcywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLnN0YXRlLnBkZjtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBhIGRvY3VtZW50IHNvdXJjZSBpcyByZXNvbHZlZCBjb3JyZWN0bHlcbiAgICAgKi9cblxuICB9XSk7XG5cbiAgcmV0dXJuIERvY3VtZW50O1xufShQdXJlQ29tcG9uZW50KTtcblxuZXhwb3J0IHsgRG9jdW1lbnQgYXMgZGVmYXVsdCB9O1xuRG9jdW1lbnQuZGVmYXVsdFByb3BzID0ge1xuICBlcnJvcjogJ0ZhaWxlZCB0byBsb2FkIFBERiBmaWxlLicsXG4gIGxvYWRpbmc6ICdMb2FkaW5nIFBERuKApicsXG4gIG5vRGF0YTogJ05vIFBERiBmaWxlIHNwZWNpZmllZC4nLFxuICBvblBhc3N3b3JkOiBmdW5jdGlvbiBvblBhc3N3b3JkKGNhbGxiYWNrLCByZWFzb24pIHtcbiAgICBzd2l0Y2ggKHJlYXNvbikge1xuICAgICAgY2FzZSBQYXNzd29yZFJlc3BvbnNlcy5ORUVEX1BBU1NXT1JEOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWFsZXJ0XG4gICAgICAgICAgdmFyIHBhc3N3b3JkID0gcHJvbXB0KCdFbnRlciB0aGUgcGFzc3dvcmQgdG8gb3BlbiB0aGlzIFBERiBmaWxlLicpO1xuICAgICAgICAgIGNhbGxiYWNrKHBhc3N3b3JkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFBhc3N3b3JkUmVzcG9uc2VzLklOQ09SUkVDVF9QQVNTV09SRDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hbGVydFxuICAgICAgICAgIHZhciBfcGFzc3dvcmQgPSBwcm9tcHQoJ0ludmFsaWQgcGFzc3dvcmQuIFBsZWFzZSB0cnkgYWdhaW4uJyk7XG5cbiAgICAgICAgICBjYWxsYmFjayhfcGFzc3dvcmQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuICB9XG59O1xudmFyIGlzRnVuY3Rpb25Pck5vZGUgPSBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm5vZGVdKTtcbkRvY3VtZW50LnByb3BUeXBlcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZXZlbnRQcm9wcyksIHt9LCB7XG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgY2xhc3NOYW1lOiBpc0NsYXNzTmFtZSxcbiAgZXJyb3I6IGlzRnVuY3Rpb25Pck5vZGUsXG4gIGZpbGU6IGlzRmlsZVByb3AsXG4gIGltYWdlUmVzb3VyY2VzUGF0aDogUHJvcFR5cGVzLnN0cmluZyxcbiAgaW5wdXRSZWY6IGlzUmVmLFxuICBsb2FkaW5nOiBpc0Z1bmN0aW9uT3JOb2RlLFxuICBub0RhdGE6IGlzRnVuY3Rpb25Pck5vZGUsXG4gIG9uSXRlbUNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25Mb2FkRXJyb3I6IFByb3BUeXBlcy5mdW5jLFxuICBvbkxvYWRQcm9ncmVzczogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uTG9hZFN1Y2Nlc3M6IFByb3BUeXBlcy5mdW5jLFxuICBvblBhc3N3b3JkOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25Tb3VyY2VFcnJvcjogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uU291cmNlU3VjY2VzczogUHJvcFR5cGVzLmZ1bmMsXG4gIHJvdGF0ZTogUHJvcFR5cGVzLm51bWJlclxufSk7IiwiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcbmV4cG9ydCBkZWZhdWx0IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KG51bGwpOyIsImltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrXCI7XG5pbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzc1wiO1xuXG52YXIgUmVmID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmVmKF9yZWYpIHtcbiAgICB2YXIgbnVtID0gX3JlZi5udW0sXG4gICAgICAgIGdlbiA9IF9yZWYuZ2VuO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlZik7XG5cbiAgICB0aGlzLm51bSA9IG51bTtcbiAgICB0aGlzLmdlbiA9IGdlbjtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhSZWYsIFt7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgdmFyIHN0ciA9IFwiXCIuY29uY2F0KHRoaXMubnVtLCBcIlJcIik7XG5cbiAgICAgIGlmICh0aGlzLmdlbiAhPT0gMCkge1xuICAgICAgICBzdHIgKz0gdGhpcy5nZW47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFJlZjtcbn0oKTtcblxuZXhwb3J0IHsgUmVmIGFzIGRlZmF1bHQgfTsiLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzXCI7XG5pbXBvcnQgX3NsaWNlZFRvQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXlcIjtcbmltcG9ydCBfcmVnZW5lcmF0b3JSdW50aW1lIGZyb20gXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiO1xuaW1wb3J0IF9hc3luY1RvR2VuZXJhdG9yIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3luY1RvR2VuZXJhdG9yXCI7XG5pbXBvcnQgX2NsYXNzQ2FsbENoZWNrIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVja1wiO1xuaW1wb3J0IF9jcmVhdGVDbGFzcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3NcIjtcbmltcG9ydCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3NlcnRUaGlzSW5pdGlhbGl6ZWRcIjtcbmltcG9ydCBfaW5oZXJpdHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2luaGVyaXRzXCI7XG5pbXBvcnQgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4gZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIjtcbmltcG9ydCBfZ2V0UHJvdG90eXBlT2YgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2dldFByb3RvdHlwZU9mXCI7XG5pbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmltcG9ydCBSZWFjdCwgeyBQdXJlQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBEb2N1bWVudENvbnRleHQgZnJvbSAnLi9Eb2N1bWVudENvbnRleHQnO1xuaW1wb3J0IE91dGxpbmVDb250ZXh0IGZyb20gJy4vT3V0bGluZUNvbnRleHQnO1xuaW1wb3J0IFJlZiBmcm9tICcuL1JlZic7XG5pbXBvcnQgeyBpc0RlZmluZWQgfSBmcm9tICcuL3NoYXJlZC91dGlscyc7XG5pbXBvcnQgeyBpc1BkZiB9IGZyb20gJy4vc2hhcmVkL3Byb3BUeXBlcyc7XG5leHBvcnQgdmFyIE91dGxpbmVJdGVtSW50ZXJuYWwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9QdXJlQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhPdXRsaW5lSXRlbUludGVybmFsLCBfUHVyZUNvbXBvbmVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihPdXRsaW5lSXRlbUludGVybmFsKTtcblxuICBmdW5jdGlvbiBPdXRsaW5lSXRlbUludGVybmFsKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBPdXRsaW5lSXRlbUludGVybmFsKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsLmFwcGx5KF9zdXBlciwgW3RoaXNdLmNvbmNhdChhcmdzKSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiZ2V0RGVzdGluYXRpb25cIiwgLyojX19QVVJFX18qL19hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMsIGl0ZW0sIHBkZjtcblxuICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX3RoaXMkcHJvcHMgPSBfdGhpcy5wcm9wcywgaXRlbSA9IF90aGlzJHByb3BzLml0ZW0sIHBkZiA9IF90aGlzJHByb3BzLnBkZjtcblxuICAgICAgICAgICAgICBpZiAoaXNEZWZpbmVkKF90aGlzLmRlc3RpbmF0aW9uKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCEodHlwZW9mIGl0ZW0uZGVzdCA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgcmV0dXJuIHBkZi5nZXREZXN0aW5hdGlvbihpdGVtLmRlc3QpO1xuXG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIF90aGlzLmRlc3RpbmF0aW9uID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIF90aGlzLmRlc3RpbmF0aW9uID0gaXRlbS5kZXN0O1xuXG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgX3RoaXMuZGVzdGluYXRpb24pO1xuXG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZSk7XG4gICAgfSkpKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJnZXRQYWdlSW5kZXhcIiwgLyojX19QVVJFX18qL19hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKCkge1xuICAgICAgdmFyIHBkZiwgZGVzdGluYXRpb24sIF9kZXN0aW5hdGlvbiwgcmVmO1xuXG4gICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgcGRmID0gX3RoaXMucHJvcHMucGRmO1xuXG4gICAgICAgICAgICAgIGlmIChpc0RlZmluZWQoX3RoaXMucGFnZUluZGV4KSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDQ7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy5nZXREZXN0aW5hdGlvbigpO1xuXG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIGRlc3RpbmF0aW9uID0gX2NvbnRleHQyLnNlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKCFkZXN0aW5hdGlvbikge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfZGVzdGluYXRpb24gPSBfc2xpY2VkVG9BcnJheShkZXN0aW5hdGlvbiwgMSksIHJlZiA9IF9kZXN0aW5hdGlvblswXTtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA5O1xuICAgICAgICAgICAgICByZXR1cm4gcGRmLmdldFBhZ2VJbmRleChuZXcgUmVmKHJlZikpO1xuXG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgIF90aGlzLnBhZ2VJbmRleCA9IF9jb250ZXh0Mi5zZW50O1xuXG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBfdGhpcy5wYWdlSW5kZXgpO1xuXG4gICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUyKTtcbiAgICB9KSkpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImdldFBhZ2VOdW1iZXJcIiwgLyojX19QVVJFX18qL19hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKCkge1xuICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGlmIChpc0RlZmluZWQoX3RoaXMucGFnZU51bWJlcikpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDM7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy5nZXRQYWdlSW5kZXgoKTtcblxuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBfY29udGV4dDMudDAgPSBfY29udGV4dDMuc2VudDtcbiAgICAgICAgICAgICAgX3RoaXMucGFnZU51bWJlciA9IF9jb250ZXh0My50MCArIDE7XG5cbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgX3RoaXMucGFnZU51bWJlcik7XG5cbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlMyk7XG4gICAgfSkpKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJvbkNsaWNrXCIsIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3JlZjQgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlNChldmVudCkge1xuICAgICAgICB2YXIgb25DbGljaywgcGFnZUluZGV4LCBwYWdlTnVtYmVyO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBvbkNsaWNrID0gX3RoaXMucHJvcHMub25DbGljaztcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZ2V0UGFnZUluZGV4KCk7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIHBhZ2VJbmRleCA9IF9jb250ZXh0NC5zZW50O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZ2V0UGFnZU51bWJlcigpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICBwYWdlTnVtYmVyID0gX2NvbnRleHQ0LnNlbnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAob25DbGljaykge1xuICAgICAgICAgICAgICAgICAgb25DbGljayh7XG4gICAgICAgICAgICAgICAgICAgIHBhZ2VJbmRleDogcGFnZUluZGV4LFxuICAgICAgICAgICAgICAgICAgICBwYWdlTnVtYmVyOiBwYWdlTnVtYmVyXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNCk7XG4gICAgICB9KSk7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoX3gpIHtcbiAgICAgICAgcmV0dXJuIF9yZWY0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH0oKSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoT3V0bGluZUl0ZW1JbnRlcm5hbCwgW3tcbiAgICBrZXk6IFwicmVuZGVyU3ViaXRlbXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyU3ViaXRlbXMoKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMyID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBpdGVtID0gX3RoaXMkcHJvcHMyLml0ZW0sXG4gICAgICAgICAgb3RoZXJQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfdGhpcyRwcm9wczIsIFtcIml0ZW1cIl0pO1xuXG4gICAgICBpZiAoIWl0ZW0uaXRlbXMgfHwgIWl0ZW0uaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3ViaXRlbXMgPSBpdGVtLml0ZW1zO1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwidWxcIiwgbnVsbCwgc3ViaXRlbXMubWFwKGZ1bmN0aW9uIChzdWJpdGVtLCBzdWJpdGVtSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KE91dGxpbmVJdGVtSW50ZXJuYWwsIF9leHRlbmRzKHtcbiAgICAgICAgICBrZXk6IHR5cGVvZiBzdWJpdGVtLmRlc3RpbmF0aW9uID09PSAnc3RyaW5nJyA/IHN1Yml0ZW0uZGVzdGluYXRpb24gOiBzdWJpdGVtSW5kZXgsXG4gICAgICAgICAgaXRlbTogc3ViaXRlbVxuICAgICAgICB9LCBvdGhlclByb3BzKSk7XG4gICAgICB9KSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgaXRlbSA9IHRoaXMucHJvcHMuaXRlbTtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIGpzeC1hMTF5L2FuY2hvci1pcy12YWxpZCAqL1xuXG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaVwiLCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImFcIiwge1xuICAgICAgICBocmVmOiBcIiNcIixcbiAgICAgICAgb25DbGljazogdGhpcy5vbkNsaWNrXG4gICAgICB9LCBpdGVtLnRpdGxlKSwgdGhpcy5yZW5kZXJTdWJpdGVtcygpKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gT3V0bGluZUl0ZW1JbnRlcm5hbDtcbn0oUHVyZUNvbXBvbmVudCk7XG52YXIgaXNEZXN0aW5hdGlvbiA9IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5hbnkpXSk7XG5PdXRsaW5lSXRlbUludGVybmFsLnByb3BUeXBlcyA9IHtcbiAgaXRlbTogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBkZXN0OiBpc0Rlc3RpbmF0aW9uLFxuICAgIGl0ZW1zOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc2hhcGUoe1xuICAgICAgZGVzdDogaXNEZXN0aW5hdGlvbixcbiAgICAgIHRpdGxlOiBQcm9wVHlwZXMuc3RyaW5nXG4gICAgfSkpLFxuICAgIHRpdGxlOiBQcm9wVHlwZXMuc3RyaW5nXG4gIH0pLmlzUmVxdWlyZWQsXG4gIG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICBwZGY6IGlzUGRmLmlzUmVxdWlyZWRcbn07XG5cbnZhciBPdXRsaW5lSXRlbSA9IGZ1bmN0aW9uIE91dGxpbmVJdGVtKHByb3BzKSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChEb2N1bWVudENvbnRleHQuQ29uc3VtZXIsIG51bGwsIGZ1bmN0aW9uIChkb2N1bWVudENvbnRleHQpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoT3V0bGluZUNvbnRleHQuQ29uc3VtZXIsIG51bGwsIGZ1bmN0aW9uIChvdXRsaW5lQ29udGV4dCkge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KE91dGxpbmVJdGVtSW50ZXJuYWwsIF9leHRlbmRzKHt9LCBkb2N1bWVudENvbnRleHQsIG91dGxpbmVDb250ZXh0LCBwcm9wcykpO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IE91dGxpbmVJdGVtOyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9yZWdlbmVyYXRvclJ1bnRpbWUgZnJvbSBcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCI7XG5pbXBvcnQgX2FzeW5jVG9HZW5lcmF0b3IgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FzeW5jVG9HZW5lcmF0b3JcIjtcbmltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrXCI7XG5pbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzc1wiO1xuaW1wb3J0IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2Fzc2VydFRoaXNJbml0aWFsaXplZFwiO1xuaW1wb3J0IF9pbmhlcml0cyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHNcIjtcbmltcG9ydCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiO1xuaW1wb3J0IF9nZXRQcm90b3R5cGVPZiBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZ2V0UHJvdG90eXBlT2ZcIjtcbmltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmltcG9ydCBSZWFjdCwgeyBQdXJlQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBtYWtlQ2FuY2VsbGFibGUgZnJvbSAnbWFrZS1jYW5jZWxsYWJsZS1wcm9taXNlJztcbmltcG9ydCBtYWtlRXZlbnRQcm9wcyBmcm9tICdtYWtlLWV2ZW50LXByb3BzJztcbmltcG9ydCBtZXJnZUNsYXNzTmFtZXMgZnJvbSAnbWVyZ2UtY2xhc3MtbmFtZXMnO1xuaW1wb3J0IERvY3VtZW50Q29udGV4dCBmcm9tICcuL0RvY3VtZW50Q29udGV4dCc7XG5pbXBvcnQgT3V0bGluZUNvbnRleHQgZnJvbSAnLi9PdXRsaW5lQ29udGV4dCc7XG5pbXBvcnQgT3V0bGluZUl0ZW0gZnJvbSAnLi9PdXRsaW5lSXRlbSc7XG5pbXBvcnQgeyBjYW5jZWxSdW5uaW5nVGFzaywgZXJyb3JPbkRldiB9IGZyb20gJy4vc2hhcmVkL3V0aWxzJztcbmltcG9ydCB7IGV2ZW50UHJvcHMsIGlzQ2xhc3NOYW1lLCBpc1BkZiwgaXNSZWYgfSBmcm9tICcuL3NoYXJlZC9wcm9wVHlwZXMnO1xuZXhwb3J0IHZhciBPdXRsaW5lSW50ZXJuYWwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9QdXJlQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhPdXRsaW5lSW50ZXJuYWwsIF9QdXJlQ29tcG9uZW50KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKE91dGxpbmVJbnRlcm5hbCk7XG5cbiAgZnVuY3Rpb24gT3V0bGluZUludGVybmFsKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBPdXRsaW5lSW50ZXJuYWwpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwuYXBwbHkoX3N1cGVyLCBbdGhpc10uY29uY2F0KGFyZ3MpKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJzdGF0ZVwiLCB7XG4gICAgICBvdXRsaW5lOiBudWxsXG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwibG9hZE91dGxpbmVcIiwgLyojX19QVVJFX18qL19hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICB2YXIgcGRmLCBjYW5jZWxsYWJsZSwgb3V0bGluZTtcbiAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHBkZiA9IF90aGlzLnByb3BzLnBkZjtcblxuICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAocHJldlN0YXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2U3RhdGUub3V0bGluZSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIG91dGxpbmU6IG51bGxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMjtcbiAgICAgICAgICAgICAgY2FuY2VsbGFibGUgPSBtYWtlQ2FuY2VsbGFibGUocGRmLmdldE91dGxpbmUoKSk7XG4gICAgICAgICAgICAgIF90aGlzLnJ1bm5pbmdUYXNrID0gY2FuY2VsbGFibGU7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA3O1xuICAgICAgICAgICAgICByZXR1cm4gY2FuY2VsbGFibGUucHJvbWlzZTtcblxuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBvdXRsaW5lID0gX2NvbnRleHQuc2VudDtcblxuICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgb3V0bGluZTogb3V0bGluZVxuICAgICAgICAgICAgICB9LCBfdGhpcy5vbkxvYWRTdWNjZXNzKTtcblxuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTE7XG4gICAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSgyKTtcblxuICAgICAgICAgICAgICBfdGhpcy5vbkxvYWRFcnJvcihfY29udGV4dC50MCk7XG5cbiAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlLCBudWxsLCBbWzIsIDExXV0pO1xuICAgIH0pKSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwib25Mb2FkU3VjY2Vzc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgb25Mb2FkU3VjY2VzcyA9IF90aGlzLnByb3BzLm9uTG9hZFN1Y2Nlc3M7XG4gICAgICB2YXIgb3V0bGluZSA9IF90aGlzLnN0YXRlLm91dGxpbmU7XG4gICAgICBpZiAob25Mb2FkU3VjY2Vzcykgb25Mb2FkU3VjY2VzcyhvdXRsaW5lKTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJvbkxvYWRFcnJvclwiLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgb3V0bGluZTogZmFsc2VcbiAgICAgIH0pO1xuXG4gICAgICBlcnJvck9uRGV2KGVycm9yKTtcbiAgICAgIHZhciBvbkxvYWRFcnJvciA9IF90aGlzLnByb3BzLm9uTG9hZEVycm9yO1xuICAgICAgaWYgKG9uTG9hZEVycm9yKSBvbkxvYWRFcnJvcihlcnJvcik7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwib25JdGVtQ2xpY2tcIiwgZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICB2YXIgcGFnZUluZGV4ID0gX3JlZjIucGFnZUluZGV4LFxuICAgICAgICAgIHBhZ2VOdW1iZXIgPSBfcmVmMi5wYWdlTnVtYmVyO1xuICAgICAgdmFyIG9uSXRlbUNsaWNrID0gX3RoaXMucHJvcHMub25JdGVtQ2xpY2s7XG5cbiAgICAgIGlmIChvbkl0ZW1DbGljaykge1xuICAgICAgICBvbkl0ZW1DbGljayh7XG4gICAgICAgICAgcGFnZUluZGV4OiBwYWdlSW5kZXgsXG4gICAgICAgICAgcGFnZU51bWJlcjogcGFnZU51bWJlclxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhPdXRsaW5lSW50ZXJuYWwsIFt7XG4gICAga2V5OiBcImNvbXBvbmVudERpZE1vdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgdmFyIHBkZiA9IHRoaXMucHJvcHMucGRmO1xuXG4gICAgICBpZiAoIXBkZikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRlZCB0byBsb2FkIGFuIG91dGxpbmUsIGJ1dCBubyBkb2N1bWVudCB3YXMgc3BlY2lmaWVkLicpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxvYWRPdXRsaW5lKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBvbmVudERpZFVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICB2YXIgcGRmID0gdGhpcy5wcm9wcy5wZGY7XG5cbiAgICAgIGlmIChwcmV2UHJvcHMucGRmICYmIHBkZiAhPT0gcHJldlByb3BzLnBkZikge1xuICAgICAgICB0aGlzLmxvYWRPdXRsaW5lKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBvbmVudFdpbGxVbm1vdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgY2FuY2VsUnVubmluZ1Rhc2sodGhpcy5ydW5uaW5nVGFzayk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlck91dGxpbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyT3V0bGluZSgpIHtcbiAgICAgIHZhciBvdXRsaW5lID0gdGhpcy5zdGF0ZS5vdXRsaW5lO1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwidWxcIiwgbnVsbCwgb3V0bGluZS5tYXAoZnVuY3Rpb24gKGl0ZW0sIGl0ZW1JbmRleCkge1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoT3V0bGluZUl0ZW0sIHtcbiAgICAgICAgICBrZXk6IHR5cGVvZiBpdGVtLmRlc3RpbmF0aW9uID09PSAnc3RyaW5nJyA/IGl0ZW0uZGVzdGluYXRpb24gOiBpdGVtSW5kZXgsXG4gICAgICAgICAgaXRlbTogaXRlbVxuICAgICAgICB9KTtcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBwZGYgPSB0aGlzLnByb3BzLnBkZjtcbiAgICAgIHZhciBvdXRsaW5lID0gdGhpcy5zdGF0ZS5vdXRsaW5lO1xuXG4gICAgICBpZiAoIXBkZiB8fCAhb3V0bGluZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBjbGFzc05hbWUgPSBfdGhpcyRwcm9wcy5jbGFzc05hbWUsXG4gICAgICAgICAgaW5wdXRSZWYgPSBfdGhpcyRwcm9wcy5pbnB1dFJlZjtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfZXh0ZW5kcyh7XG4gICAgICAgIGNsYXNzTmFtZTogbWVyZ2VDbGFzc05hbWVzKCdyZWFjdC1wZGZfX091dGxpbmUnLCBjbGFzc05hbWUpLFxuICAgICAgICByZWY6IGlucHV0UmVmXG4gICAgICB9LCB0aGlzLmV2ZW50UHJvcHMpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChPdXRsaW5lQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogdGhpcy5jaGlsZENvbnRleHRcbiAgICAgIH0sIHRoaXMucmVuZGVyT3V0bGluZSgpKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNoaWxkQ29udGV4dFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb25DbGljazogdGhpcy5vbkl0ZW1DbGlja1xuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXZlbnRQcm9wc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9kZXN0cnVjdHVyaW5nLWFzc2lnbm1lbnRcbiAgICAgIHJldHVybiBtYWtlRXZlbnRQcm9wcyh0aGlzLnByb3BzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczIuc3RhdGUub3V0bGluZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBhbiBvdXRsaW5lIGlzIHJlYWQgc3VjY2Vzc2Z1bGx5XG4gICAgICovXG5cbiAgfV0pO1xuXG4gIHJldHVybiBPdXRsaW5lSW50ZXJuYWw7XG59KFB1cmVDb21wb25lbnQpO1xuT3V0bGluZUludGVybmFsLnByb3BUeXBlcyA9IF9vYmplY3RTcHJlYWQoe1xuICBjbGFzc05hbWU6IGlzQ2xhc3NOYW1lLFxuICBpbnB1dFJlZjogaXNSZWYsXG4gIG9uSXRlbUNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25Mb2FkRXJyb3I6IFByb3BUeXBlcy5mdW5jLFxuICBvbkxvYWRTdWNjZXNzOiBQcm9wVHlwZXMuZnVuYyxcbiAgcGRmOiBpc1BkZlxufSwgZXZlbnRQcm9wcyk7XG5cbmZ1bmN0aW9uIE91dGxpbmUocHJvcHMsIHJlZikge1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRG9jdW1lbnRDb250ZXh0LkNvbnN1bWVyLCBudWxsLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChPdXRsaW5lSW50ZXJuYWwsIF9leHRlbmRzKHtcbiAgICAgIHJlZjogcmVmXG4gICAgfSwgY29udGV4dCwgcHJvcHMpKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKE91dGxpbmUpOyIsIi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IG1lcmdlcyBSZWFjdCByZWZzIGludG8gb25lLlxuICogU3VwcG9ydHMgYm90aCBmdW5jdGlvbnMgYW5kIHJlZiBvYmplY3RzIGNyZWF0ZWQgdXNpbmcgY3JlYXRlUmVmKCkgYW5kIHVzZVJlZigpLlxuICpcbiAqIFVzYWdlOlxuICogYGBganN4XG4gKiA8ZGl2IHJlZj17bWVyZ2VSZWZzKHJlZjEsIHJlZjIsIHJlZjMpfSAvPlxuICogYGBgXG4gKlxuICogQHBhcmFtIHsuLi5BcnJheTxGdW5jdGlvbnxvYmplY3Q+fSBpbnB1dFJlZnMgQXJyYXkgb2YgcmVmc1xuICogQHJldHVybnMge0Z1bmN0aW9ufSBNZXJnZWQgcmVmc1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtZXJnZVJlZnMoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBpbnB1dFJlZnMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgaW5wdXRSZWZzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgdmFyIGZpbHRlcmVkSW5wdXRSZWZzID0gaW5wdXRSZWZzLmZpbHRlcihCb29sZWFuKTtcblxuICBpZiAoZmlsdGVyZWRJbnB1dFJlZnMubGVuZ3RoIDw9IDEpIHtcbiAgICByZXR1cm4gZmlsdGVyZWRJbnB1dFJlZnNbMF07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkUmVmcyhyZWYpIHtcbiAgICBmaWx0ZXJlZElucHV0UmVmcy5mb3JFYWNoKGZ1bmN0aW9uIChpbnB1dFJlZikge1xuICAgICAgaWYgKHR5cGVvZiBpbnB1dFJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpbnB1dFJlZihyZWYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIGlucHV0UmVmLmN1cnJlbnQgPSByZWY7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IiwiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcbmV4cG9ydCBkZWZhdWx0IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KG51bGwpOyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9jbGFzc0NhbGxDaGVjayBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2tcIjtcbmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzXCI7XG5pbXBvcnQgX2Fzc2VydFRoaXNJbml0aWFsaXplZCBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXNzZXJ0VGhpc0luaXRpYWxpemVkXCI7XG5pbXBvcnQgX2luaGVyaXRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pbmhlcml0c1wiO1xuaW1wb3J0IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCI7XG5pbXBvcnQgX2dldFByb3RvdHlwZU9mIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9nZXRQcm90b3R5cGVPZlwiO1xuaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5pbXBvcnQgUmVhY3QsIHsgUHVyZUNvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgbWVyZ2VSZWZzIGZyb20gJ21lcmdlLXJlZnMnO1xuaW1wb3J0IFBhZ2VDb250ZXh0IGZyb20gJy4uL1BhZ2VDb250ZXh0JztcbmltcG9ydCB7IGVycm9yT25EZXYsIGdldFBpeGVsUmF0aW8sIGlzQ2FuY2VsRXhjZXB0aW9uLCBtYWtlUGFnZUNhbGxiYWNrIH0gZnJvbSAnLi4vc2hhcmVkL3V0aWxzJztcbmltcG9ydCB7IGlzUGFnZSwgaXNSZWYsIGlzUm90YXRlIH0gZnJvbSAnLi4vc2hhcmVkL3Byb3BUeXBlcyc7XG5leHBvcnQgdmFyIFBhZ2VDYW52YXNJbnRlcm5hbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1B1cmVDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFBhZ2VDYW52YXNJbnRlcm5hbCwgX1B1cmVDb21wb25lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoUGFnZUNhbnZhc0ludGVybmFsKTtcblxuICBmdW5jdGlvbiBQYWdlQ2FudmFzSW50ZXJuYWwoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBhZ2VDYW52YXNJbnRlcm5hbCk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbC5hcHBseShfc3VwZXIsIFt0aGlzXS5jb25jYXQoYXJncykpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm9uUmVuZGVyU3VjY2Vzc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICBvblJlbmRlclN1Y2Nlc3MgPSBfdGhpcyRwcm9wcy5vblJlbmRlclN1Y2Nlc3MsXG4gICAgICAgICAgcGFnZSA9IF90aGlzJHByb3BzLnBhZ2UsXG4gICAgICAgICAgc2NhbGUgPSBfdGhpcyRwcm9wcy5zY2FsZTtcbiAgICAgIGlmIChvblJlbmRlclN1Y2Nlc3MpIG9uUmVuZGVyU3VjY2VzcyhtYWtlUGFnZUNhbGxiYWNrKHBhZ2UsIHNjYWxlKSk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwib25SZW5kZXJFcnJvclwiLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0NhbmNlbEV4Y2VwdGlvbihlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBlcnJvck9uRGV2KGVycm9yKTtcbiAgICAgIHZhciBvblJlbmRlckVycm9yID0gX3RoaXMucHJvcHMub25SZW5kZXJFcnJvcjtcbiAgICAgIGlmIChvblJlbmRlckVycm9yKSBvblJlbmRlckVycm9yKGVycm9yKTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJkcmF3UGFnZU9uQ2FudmFzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfYXNzZXJ0VGhpc0luaXRpYWxpemUgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSxcbiAgICAgICAgICBjYW52YXMgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemUuY2FudmFzTGF5ZXI7XG5cbiAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2Fzc2VydFRoaXNJbml0aWFsaXplMiA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLFxuICAgICAgICAgIHJlbmRlclZpZXdwb3J0ID0gX2Fzc2VydFRoaXNJbml0aWFsaXplMi5yZW5kZXJWaWV3cG9ydCxcbiAgICAgICAgICB2aWV3cG9ydCA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZTIudmlld3BvcnQ7XG5cbiAgICAgIHZhciBfdGhpcyRwcm9wczIgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICBwYWdlID0gX3RoaXMkcHJvcHMyLnBhZ2UsXG4gICAgICAgICAgcmVuZGVySW50ZXJhY3RpdmVGb3JtcyA9IF90aGlzJHByb3BzMi5yZW5kZXJJbnRlcmFjdGl2ZUZvcm1zO1xuICAgICAgY2FudmFzLndpZHRoID0gcmVuZGVyVmlld3BvcnQud2lkdGg7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gcmVuZGVyVmlld3BvcnQuaGVpZ2h0O1xuICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gXCJcIi5jb25jYXQoTWF0aC5mbG9vcih2aWV3cG9ydC53aWR0aCksIFwicHhcIik7XG4gICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gXCJcIi5jb25jYXQoTWF0aC5mbG9vcih2aWV3cG9ydC5oZWlnaHQpLCBcInB4XCIpO1xuICAgICAgdmFyIHJlbmRlckNvbnRleHQgPSB7XG4gICAgICAgIGdldCBjYW52YXNDb250ZXh0KCkge1xuICAgICAgICAgIHJldHVybiBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgfSxcblxuICAgICAgICB2aWV3cG9ydDogcmVuZGVyVmlld3BvcnQsXG4gICAgICAgIHJlbmRlckludGVyYWN0aXZlRm9ybXM6IHJlbmRlckludGVyYWN0aXZlRm9ybXNcbiAgICAgIH07IC8vIElmIGFub3RoZXIgcmVuZGVyIGlzIGluIHByb2dyZXNzLCBsZXQncyBjYW5jZWwgaXRcblxuICAgICAgX3RoaXMuY2FuY2VsUmVuZGVyaW5nVGFzaygpO1xuXG4gICAgICBfdGhpcy5yZW5kZXJlciA9IHBhZ2UucmVuZGVyKHJlbmRlckNvbnRleHQpO1xuICAgICAgcmV0dXJuIF90aGlzLnJlbmRlcmVyLnByb21pc2UudGhlbihfdGhpcy5vblJlbmRlclN1Y2Nlc3MpW1wiY2F0Y2hcIl0oX3RoaXMub25SZW5kZXJFcnJvcik7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUGFnZUNhbnZhc0ludGVybmFsLCBbe1xuICAgIGtleTogXCJjb21wb25lbnREaWRNb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgIHRoaXMuZHJhd1BhZ2VPbkNhbnZhcygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wb25lbnREaWRVcGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgdmFyIF90aGlzJHByb3BzMyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgcGFnZSA9IF90aGlzJHByb3BzMy5wYWdlLFxuICAgICAgICAgIHJlbmRlckludGVyYWN0aXZlRm9ybXMgPSBfdGhpcyRwcm9wczMucmVuZGVySW50ZXJhY3RpdmVGb3JtcztcblxuICAgICAgaWYgKHJlbmRlckludGVyYWN0aXZlRm9ybXMgIT09IHByZXZQcm9wcy5yZW5kZXJJbnRlcmFjdGl2ZUZvcm1zKSB7XG4gICAgICAgIC8vIEVuc3VyZXMgdGhlIGNhbnZhcyB3aWxsIGJlIHJlLXJlbmRlcmVkIGZyb20gc2NyYXRjaC4gT3RoZXJ3aXNlIGFsbCBmb3JtIGRhdGEgd2lsbCBzdGF5LlxuICAgICAgICBwYWdlLmNsZWFudXAoKTtcbiAgICAgICAgdGhpcy5kcmF3UGFnZU9uQ2FudmFzKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBvbmVudFdpbGxVbm1vdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgdGhpcy5jYW5jZWxSZW5kZXJpbmdUYXNrKCk7XG4gICAgICAvKipcbiAgICAgICAqIFplcm9pbmcgdGhlIHdpZHRoIGFuZCBoZWlnaHQgY2F1c2UgbW9zdCBicm93c2VycyB0byByZWxlYXNlIGdyYXBoaWNzXG4gICAgICAgKiByZXNvdXJjZXMgaW1tZWRpYXRlbHksIHdoaWNoIGNhbiBncmVhdGx5IHJlZHVjZSBtZW1vcnkgY29uc3VtcHRpb24uXG4gICAgICAgKi9cblxuICAgICAgaWYgKHRoaXMuY2FudmFzTGF5ZXIpIHtcbiAgICAgICAgdGhpcy5jYW52YXNMYXllci53aWR0aCA9IDA7XG4gICAgICAgIHRoaXMuY2FudmFzTGF5ZXIuaGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5jYW52YXNMYXllciA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbmNlbFJlbmRlcmluZ1Rhc2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FuY2VsUmVuZGVyaW5nVGFzaygpIHtcbiAgICAgIGlmICh0aGlzLnJlbmRlcmVyKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuY2FuY2VsKCk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBhIHBhZ2UgaXMgcmVuZGVyZWQgc3VjY2Vzc2Z1bGx5LlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgY2FudmFzUmVmID0gdGhpcy5wcm9wcy5jYW52YXNSZWY7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiwge1xuICAgICAgICBjbGFzc05hbWU6IFwicmVhY3QtcGRmX19QYWdlX19jYW52YXNcIixcbiAgICAgICAgZGlyOiBcImx0clwiLFxuICAgICAgICByZWY6IG1lcmdlUmVmcyhjYW52YXNSZWYsIGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICBfdGhpczIuY2FudmFzTGF5ZXIgPSByZWY7XG4gICAgICAgIH0pLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgICAgICAgdXNlclNlbGVjdDogJ25vbmUnXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJWaWV3cG9ydFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzNCA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgcGFnZSA9IF90aGlzJHByb3BzNC5wYWdlLFxuICAgICAgICAgIHJvdGF0ZSA9IF90aGlzJHByb3BzNC5yb3RhdGUsXG4gICAgICAgICAgc2NhbGUgPSBfdGhpcyRwcm9wczQuc2NhbGU7XG4gICAgICB2YXIgcGl4ZWxSYXRpbyA9IGdldFBpeGVsUmF0aW8oKTtcbiAgICAgIHJldHVybiBwYWdlLmdldFZpZXdwb3J0KHtcbiAgICAgICAgc2NhbGU6IHNjYWxlICogcGl4ZWxSYXRpbyxcbiAgICAgICAgcm90YXRpb246IHJvdGF0ZVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZpZXdwb3J0XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHM1ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBwYWdlID0gX3RoaXMkcHJvcHM1LnBhZ2UsXG4gICAgICAgICAgcm90YXRlID0gX3RoaXMkcHJvcHM1LnJvdGF0ZSxcbiAgICAgICAgICBzY2FsZSA9IF90aGlzJHByb3BzNS5zY2FsZTtcbiAgICAgIHJldHVybiBwYWdlLmdldFZpZXdwb3J0KHtcbiAgICAgICAgc2NhbGU6IHNjYWxlLFxuICAgICAgICByb3RhdGlvbjogcm90YXRlXG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUGFnZUNhbnZhc0ludGVybmFsO1xufShQdXJlQ29tcG9uZW50KTtcblBhZ2VDYW52YXNJbnRlcm5hbC5wcm9wVHlwZXMgPSB7XG4gIGNhbnZhc1JlZjogaXNSZWYsXG4gIG9uUmVuZGVyRXJyb3I6IFByb3BUeXBlcy5mdW5jLFxuICBvblJlbmRlclN1Y2Nlc3M6IFByb3BUeXBlcy5mdW5jLFxuICBwYWdlOiBpc1BhZ2UuaXNSZXF1aXJlZCxcbiAgcmVuZGVySW50ZXJhY3RpdmVGb3JtczogUHJvcFR5cGVzLmJvb2wsXG4gIHJvdGF0ZTogaXNSb3RhdGUsXG4gIHNjYWxlOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWRcbn07XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBQYWdlQ2FudmFzKHByb3BzKSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChQYWdlQ29udGV4dC5Db25zdW1lciwgbnVsbCwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUGFnZUNhbnZhc0ludGVybmFsLCBfZXh0ZW5kcyh7fSwgY29udGV4dCwgcHJvcHMpKTtcbiAgfSk7XG59IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX2NsYXNzQ2FsbENoZWNrIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVja1wiO1xuaW1wb3J0IF9jcmVhdGVDbGFzcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3NcIjtcbmltcG9ydCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3NlcnRUaGlzSW5pdGlhbGl6ZWRcIjtcbmltcG9ydCBfaW5oZXJpdHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2luaGVyaXRzXCI7XG5pbXBvcnQgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4gZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIjtcbmltcG9ydCBfZ2V0UHJvdG90eXBlT2YgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2dldFByb3RvdHlwZU9mXCI7XG5pbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmltcG9ydCBSZWFjdCwgeyBQdXJlQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCAqIGFzIHBkZmpzIGZyb20gJ3BkZmpzLWRpc3QnO1xuaW1wb3J0IFBhZ2VDb250ZXh0IGZyb20gJy4uL1BhZ2VDb250ZXh0JztcbmltcG9ydCB7IGVycm9yT25EZXYsIGlzQ2FuY2VsRXhjZXB0aW9uLCBtYWtlUGFnZUNhbGxiYWNrIH0gZnJvbSAnLi4vc2hhcmVkL3V0aWxzJztcbmltcG9ydCB7IGlzUGFnZSwgaXNSb3RhdGUgfSBmcm9tICcuLi9zaGFyZWQvcHJvcFR5cGVzJztcbmV4cG9ydCB2YXIgUGFnZVNWR0ludGVybmFsID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUHVyZUNvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoUGFnZVNWR0ludGVybmFsLCBfUHVyZUNvbXBvbmVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihQYWdlU1ZHSW50ZXJuYWwpO1xuXG4gIGZ1bmN0aW9uIFBhZ2VTVkdJbnRlcm5hbCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGFnZVNWR0ludGVybmFsKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsLmFwcGx5KF9zdXBlciwgW3RoaXNdLmNvbmNhdChhcmdzKSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwic3RhdGVcIiwge1xuICAgICAgc3ZnOiBudWxsXG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwib25SZW5kZXJTdWNjZXNzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IF90aGlzLnByb3BzLFxuICAgICAgICAgIG9uUmVuZGVyU3VjY2VzcyA9IF90aGlzJHByb3BzLm9uUmVuZGVyU3VjY2VzcyxcbiAgICAgICAgICBwYWdlID0gX3RoaXMkcHJvcHMucGFnZSxcbiAgICAgICAgICBzY2FsZSA9IF90aGlzJHByb3BzLnNjYWxlO1xuICAgICAgaWYgKG9uUmVuZGVyU3VjY2Vzcykgb25SZW5kZXJTdWNjZXNzKG1ha2VQYWdlQ2FsbGJhY2socGFnZSwgc2NhbGUpKTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJvblJlbmRlckVycm9yXCIsIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgaWYgKGlzQ2FuY2VsRXhjZXB0aW9uKGVycm9yKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGVycm9yT25EZXYoZXJyb3IpO1xuICAgICAgdmFyIG9uUmVuZGVyRXJyb3IgPSBfdGhpcy5wcm9wcy5vblJlbmRlckVycm9yO1xuICAgICAgaWYgKG9uUmVuZGVyRXJyb3IpIG9uUmVuZGVyRXJyb3IoZXJyb3IpO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInJlbmRlclNWR1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGFnZSA9IF90aGlzLnByb3BzLnBhZ2U7XG4gICAgICBfdGhpcy5yZW5kZXJlciA9IHBhZ2UuZ2V0T3BlcmF0b3JMaXN0KCk7XG4gICAgICByZXR1cm4gX3RoaXMucmVuZGVyZXIudGhlbihmdW5jdGlvbiAob3BlcmF0b3JMaXN0KSB7XG4gICAgICAgIHZhciBzdmdHZnggPSBuZXcgcGRmanMuU1ZHR3JhcGhpY3MocGFnZS5jb21tb25PYmpzLCBwYWdlLm9ianMpO1xuICAgICAgICBfdGhpcy5yZW5kZXJlciA9IHN2Z0dmeC5nZXRTVkcob3BlcmF0b3JMaXN0LCBfdGhpcy52aWV3cG9ydCkudGhlbihmdW5jdGlvbiAoc3ZnKSB7XG4gICAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgc3ZnOiBzdmdcbiAgICAgICAgICB9LCBfdGhpcy5vblJlbmRlclN1Y2Nlc3MpO1xuICAgICAgICB9KVtcImNhdGNoXCJdKF90aGlzLm9uUmVuZGVyRXJyb3IpO1xuICAgICAgfSlbXCJjYXRjaFwiXShfdGhpcy5vblJlbmRlckVycm9yKTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJkcmF3UGFnZU9uQ29udGFpbmVyXCIsIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICB2YXIgc3ZnID0gX3RoaXMuc3RhdGUuc3ZnO1xuXG4gICAgICBpZiAoIWVsZW1lbnQgfHwgIXN2Zykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIEFwcGVuZCBTVkcgZWxlbWVudCB0byB0aGUgbWFpbiBjb250YWluZXIsIGlmIHRoaXMgaGFzbid0IGJlZW4gZG9uZSBhbHJlYWR5XG5cblxuICAgICAgaWYgKCFlbGVtZW50LmZpcnN0RWxlbWVudENoaWxkKSB7XG4gICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoc3ZnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIF90aGlzJHZpZXdwb3J0ID0gX3RoaXMudmlld3BvcnQsXG4gICAgICAgICAgd2lkdGggPSBfdGhpcyR2aWV3cG9ydC53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSBfdGhpcyR2aWV3cG9ydC5oZWlnaHQ7XG4gICAgICBzdmcuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHdpZHRoKTtcbiAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGhlaWdodCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUGFnZVNWR0ludGVybmFsLCBbe1xuICAgIGtleTogXCJjb21wb25lbnREaWRNb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgIHRoaXMucmVuZGVyU1ZHKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIGEgcGFnZSBpcyByZW5kZXJlZCBzdWNjZXNzZnVsbHkuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBfdGhpcyR2aWV3cG9ydDIgPSB0aGlzLnZpZXdwb3J0LFxuICAgICAgICAgIHdpZHRoID0gX3RoaXMkdmlld3BvcnQyLndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IF90aGlzJHZpZXdwb3J0Mi5oZWlnaHQ7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBjbGFzc05hbWU6IFwicmVhY3QtcGRmX19QYWdlX19zdmdcIiAvLyBOb3RlOiBUaGlzIGNhbm5vdCBiZSBzaG9ydGVuZWQsIGFzIHdlIG5lZWQgdGhpcyBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2l0aCBlYWNoIHJlbmRlci5cbiAgICAgICAgLFxuICAgICAgICByZWY6IGZ1bmN0aW9uIHJlZihfcmVmKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5kcmF3UGFnZU9uQ29udGFpbmVyKF9yZWYpO1xuICAgICAgICB9LFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnd2hpdGUnLFxuICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgdXNlclNlbGVjdDogJ25vbmUnXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2aWV3cG9ydFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzMiA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgcGFnZSA9IF90aGlzJHByb3BzMi5wYWdlLFxuICAgICAgICAgIHJvdGF0ZSA9IF90aGlzJHByb3BzMi5yb3RhdGUsXG4gICAgICAgICAgc2NhbGUgPSBfdGhpcyRwcm9wczIuc2NhbGU7XG4gICAgICByZXR1cm4gcGFnZS5nZXRWaWV3cG9ydCh7XG4gICAgICAgIHNjYWxlOiBzY2FsZSxcbiAgICAgICAgcm90YXRpb246IHJvdGF0ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBhZ2VTVkdJbnRlcm5hbDtcbn0oUHVyZUNvbXBvbmVudCk7XG5QYWdlU1ZHSW50ZXJuYWwucHJvcFR5cGVzID0ge1xuICBvblJlbmRlckVycm9yOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25SZW5kZXJTdWNjZXNzOiBQcm9wVHlwZXMuZnVuYyxcbiAgcGFnZTogaXNQYWdlLmlzUmVxdWlyZWQsXG4gIHJvdGF0ZTogaXNSb3RhdGUsXG4gIHNjYWxlOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWRcbn07XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBQYWdlU1ZHKHByb3BzKSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChQYWdlQ29udGV4dC5Db25zdW1lciwgbnVsbCwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUGFnZVNWR0ludGVybmFsLCBfZXh0ZW5kcyh7fSwgY29udGV4dCwgcHJvcHMpKTtcbiAgfSk7XG59IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX3NsaWNlZFRvQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXlcIjtcbmltcG9ydCBfcmVnZW5lcmF0b3JSdW50aW1lIGZyb20gXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiO1xuaW1wb3J0IF9hc3luY1RvR2VuZXJhdG9yIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3luY1RvR2VuZXJhdG9yXCI7XG5pbXBvcnQgX2NsYXNzQ2FsbENoZWNrIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVja1wiO1xuaW1wb3J0IF9jcmVhdGVDbGFzcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3NcIjtcbmltcG9ydCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3NlcnRUaGlzSW5pdGlhbGl6ZWRcIjtcbmltcG9ydCBfaW5oZXJpdHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2luaGVyaXRzXCI7XG5pbXBvcnQgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4gZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIjtcbmltcG9ydCBfZ2V0UHJvdG90eXBlT2YgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2dldFByb3RvdHlwZU9mXCI7XG5pbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmltcG9ydCBSZWFjdCwgeyBQdXJlQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBQYWdlQ29udGV4dCBmcm9tICcuLi9QYWdlQ29udGV4dCc7XG5pbXBvcnQgeyBpc1BhZ2UsIGlzUm90YXRlIH0gZnJvbSAnLi4vc2hhcmVkL3Byb3BUeXBlcyc7XG5leHBvcnQgdmFyIFRleHRMYXllckl0ZW1JbnRlcm5hbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1B1cmVDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFRleHRMYXllckl0ZW1JbnRlcm5hbCwgX1B1cmVDb21wb25lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoVGV4dExheWVySXRlbUludGVybmFsKTtcblxuICBmdW5jdGlvbiBUZXh0TGF5ZXJJdGVtSW50ZXJuYWwoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRleHRMYXllckl0ZW1JbnRlcm5hbCk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbC5hcHBseShfc3VwZXIsIFt0aGlzXS5jb25jYXQoYXJncykpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImdldEVsZW1lbnRXaWR0aFwiLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgdmFyIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZSA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLFxuICAgICAgICAgIHNpZGV3YXlzID0gX2Fzc2VydFRoaXNJbml0aWFsaXplLnNpZGV3YXlzO1xuXG4gICAgICByZXR1cm4gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtzaWRld2F5cyA/ICdoZWlnaHQnIDogJ3dpZHRoJ107XG4gICAgfSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVGV4dExheWVySXRlbUludGVybmFsLCBbe1xuICAgIGtleTogXCJjb21wb25lbnREaWRNb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgIHRoaXMuYWxpZ25UZXh0SXRlbSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wb25lbnREaWRVcGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgdGhpcy5hbGlnblRleHRJdGVtKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEZvbnREYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZ2V0Rm9udERhdGEgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKGZvbnROYW1lKSB7XG4gICAgICAgIHZhciBwYWdlLCBmb250O1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHBhZ2UgPSB0aGlzLnByb3BzLnBhZ2U7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgICBwYWdlLmNvbW1vbk9ianMuZ2V0KGZvbnROYW1lLCByZXNvbHZlKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgZm9udCA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBmb250KTtcblxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGdldEZvbnREYXRhKF94KSB7XG4gICAgICAgIHJldHVybiBfZ2V0Rm9udERhdGEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdldEZvbnREYXRhO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcImFsaWduVGV4dEl0ZW1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9hbGlnblRleHRJdGVtID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoKSB7XG4gICAgICAgIHZhciBlbGVtZW50LCBfdGhpcyRwcm9wcywgZm9udE5hbWUsIHNjYWxlLCB3aWR0aCwgZm9udERhdGEsIGZhbGxiYWNrRm9udE5hbWUsIHRhcmdldFdpZHRoLCBhY3R1YWxXaWR0aCwgdHJhbnNmb3JtLCBhc2NlbnQ7XG5cbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IHRoaXMuaXRlbTtcblxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiKTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSAnJztcbiAgICAgICAgICAgICAgICBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsIGZvbnROYW1lID0gX3RoaXMkcHJvcHMuZm9udE5hbWUsIHNjYWxlID0gX3RoaXMkcHJvcHMuc2NhbGUsIHdpZHRoID0gX3RoaXMkcHJvcHMud2lkdGg7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5mb250RmFtaWx5ID0gXCJcIi5jb25jYXQoZm9udE5hbWUsIFwiLCBzYW5zLXNlcmlmXCIpO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gODtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRGb250RGF0YShmb250TmFtZSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIGZvbnREYXRhID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICAgICAgZmFsbGJhY2tGb250TmFtZSA9IGZvbnREYXRhID8gZm9udERhdGEuZmFsbGJhY2tOYW1lIDogJ3NhbnMtc2VyaWYnO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuZm9udEZhbWlseSA9IFwiXCIuY29uY2F0KGZvbnROYW1lLCBcIiwgXCIpLmNvbmNhdChmYWxsYmFja0ZvbnROYW1lKTtcbiAgICAgICAgICAgICAgICB0YXJnZXRXaWR0aCA9IHdpZHRoICogc2NhbGU7XG4gICAgICAgICAgICAgICAgYWN0dWFsV2lkdGggPSB0aGlzLmdldEVsZW1lbnRXaWR0aChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0gPSBcInNjYWxlWChcIi5jb25jYXQodGFyZ2V0V2lkdGggLyBhY3R1YWxXaWR0aCwgXCIpXCIpO1xuICAgICAgICAgICAgICAgIGFzY2VudCA9IGZvbnREYXRhID8gZm9udERhdGEuYXNjZW50IDogMDtcblxuICAgICAgICAgICAgICAgIGlmIChhc2NlbnQpIHtcbiAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybSArPSBcIiB0cmFuc2xhdGVZKFwiLmNvbmNhdCgoMSAtIGFzY2VudCkgKiAxMDAsIFwiJSlcIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5XZWJraXRUcmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG5cbiAgICAgICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTIsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBhbGlnblRleHRJdGVtKCkge1xuICAgICAgICByZXR1cm4gX2FsaWduVGV4dEl0ZW0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFsaWduVGV4dEl0ZW07XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgZm9udFNpemUgPSB0aGlzLmZvbnRTaXplLFxuICAgICAgICAgIHRvcCA9IHRoaXMudG9wLFxuICAgICAgICAgIGxlZnQgPSB0aGlzLmxlZnQ7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMyID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBjdXN0b21UZXh0UmVuZGVyZXIgPSBfdGhpcyRwcm9wczIuY3VzdG9tVGV4dFJlbmRlcmVyLFxuICAgICAgICAgIHNjYWxlID0gX3RoaXMkcHJvcHMyLnNjYWxlLFxuICAgICAgICAgIHRleHQgPSBfdGhpcyRwcm9wczIuc3RyO1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgICAgIHJlZjogZnVuY3Rpb24gcmVmKF9yZWYpIHtcbiAgICAgICAgICBfdGhpczIuaXRlbSA9IF9yZWY7XG4gICAgICAgIH0sXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgaGVpZ2h0OiAnMWVtJyxcbiAgICAgICAgICBmb250RmFtaWx5OiAnc2Fucy1zZXJpZicsXG4gICAgICAgICAgZm9udFNpemU6IFwiXCIuY29uY2F0KGZvbnRTaXplICogc2NhbGUsIFwicHhcIiksXG4gICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgdG9wOiBcIlwiLmNvbmNhdCh0b3AgKiBzY2FsZSwgXCJweFwiKSxcbiAgICAgICAgICBsZWZ0OiBcIlwiLmNvbmNhdChsZWZ0ICogc2NhbGUsIFwicHhcIiksXG4gICAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiAnbGVmdCBib3R0b20nLFxuICAgICAgICAgIHdoaXRlU3BhY2U6ICdwcmUnLFxuICAgICAgICAgIHBvaW50ZXJFdmVudHM6ICdhbGwnXG4gICAgICAgIH1cbiAgICAgIH0sIGN1c3RvbVRleHRSZW5kZXJlciA/IGN1c3RvbVRleHRSZW5kZXJlcih0aGlzLnByb3BzKSA6IHRleHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bnJvdGF0ZWRWaWV3cG9ydFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzMyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgcGFnZSA9IF90aGlzJHByb3BzMy5wYWdlLFxuICAgICAgICAgIHNjYWxlID0gX3RoaXMkcHJvcHMzLnNjYWxlO1xuICAgICAgcmV0dXJuIHBhZ2UuZ2V0Vmlld3BvcnQoe1xuICAgICAgICBzY2FsZTogc2NhbGVcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJdCBtaWdodCBoYXBwZW4gdGhhdCB0aGUgcGFnZSBpcyByb3RhdGVkIGJ5IGRlZmF1bHQuIEluIHN1Y2ggY2FzZXMsIHdlIHNob3VsZG4ndCByb3RhdGVcbiAgICAgKiB0ZXh0IGNvbnRlbnQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyb3RhdGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczQgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIHBhZ2UgPSBfdGhpcyRwcm9wczQucGFnZSxcbiAgICAgICAgICByb3RhdGUgPSBfdGhpcyRwcm9wczQucm90YXRlO1xuICAgICAgcmV0dXJuIHJvdGF0ZSAtIHBhZ2Uucm90YXRlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaWRld2F5c1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIHJvdGF0ZSA9IHRoaXMucm90YXRlO1xuICAgICAgcmV0dXJuIHJvdGF0ZSAlIDE4MCAhPT0gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVmYXVsdFNpZGV3YXlzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgcm90YXRpb24gPSB0aGlzLnVucm90YXRlZFZpZXdwb3J0LnJvdGF0aW9uO1xuICAgICAgcmV0dXJuIHJvdGF0aW9uICUgMTgwICE9PSAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb250U2l6ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMucHJvcHMudHJhbnNmb3JtO1xuICAgICAgdmFyIGRlZmF1bHRTaWRld2F5cyA9IHRoaXMuZGVmYXVsdFNpZGV3YXlzO1xuXG4gICAgICB2YXIgX3RyYW5zZm9ybSA9IF9zbGljZWRUb0FycmF5KHRyYW5zZm9ybSwgMiksXG4gICAgICAgICAgZm9udEhlaWdodFB4ID0gX3RyYW5zZm9ybVswXSxcbiAgICAgICAgICBmb250V2lkdGhQeCA9IF90cmFuc2Zvcm1bMV07XG5cbiAgICAgIHJldHVybiBkZWZhdWx0U2lkZXdheXMgPyBmb250V2lkdGhQeCA6IGZvbnRIZWlnaHRQeDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9wXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy5wcm9wcy50cmFuc2Zvcm07XG4gICAgICB2YXIgdmlld3BvcnQgPSB0aGlzLnVucm90YXRlZFZpZXdwb3J0LFxuICAgICAgICAgIGRlZmF1bHRTaWRld2F5cyA9IHRoaXMuZGVmYXVsdFNpZGV3YXlzO1xuXG4gICAgICB2YXIgX3RyYW5zZm9ybTIgPSBfc2xpY2VkVG9BcnJheSh0cmFuc2Zvcm0sIDYpLFxuXG4gICAgICAvKiBmb250SGVpZ2h0UHggKi9cblxuICAgICAgLyogZm9udFdpZHRoUHggKi9cbiAgICAgIG9mZnNldFggPSBfdHJhbnNmb3JtMlsyXSxcbiAgICAgICAgICBvZmZzZXRZID0gX3RyYW5zZm9ybTJbM10sXG4gICAgICAgICAgeCA9IF90cmFuc2Zvcm0yWzRdLFxuICAgICAgICAgIHkgPSBfdHJhbnNmb3JtMls1XTtcblxuICAgICAgdmFyIF92aWV3cG9ydCR2aWV3Qm94ID0gX3NsaWNlZFRvQXJyYXkodmlld3BvcnQudmlld0JveCwgNCksXG5cbiAgICAgIC8qIHhNaW4gKi9cbiAgICAgIHlNaW4gPSBfdmlld3BvcnQkdmlld0JveFsxXSxcblxuICAgICAgLyogeE1heCAqL1xuICAgICAgeU1heCA9IF92aWV3cG9ydCR2aWV3Qm94WzNdO1xuXG4gICAgICByZXR1cm4gZGVmYXVsdFNpZGV3YXlzID8geCArIG9mZnNldFggKyB5TWluIDogeU1heCAtICh5ICsgb2Zmc2V0WSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxlZnRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciB0cmFuc2Zvcm0gPSB0aGlzLnByb3BzLnRyYW5zZm9ybTtcbiAgICAgIHZhciB2aWV3cG9ydCA9IHRoaXMudW5yb3RhdGVkVmlld3BvcnQsXG4gICAgICAgICAgZGVmYXVsdFNpZGV3YXlzID0gdGhpcy5kZWZhdWx0U2lkZXdheXM7XG5cbiAgICAgIHZhciBfdHJhbnNmb3JtMyA9IF9zbGljZWRUb0FycmF5KHRyYW5zZm9ybSwgNiksXG5cbiAgICAgIC8qIGZvbnRIZWlnaHRQeCAqL1xuXG4gICAgICAvKiBmb250V2lkdGhQeCAqL1xuXG4gICAgICAvKiBvZmZzZXRYICovXG5cbiAgICAgIC8qIG9mZnNldFkgKi9cbiAgICAgIHggPSBfdHJhbnNmb3JtM1s0XSxcbiAgICAgICAgICB5ID0gX3RyYW5zZm9ybTNbNV07XG5cbiAgICAgIHZhciBfdmlld3BvcnQkdmlld0JveDIgPSBfc2xpY2VkVG9BcnJheSh2aWV3cG9ydC52aWV3Qm94LCAxKSxcbiAgICAgICAgICB4TWluID0gX3ZpZXdwb3J0JHZpZXdCb3gyWzBdO1xuXG4gICAgICByZXR1cm4gZGVmYXVsdFNpZGV3YXlzID8geSAtIHhNaW4gOiB4IC0geE1pbjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVGV4dExheWVySXRlbUludGVybmFsO1xufShQdXJlQ29tcG9uZW50KTtcblRleHRMYXllckl0ZW1JbnRlcm5hbC5wcm9wVHlwZXMgPSB7XG4gIGN1c3RvbVRleHRSZW5kZXJlcjogUHJvcFR5cGVzLmZ1bmMsXG4gIGZvbnROYW1lOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gIGl0ZW1JbmRleDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlYWN0L25vLXVudXNlZC1wcm9wLXR5cGVzXG4gIHBhZ2U6IGlzUGFnZS5pc1JlcXVpcmVkLFxuICByb3RhdGU6IGlzUm90YXRlLFxuICBzY2FsZTogUHJvcFR5cGVzLm51bWJlcixcbiAgc3RyOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gIHRyYW5zZm9ybTogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm51bWJlcikuaXNSZXF1aXJlZCxcbiAgd2lkdGg6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZFxufTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFRleHRMYXllckl0ZW0ocHJvcHMpIHtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFBhZ2VDb250ZXh0LkNvbnN1bWVyLCBudWxsLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChUZXh0TGF5ZXJJdGVtSW50ZXJuYWwsIF9leHRlbmRzKHt9LCBjb250ZXh0LCBwcm9wcykpO1xuICB9KTtcbn0iLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfcmVnZW5lcmF0b3JSdW50aW1lIGZyb20gXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiO1xuaW1wb3J0IF9hc3luY1RvR2VuZXJhdG9yIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3luY1RvR2VuZXJhdG9yXCI7XG5pbXBvcnQgX2NsYXNzQ2FsbENoZWNrIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVja1wiO1xuaW1wb3J0IF9jcmVhdGVDbGFzcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3NcIjtcbmltcG9ydCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3NlcnRUaGlzSW5pdGlhbGl6ZWRcIjtcbmltcG9ydCBfaW5oZXJpdHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2luaGVyaXRzXCI7XG5pbXBvcnQgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4gZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIjtcbmltcG9ydCBfZ2V0UHJvdG90eXBlT2YgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2dldFByb3RvdHlwZU9mXCI7XG5pbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eVwiO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmltcG9ydCBSZWFjdCwgeyBQdXJlQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBtYWtlQ2FuY2VsbGFibGUgZnJvbSAnbWFrZS1jYW5jZWxsYWJsZS1wcm9taXNlJztcbmltcG9ydCBQYWdlQ29udGV4dCBmcm9tICcuLi9QYWdlQ29udGV4dCc7XG5pbXBvcnQgVGV4dExheWVySXRlbSBmcm9tICcuL1RleHRMYXllckl0ZW0nO1xuaW1wb3J0IHsgY2FuY2VsUnVubmluZ1Rhc2ssIGVycm9yT25EZXYgfSBmcm9tICcuLi9zaGFyZWQvdXRpbHMnO1xuaW1wb3J0IHsgaXNQYWdlLCBpc1JvdGF0ZSB9IGZyb20gJy4uL3NoYXJlZC9wcm9wVHlwZXMnO1xuZXhwb3J0IHZhciBUZXh0TGF5ZXJJbnRlcm5hbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1B1cmVDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFRleHRMYXllckludGVybmFsLCBfUHVyZUNvbXBvbmVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihUZXh0TGF5ZXJJbnRlcm5hbCk7XG5cbiAgZnVuY3Rpb24gVGV4dExheWVySW50ZXJuYWwoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRleHRMYXllckludGVybmFsKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsLmFwcGx5KF9zdXBlciwgW3RoaXNdLmNvbmNhdChhcmdzKSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwic3RhdGVcIiwge1xuICAgICAgdGV4dEl0ZW1zOiBudWxsXG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwibG9hZFRleHRJdGVtc1wiLCAvKiNfX1BVUkVfXyovX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZSgpIHtcbiAgICAgIHZhciBwYWdlLCBjYW5jZWxsYWJsZSwgX3lpZWxkJGNhbmNlbGxhYmxlJHByLCB0ZXh0SXRlbXM7XG5cbiAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHBhZ2UgPSBfdGhpcy5wcm9wcy5wYWdlO1xuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTtcbiAgICAgICAgICAgICAgY2FuY2VsbGFibGUgPSBtYWtlQ2FuY2VsbGFibGUocGFnZS5nZXRUZXh0Q29udGVudCgpKTtcbiAgICAgICAgICAgICAgX3RoaXMucnVubmluZ1Rhc2sgPSBjYW5jZWxsYWJsZTtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDY7XG4gICAgICAgICAgICAgIHJldHVybiBjYW5jZWxsYWJsZS5wcm9taXNlO1xuXG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIF95aWVsZCRjYW5jZWxsYWJsZSRwciA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICAgIHRleHRJdGVtcyA9IF95aWVsZCRjYW5jZWxsYWJsZSRwci5pdGVtcztcblxuICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgdGV4dEl0ZW1zOiB0ZXh0SXRlbXNcbiAgICAgICAgICAgICAgfSwgX3RoaXMub25Mb2FkU3VjY2Vzcyk7XG5cbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE0O1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDExO1xuICAgICAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oMSk7XG5cbiAgICAgICAgICAgICAgX3RoaXMub25Mb2FkRXJyb3IoX2NvbnRleHQudDApO1xuXG4gICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZSwgbnVsbCwgW1sxLCAxMV1dKTtcbiAgICB9KSkpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm9uTG9hZFN1Y2Nlc3NcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG9uR2V0VGV4dFN1Y2Nlc3MgPSBfdGhpcy5wcm9wcy5vbkdldFRleHRTdWNjZXNzO1xuICAgICAgdmFyIHRleHRJdGVtcyA9IF90aGlzLnN0YXRlLnRleHRJdGVtcztcbiAgICAgIGlmIChvbkdldFRleHRTdWNjZXNzKSBvbkdldFRleHRTdWNjZXNzKHRleHRJdGVtcyk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwib25Mb2FkRXJyb3JcIiwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHRleHRJdGVtczogZmFsc2VcbiAgICAgIH0pO1xuXG4gICAgICBlcnJvck9uRGV2KGVycm9yKTtcbiAgICAgIHZhciBvbkdldFRleHRFcnJvciA9IF90aGlzLnByb3BzLm9uR2V0VGV4dEVycm9yO1xuICAgICAgaWYgKG9uR2V0VGV4dEVycm9yKSBvbkdldFRleHRFcnJvcihlcnJvcik7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVGV4dExheWVySW50ZXJuYWwsIFt7XG4gICAga2V5OiBcImNvbXBvbmVudERpZE1vdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgdmFyIHBhZ2UgPSB0aGlzLnByb3BzLnBhZ2U7XG5cbiAgICAgIGlmICghcGFnZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRlZCB0byBsb2FkIHBhZ2UgdGV4dCBjb250ZW50LCBidXQgbm8gcGFnZSB3YXMgc3BlY2lmaWVkLicpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxvYWRUZXh0SXRlbXMoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50RGlkVXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgIHZhciBwYWdlID0gdGhpcy5wcm9wcy5wYWdlO1xuXG4gICAgICBpZiAocHJldlByb3BzLnBhZ2UgJiYgcGFnZSAhPT0gcHJldlByb3BzLnBhZ2UpIHtcbiAgICAgICAgdGhpcy5sb2FkVGV4dEl0ZW1zKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBvbmVudFdpbGxVbm1vdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgY2FuY2VsUnVubmluZ1Rhc2sodGhpcy5ydW5uaW5nVGFzayk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclRleHRJdGVtc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJUZXh0SXRlbXMoKSB7XG4gICAgICB2YXIgdGV4dEl0ZW1zID0gdGhpcy5zdGF0ZS50ZXh0SXRlbXM7XG5cbiAgICAgIGlmICghdGV4dEl0ZW1zKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGV4dEl0ZW1zLm1hcChmdW5jdGlvbiAodGV4dEl0ZW0sIGl0ZW1JbmRleCkge1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVGV4dExheWVySXRlbSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tYXJyYXktaW5kZXgta2V5XG4gICAgICAgICwgX2V4dGVuZHMoe1xuICAgICAgICAgIGtleTogaXRlbUluZGV4LFxuICAgICAgICAgIGl0ZW1JbmRleDogaXRlbUluZGV4XG4gICAgICAgIH0sIHRleHRJdGVtKSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciB2aWV3cG9ydCA9IHRoaXMudW5yb3RhdGVkVmlld3BvcnQsXG4gICAgICAgICAgcm90YXRlID0gdGhpcy5yb3RhdGU7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBjbGFzc05hbWU6IFwicmVhY3QtcGRmX19QYWdlX190ZXh0Q29udGVudFwiLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgIHRvcDogJzUwJScsXG4gICAgICAgICAgbGVmdDogJzUwJScsXG4gICAgICAgICAgd2lkdGg6IFwiXCIuY29uY2F0KHZpZXdwb3J0LndpZHRoLCBcInB4XCIpLFxuICAgICAgICAgIGhlaWdodDogXCJcIi5jb25jYXQodmlld3BvcnQuaGVpZ2h0LCBcInB4XCIpLFxuICAgICAgICAgIGNvbG9yOiAndHJhbnNwYXJlbnQnLFxuICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoLTUwJSwgLTUwJSkgcm90YXRlKFwiLmNvbmNhdChyb3RhdGUsIFwiZGVnKVwiKSxcbiAgICAgICAgICBXZWJraXRUcmFuc2Zvcm06IFwidHJhbnNsYXRlKC01MCUsIC01MCUpIHJvdGF0ZShcIi5jb25jYXQocm90YXRlLCBcImRlZylcIiksXG4gICAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnXG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMucmVuZGVyVGV4dEl0ZW1zKCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bnJvdGF0ZWRWaWV3cG9ydFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBwYWdlID0gX3RoaXMkcHJvcHMucGFnZSxcbiAgICAgICAgICBzY2FsZSA9IF90aGlzJHByb3BzLnNjYWxlO1xuICAgICAgcmV0dXJuIHBhZ2UuZ2V0Vmlld3BvcnQoe1xuICAgICAgICBzY2FsZTogc2NhbGVcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJdCBtaWdodCBoYXBwZW4gdGhhdCB0aGUgcGFnZSBpcyByb3RhdGVkIGJ5IGRlZmF1bHQuIEluIHN1Y2ggY2FzZXMsIHdlIHNob3VsZG4ndCByb3RhdGVcbiAgICAgKiB0ZXh0IGNvbnRlbnQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyb3RhdGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczIgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIHBhZ2UgPSBfdGhpcyRwcm9wczIucGFnZSxcbiAgICAgICAgICByb3RhdGUgPSBfdGhpcyRwcm9wczIucm90YXRlO1xuICAgICAgcmV0dXJuIHJvdGF0ZSAtIHBhZ2Uucm90YXRlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUZXh0TGF5ZXJJbnRlcm5hbDtcbn0oUHVyZUNvbXBvbmVudCk7XG5UZXh0TGF5ZXJJbnRlcm5hbC5wcm9wVHlwZXMgPSB7XG4gIG9uR2V0VGV4dEVycm9yOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25HZXRUZXh0U3VjY2VzczogUHJvcFR5cGVzLmZ1bmMsXG4gIHBhZ2U6IGlzUGFnZS5pc1JlcXVpcmVkLFxuICByb3RhdGU6IGlzUm90YXRlLFxuICBzY2FsZTogUHJvcFR5cGVzLm51bWJlclxufTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFRleHRMYXllcihwcm9wcykge1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUGFnZUNvbnRleHQuQ29uc3VtZXIsIG51bGwsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFRleHRMYXllckludGVybmFsLCBfZXh0ZW5kcyh7fSwgY29udGV4dCwgcHJvcHMpKTtcbiAgfSk7XG59IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX3JlZ2VuZXJhdG9yUnVudGltZSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIjtcbmltcG9ydCBfYXN5bmNUb0dlbmVyYXRvciBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXN5bmNUb0dlbmVyYXRvclwiO1xuaW1wb3J0IF9jbGFzc0NhbGxDaGVjayBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2tcIjtcbmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzXCI7XG5pbXBvcnQgX2Fzc2VydFRoaXNJbml0aWFsaXplZCBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXNzZXJ0VGhpc0luaXRpYWxpemVkXCI7XG5pbXBvcnQgX2luaGVyaXRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pbmhlcml0c1wiO1xuaW1wb3J0IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCI7XG5pbXBvcnQgX2dldFByb3RvdHlwZU9mIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9nZXRQcm90b3R5cGVPZlwiO1xuaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5pbXBvcnQgUmVhY3QsIHsgUHVyZUNvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgKiBhcyBwZGZqcyBmcm9tICdwZGZqcy1kaXN0JztcbmltcG9ydCBtYWtlQ2FuY2VsbGFibGUgZnJvbSAnbWFrZS1jYW5jZWxsYWJsZS1wcm9taXNlJztcbmltcG9ydCBEb2N1bWVudENvbnRleHQgZnJvbSAnLi4vRG9jdW1lbnRDb250ZXh0JztcbmltcG9ydCBQYWdlQ29udGV4dCBmcm9tICcuLi9QYWdlQ29udGV4dCc7XG5pbXBvcnQgeyBjYW5jZWxSdW5uaW5nVGFzaywgZXJyb3JPbkRldiB9IGZyb20gJy4uL3NoYXJlZC91dGlscyc7XG5pbXBvcnQgeyBpc0xpbmtTZXJ2aWNlLCBpc1BhZ2UsIGlzUm90YXRlIH0gZnJvbSAnLi4vc2hhcmVkL3Byb3BUeXBlcyc7XG5leHBvcnQgdmFyIEFubm90YXRpb25MYXllckludGVybmFsID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUHVyZUNvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoQW5ub3RhdGlvbkxheWVySW50ZXJuYWwsIF9QdXJlQ29tcG9uZW50KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEFubm90YXRpb25MYXllckludGVybmFsKTtcblxuICBmdW5jdGlvbiBBbm5vdGF0aW9uTGF5ZXJJbnRlcm5hbCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQW5ub3RhdGlvbkxheWVySW50ZXJuYWwpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwuYXBwbHkoX3N1cGVyLCBbdGhpc10uY29uY2F0KGFyZ3MpKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJzdGF0ZVwiLCB7XG4gICAgICBhbm5vdGF0aW9uczogbnVsbFxuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImxvYWRBbm5vdGF0aW9uc1wiLCAvKiNfX1BVUkVfXyovX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZSgpIHtcbiAgICAgIHZhciBwYWdlLCBjYW5jZWxsYWJsZSwgYW5ub3RhdGlvbnM7XG4gICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBwYWdlID0gX3RoaXMucHJvcHMucGFnZTtcbiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDE7XG4gICAgICAgICAgICAgIGNhbmNlbGxhYmxlID0gbWFrZUNhbmNlbGxhYmxlKHBhZ2UuZ2V0QW5ub3RhdGlvbnMoKSk7XG4gICAgICAgICAgICAgIF90aGlzLnJ1bm5pbmdUYXNrID0gY2FuY2VsbGFibGU7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA2O1xuICAgICAgICAgICAgICByZXR1cm4gY2FuY2VsbGFibGUucHJvbWlzZTtcblxuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICBhbm5vdGF0aW9ucyA9IF9jb250ZXh0LnNlbnQ7XG5cbiAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGFubm90YXRpb25zOiBhbm5vdGF0aW9uc1xuICAgICAgICAgICAgICB9LCBfdGhpcy5vbkxvYWRTdWNjZXNzKTtcblxuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTA7XG4gICAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSgxKTtcblxuICAgICAgICAgICAgICBfdGhpcy5vbkxvYWRFcnJvcihfY29udGV4dC50MCk7XG5cbiAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlLCBudWxsLCBbWzEsIDEwXV0pO1xuICAgIH0pKSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwib25Mb2FkU3VjY2Vzc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgb25HZXRBbm5vdGF0aW9uc1N1Y2Nlc3MgPSBfdGhpcy5wcm9wcy5vbkdldEFubm90YXRpb25zU3VjY2VzcztcbiAgICAgIHZhciBhbm5vdGF0aW9ucyA9IF90aGlzLnN0YXRlLmFubm90YXRpb25zO1xuICAgICAgaWYgKG9uR2V0QW5ub3RhdGlvbnNTdWNjZXNzKSBvbkdldEFubm90YXRpb25zU3VjY2Vzcyhhbm5vdGF0aW9ucyk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwib25Mb2FkRXJyb3JcIiwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGFubm90YXRpb25zOiBmYWxzZVxuICAgICAgfSk7XG5cbiAgICAgIGVycm9yT25EZXYoZXJyb3IpO1xuICAgICAgdmFyIG9uR2V0QW5ub3RhdGlvbnNFcnJvciA9IF90aGlzLnByb3BzLm9uR2V0QW5ub3RhdGlvbnNFcnJvcjtcbiAgICAgIGlmIChvbkdldEFubm90YXRpb25zRXJyb3IpIG9uR2V0QW5ub3RhdGlvbnNFcnJvcihlcnJvcik7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwib25SZW5kZXJTdWNjZXNzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBvblJlbmRlckFubm90YXRpb25MYXllclN1Y2Nlc3MgPSBfdGhpcy5wcm9wcy5vblJlbmRlckFubm90YXRpb25MYXllclN1Y2Nlc3M7XG4gICAgICBpZiAob25SZW5kZXJBbm5vdGF0aW9uTGF5ZXJTdWNjZXNzKSBvblJlbmRlckFubm90YXRpb25MYXllclN1Y2Nlc3MoKTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJvblJlbmRlckVycm9yXCIsIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgZXJyb3JPbkRldihlcnJvcik7XG4gICAgICB2YXIgb25SZW5kZXJBbm5vdGF0aW9uTGF5ZXJFcnJvciA9IF90aGlzLnByb3BzLm9uUmVuZGVyQW5ub3RhdGlvbkxheWVyRXJyb3I7XG4gICAgICBpZiAob25SZW5kZXJBbm5vdGF0aW9uTGF5ZXJFcnJvcikgb25SZW5kZXJBbm5vdGF0aW9uTGF5ZXJFcnJvcihlcnJvcik7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQW5ub3RhdGlvbkxheWVySW50ZXJuYWwsIFt7XG4gICAga2V5OiBcImNvbXBvbmVudERpZE1vdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgdmFyIHBhZ2UgPSB0aGlzLnByb3BzLnBhZ2U7XG5cbiAgICAgIGlmICghcGFnZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRlZCB0byBsb2FkIHBhZ2UgYW5ub3RhdGlvbnMsIGJ1dCBubyBwYWdlIHdhcyBzcGVjaWZpZWQuJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubG9hZEFubm90YXRpb25zKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBvbmVudERpZFVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIHBhZ2UgPSBfdGhpcyRwcm9wcy5wYWdlLFxuICAgICAgICAgIHJlbmRlckludGVyYWN0aXZlRm9ybXMgPSBfdGhpcyRwcm9wcy5yZW5kZXJJbnRlcmFjdGl2ZUZvcm1zO1xuXG4gICAgICBpZiAocHJldlByb3BzLnBhZ2UgJiYgcGFnZSAhPT0gcHJldlByb3BzLnBhZ2UgfHwgcmVuZGVySW50ZXJhY3RpdmVGb3JtcyAhPT0gcHJldlByb3BzLnJlbmRlckludGVyYWN0aXZlRm9ybXMpIHtcbiAgICAgICAgdGhpcy5sb2FkQW5ub3RhdGlvbnMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50V2lsbFVubW91bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICBjYW5jZWxSdW5uaW5nVGFzayh0aGlzLnJ1bm5pbmdUYXNrKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyQW5ub3RhdGlvbkxheWVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckFubm90YXRpb25MYXllcigpIHtcbiAgICAgIHZhciBhbm5vdGF0aW9ucyA9IHRoaXMuc3RhdGUuYW5ub3RhdGlvbnM7XG5cbiAgICAgIGlmICghYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3RoaXMkcHJvcHMyID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBpbWFnZVJlc291cmNlc1BhdGggPSBfdGhpcyRwcm9wczIuaW1hZ2VSZXNvdXJjZXNQYXRoLFxuICAgICAgICAgIGxpbmtTZXJ2aWNlID0gX3RoaXMkcHJvcHMyLmxpbmtTZXJ2aWNlLFxuICAgICAgICAgIHBhZ2UgPSBfdGhpcyRwcm9wczIucGFnZSxcbiAgICAgICAgICByZW5kZXJJbnRlcmFjdGl2ZUZvcm1zID0gX3RoaXMkcHJvcHMyLnJlbmRlckludGVyYWN0aXZlRm9ybXM7XG4gICAgICB2YXIgdmlld3BvcnQgPSB0aGlzLnZpZXdwb3J0LmNsb25lKHtcbiAgICAgICAgZG9udEZsaXA6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdmFyIHBhcmFtZXRlcnMgPSB7XG4gICAgICAgIGFubm90YXRpb25zOiBhbm5vdGF0aW9ucyxcbiAgICAgICAgZGl2OiB0aGlzLmFubm90YXRpb25MYXllcixcbiAgICAgICAgaW1hZ2VSZXNvdXJjZXNQYXRoOiBpbWFnZVJlc291cmNlc1BhdGgsXG4gICAgICAgIGxpbmtTZXJ2aWNlOiBsaW5rU2VydmljZSxcbiAgICAgICAgcGFnZTogcGFnZSxcbiAgICAgICAgcmVuZGVySW50ZXJhY3RpdmVGb3JtczogcmVuZGVySW50ZXJhY3RpdmVGb3JtcyxcbiAgICAgICAgdmlld3BvcnQ6IHZpZXdwb3J0XG4gICAgICB9O1xuICAgICAgdGhpcy5hbm5vdGF0aW9uTGF5ZXIuaW5uZXJIVE1MID0gJyc7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHBkZmpzLkFubm90YXRpb25MYXllci5yZW5kZXIocGFyYW1ldGVycyk7XG4gICAgICAgIHRoaXMub25SZW5kZXJTdWNjZXNzKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aGlzLm9uUmVuZGVyRXJyb3IoZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJyZWFjdC1wZGZfX1BhZ2VfX2Fubm90YXRpb25zIGFubm90YXRpb25MYXllclwiLFxuICAgICAgICByZWY6IGZ1bmN0aW9uIHJlZihfcmVmMikge1xuICAgICAgICAgIF90aGlzMi5hbm5vdGF0aW9uTGF5ZXIgPSBfcmVmMjtcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcy5yZW5kZXJBbm5vdGF0aW9uTGF5ZXIoKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZpZXdwb3J0XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBwYWdlID0gX3RoaXMkcHJvcHMzLnBhZ2UsXG4gICAgICAgICAgcm90YXRlID0gX3RoaXMkcHJvcHMzLnJvdGF0ZSxcbiAgICAgICAgICBzY2FsZSA9IF90aGlzJHByb3BzMy5zY2FsZTtcbiAgICAgIHJldHVybiBwYWdlLmdldFZpZXdwb3J0KHtcbiAgICAgICAgc2NhbGU6IHNjYWxlLFxuICAgICAgICByb3RhdGlvbjogcm90YXRlXG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQW5ub3RhdGlvbkxheWVySW50ZXJuYWw7XG59KFB1cmVDb21wb25lbnQpO1xuQW5ub3RhdGlvbkxheWVySW50ZXJuYWwucHJvcFR5cGVzID0ge1xuICBpbWFnZVJlc291cmNlc1BhdGg6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGxpbmtTZXJ2aWNlOiBpc0xpbmtTZXJ2aWNlLmlzUmVxdWlyZWQsXG4gIG9uR2V0QW5ub3RhdGlvbnNFcnJvcjogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uR2V0QW5ub3RhdGlvbnNTdWNjZXNzOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25SZW5kZXJBbm5vdGF0aW9uTGF5ZXJFcnJvcjogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uUmVuZGVyQW5ub3RhdGlvbkxheWVyU3VjY2VzczogUHJvcFR5cGVzLmZ1bmMsXG4gIHBhZ2U6IGlzUGFnZSxcbiAgcmVuZGVySW50ZXJhY3RpdmVGb3JtczogUHJvcFR5cGVzLmJvb2wsXG4gIHJvdGF0ZTogaXNSb3RhdGUsXG4gIHNjYWxlOiBQcm9wVHlwZXMubnVtYmVyXG59O1xuXG52YXIgQW5ub3RhdGlvbkxheWVyID0gZnVuY3Rpb24gQW5ub3RhdGlvbkxheWVyKHByb3BzKSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChEb2N1bWVudENvbnRleHQuQ29uc3VtZXIsIG51bGwsIGZ1bmN0aW9uIChkb2N1bWVudENvbnRleHQpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUGFnZUNvbnRleHQuQ29uc3VtZXIsIG51bGwsIGZ1bmN0aW9uIChwYWdlQ29udGV4dCkge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEFubm90YXRpb25MYXllckludGVybmFsLCBfZXh0ZW5kcyh7fSwgZG9jdW1lbnRDb250ZXh0LCBwYWdlQ29udGV4dCwgcHJvcHMpKTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBBbm5vdGF0aW9uTGF5ZXI7IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX3JlZ2VuZXJhdG9yUnVudGltZSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIjtcbmltcG9ydCBfYXN5bmNUb0dlbmVyYXRvciBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXN5bmNUb0dlbmVyYXRvclwiO1xuaW1wb3J0IF9jbGFzc0NhbGxDaGVjayBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2tcIjtcbmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzXCI7XG5pbXBvcnQgX2Fzc2VydFRoaXNJbml0aWFsaXplZCBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXNzZXJ0VGhpc0luaXRpYWxpemVkXCI7XG5pbXBvcnQgX2luaGVyaXRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pbmhlcml0c1wiO1xuaW1wb3J0IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCI7XG5pbXBvcnQgX2dldFByb3RvdHlwZU9mIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9nZXRQcm90b3R5cGVPZlwiO1xuaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHlcIjtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuaW1wb3J0IFJlYWN0LCB7IFB1cmVDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IG1ha2VDYW5jZWxsYWJsZSBmcm9tICdtYWtlLWNhbmNlbGxhYmxlLXByb21pc2UnO1xuaW1wb3J0IG1ha2VFdmVudFByb3BzIGZyb20gJ21ha2UtZXZlbnQtcHJvcHMnO1xuaW1wb3J0IG1lcmdlQ2xhc3NOYW1lcyBmcm9tICdtZXJnZS1jbGFzcy1uYW1lcyc7XG5pbXBvcnQgbWVyZ2VSZWZzIGZyb20gJ21lcmdlLXJlZnMnO1xuaW1wb3J0IERvY3VtZW50Q29udGV4dCBmcm9tICcuL0RvY3VtZW50Q29udGV4dCc7XG5pbXBvcnQgUGFnZUNvbnRleHQgZnJvbSAnLi9QYWdlQ29udGV4dCc7XG5pbXBvcnQgTWVzc2FnZSBmcm9tICcuL01lc3NhZ2UnO1xuaW1wb3J0IFBhZ2VDYW52YXMgZnJvbSAnLi9QYWdlL1BhZ2VDYW52YXMnO1xuaW1wb3J0IFBhZ2VTVkcgZnJvbSAnLi9QYWdlL1BhZ2VTVkcnO1xuaW1wb3J0IFRleHRMYXllciBmcm9tICcuL1BhZ2UvVGV4dExheWVyJztcbmltcG9ydCBBbm5vdGF0aW9uTGF5ZXIgZnJvbSAnLi9QYWdlL0Fubm90YXRpb25MYXllcic7XG5pbXBvcnQgeyBjYW5jZWxSdW5uaW5nVGFzaywgZXJyb3JPbkRldiwgaXNQcm92aWRlZCwgbWFrZVBhZ2VDYWxsYmFjayB9IGZyb20gJy4vc2hhcmVkL3V0aWxzJztcbmltcG9ydCB7IGV2ZW50UHJvcHMsIGlzQ2xhc3NOYW1lLCBpc1BhZ2VJbmRleCwgaXNQYWdlTnVtYmVyLCBpc1BkZiwgaXNSZWYsIGlzUmVuZGVyTW9kZSwgaXNSb3RhdGUgfSBmcm9tICcuL3NoYXJlZC9wcm9wVHlwZXMnO1xudmFyIGRlZmF1bHRTY2FsZSA9IDE7XG5leHBvcnQgdmFyIFBhZ2VJbnRlcm5hbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1B1cmVDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFBhZ2VJbnRlcm5hbCwgX1B1cmVDb21wb25lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoUGFnZUludGVybmFsKTtcblxuICBmdW5jdGlvbiBQYWdlSW50ZXJuYWwoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBhZ2VJbnRlcm5hbCk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbC5hcHBseShfc3VwZXIsIFt0aGlzXS5jb25jYXQoYXJncykpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInN0YXRlXCIsIHtcbiAgICAgIHBhZ2U6IG51bGxcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJvbkxvYWRTdWNjZXNzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IF90aGlzLnByb3BzLFxuICAgICAgICAgIG9uTG9hZFN1Y2Nlc3MgPSBfdGhpcyRwcm9wcy5vbkxvYWRTdWNjZXNzLFxuICAgICAgICAgIHJlZ2lzdGVyUGFnZSA9IF90aGlzJHByb3BzLnJlZ2lzdGVyUGFnZTtcbiAgICAgIHZhciBwYWdlID0gX3RoaXMuc3RhdGUucGFnZTtcbiAgICAgIGlmIChvbkxvYWRTdWNjZXNzKSBvbkxvYWRTdWNjZXNzKG1ha2VQYWdlQ2FsbGJhY2socGFnZSwgX3RoaXMuc2NhbGUpKTtcbiAgICAgIGlmIChyZWdpc3RlclBhZ2UpIHJlZ2lzdGVyUGFnZShfdGhpcy5wYWdlSW5kZXgsIF90aGlzLnJlZik7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwib25Mb2FkRXJyb3JcIiwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBlcnJvck9uRGV2KGVycm9yKTtcbiAgICAgIHZhciBvbkxvYWRFcnJvciA9IF90aGlzLnByb3BzLm9uTG9hZEVycm9yO1xuICAgICAgaWYgKG9uTG9hZEVycm9yKSBvbkxvYWRFcnJvcihlcnJvcik7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwibG9hZFBhZ2VcIiwgLyojX19QVVJFX18qL19hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICB2YXIgcGRmLCBwYWdlTnVtYmVyLCBjYW5jZWxsYWJsZSwgcGFnZTtcbiAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHBkZiA9IF90aGlzLnByb3BzLnBkZjtcbiAgICAgICAgICAgICAgcGFnZU51bWJlciA9IF90aGlzLmdldFBhZ2VOdW1iZXIoKTtcblxuICAgICAgICAgICAgICBpZiAocGFnZU51bWJlcikge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiKTtcblxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAocHJldlN0YXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2U3RhdGUucGFnZSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIHBhZ2U6IG51bGxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gNTtcbiAgICAgICAgICAgICAgY2FuY2VsbGFibGUgPSBtYWtlQ2FuY2VsbGFibGUocGRmLmdldFBhZ2UocGFnZU51bWJlcikpO1xuICAgICAgICAgICAgICBfdGhpcy5ydW5uaW5nVGFzayA9IGNhbmNlbGxhYmxlO1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgIHJldHVybiBjYW5jZWxsYWJsZS5wcm9taXNlO1xuXG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICBwYWdlID0gX2NvbnRleHQuc2VudDtcblxuICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgcGFnZTogcGFnZVxuICAgICAgICAgICAgICB9LCBfdGhpcy5vbkxvYWRTdWNjZXNzKTtcblxuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTg7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTQ7XG4gICAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSg1KTtcblxuICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgcGFnZTogZmFsc2VcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgX3RoaXMub25Mb2FkRXJyb3IoX2NvbnRleHQudDApO1xuXG4gICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZSwgbnVsbCwgW1s1LCAxNF1dKTtcbiAgICB9KSkpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBhZ2VJbnRlcm5hbCwgW3tcbiAgICBrZXk6IFwiY29tcG9uZW50RGlkTW91bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICB2YXIgcGRmID0gdGhpcy5wcm9wcy5wZGY7XG5cbiAgICAgIGlmICghcGRmKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHRvIGxvYWQgYSBwYWdlLCBidXQgbm8gZG9jdW1lbnQgd2FzIHNwZWNpZmllZC4nKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sb2FkUGFnZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wb25lbnREaWRVcGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgdmFyIHBkZiA9IHRoaXMucHJvcHMucGRmO1xuXG4gICAgICBpZiAocHJldlByb3BzLnBkZiAmJiBwZGYgIT09IHByZXZQcm9wcy5wZGYgfHwgdGhpcy5nZXRQYWdlTnVtYmVyKCkgIT09IHRoaXMuZ2V0UGFnZU51bWJlcihwcmV2UHJvcHMpKSB7XG4gICAgICAgIHZhciB1bnJlZ2lzdGVyUGFnZSA9IHRoaXMucHJvcHMudW5yZWdpc3RlclBhZ2U7XG4gICAgICAgIGlmICh1bnJlZ2lzdGVyUGFnZSkgdW5yZWdpc3RlclBhZ2UodGhpcy5nZXRQYWdlSW5kZXgocHJldlByb3BzKSk7XG4gICAgICAgIHRoaXMubG9hZFBhZ2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50V2lsbFVubW91bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICB2YXIgdW5yZWdpc3RlclBhZ2UgPSB0aGlzLnByb3BzLnVucmVnaXN0ZXJQYWdlO1xuICAgICAgaWYgKHVucmVnaXN0ZXJQYWdlKSB1bnJlZ2lzdGVyUGFnZSh0aGlzLnBhZ2VJbmRleCk7XG4gICAgICBjYW5jZWxSdW5uaW5nVGFzayh0aGlzLnJ1bm5pbmdUYXNrKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UGFnZUluZGV4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBhZ2VJbmRleCgpIHtcbiAgICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdGhpcy5wcm9wcztcblxuICAgICAgaWYgKGlzUHJvdmlkZWQocHJvcHMucGFnZU51bWJlcikpIHtcbiAgICAgICAgcmV0dXJuIHByb3BzLnBhZ2VOdW1iZXIgLSAxO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNQcm92aWRlZChwcm9wcy5wYWdlSW5kZXgpKSB7XG4gICAgICAgIHJldHVybiBwcm9wcy5wYWdlSW5kZXg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRQYWdlTnVtYmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBhZ2VOdW1iZXIoKSB7XG4gICAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRoaXMucHJvcHM7XG5cbiAgICAgIGlmIChpc1Byb3ZpZGVkKHByb3BzLnBhZ2VOdW1iZXIpKSB7XG4gICAgICAgIHJldHVybiBwcm9wcy5wYWdlTnVtYmVyO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNQcm92aWRlZChwcm9wcy5wYWdlSW5kZXgpKSB7XG4gICAgICAgIHJldHVybiBwcm9wcy5wYWdlSW5kZXggKyAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyTWFpbkxheWVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlck1haW5MYXllcigpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczIgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGNhbnZhc1JlZiA9IF90aGlzJHByb3BzMi5jYW52YXNSZWYsXG4gICAgICAgICAgcmVuZGVyTW9kZSA9IF90aGlzJHByb3BzMi5yZW5kZXJNb2RlO1xuXG4gICAgICBzd2l0Y2ggKHJlbmRlck1vZGUpIHtcbiAgICAgICAgY2FzZSAnbm9uZSc6XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgY2FzZSAnc3ZnJzpcbiAgICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUGFnZVNWRywge1xuICAgICAgICAgICAga2V5OiBcIlwiLmNvbmNhdCh0aGlzLnBhZ2VLZXlOb1NjYWxlLCBcIl9zdmdcIilcbiAgICAgICAgICB9KTtcblxuICAgICAgICBjYXNlICdjYW52YXMnOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChQYWdlQ2FudmFzLCB7XG4gICAgICAgICAgICBrZXk6IFwiXCIuY29uY2F0KHRoaXMucGFnZUtleSwgXCJfY2FudmFzXCIpLFxuICAgICAgICAgICAgY2FudmFzUmVmOiBjYW52YXNSZWZcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyVGV4dExheWVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlclRleHRMYXllcigpIHtcbiAgICAgIHZhciByZW5kZXJUZXh0TGF5ZXIgPSB0aGlzLnByb3BzLnJlbmRlclRleHRMYXllcjtcblxuICAgICAgaWYgKCFyZW5kZXJUZXh0TGF5ZXIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChUZXh0TGF5ZXIsIHtcbiAgICAgICAga2V5OiBcIlwiLmNvbmNhdCh0aGlzLnBhZ2VLZXksIFwiX3RleHRcIilcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJBbm5vdGF0aW9uTGF5ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyQW5ub3RhdGlvbkxheWVyKCkge1xuICAgICAgdmFyIHJlbmRlckFubm90YXRpb25MYXllciA9IHRoaXMucHJvcHMucmVuZGVyQW5ub3RhdGlvbkxheWVyO1xuXG4gICAgICBpZiAoIXJlbmRlckFubm90YXRpb25MYXllcikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogQXMgb2Ygbm93LCBQREYuanMgMi4wLjk0MyByZXR1cm5zIHdhcm5pbmdzIG9uIHVuaW1wbGVtZW50ZWQgYW5ub3RhdGlvbnMgaW4gU1ZHIG1vZGUuXG4gICAgICAgKiBUaGVyZWZvcmUsIGFzIGEgZmFsbGJhY2ssIHdlIHJlbmRlciBcInRyYWRpdGlvbmFsXCIgQW5ub3RhdGlvbkxheWVyIGNvbXBvbmVudC5cbiAgICAgICAqL1xuXG5cbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBbm5vdGF0aW9uTGF5ZXIsIHtcbiAgICAgICAga2V5OiBcIlwiLmNvbmNhdCh0aGlzLnBhZ2VLZXksIFwiX2Fubm90YXRpb25zXCIpXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyQ2hpbGRyZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyQ2hpbGRyZW4oKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFBhZ2VDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiB0aGlzLmNoaWxkQ29udGV4dFxuICAgICAgfSwgdGhpcy5yZW5kZXJNYWluTGF5ZXIoKSwgdGhpcy5yZW5kZXJUZXh0TGF5ZXIoKSwgdGhpcy5yZW5kZXJBbm5vdGF0aW9uTGF5ZXIoKSwgY2hpbGRyZW4pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJDb250ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckNvbnRlbnQoKSB7XG4gICAgICB2YXIgcGFnZU51bWJlciA9IHRoaXMucGFnZU51bWJlcjtcbiAgICAgIHZhciBwZGYgPSB0aGlzLnByb3BzLnBkZjtcbiAgICAgIHZhciBwYWdlID0gdGhpcy5zdGF0ZS5wYWdlO1xuXG4gICAgICBpZiAoIXBhZ2VOdW1iZXIpIHtcbiAgICAgICAgdmFyIG5vRGF0YSA9IHRoaXMucHJvcHMubm9EYXRhO1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTWVzc2FnZSwge1xuICAgICAgICAgIHR5cGU6IFwibm8tZGF0YVwiXG4gICAgICAgIH0sIHR5cGVvZiBub0RhdGEgPT09ICdmdW5jdGlvbicgPyBub0RhdGEoKSA6IG5vRGF0YSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwZGYgPT09IG51bGwgfHwgcGFnZSA9PT0gbnVsbCkge1xuICAgICAgICB2YXIgbG9hZGluZyA9IHRoaXMucHJvcHMubG9hZGluZztcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KE1lc3NhZ2UsIHtcbiAgICAgICAgICB0eXBlOiBcImxvYWRpbmdcIlxuICAgICAgICB9LCB0eXBlb2YgbG9hZGluZyA9PT0gJ2Z1bmN0aW9uJyA/IGxvYWRpbmcoKSA6IGxvYWRpbmcpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGRmID09PSBmYWxzZSB8fCBwYWdlID09PSBmYWxzZSkge1xuICAgICAgICB2YXIgZXJyb3IgPSB0aGlzLnByb3BzLmVycm9yO1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTWVzc2FnZSwge1xuICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIlxuICAgICAgICB9LCB0eXBlb2YgZXJyb3IgPT09ICdmdW5jdGlvbicgPyBlcnJvcigpIDogZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJDaGlsZHJlbigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIHBhZ2VOdW1iZXIgPSB0aGlzLnBhZ2VOdW1iZXI7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBjbGFzc05hbWUgPSBfdGhpcyRwcm9wczMuY2xhc3NOYW1lLFxuICAgICAgICAgIGlucHV0UmVmID0gX3RoaXMkcHJvcHMzLmlucHV0UmVmO1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9leHRlbmRzKHtcbiAgICAgICAgY2xhc3NOYW1lOiBtZXJnZUNsYXNzTmFtZXMoJ3JlYWN0LXBkZl9fUGFnZScsIGNsYXNzTmFtZSksXG4gICAgICAgIFwiZGF0YS1wYWdlLW51bWJlclwiOiBwYWdlTnVtYmVyLFxuICAgICAgICByZWY6IG1lcmdlUmVmcyhpbnB1dFJlZiwgdGhpcy5yZWYpLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnXG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMuZXZlbnRQcm9wcyksIHRoaXMucmVuZGVyQ29udGVudCgpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2hpbGRDb250ZXh0XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgcGFnZSA9IHRoaXMuc3RhdGUucGFnZTtcblxuICAgICAgaWYgKCFwYWdlKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cblxuICAgICAgdmFyIF90aGlzJHByb3BzNCA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgY3VzdG9tVGV4dFJlbmRlcmVyID0gX3RoaXMkcHJvcHM0LmN1c3RvbVRleHRSZW5kZXJlcixcbiAgICAgICAgICBvbkdldEFubm90YXRpb25zRXJyb3IgPSBfdGhpcyRwcm9wczQub25HZXRBbm5vdGF0aW9uc0Vycm9yLFxuICAgICAgICAgIG9uR2V0QW5ub3RhdGlvbnNTdWNjZXNzID0gX3RoaXMkcHJvcHM0Lm9uR2V0QW5ub3RhdGlvbnNTdWNjZXNzLFxuICAgICAgICAgIG9uR2V0VGV4dEVycm9yID0gX3RoaXMkcHJvcHM0Lm9uR2V0VGV4dEVycm9yLFxuICAgICAgICAgIG9uR2V0VGV4dFN1Y2Nlc3MgPSBfdGhpcyRwcm9wczQub25HZXRUZXh0U3VjY2VzcyxcbiAgICAgICAgICBvblJlbmRlckFubm90YXRpb25MYXllckVycm9yID0gX3RoaXMkcHJvcHM0Lm9uUmVuZGVyQW5ub3RhdGlvbkxheWVyRXJyb3IsXG4gICAgICAgICAgb25SZW5kZXJBbm5vdGF0aW9uTGF5ZXJTdWNjZXNzID0gX3RoaXMkcHJvcHM0Lm9uUmVuZGVyQW5ub3RhdGlvbkxheWVyU3VjY2VzcyxcbiAgICAgICAgICBvblJlbmRlckVycm9yID0gX3RoaXMkcHJvcHM0Lm9uUmVuZGVyRXJyb3IsXG4gICAgICAgICAgb25SZW5kZXJTdWNjZXNzID0gX3RoaXMkcHJvcHM0Lm9uUmVuZGVyU3VjY2VzcyxcbiAgICAgICAgICByZW5kZXJJbnRlcmFjdGl2ZUZvcm1zID0gX3RoaXMkcHJvcHM0LnJlbmRlckludGVyYWN0aXZlRm9ybXM7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjdXN0b21UZXh0UmVuZGVyZXI6IGN1c3RvbVRleHRSZW5kZXJlcixcbiAgICAgICAgb25HZXRBbm5vdGF0aW9uc0Vycm9yOiBvbkdldEFubm90YXRpb25zRXJyb3IsXG4gICAgICAgIG9uR2V0QW5ub3RhdGlvbnNTdWNjZXNzOiBvbkdldEFubm90YXRpb25zU3VjY2VzcyxcbiAgICAgICAgb25HZXRUZXh0RXJyb3I6IG9uR2V0VGV4dEVycm9yLFxuICAgICAgICBvbkdldFRleHRTdWNjZXNzOiBvbkdldFRleHRTdWNjZXNzLFxuICAgICAgICBvblJlbmRlckFubm90YXRpb25MYXllckVycm9yOiBvblJlbmRlckFubm90YXRpb25MYXllckVycm9yLFxuICAgICAgICBvblJlbmRlckFubm90YXRpb25MYXllclN1Y2Nlc3M6IG9uUmVuZGVyQW5ub3RhdGlvbkxheWVyU3VjY2VzcyxcbiAgICAgICAgb25SZW5kZXJFcnJvcjogb25SZW5kZXJFcnJvcixcbiAgICAgICAgb25SZW5kZXJTdWNjZXNzOiBvblJlbmRlclN1Y2Nlc3MsXG4gICAgICAgIHBhZ2U6IHBhZ2UsXG4gICAgICAgIHJlbmRlckludGVyYWN0aXZlRm9ybXM6IHJlbmRlckludGVyYWN0aXZlRm9ybXMsXG4gICAgICAgIHJvdGF0ZTogdGhpcy5yb3RhdGUsXG4gICAgICAgIHNjYWxlOiB0aGlzLnNjYWxlXG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBhIHBhZ2UgaXMgbG9hZGVkIHN1Y2Nlc3NmdWxseVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicGFnZUluZGV4XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRQYWdlSW5kZXgoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFnZU51bWJlclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFnZU51bWJlcigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyb3RhdGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciByb3RhdGUgPSB0aGlzLnByb3BzLnJvdGF0ZTtcblxuICAgICAgaWYgKGlzUHJvdmlkZWQocm90YXRlKSkge1xuICAgICAgICByZXR1cm4gcm90YXRlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFnZSA9IHRoaXMuc3RhdGUucGFnZTtcblxuICAgICAgaWYgKCFwYWdlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFnZS5yb3RhdGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNjYWxlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgcGFnZSA9IHRoaXMuc3RhdGUucGFnZTtcblxuICAgICAgaWYgKCFwYWdlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3RoaXMkcHJvcHM1ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBzY2FsZSA9IF90aGlzJHByb3BzNS5zY2FsZSxcbiAgICAgICAgICB3aWR0aCA9IF90aGlzJHByb3BzNS53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSBfdGhpcyRwcm9wczUuaGVpZ2h0O1xuICAgICAgdmFyIHJvdGF0ZSA9IHRoaXMucm90YXRlOyAvLyBCZSBkZWZhdWx0LCB3ZSdsbCByZW5kZXIgcGFnZSBhdCAxMDAlICogc2NhbGUgd2lkdGguXG5cbiAgICAgIHZhciBwYWdlU2NhbGUgPSAxOyAvLyBQYXNzaW5nIHNjYWxlIGV4cGxpY2l0bHkgbnVsbCB3b3VsZCBjYXVzZSB0aGUgcGFnZSBub3QgdG8gcmVuZGVyXG5cbiAgICAgIHZhciBzY2FsZVdpdGhEZWZhdWx0ID0gc2NhbGUgPT09IG51bGwgPyBkZWZhdWx0U2NhbGUgOiBzY2FsZTsgLy8gSWYgd2lkdGgvaGVpZ2h0IGlzIGRlZmluZWQsIGNhbGN1bGF0ZSB0aGUgc2NhbGUgb2YgdGhlIHBhZ2Ugc28gaXQgY291bGQgYmUgb2YgZGVzaXJlZCB3aWR0aC5cblxuICAgICAgaWYgKHdpZHRoIHx8IGhlaWdodCkge1xuICAgICAgICB2YXIgdmlld3BvcnQgPSBwYWdlLmdldFZpZXdwb3J0KHtcbiAgICAgICAgICBzY2FsZTogMSxcbiAgICAgICAgICByb3RhdGlvbjogcm90YXRlXG4gICAgICAgIH0pO1xuICAgICAgICBwYWdlU2NhbGUgPSB3aWR0aCA/IHdpZHRoIC8gdmlld3BvcnQud2lkdGggOiBoZWlnaHQgLyB2aWV3cG9ydC5oZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzY2FsZVdpdGhEZWZhdWx0ICogcGFnZVNjYWxlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJldmVudFByb3BzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgcmV0dXJuIG1ha2VFdmVudFByb3BzKHRoaXMucHJvcHMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhZ2UgPSBfdGhpczIuc3RhdGUucGFnZTtcblxuICAgICAgICBpZiAoIXBhZ2UpIHtcbiAgICAgICAgICByZXR1cm4gcGFnZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYWtlUGFnZUNhbGxiYWNrKHBhZ2UsIF90aGlzMi5zY2FsZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFnZUtleVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIHBhZ2UgPSB0aGlzLnN0YXRlLnBhZ2U7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQocGFnZS5wYWdlSW5kZXgsIFwiQFwiKS5jb25jYXQodGhpcy5zY2FsZSwgXCIvXCIpLmNvbmNhdCh0aGlzLnJvdGF0ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhZ2VLZXlOb1NjYWxlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgcGFnZSA9IHRoaXMuc3RhdGUucGFnZTtcbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdChwYWdlLnBhZ2VJbmRleCwgXCIvXCIpLmNvbmNhdCh0aGlzLnJvdGF0ZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBhZ2VJbnRlcm5hbDtcbn0oUHVyZUNvbXBvbmVudCk7XG5QYWdlSW50ZXJuYWwuZGVmYXVsdFByb3BzID0ge1xuICBlcnJvcjogJ0ZhaWxlZCB0byBsb2FkIHRoZSBwYWdlLicsXG4gIGxvYWRpbmc6ICdMb2FkaW5nIHBhZ2XigKYnLFxuICBub0RhdGE6ICdObyBwYWdlIHNwZWNpZmllZC4nLFxuICByZW5kZXJBbm5vdGF0aW9uTGF5ZXI6IHRydWUsXG4gIHJlbmRlckludGVyYWN0aXZlRm9ybXM6IGZhbHNlLFxuICByZW5kZXJNb2RlOiAnY2FudmFzJyxcbiAgcmVuZGVyVGV4dExheWVyOiB0cnVlLFxuICBzY2FsZTogZGVmYXVsdFNjYWxlXG59O1xudmFyIGlzRnVuY3Rpb25Pck5vZGUgPSBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm5vZGVdKTtcblBhZ2VJbnRlcm5hbC5wcm9wVHlwZXMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGV2ZW50UHJvcHMpLCB7fSwge1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gIGNsYXNzTmFtZTogaXNDbGFzc05hbWUsXG4gIGN1c3RvbVRleHRSZW5kZXJlcjogUHJvcFR5cGVzLmZ1bmMsXG4gIGVycm9yOiBpc0Z1bmN0aW9uT3JOb2RlLFxuICBoZWlnaHQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIGltYWdlUmVzb3VyY2VzUGF0aDogUHJvcFR5cGVzLnN0cmluZyxcbiAgaW5wdXRSZWY6IGlzUmVmLFxuICBsb2FkaW5nOiBpc0Z1bmN0aW9uT3JOb2RlLFxuICBub0RhdGE6IGlzRnVuY3Rpb25Pck5vZGUsXG4gIG9uR2V0VGV4dEVycm9yOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25HZXRUZXh0U3VjY2VzczogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uTG9hZEVycm9yOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25Mb2FkU3VjY2VzczogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uUmVuZGVyRXJyb3I6IFByb3BUeXBlcy5mdW5jLFxuICBvblJlbmRlclN1Y2Nlc3M6IFByb3BUeXBlcy5mdW5jLFxuICBwYWdlSW5kZXg6IGlzUGFnZUluZGV4LFxuICBwYWdlTnVtYmVyOiBpc1BhZ2VOdW1iZXIsXG4gIHBkZjogaXNQZGYsXG4gIHJlZ2lzdGVyUGFnZTogUHJvcFR5cGVzLmZ1bmMsXG4gIHJlbmRlckFubm90YXRpb25MYXllcjogUHJvcFR5cGVzLmJvb2wsXG4gIHJlbmRlckludGVyYWN0aXZlRm9ybXM6IFByb3BUeXBlcy5ib29sLFxuICByZW5kZXJNb2RlOiBpc1JlbmRlck1vZGUsXG4gIHJlbmRlclRleHRMYXllcjogUHJvcFR5cGVzLmJvb2wsXG4gIHJvdGF0ZTogaXNSb3RhdGUsXG4gIHNjYWxlOiBQcm9wVHlwZXMubnVtYmVyLFxuICB1bnJlZ2lzdGVyUGFnZTogUHJvcFR5cGVzLmZ1bmMsXG4gIHdpZHRoOiBQcm9wVHlwZXMubnVtYmVyXG59KTtcblxuZnVuY3Rpb24gUGFnZShwcm9wcywgcmVmKSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChEb2N1bWVudENvbnRleHQuQ29uc3VtZXIsIG51bGwsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFBhZ2VJbnRlcm5hbCwgX2V4dGVuZHMoe1xuICAgICAgcmVmOiByZWZcbiAgICB9LCBjb250ZXh0LCBwcm9wcykpO1xuICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoUGFnZSk7IiwiaW1wb3J0ICogYXMgcGRmanMgZnJvbSAncGRmanMtZGlzdCc7XG5pbXBvcnQgRG9jdW1lbnQgZnJvbSAnLi9Eb2N1bWVudCc7XG5pbXBvcnQgT3V0bGluZSBmcm9tICcuL091dGxpbmUnO1xuaW1wb3J0IFBhZ2UgZnJvbSAnLi9QYWdlJztcbmltcG9ydCB7IGlzTG9jYWxGaWxlU3lzdGVtLCB3YXJuT25EZXYgfSBmcm9tICcuL3NoYXJlZC91dGlscyc7XG5cbmlmIChpc0xvY2FsRmlsZVN5c3RlbSkge1xuICB3YXJuT25EZXYoJ1lvdSBhcmUgcnVubmluZyBSZWFjdC1QREYgZnJvbSB5b3VyIGxvY2FsIGZpbGUgc3lzdGVtLiBQREYuanMgV29ya2VyIG1heSBmYWlsIHRvIGxvYWQgZHVlIHRvIGJyb3dzZXJcXCdzIHNlY3VyaXR5IHBvbGljaWVzLiBJZiB5b3VcXCdyZSBvbiBHb29nbGUgQ2hyb21lLCB5b3UgY2FuIHVzZSAtLWFsbG93LWZpbGUtYWNjZXNzLWZyb20tZmlsZXMgZmxhZyBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLicpO1xufVxuXG5wZGZqcy5HbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclNyYyA9ICdwZGYud29ya2VyLmpzJztcbmV4cG9ydCB7IHBkZmpzLCBEb2N1bWVudCwgT3V0bGluZSwgUGFnZSB9OyIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgTnVsbGFibGUgfSBmcm9tICcuLi9jb21wb25lbnRzL3R5cGVzL3R5cGVzJztcbmltcG9ydCB7IGxvZ1Byb3ZpZGVyV2FybmluZyB9IGZyb20gJy4uL3V0aWxzL3Byb3ZpZGVyJztcblxuZXhwb3J0IGludGVyZmFjZSBJVWlDb250ZXh0IHtcbiAgZXJyb3JNZXNzYWdlOiBOdWxsYWJsZTxzdHJpbmc+O1xuICBpc0xvYWRpbmc6IGJvb2xlYW47XG4gIGlzU2hvd2luZ0hpZ2hsaWdodE92ZXJsYXk6IGJvb2xlYW47XG4gIGlzU2hvd2luZ091dGxpbmU6IGJvb2xlYW47XG4gIGlzU2hvd2luZ1RleHRIaWdobGlnaHQ6IGJvb2xlYW47XG4gIHNldEVycm9yTWVzc2FnZTogKGVycm9yTWVzc2FnZTogTnVsbGFibGU8c3RyaW5nPikgPT4gdm9pZDtcbiAgc2V0SXNMb2FkaW5nOiAoaXNMb2FkaW5nOiBib29sZWFuKSA9PiB2b2lkO1xuICBzZXRJc1Nob3dpbmdIaWdobGlnaHRPdmVybGF5OiAoaXNTaG93aW5nSGlnaGxpZ2h0T3ZlcmxheTogYm9vbGVhbikgPT4gdm9pZDtcbiAgc2V0SXNTaG93aW5nT3V0bGluZTogKGlzU2hvd2luZ091dGxpbmU6IGJvb2xlYW4pID0+IHZvaWQ7XG4gIHNldElzU2hvd2luZ1RleHRIaWdobGlnaHQ6IChpc1Nob3dpbmdUZXh0SGlnaGxpZ2h0OiBib29sZWFuKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgY29uc3QgVWlDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDxJVWlDb250ZXh0Pih7XG4gIGVycm9yTWVzc2FnZTogbnVsbCxcbiAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgaXNTaG93aW5nSGlnaGxpZ2h0T3ZlcmxheTogZmFsc2UsXG4gIGlzU2hvd2luZ091dGxpbmU6IGZhbHNlLFxuICBpc1Nob3dpbmdUZXh0SGlnaGxpZ2h0OiBmYWxzZSxcbiAgc2V0RXJyb3JNZXNzYWdlOiBlcnJvck1lc3NhZ2UgPT4ge1xuICAgIGxvZ1Byb3ZpZGVyV2FybmluZyhgc2V0RXJyb3JNZXNzYWdlKCR7ZXJyb3JNZXNzYWdlfSlgLCAnVWlDb250ZXh0Jyk7XG4gIH0sXG4gIHNldElzU2hvd2luZ091dGxpbmU6IGlzU2hvd2luZ091dGxpbmUgPT4ge1xuICAgIGxvZ1Byb3ZpZGVyV2FybmluZyhgc2V0SXNTaG93aW5nT3V0bGluZSgke2lzU2hvd2luZ091dGxpbmV9KWAsICdVaUNvbnRleHQnKTtcbiAgfSxcbiAgc2V0SXNMb2FkaW5nOiBpc0xvYWRpbmcgPT4ge1xuICAgIGxvZ1Byb3ZpZGVyV2FybmluZyhgc2V0SXNMb2FkaW5nKCR7aXNMb2FkaW5nfSlgLCAnVWlDb250ZXh0Jyk7XG4gIH0sXG4gIHNldElzU2hvd2luZ0hpZ2hsaWdodE92ZXJsYXk6IGlzU2hvd2luZ0hpZ2hsaWdodE92ZXJsYXkgPT4ge1xuICAgIGxvZ1Byb3ZpZGVyV2FybmluZyhgc2V0SXNTaG93aW5nSGlnaGxpZ2h0T3ZlcmxheSgke2lzU2hvd2luZ0hpZ2hsaWdodE92ZXJsYXl9KWAsICdVaUNvbnRleHQnKTtcbiAgfSxcbiAgc2V0SXNTaG93aW5nVGV4dEhpZ2hsaWdodDogaXNTaG93aW5nVGV4dEhpZ2hsaWdodCA9PiB7XG4gICAgbG9nUHJvdmlkZXJXYXJuaW5nKGBzZXRJc1Nob3dpbmdUZXh0SGlnaGxpZ2h0KCR7aXNTaG93aW5nVGV4dEhpZ2hsaWdodH0pYCwgJ1VpQ29udGV4dCcpO1xuICB9LFxufSk7XG4iLCIvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZXhwb3J0IGZ1bmN0aW9uIGdldEVycm9yTWVzc2FnZShlcnJvcjogYW55KTogc3RyaW5nIHtcbiAgaWYgKCFlcnJvcikge1xuICAgIHJldHVybiAnVW5rbm93biBlcnJvcic7XG4gIH1cbiAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cbiAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IubWVzc2FnZTtcbiAgfVxuICBpZiAodHlwZW9mIGVycm9yLmVycm9yID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBlcnJvci5lcnJvcjtcbiAgfVxuICByZXR1cm4gZXJyb3IudG9TdHJpbmcoKTtcbn1cbiIsImltcG9ydCB7IHBkZmpzIH0gZnJvbSAncmVhY3QtcGRmJztcblxuLy8gU2V0IFBERmpzIHdvcmtlciBzb3VyY2Ugb3IgZWxzZSBQREYgd2lsbCBub3QgbG9hZCB3aGVuIHRoaXMgbGlicmFyeSBpcyBpbXBvcnRlZCBhcyBhIHBhY2thZ2UuXG5leHBvcnQgZnVuY3Rpb24gaW5pdFBkZldvcmtlcigpOiB2b2lkIHtcbiAgcGRmanMuR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJTcmMgPSBgLy9jZG5qcy5jbG91ZGZsYXJlLmNvbS9hamF4L2xpYnMvcGRmLmpzLyR7cGRmanMudmVyc2lvbn0vcGRmLndvcmtlci5taW4uanNgO1xufVxuIiwiaW1wb3J0IHsgRGltZW5zaW9ucyB9IGZyb20gJy4uL2NvbXBvbmVudHMvdHlwZXMvdHlwZXMnO1xuXG4vLyBEYXRhIGZyb20gcmVhY3QtcGRmL3BkZmpzIHRoYXQgd2UgbmVlZCB0byBjb21wdXRlIHRoZSBwaXhlbCBzaXplIG9mIHRoZSBQREYncyBwYWdlKHMpLlxuZXhwb3J0IGludGVyZmFjZSBJUERGUGFnZVByb3h5IHtcbiAgdXNlclVuaXQ6IG51bWJlcjsgLy8gdGhlIGRlZmF1bHQgc2l6ZSBvZiB1bml0cyBpbiAxLzcybmRzIG9mIGFuIGluY2hcbiAgdmlldzogQXJyYXk8bnVtYmVyPjsgLy8gZm9ybWF0OiBbIHRvcCBsZWZ0IHggY29vcmRpbmF0ZSwgdG9wIGxlZnQgeSBjb29yZGluYXRlLCBib3R0b20gcmlnaHQgeCwgYm90dG9tIHJpZ2h0IHldXG59XG5cbi8vIFdlIGFzc3VtZSA5NiBEUEkgZm9yIGRpc3BsYXlcbi8vIFRPRE86IFRoZXJlIGFyZSBtb3JlIGFjY3VyYXRlIHdheXMgdG8gZG8gdGhpcywgYnV0IHRoaXMgaXMgd2hhdCBTY2hvbGFyUGhpIGRvZXMgbm93XG5jb25zdCBEUEkgPSA5NjtcblxuLy8gUERGIHVuaXRzIGFyZSBpbiAxLzcybmRzIG9mIGFuIGluY2hcbmNvbnN0IFVTRVJfVU5JVF9ERU5PTUlOQVRPUiA9IDcyO1xuXG4vKipcbiAqIEdpdmVuIGEgUERGUGFnZVByb3h5LCBjYWxjdWxhdGVzIHRoZSBzY3JlZW4gcGl4ZWwgc2l6ZSBvZiB0aGUgUERGIHBhZ2UgYXQgMTAwJSBzY2FsZVxuICogQHBhcmFtIHBhZ2UgVGhlIFBERlBhZ2VQcm94eSB0byBjYWxjdWxhdGUgc2l6ZSBmb3JcbiAqIEByZXR1cm5zIFBpeGVsIHNpemUgb2YgYSBwYWdlIGF0IDEwMCUgc2NhbGUgYXNzdW1pbmcgOTZEUEkgZGlzcGxheVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZVBhZ2VEaW1lbnNpb25zKHBhZ2U6IElQREZQYWdlUHJveHkpOiBEaW1lbnNpb25zIHtcbiAgY29uc3QgW2xlZnRQeCwgdG9wUHgsIHJpZ2h0UHgsIGJvdHRvbVB4XSA9IHBhZ2UudmlldztcbiAgY29uc3QgUFBJID0gKHBhZ2UudXNlclVuaXQgLyBVU0VSX1VOSVRfREVOT01JTkFUT1IpICogRFBJO1xuXG4gIHJldHVybiB7XG4gICAgaGVpZ2h0OiAoYm90dG9tUHggLSB0b3BQeCkgKiBQUEksXG4gICAgd2lkdGg6IChyaWdodFB4IC0gbGVmdFB4KSAqIFBQSSxcbiAgfTtcbn1cbiIsImltcG9ydCB7IFBERkRvY3VtZW50UHJveHkgfSBmcm9tICdwZGZqcy1kaXN0L3R5cGVzL2Rpc3BsYXkvYXBpJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IERvY3VtZW50LCBEb2N1bWVudFByb3BzIH0gZnJvbSAncmVhY3QtcGRmJztcblxuaW1wb3J0IHsgRG9jdW1lbnRDb250ZXh0IH0gZnJvbSAnLi4vY29udGV4dC9Eb2N1bWVudENvbnRleHQnO1xuaW1wb3J0IHsgVWlDb250ZXh0IH0gZnJvbSAnLi4vY29udGV4dC9VaUNvbnRleHQnO1xuaW1wb3J0IHsgZ2V0RXJyb3JNZXNzYWdlIH0gZnJvbSAnLi4vdXRpbHMvZXJyb3JNZXNzYWdlJztcbmltcG9ydCB7IGluaXRQZGZXb3JrZXIgfSBmcm9tICcuLi91dGlscy9wZGZXb3JrZXInO1xuaW1wb3J0IHsgY29tcHV0ZVBhZ2VEaW1lbnNpb25zLCBJUERGUGFnZVByb3h5IH0gZnJvbSAnLi4vdXRpbHMvc2NhbGUnO1xuXG5leHBvcnQgdHlwZSBQcm9wcyA9IHtcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG59ICYgRG9jdW1lbnRQcm9wcztcblxuZXhwb3J0IGNvbnN0IERvY3VtZW50V3JhcHBlcjogUmVhY3QuRnVuY3Rpb25Db21wb25lbnQ8UHJvcHM+ID0gKHsgY2hpbGRyZW4sIC4uLnJlc3QgfTogUHJvcHMpID0+IHtcbiAgaW5pdFBkZldvcmtlcigpO1xuXG4gIGNvbnN0IHsgcGRmRG9jUHJveHksIHNldE51bVBhZ2VzLCBzZXRQYWdlRGltZW5zaW9ucywgc2V0UGRmRG9jUHJveHkgfSA9XG4gICAgUmVhY3QudXNlQ29udGV4dChEb2N1bWVudENvbnRleHQpO1xuICBjb25zdCB7IHNldEVycm9yTWVzc2FnZSwgc2V0SXNMb2FkaW5nIH0gPSBSZWFjdC51c2VDb250ZXh0KFVpQ29udGV4dCk7XG5cbiAgZnVuY3Rpb24gZ2V0Rmlyc3RQYWdlKHBkZkRvYzogUERGRG9jdW1lbnRQcm94eSk6IFByb21pc2U8SVBERlBhZ2VQcm94eT4ge1xuICAgIC8vIGdldFBhZ2UgdXNlcyAxLWluZGV4ZWQgcGFnZU51bWJlciwgbm90IDAtaW5kZXhlZCBwYWdlSW5kZXhcbiAgICByZXR1cm4gcGRmRG9jLmdldFBhZ2UoMSk7XG4gIH1cblxuICBjb25zdCBvblBkZkxvYWRTdWNjZXNzID0gUmVhY3QudXNlQ2FsbGJhY2soKHBkZkRvYzogUERGRG9jdW1lbnRQcm94eSk6IHZvaWQgPT4ge1xuICAgIHNldE51bVBhZ2VzKHBkZkRvYy5udW1QYWdlcyk7XG4gICAgZ2V0Rmlyc3RQYWdlKHBkZkRvYylcbiAgICAgIC50aGVuKHBhZ2UgPT4ge1xuICAgICAgICBzZXRQYWdlRGltZW5zaW9ucyhjb21wdXRlUGFnZURpbWVuc2lvbnMocGFnZSkpO1xuICAgICAgICBzZXRFcnJvck1lc3NhZ2UobnVsbCk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgc2V0RXJyb3JNZXNzYWdlKGdldEVycm9yTWVzc2FnZShlcnJvcikpO1xuICAgICAgfSlcbiAgICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgIH0pO1xuXG4gICAgaWYgKCFwZGZEb2NQcm94eSkge1xuICAgICAgc2V0UGRmRG9jUHJveHkocGRmRG9jKTtcbiAgICB9XG4gIH0sIFtdKTtcblxuICBjb25zdCBvblBkZkxvYWRFcnJvciA9IFJlYWN0LnVzZUNhbGxiYWNrKChlcnJvcjogdW5rbm93bik6IHZvaWQgPT4ge1xuICAgIHNldEVycm9yTWVzc2FnZShnZXRFcnJvck1lc3NhZ2UoZXJyb3IpKTtcbiAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8RG9jdW1lbnRcbiAgICAgIG9wdGlvbnM9e3sgY01hcFVybDogJ2NtYXBzLycsIGNNYXBQYWNrZWQ6IHRydWUgfX1cbiAgICAgIG9uTG9hZEVycm9yPXtvblBkZkxvYWRFcnJvcn1cbiAgICAgIG9uTG9hZFN1Y2Nlc3M9e29uUGRmTG9hZFN1Y2Nlc3N9XG4gICAgICB7Li4ucmVzdH0+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9Eb2N1bWVudD5cbiAgKTtcbn07XG4iLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmV4cG9ydCB0eXBlIFByb3BzID0ge1xuICBwZGZVcmw6IHN0cmluZztcbn07XG5cbi8qKlxuICogSFRNTCBhbmNob3IgdGFnIGFsbG93cyB5b3UgdG8gZG93bmxvYWQgYSBmaWxlIGZyb20gdGhlIHNhbWUgb3JpZ2luLlxuICogVGhpcyBpcyBhIHdvcmthcm91bmQgdG8gZG93bmxvYWQgYSBmaWxlIHNlcnZlZCBmcm9tIGEgZGlmZmVyZW50IG9yaWdpblxuICovXG5leHBvcnQgY29uc3QgRG93bmxvYWRCdXR0b246IFJlYWN0LkZ1bmN0aW9uQ29tcG9uZW50PFByb3BzPiA9ICh7IHBkZlVybCB9OiBQcm9wcykgPT4ge1xuICBjb25zdCBbZmV0Y2hpbmcsIHNldEZldGNoaW5nXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcblxuICBjb25zdCBkb3dubG9hZCA9ICgpID0+IHtcbiAgICBzZXRGZXRjaGluZyh0cnVlKTtcblxuICAgIGZldGNoKHBkZlVybClcbiAgICAgIC50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmJsb2IoKSlcbiAgICAgIC50aGVuKGJsb2IgPT4ge1xuICAgICAgICBzZXRGZXRjaGluZyhmYWxzZSk7XG4gICAgICAgIGNvbnN0IGJsb2JVUkwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICBjb25zdCBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICBhLmhyZWYgPSBibG9iVVJMO1xuICAgICAgICBhLmRvd25sb2FkID0gcGRmVXJsLnNwbGl0KCcvJykucG9wKCkgfHwgcGRmVXJsO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGEpO1xuICAgICAgICBhLmNsaWNrKCk7XG4gICAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxidXR0b24gZGlzYWJsZWQ9e2ZldGNoaW5nfSBvbkNsaWNrPXsoKSA9PiBkb3dubG9hZCgpfSBhcmlhLWxhYmVsPVwiRG93bmxvYWQgUERGXCI+XG4gICAgICBEb3dubG9hZFxuICAgIDwvYnV0dG9uPlxuICApO1xufTtcbiIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgRG9jdW1lbnRDb250ZXh0IH0gZnJvbSAnLi4vY29udGV4dC9Eb2N1bWVudENvbnRleHQnO1xuaW1wb3J0IHsgVHJhbnNmb3JtQ29udGV4dCB9IGZyb20gJy4uL2NvbnRleHQvVHJhbnNmb3JtQ29udGV4dCc7XG5pbXBvcnQgeyBjb21wdXRlQm91bmRpbmdCb3hTdHlsZSwgY29tcHV0ZVBhZ2VTdHlsZSB9IGZyb20gJy4uL3V0aWxzL3N0eWxlJztcbmltcG9ydCB7IFByb3BzIGFzIEJvdW5kaW5nQm94UHJvcHMgfSBmcm9tICcuL0JvdW5kaW5nQm94JztcblxuZXhwb3J0IHR5cGUgUHJvcHMgPSB7XG4gIGNoaWxkcmVuPzogUmVhY3QuUmVhY3RFbGVtZW50PEJvdW5kaW5nQm94UHJvcHM+IHwgQXJyYXk8UmVhY3QuUmVhY3RFbGVtZW50PEJvdW5kaW5nQm94UHJvcHM+PjtcbiAgcGFnZUluZGV4OiBudW1iZXI7XG59O1xuXG5leHBvcnQgY29uc3QgSGlnaGxpZ2h0T3ZlcmxheTogUmVhY3QuRnVuY3Rpb25Db21wb25lbnQ8UHJvcHM+ID0gKHtcbiAgY2hpbGRyZW4sXG4gIHBhZ2VJbmRleCxcbn06IFByb3BzKSA9PiB7XG4gIGNvbnN0IHsgcGFnZURpbWVuc2lvbnMgfSA9IFJlYWN0LnVzZUNvbnRleHQoRG9jdW1lbnRDb250ZXh0KTtcbiAgY29uc3QgeyByb3RhdGlvbiwgc2NhbGUgfSA9IFJlYWN0LnVzZUNvbnRleHQoVHJhbnNmb3JtQ29udGV4dCk7XG4gIGNvbnN0IG1hc2tJZCA9IGBoaWdobGlnaHQtb3ZlcmxheS1tYXNrLSR7cGFnZUluZGV4fWA7XG5cbiAgY29uc3QgZ2V0UGFnZVN0eWxlID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHJldHVybiBjb21wdXRlUGFnZVN0eWxlKHBhZ2VEaW1lbnNpb25zLCByb3RhdGlvbiwgc2NhbGUpO1xuICB9LCBbcGFnZURpbWVuc2lvbnMsIHJvdGF0aW9uLCBzY2FsZV0pO1xuXG4gIGNvbnN0IGdldFVubWFza2VkQXJlYSA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgIChcbiAgICAgIGJvdW5kaW5nQm94ZXM6XG4gICAgICAgIHwgUmVhY3QuUmVhY3RFbGVtZW50PEJvdW5kaW5nQm94UHJvcHM+XG4gICAgICAgIHwgQXJyYXk8UmVhY3QuUmVhY3RFbGVtZW50PEJvdW5kaW5nQm94UHJvcHM+PlxuICAgICkgPT4ge1xuICAgICAgY29uc3QgYm94ZXMgPSBBcnJheS5pc0FycmF5KGJvdW5kaW5nQm94ZXMpID8gYm91bmRpbmdCb3hlcyA6IFtib3VuZGluZ0JveGVzXTtcbiAgICAgIHJldHVybiBib3hlcy5tYXAoKGJveCwgaSkgPT4ge1xuICAgICAgICBjb25zdCBib3hTdHlsZSA9IGNvbXB1dGVCb3VuZGluZ0JveFN0eWxlKGJveC5wcm9wcywgcGFnZURpbWVuc2lvbnMsIHJvdGF0aW9uLCBzY2FsZSk7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgPHJlY3Qgc3R5bGU9e2JveFN0eWxlfSB4PXtib3hTdHlsZS5sZWZ0fSB5PXtib3hTdHlsZS50b3B9IGtleT17aX0gZmlsbD1cImJsYWNrXCI+PC9yZWN0PlxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBbcGFnZURpbWVuc2lvbnMsIHJvdGF0aW9uLCBzY2FsZV1cbiAgKTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwicmVhZGVyX19wYWdlLWhpZ2hsaWdodC1vdmVybGF5XCIgc3R5bGU9e2dldFBhZ2VTdHlsZSgpfT5cbiAgICAgIDxzdmcgY2xhc3NOYW1lPVwicGFnZS1tYXNrXCIgc3R5bGU9e2dldFBhZ2VTdHlsZSgpfT5cbiAgICAgICAgPG1hc2sgaWQ9e21hc2tJZH0+XG4gICAgICAgICAgPHJlY3Qgc3R5bGU9e2dldFBhZ2VTdHlsZSgpfSBmaWxsPVwid2hpdGVcIj48L3JlY3Q+XG4gICAgICAgICAge2NoaWxkcmVuICYmIGdldFVubWFza2VkQXJlYShjaGlsZHJlbil9XG4gICAgICAgIDwvbWFzaz5cbiAgICAgICAgPHJlY3Qgc3R5bGU9e2dldFBhZ2VTdHlsZSgpfSBmaWxsPVwid2hpdGVcIiBvcGFjaXR5PVwiMC42XCIgbWFzaz17YHVybCgjJHttYXNrSWR9KWB9PjwvcmVjdD5cbiAgICAgIDwvc3ZnPlxuICAgIDwvZGl2PlxuICApO1xufTtcbiIsImltcG9ydCB7IFBhZ2VQcm9wZXJ0aWVzIH0gZnJvbSAnLi4vY29tcG9uZW50cy90eXBlcy9QYWdlJztcbmltcG9ydCB7IFBhZ2VSb3RhdGlvbiB9IGZyb20gJy4uL3V0aWxzL3JvdGF0ZSc7XG5cbi8vIEVhY2ggcGFnZSBkaXYgaXMgSUQnZCBhY2NvcmRpbmcgdG8gcGFnZSBpbmRleFxuLy8gZS5nLiByZWFkZXJfcGdfMCwgcmVhZGVyX3BnXzEsIGV0Yy5cbmV4cG9ydCBjb25zdCBQQUdFX05BVl9UQVJHRVRfSURfUk9PVCA9ICdyZWFkZXJfcGdfJztcbmV4cG9ydCBjb25zdCBTQ1JPTExBQkxFX1RBUkdFVF9ESVZfQ0xBU1NOQU1FID0gJ3JlYWRlcl9fcGFnZS1saXN0JztcblxuY29uc3QgUERGX0hFSUdIVF9QT0lOVFMgPSA3OTI7XG5jb25zdCBQREZfV0lEVEhfUE9JTlRTID0gNjEyO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVQYWdlSWRGcm9tSW5kZXgocGFnZUluZGV4OiBudW1iZXIgfCBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gYCR7UEFHRV9OQVZfVEFSR0VUX0lEX1JPT1R9JHtwYWdlSW5kZXh9YDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNjcm9sbFRvSWQoaWQ6IHN0cmluZyk6IHZvaWQge1xuICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICBpZiAoZWxlbWVudCkge1xuICAgIGVsZW1lbnQuc2Nyb2xsSW50b1ZpZXcoeyBiZWhhdmlvcjogJ3Ntb290aCcsIGJsb2NrOiAnc3RhcnQnLCBpbmxpbmU6ICdjZW50ZXInIH0pO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUuZXJyb3IoYENvdWxkIG5vdCBmaW5kIHNjcm9sbCB0YXJnZXQgd2l0aCBJRCAjJHtpZH1gKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2Nyb2xsVG9QZGZQYWdlSW5kZXgocGFnZUluZGV4OiBudW1iZXIgfCBzdHJpbmcpOiB2b2lkIHtcbiAgc2Nyb2xsVG9JZChnZW5lcmF0ZVBhZ2VJZEZyb21JbmRleChwYWdlSW5kZXgpKTtcbn1cblxuLyoqXG4gKiBTY3JvbGwgUERGIGRvY3VtZW50IHRvIGEgc3BlY2lmaWMgcG9zaXRpb24uXG4gKiBAcGFyYW0gcGFnZUluZGV4IFRoZSBpbmRleCBvZiB0aGUgcGFnZSB3aGVyZSB0aGUgcG9zaXRpb24gbG9jYXRlcyBhdFxuICogQHBhcmFtIGxlZnRQb2ludHMgVGhlIGhvcml6b250YWwgZGlzdGFuY2UgYmV0d2VlbiB0aGUgb3JpZ2luIGFuZCB0aGUgcG9zaXRpb24gKGluIFBERiBjb29yZGluYXRlcylcbiAqIEBwYXJhbSBib3R0b21Qb2ludHMgVGhlIHZlcnRpY2FsIGRpc3RhbmNlIGJldHdlZW4gdGhlIG9yaWdpbiBhbmQgdGhlIHBvc2l0aW9uIChpbiBQREYgY29vcmRpbmF0ZXMpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY3JvbGxUb1Bvc2l0aW9uKFxuICBwYWdlSW5kZXg6IG51bWJlcixcbiAgbGVmdFBvaW50czogbnVtYmVyLFxuICBib3R0b21Qb2ludHM6IG51bWJlcixcbiAgcm90YXRpb246IFBhZ2VSb3RhdGlvbiA9IFBhZ2VSb3RhdGlvbi5Sb3RhdGUwXG4pOiB2b2lkIHtcbiAgY29uc3QgdGFyZ2V0RGl2OiBFbGVtZW50IHwgbnVsbCA9IGRvY3VtZW50XG4gICAgLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoU0NST0xMQUJMRV9UQVJHRVRfRElWX0NMQVNTTkFNRSlcbiAgICAuaXRlbSgwKTtcbiAgaWYgKCF0YXJnZXREaXYpIHtcbiAgICBjb25zb2xlLmVycm9yKGBDYW5ub3QgZmluZCBzY3JvbGwgdGFyZ2V0IHdpdGggY2xhc3NuYW1lICR7U0NST0xMQUJMRV9UQVJHRVRfRElWX0NMQVNTTkFNRX1gKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKlxuICAgIFZlcnRpY2FsIHNjcm9sbCBkaXN0YW5jZSBpcyBjYWxjdWxhdGVkIGFzXG4gICAgPSB0b3RhbCBudW1iZXIgb2YgcHJldmlvdXMgcGFnZXMgKiBwYWdlIGhlaWdodCBpbmNsdWRpbmcgdG9wL2Rvd24gbWFyZ2luc1xuICAgICsgdGhlIG1hcmdpbiB0b3Agb2YgY3VycmVudCBwYWdlXG4gICAgKyB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgcGFnZSB0b3AgdG8gdGhlIHNwZWNpZmllZCBwb3NpdGlvblxuXG4gICAgTm90aWNlIHRoYXQgdGhlIHNjcm9sbCBkaXN0YW5jZSBpcyBtZWFzdXJlZCBpbiBwaXhlbHMsXG4gICAgc28gbGVmdFBvaW50cy9ib3R0b21Qb2ludHMgaGFzIHRvIGJlIHRyYW5zZm9ybWVkIGZyb20gcG9pbnRzIHRvIHBpeGVscyBmaXJzdC5cbiAgKi9cblxuICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIG1hcmdpblRvcCwgbWFyZ2luQm90dG9tLCBtYXJnaW5MZWZ0LCBtYXJnaW5SaWdodCB9ID1cbiAgICBnZXRQYWdlUHJvcGVydGllc0luUGl4ZWxzKCk7XG4gIGNvbnN0IGhlaWdodFdpdGhNYXJnaW5zID0gaGVpZ2h0ICsgbWFyZ2luVG9wICsgbWFyZ2luQm90dG9tO1xuICAvLyBXaGVuIGEgcGFwZXIgaXMgcm90YXRlZCwgaXRzIGhlaWdodCBhbmQgd2lkdGggd291bGQgYmUgc3dpdGNoZWQgYXV0b21hdGljYWxseS4gSG93ZXZlciwgbGVmdFBvaW50cyBhbmQgYm90dG9tUG9pbnRzIHJlbWFpbiB0aGUgc2FtZS5cbiAgbGV0IG1hcmdpblRvcFBpeGVscyA9IG1hcmdpblRvcDtcbiAgbGV0IGJvdHRvbVBpeGVscyA9IChoZWlnaHQgKiBib3R0b21Qb2ludHMpIC8gUERGX0hFSUdIVF9QT0lOVFM7XG4gIGxldCBsZWZ0UGl4ZWxzID0gKHdpZHRoICogbGVmdFBvaW50cykgLyBQREZfV0lEVEhfUE9JTlRTO1xuXG4gIGlmIChyb3RhdGlvbiA9PSBQYWdlUm90YXRpb24uUm90YXRlOTApIHtcbiAgICBtYXJnaW5Ub3BQaXhlbHMgPSBtYXJnaW5MZWZ0O1xuICAgIGJvdHRvbVBpeGVscyA9IChoZWlnaHQgKiAoUERGX1dJRFRIX1BPSU5UUyAtIGxlZnRQb2ludHMpKSAvIFBERl9XSURUSF9QT0lOVFM7XG4gICAgbGVmdFBpeGVscyA9ICh3aWR0aCAqIGJvdHRvbVBvaW50cykgLyBQREZfSEVJR0hUX1BPSU5UUztcbiAgfSBlbHNlIGlmIChyb3RhdGlvbiA9PSBQYWdlUm90YXRpb24uUm90YXRlMTgwKSB7XG4gICAgbWFyZ2luVG9wUGl4ZWxzID0gbWFyZ2luQm90dG9tO1xuICAgIGJvdHRvbVBpeGVscyA9IChoZWlnaHQgKiAoUERGX0hFSUdIVF9QT0lOVFMgLSBib3R0b21Qb2ludHMpKSAvIFBERl9IRUlHSFRfUE9JTlRTO1xuICAgIGxlZnRQaXhlbHMgPSAod2lkdGggKiAoUERGX1dJRFRIX1BPSU5UUyAtIGxlZnRQb2ludHMpKSAvIFBERl9XSURUSF9QT0lOVFM7XG4gIH0gZWxzZSBpZiAocm90YXRpb24gPT0gUGFnZVJvdGF0aW9uLlJvdGF0ZTI3MCkge1xuICAgIG1hcmdpblRvcFBpeGVscyA9IG1hcmdpblJpZ2h0O1xuICAgIGJvdHRvbVBpeGVscyA9IChoZWlnaHQgKiBsZWZ0UG9pbnRzKSAvIFBERl9XSURUSF9QT0lOVFM7XG4gICAgbGVmdFBpeGVscyA9ICh3aWR0aCAqIChQREZfSEVJR0hUX1BPSU5UUyAtIGJvdHRvbVBvaW50cykpIC8gUERGX0hFSUdIVF9QT0lOVFM7XG4gIH1cblxuICB0YXJnZXREaXYuc2Nyb2xsVG8oe1xuICAgIHRvcDogTWF0aC5mbG9vcihoZWlnaHRXaXRoTWFyZ2lucyAqIHBhZ2VJbmRleCArIG1hcmdpblRvcFBpeGVscyArIChoZWlnaHQgLSBib3R0b21QaXhlbHMpKSxcbiAgICBsZWZ0OiBNYXRoLmZsb29yKGxlZnRQaXhlbHMpLFxuICAgIGJlaGF2aW9yOiAnc21vb3RoJyxcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IGxlbmd0aHMsIHdpZHRocywgYW5kIG1hcmdpbnMgb2YgYSBwYWdlLlxuICogQHJldHVybnMgYSBQYWdlUHJvcGVydGllcyBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFBhZ2VQcm9wZXJ0aWVzSW5QaXhlbHMoKTogUGFnZVByb3BlcnRpZXMge1xuICBjb25zdCBmaXJzdFBhZ2UgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChnZW5lcmF0ZVBhZ2VJZEZyb21JbmRleCgwKSk7XG4gIGlmICghZmlyc3RQYWdlKSB7XG4gICAgY29uc29sZS5lcnJvcihgQ2Fubm90IGdldCB0aGUgZmlyc3QgcGFnZSBvZiB0aGlzIGRvY3VtZW50LmApO1xuICAgIGNvbnN0IGVtcHR5UGFnZVByb3BlcnRpZXM6IFBhZ2VQcm9wZXJ0aWVzID0ge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDAsXG4gICAgICBtYXJnaW5Ub3A6IDAsXG4gICAgICBtYXJnaW5Cb3R0b206IDAsXG4gICAgICBtYXJnaW5MZWZ0OiAwLFxuICAgICAgbWFyZ2luUmlnaHQ6IDAsXG4gICAgfTtcbiAgICByZXR1cm4gZW1wdHlQYWdlUHJvcGVydGllcztcbiAgfVxuXG4gIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShmaXJzdFBhZ2UgYXMgRWxlbWVudCk7XG4gIGNvbnN0IHBhZ2VQcm9wZXJ0aWVzOiBQYWdlUHJvcGVydGllcyA9IHtcbiAgICB3aWR0aDogcGFyc2VJbnQoc3R5bGUud2lkdGgpLFxuICAgIGhlaWdodDogcGFyc2VJbnQoc3R5bGUuaGVpZ2h0KSxcbiAgICBtYXJnaW5Ub3A6IHBhcnNlSW50KHN0eWxlLm1hcmdpblRvcCksXG4gICAgbWFyZ2luQm90dG9tOiBwYXJzZUludChzdHlsZS5tYXJnaW5Cb3R0b20pLFxuICAgIG1hcmdpbkxlZnQ6IHBhcnNlSW50KHN0eWxlLm1hcmdpbkxlZnQpLFxuICAgIG1hcmdpblJpZ2h0OiBwYXJzZUludChzdHlsZS5tYXJnaW5SaWdodCksXG4gIH07XG5cbiAgcmV0dXJuIHBhZ2VQcm9wZXJ0aWVzO1xufVxuIiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBOb2RlRGVzdGluYXRpb24sIE91dGxpbmVOb2RlIH0gZnJvbSAnLi4vdHlwZXMvT3V0bGluZSc7XG5cbnR5cGUgUHJvcHMgPSB7XG4gIGl0ZW1zPzogQXJyYXk8T3V0bGluZU5vZGU+O1xuICBvbkNsaWNrPzogKGRlc3Q6IE5vZGVEZXN0aW5hdGlvbikgPT4gdm9pZDtcbn07XG5cbmV4cG9ydCBjb25zdCBPdXRsaW5lSXRlbTogUmVhY3QuRnVuY3Rpb25Db21wb25lbnQ8UHJvcHM+ID0gKHsgaXRlbXMsIG9uQ2xpY2sgfTogUHJvcHMpID0+IHtcbiAgaWYgKCFpdGVtcyB8fCAhaXRlbXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXJJdGVtKGl0ZW06IE91dGxpbmVOb2RlKSB7XG4gICAgY29uc3QgY2xpY2tIYW5kbGVyID0gKGV2ZW50OiBhbnkpID0+IHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAob25DbGljaykge1xuICAgICAgICBvbkNsaWNrKGl0ZW0uZGVzdCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIElmIGFuIGl0ZW0gaGFzIHN1YiB0aXRsZXMsIHJlbmRlciA8T3V0bGluZUl0ZW0gLz5cbiAgICByZXR1cm4gKFxuICAgICAgPGxpIGtleT17aXRlbS50aXRsZX0+XG4gICAgICAgIDxhIGhyZWY9XCIjXCIgb25DbGljaz17Y2xpY2tIYW5kbGVyfT5cbiAgICAgICAgICB7aXRlbS50aXRsZX1cbiAgICAgICAgPC9hPlxuICAgICAgICA8T3V0bGluZUl0ZW0gaXRlbXM9e2l0ZW0uaXRlbXN9IG9uQ2xpY2s9e29uQ2xpY2t9IC8+XG4gICAgICA8L2xpPlxuICAgICk7XG4gIH1cblxuICByZXR1cm4gPHVsPntpdGVtcy5tYXAoaXRlbSA9PiByZW5kZXJJdGVtKGl0ZW0pKX08L3VsPjtcbn07XG4iLCJpbXBvcnQgeyBQYWdlUmVmZXJlbmNlIH0gZnJvbSAnLi4vdHlwZXMvUGFnZSc7XG5cbi8qKlxuICogVGhpcyBjbGFzcyBpcyB0aGUgZGVmaW5pdGlvbiBvZiB0aGUgZmlyc3QgaXRlbSB3aGVuIERlc3RpbmF0aW9uIGlzIHJldHVybmVkIGFzIGFuIGFycmF5LlxuICogSXQgaXMgY3JlYXRlZCBiYXNlZCBvbiB0aGUgc2FtZSBjbGFzcyBpbiAncmVhY3QtcGRmJyBsaWJyYXJ5OlxuICogaHR0cHM6Ly9naXRodWIuY29tL3dvanRla21hai9yZWFjdC1wZGYvYmxvYi9jYTQ0NTNmMTIzYWY1MWUyZmFlZDM5YThhNjI4MDA5MDEwMzA0NTlhL3NyYy9SZWYuanNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVmIGltcGxlbWVudHMgUGFnZVJlZmVyZW5jZSB7XG4gIG51bTogbnVtYmVyO1xuICBnZW46IG51bWJlcjtcblxuICBjb25zdHJ1Y3Rvcih7IG51bSwgZ2VuIH06IFBhZ2VSZWZlcmVuY2UpIHtcbiAgICB0aGlzLm51bSA9IG51bTtcbiAgICB0aGlzLmdlbiA9IGdlbjtcbiAgfVxuXG4gIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuZ2VuICE9PSAwID8gYCR7dGhpcy5udW19UiR7dGhpcy5nZW59YCA6IGAke3RoaXMubnVtfVJgO1xuICB9XG59XG4iLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IERvY3VtZW50Q29udGV4dCB9IGZyb20gJy4uLy4uL2NvbnRleHQvRG9jdW1lbnRDb250ZXh0JztcbmltcG9ydCB7IFRyYW5zZm9ybUNvbnRleHQgfSBmcm9tICcuLi8uLi9jb250ZXh0L1RyYW5zZm9ybUNvbnRleHQnO1xuaW1wb3J0IHsgc2Nyb2xsVG9Qb3NpdGlvbiB9IGZyb20gJy4uLy4uL3V0aWxzL3Njcm9sbCc7XG5pbXBvcnQgeyBOb2RlRGVzdGluYXRpb24sIE91dGxpbmVOb2RlIH0gZnJvbSAnLi4vdHlwZXMvT3V0bGluZSc7XG5pbXBvcnQgeyBPdXRsaW5lSXRlbSB9IGZyb20gJy4vT3V0bGluZUl0ZW0nO1xuaW1wb3J0IFJlZiBmcm9tICcuL1JlZic7XG5cbmV4cG9ydCBjb25zdCBPdXRsaW5lOiBSZWFjdC5GdW5jdGlvbkNvbXBvbmVudCA9ICgpID0+IHtcbiAgY29uc3QgeyBwZGZEb2NQcm94eSB9ID0gUmVhY3QudXNlQ29udGV4dChEb2N1bWVudENvbnRleHQpO1xuICBjb25zdCB7IHJvdGF0aW9uIH0gPSBSZWFjdC51c2VDb250ZXh0KFRyYW5zZm9ybUNvbnRleHQpO1xuICBjb25zdCBbb3V0bGluZSwgc2V0T3V0bGluZV0gPSBSZWFjdC51c2VTdGF0ZTxBcnJheTxPdXRsaW5lTm9kZT4+KCk7XG5cbiAgaWYgKCFwZGZEb2NQcm94eSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKCFvdXRsaW5lKSB7XG4gICAgcGRmRG9jUHJveHkuZ2V0T3V0bGluZSgpLnRoZW4oKG91dGxpbmVBcnJheTogQXJyYXk8T3V0bGluZU5vZGU+KSA9PiB7XG4gICAgICBzZXRPdXRsaW5lKG91dGxpbmVBcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjb25zdCBjbGlja0hhbmRsZXIgPSAoZGVzdDogTm9kZURlc3RpbmF0aW9uKTogdm9pZCA9PiB7XG4gICAgaWYgKCFkZXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHBkZkRvY1Byb3h5LmdldERlc3RpbmF0aW9uKGRlc3QudG9TdHJpbmcoKSkudGhlbihkZXN0QXJyYXkgPT4ge1xuICAgICAgLypcbiAgICAgICAgZGVzdEFycmF5IHJldHVybmVkIGJ5IGdldERlc3RpbmF0aW9uIGNvbnRhaW5zIDUgaXRlbXM6XG4gICAgICAgIDEuIFJlZmVyZW5jZSB0byB0aGUgcGFnZSB3aGVyZSBkZXN0IGxvY2F0ZXMgYXRcbiAgICAgICAgMi4gVHlwZXMgb2YgZGVzdDsgY3VycmVudGx5IG9ubHkgXCJYWVpcIiBpcyBoYW5kbGVkXG4gICAgICAgIDMuIFggLS0gdGhlIGRpc3RhbmNlIGZyb20gdGhlIGxlZnQgZWRnZSBvZiBhIHBhZ2UgdG8gZGVzdCwgbWVhc3VyZWQgaW4gcG9pbnRzXG4gICAgICAgIDQuIFkgLS0gdGhlIGRpc3RhbmNlIGZyb20gdGhlIGJvdHRvbSBlZGdlIG9mIGEgcGFnZSB0byBkZXN0LCBtZWFzdXJlZCBpbiBwb2ludHNcbiAgICAgICAgNS4gU2NhbGVcbiAgICAgICAgXG4gICAgICAgIFJlZmVyZW5jZTogaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvcGRmLmpzL2Jsb2IvZDNlMWQ3MDkwYWM2ZjU4MmQwYzI3N2U4NzY4YWM2M2JiYmFhMTEzNC93ZWIvYmFzZV92aWV3ZXIuanMjTDExNTJcbiAgICAgICovXG4gICAgICAvLyBUaGUgc2Vjb25kIGFuZCB0aGUgZmlmdGggaXRlbXMgYXJlIGxlZnQgb3V0IGludGVudGlvbmFsbHkgZm9yIG5vdCBiZWluZyB1c2VkIGluIHNjcm9sbGluZyBmdW5jdGlvbi5cbiAgICAgIGNvbnN0IFtyZWYsICwgbGVmdFBvaW50cywgYm90dG9tUG9pbnRzXSA9IGRlc3RBcnJheTtcbiAgICAgIHBkZkRvY1Byb3h5LmdldFBhZ2VJbmRleChuZXcgUmVmKHJlZikpLnRoZW4ocmVmSW5mbyA9PiB7XG4gICAgICAgIHNjcm9sbFRvUG9zaXRpb24ocGFyc2VJbnQocmVmSW5mby50b1N0cmluZygpKSwgbGVmdFBvaW50cywgYm90dG9tUG9pbnRzLCByb3RhdGlvbik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gPGRpdj57ISFvdXRsaW5lICYmIDxPdXRsaW5lSXRlbSBpdGVtcz17b3V0bGluZX0gb25DbGljaz17Y2xpY2tIYW5kbGVyfSAvPn08L2Rpdj47XG59O1xuIiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBEb2N1bWVudENvbnRleHQgfSBmcm9tICcuLi9jb250ZXh0L0RvY3VtZW50Q29udGV4dCc7XG5pbXBvcnQgeyBUcmFuc2Zvcm1Db250ZXh0IH0gZnJvbSAnLi4vY29udGV4dC9UcmFuc2Zvcm1Db250ZXh0JztcbmltcG9ydCB7IGNvbXB1dGVQYWdlU3R5bGUgfSBmcm9tICcuLi91dGlscy9zdHlsZSc7XG5pbXBvcnQgeyBCb3VuZGluZ0JveCB9IGZyb20gJy4vQm91bmRpbmdCb3gnO1xuXG5leHBvcnQgdHlwZSBQcm9wcyA9IHtcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdEVsZW1lbnQ8dHlwZW9mIEJvdW5kaW5nQm94PiB8IEFycmF5PFJlYWN0LlJlYWN0RWxlbWVudDx0eXBlb2YgQm91bmRpbmdCb3g+Pjtcbn07XG5cbmV4cG9ydCBjb25zdCBPdmVybGF5OiBSZWFjdC5GdW5jdGlvbkNvbXBvbmVudDxQcm9wcz4gPSAoeyBjaGlsZHJlbiB9OiBQcm9wcykgPT4ge1xuICBjb25zdCB7IHBhZ2VEaW1lbnNpb25zIH0gPSBSZWFjdC51c2VDb250ZXh0KERvY3VtZW50Q29udGV4dCk7XG4gIGNvbnN0IHsgcm90YXRpb24sIHNjYWxlIH0gPSBSZWFjdC51c2VDb250ZXh0KFRyYW5zZm9ybUNvbnRleHQpO1xuXG4gIGNvbnN0IGdldE92ZXJsYXlTdHlsZSA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICByZXR1cm4gY29tcHV0ZVBhZ2VTdHlsZShwYWdlRGltZW5zaW9ucywgcm90YXRpb24sIHNjYWxlKTtcbiAgfSwgW3BhZ2VEaW1lbnNpb25zLCByb3RhdGlvbiwgc2NhbGVdKTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwicmVhZGVyX19wYWdlLW92ZXJsYXlcIiBzdHlsZT17Z2V0T3ZlcmxheVN0eWxlKCl9PlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvZGl2PlxuICApO1xufTtcbiIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFBhZ2UgfSBmcm9tICdyZWFjdC1wZGYnO1xuaW1wb3J0IHsgUmVuZGVyRnVuY3Rpb24gfSBmcm9tICdyZWFjdC1wZGYvZGlzdC9QYWdlJztcblxuaW1wb3J0IHsgRG9jdW1lbnRDb250ZXh0IH0gZnJvbSAnLi4vY29udGV4dC9Eb2N1bWVudENvbnRleHQnO1xuaW1wb3J0IHsgVHJhbnNmb3JtQ29udGV4dCB9IGZyb20gJy4uL2NvbnRleHQvVHJhbnNmb3JtQ29udGV4dCc7XG5pbXBvcnQgeyBnZW5lcmF0ZVBhZ2VJZEZyb21JbmRleCB9IGZyb20gJy4uL3V0aWxzL3Njcm9sbCc7XG5pbXBvcnQgeyBjb21wdXRlUGFnZVN0eWxlLCBnZXRQYWdlV2lkdGggfSBmcm9tICcuLi91dGlscy9zdHlsZSc7XG5pbXBvcnQgeyBIaWdobGlnaHRPdmVybGF5IH0gZnJvbSAnLi9IaWdobGlnaHRPdmVybGF5JztcbmltcG9ydCB7IE92ZXJsYXkgfSBmcm9tICcuL092ZXJsYXknO1xuXG4vKipcbiAqIEEgc3Vic2V0IG9mIHJlYWN0LXBkZidzIFBhZ2UgY29tcG9uZW50IHByb3BzIGV4cG9zZWQgYnkgdGhpcyB3cmFwcGVyXG4gKi9cbmV4cG9ydCB0eXBlIFBhZ2VQcm9wcyA9IHtcbiAgZXJyb3I/OiBzdHJpbmcgfCBSZWFjdC5SZWFjdEVsZW1lbnQgfCBSZW5kZXJGdW5jdGlvbjtcbiAgbG9hZGluZz86IHN0cmluZyB8IFJlYWN0LlJlYWN0RWxlbWVudCB8IFJlbmRlckZ1bmN0aW9uO1xuICBub0RhdGE/OiBzdHJpbmcgfCBSZWFjdC5SZWFjdEVsZW1lbnQgfCBSZW5kZXJGdW5jdGlvbjtcbiAgcGFnZUluZGV4OiBudW1iZXI7XG59O1xuXG5leHBvcnQgdHlwZSBQcm9wcyA9IHtcbiAgY2xhc3NOYW1lPzogc3RyaW5nO1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0RWxlbWVudDx0eXBlb2YgSGlnaGxpZ2h0T3ZlcmxheSB8IHR5cGVvZiBPdmVybGF5Pjtcbn0gJiBQYWdlUHJvcHM7XG5cbmV4cG9ydCBjb25zdCBQYWdlV3JhcHBlcjogUmVhY3QuRnVuY3Rpb25Db21wb25lbnQ8UHJvcHM+ID0gKHtcbiAgY2hpbGRyZW4sXG4gIGVycm9yLFxuICBsb2FkaW5nLFxuICBub0RhdGEsXG4gIHBhZ2VJbmRleCxcbn06IFByb3BzKSA9PiB7XG4gIGNvbnN0IHsgcm90YXRpb24sIHNjYWxlIH0gPSBSZWFjdC51c2VDb250ZXh0KFRyYW5zZm9ybUNvbnRleHQpO1xuICBjb25zdCB7IHBhZ2VEaW1lbnNpb25zIH0gPSBSZWFjdC51c2VDb250ZXh0KERvY3VtZW50Q29udGV4dCk7XG5cbiAgLy8gRG9uJ3QgZGlzcGxheSB1bnRpbCB3ZSBoYXZlIHBhZ2Ugc2l6ZSBkYXRhXG4gIC8vIFRPRE86IEhhbmRsZSB0aGlzIG5pY2VyIHNvIHdlIGRpc3BsYXkgZWl0aGVyIHRoZSBsb2FkaW5nIG9yIGVycm9yIHRyZWF0bWVudFxuICBpZiAoIXBhZ2VEaW1lbnNpb25zKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBvbkNsaWNrID0gUmVhY3QudXNlQ2FsbGJhY2soKGU6IHVua25vd24pID0+IHtcbiAgICBjb25zb2xlLmxvZyhlKTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IGdldFdpZHRoID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHJldHVybiBnZXRQYWdlV2lkdGgocGFnZURpbWVuc2lvbnMsIHJvdGF0aW9uKTtcbiAgfSwgW3BhZ2VEaW1lbnNpb25zLCByb3RhdGlvbl0pO1xuXG4gIGNvbnN0IGdldFBhZ2VTdHlsZSA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICByZXR1cm4gY29tcHV0ZVBhZ2VTdHlsZShwYWdlRGltZW5zaW9ucywgcm90YXRpb24sIHNjYWxlKTtcbiAgfSwgW3BhZ2VEaW1lbnNpb25zLCByb3RhdGlvbiwgc2NhbGVdKTtcblxuICAvLyBXaWR0aCBuZWVkcyB0byBiZSBzZXQgdG8gcHJldmVudCB0aGUgb3V0ZXJtb3N0IFBhZ2UgZGl2IGZyb20gZXh0ZW5kaW5nIHRvIGZpdCB0aGUgcGFyZW50LFxuICAvLyBhbmQgbWlzLWFsaWduaW5nIHRoZSB0ZXh0IGxheWVyLlxuICAvLyBUT0RPOiBDYW4gd2UgQ1NTIHRoaXMgdG8gYXV0by1zaHJpbms/XG4gIHJldHVybiAoXG4gICAgPGRpdiBpZD17Z2VuZXJhdGVQYWdlSWRGcm9tSW5kZXgocGFnZUluZGV4KX0gY2xhc3NOYW1lPVwicmVhZGVyX19wYWdlXCIgc3R5bGU9e2dldFBhZ2VTdHlsZSgpfT5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICAgIDxQYWdlXG4gICAgICAgIHdpZHRoPXtnZXRXaWR0aCgpfVxuICAgICAgICBlcnJvcj17ZXJyb3J9XG4gICAgICAgIGxvYWRpbmc9e2xvYWRpbmd9XG4gICAgICAgIG5vRGF0YT17bm9EYXRhfVxuICAgICAgICBwYWdlSW5kZXg9e3BhZ2VJbmRleH1cbiAgICAgICAgc2NhbGU9e3NjYWxlfVxuICAgICAgICBvbkNsaWNrPXtvbkNsaWNrfVxuICAgICAgICByb3RhdGU9e3JvdGF0aW9ufVxuICAgICAgICByZW5kZXJBbm5vdGF0aW9uTGF5ZXI9e2ZhbHNlfVxuICAgICAgLz5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG4iLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IFRyYW5zZm9ybUNvbnRleHQgfSBmcm9tICcuLi9jb250ZXh0L1RyYW5zZm9ybUNvbnRleHQnO1xuXG5leHBvcnQgdHlwZSBQcm9wcyA9IHtcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG59O1xuXG5leHBvcnQgY29uc3QgWm9vbUluQnV0dG9uOiBSZWFjdC5GdW5jdGlvbkNvbXBvbmVudDxQcm9wcz4gPSAoeyBjaGlsZHJlbiB9OiBQcm9wcykgPT4ge1xuICBjb25zdCB7IHNjYWxlLCBzZXRTY2FsZSwgem9vbU11bHRpcGxpZXIgfSA9IFJlYWN0LnVzZUNvbnRleHQoVHJhbnNmb3JtQ29udGV4dCk7XG5cbiAgY29uc3QgaGFuZGxlWm9vbUluID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHNldFNjYWxlKHNjYWxlICogem9vbU11bHRpcGxpZXIpO1xuICB9LCBbc2NhbGUsIHpvb21NdWx0aXBsaWVyXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8YnV0dG9uIGNsYXNzTmFtZT1cInJlYWRlcl9fem9vbS1idG4gem9vbS1pblwiIG9uQ2xpY2s9e2hhbmRsZVpvb21Jbn0+XG4gICAgICB7Y2hpbGRyZW4gPyBjaGlsZHJlbiA6ICcrJ31cbiAgICA8L2J1dHRvbj5cbiAgKTtcbn07XG4iLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IFRyYW5zZm9ybUNvbnRleHQgfSBmcm9tICcuLi9jb250ZXh0L1RyYW5zZm9ybUNvbnRleHQnO1xuXG5leHBvcnQgdHlwZSBQcm9wcyA9IHtcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG59O1xuXG5leHBvcnQgY29uc3QgWm9vbU91dEJ1dHRvbjogUmVhY3QuRnVuY3Rpb25Db21wb25lbnQgPSAoeyBjaGlsZHJlbiB9OiBQcm9wcykgPT4ge1xuICBjb25zdCB7IHNjYWxlLCBzZXRTY2FsZSwgem9vbU11bHRpcGxpZXIgfSA9IFJlYWN0LnVzZUNvbnRleHQoVHJhbnNmb3JtQ29udGV4dCk7XG5cbiAgY29uc3QgaGFuZGxlWm9vbU91dCA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBzZXRTY2FsZShzY2FsZSAvIHpvb21NdWx0aXBsaWVyKTtcbiAgfSwgW3NjYWxlLCB6b29tTXVsdGlwbGllcl0pO1xuXG4gIHJldHVybiAoXG4gICAgPGJ1dHRvbiBjbGFzc05hbWU9XCJyZWFkZXJfX3pvb20tYnRuIHpvb20tb3V0XCIgb25DbGljaz17aGFuZGxlWm9vbU91dH0+XG4gICAgICB7Y2hpbGRyZW4gPyBjaGlsZHJlbiA6ICctJ31cbiAgICA8L2J1dHRvbj5cbiAgKTtcbn07XG4iLCJpbXBvcnQgeyBQREZEb2N1bWVudFByb3h5IH0gZnJvbSAncGRmanMtZGlzdC90eXBlcy9kaXNwbGF5L2FwaSc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IERpbWVuc2lvbnMsIE51bGxhYmxlIH0gZnJvbSAnLi4vY29tcG9uZW50cy90eXBlcy90eXBlcyc7XG5pbXBvcnQgeyBQYWdlUm90YXRpb24gfSBmcm9tICcuLi91dGlscy9yb3RhdGUnO1xuaW1wb3J0IHsgRG9jdW1lbnRDb250ZXh0LCBJRG9jdW1lbnRDb250ZXh0IH0gZnJvbSAnLi9Eb2N1bWVudENvbnRleHQnO1xuaW1wb3J0IHsgSVRyYW5zZm9ybUNvbnRleHQsIFRyYW5zZm9ybUNvbnRleHQgfSBmcm9tICcuL1RyYW5zZm9ybUNvbnRleHQnO1xuaW1wb3J0IHsgSVVpQ29udGV4dCwgVWlDb250ZXh0IH0gZnJvbSAnLi9VaUNvbnRleHQnO1xuXG5leHBvcnQgdHlwZSBQcm9wcyA9IHtcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdEVsZW1lbnQgfCBBcnJheTxSZWFjdC5SZWFjdEVsZW1lbnQ+O1xufTtcblxuZnVuY3Rpb24gdXNlRG9jdW1lbnRDb250ZXh0UHJvcHMoKTogSURvY3VtZW50Q29udGV4dCB7XG4gIGNvbnN0IFtudW1QYWdlcywgc2V0TnVtUGFnZXNdID0gUmVhY3QudXNlU3RhdGU8bnVtYmVyPigwKTtcbiAgY29uc3QgW3BhZ2VEaW1lbnNpb25zLCBzZXRQYWdlRGltZW5zaW9uc10gPSBSZWFjdC51c2VTdGF0ZTxEaW1lbnNpb25zPih7IGhlaWdodDogMCwgd2lkdGg6IDAgfSk7XG4gIGNvbnN0IFtwZGZEb2NQcm94eSwgc2V0UGRmRG9jUHJveHldID0gUmVhY3QudXNlU3RhdGU8UERGRG9jdW1lbnRQcm94eT4oKTtcblxuICByZXR1cm4ge1xuICAgIG51bVBhZ2VzLFxuICAgIHBhZ2VEaW1lbnNpb25zOiBwYWdlRGltZW5zaW9ucyxcbiAgICBwZGZEb2NQcm94eSxcbiAgICBzZXROdW1QYWdlcyxcbiAgICBzZXRQYWdlRGltZW5zaW9uczogc2V0UGFnZURpbWVuc2lvbnMsXG4gICAgc2V0UGRmRG9jUHJveHksXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZVRyYW5zZm9ybUNvbnRleHRQcm9wcygpOiBJVHJhbnNmb3JtQ29udGV4dCB7XG4gIGNvbnN0IFtyb3RhdGlvbiwgc2V0Um90YXRpb25dID0gUmVhY3QudXNlU3RhdGU8UGFnZVJvdGF0aW9uPihQYWdlUm90YXRpb24uUm90YXRlMCk7XG4gIGNvbnN0IFtzY2FsZSwgc2V0U2NhbGVdID0gUmVhY3QudXNlU3RhdGU8bnVtYmVyPigxLjApO1xuICBjb25zdCBbem9vbU11bHRpcGxpZXIsIHNldFpvb21NdWx0aXBsaWVyXSA9IFJlYWN0LnVzZVN0YXRlPG51bWJlcj4oMS4yKTtcblxuICByZXR1cm4ge1xuICAgIHJvdGF0aW9uLFxuICAgIHNjYWxlLFxuICAgIHNldFJvdGF0aW9uLFxuICAgIHNldFNjYWxlLFxuICAgIHNldFpvb21NdWx0aXBsaWVyLFxuICAgIHpvb21NdWx0aXBsaWVyLFxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VVaUNvbnRleHRQcm9wcygpOiBJVWlDb250ZXh0IHtcbiAgY29uc3QgW2Vycm9yTWVzc2FnZSwgc2V0RXJyb3JNZXNzYWdlXSA9IFJlYWN0LnVzZVN0YXRlPE51bGxhYmxlPHN0cmluZz4+KG51bGwpO1xuICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gUmVhY3QudXNlU3RhdGU8Ym9vbGVhbj4odHJ1ZSk7XG4gIGNvbnN0IFtpc1Nob3dpbmdIaWdobGlnaHRPdmVybGF5LCBzZXRJc1Nob3dpbmdIaWdobGlnaHRPdmVybGF5XSA9IFJlYWN0LnVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcbiAgY29uc3QgW2lzU2hvd2luZ091dGxpbmUsIHNldElzU2hvd2luZ091dGxpbmVdID0gUmVhY3QudXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpO1xuICBjb25zdCBbaXNTaG93aW5nVGV4dEhpZ2hsaWdodCwgc2V0SXNTaG93aW5nVGV4dEhpZ2hsaWdodF0gPSBSZWFjdC51c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XG5cbiAgcmV0dXJuIHtcbiAgICBlcnJvck1lc3NhZ2UsXG4gICAgaXNMb2FkaW5nLFxuICAgIGlzU2hvd2luZ0hpZ2hsaWdodE92ZXJsYXksXG4gICAgaXNTaG93aW5nT3V0bGluZSxcbiAgICBpc1Nob3dpbmdUZXh0SGlnaGxpZ2h0LFxuICAgIHNldEVycm9yTWVzc2FnZSxcbiAgICBzZXRJc0xvYWRpbmcsXG4gICAgc2V0SXNTaG93aW5nSGlnaGxpZ2h0T3ZlcmxheSxcbiAgICBzZXRJc1Nob3dpbmdPdXRsaW5lLFxuICAgIHNldElzU2hvd2luZ1RleHRIaWdobGlnaHQsXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBDb250ZXh0UHJvdmlkZXI6IFJlYWN0LkZ1bmN0aW9uQ29tcG9uZW50PFByb3BzPiA9ICh7IGNoaWxkcmVuIH06IFByb3BzKSA9PiB7XG4gIGNvbnN0IGRvY3VtZW50UHJvcHMgPSB1c2VEb2N1bWVudENvbnRleHRQcm9wcygpO1xuICBjb25zdCB0cmFuc2Zvcm1Qcm9wcyA9IHVzZVRyYW5zZm9ybUNvbnRleHRQcm9wcygpO1xuICBjb25zdCB1aVByb3BzID0gdXNlVWlDb250ZXh0UHJvcHMoKTtcblxuICByZXR1cm4gKFxuICAgIDxEb2N1bWVudENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2RvY3VtZW50UHJvcHN9PlxuICAgICAgPFRyYW5zZm9ybUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3RyYW5zZm9ybVByb3BzfT5cbiAgICAgICAgPFVpQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17dWlQcm9wc30+e2NoaWxkcmVufTwvVWlDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgPC9UcmFuc2Zvcm1Db250ZXh0LlByb3ZpZGVyPlxuICAgIDwvRG9jdW1lbnRDb250ZXh0LlByb3ZpZGVyPlxuICApO1xufTtcbiIsIi8qXG4gKiBQREYgQ29tcG9uZW50IExpYnJhcnkgZXhwb3J0c1xuICovXG5cbmltcG9ydCAnLi9sZXNzL2luZGV4Lmxlc3MnO1xuXG5pbXBvcnQgeyBCb3VuZGluZ0JveCwgUHJvcHMgYXMgQm91bmRpbmdCb3hQcm9wcyB9IGZyb20gJy4vc3JjL2NvbXBvbmVudHMvQm91bmRpbmdCb3gnO1xuaW1wb3J0IHsgRG9jdW1lbnRXcmFwcGVyLCBQcm9wcyBhcyBEb2N1bWVudFdyYXBwZXJQcm9wcyB9IGZyb20gJy4vc3JjL2NvbXBvbmVudHMvRG9jdW1lbnRXcmFwcGVyJztcbmltcG9ydCB7IERvd25sb2FkQnV0dG9uLCBQcm9wcyBhcyBEb3dubG9hZEJ1dHRvblByb3BzIH0gZnJvbSAnLi9zcmMvY29tcG9uZW50cy9Eb3dubG9hZEJ1dHRvbic7XG5pbXBvcnQge1xuICBIaWdobGlnaHRPdmVybGF5LFxuICBQcm9wcyBhcyBIaWdobGlnaHRPdmVybGF5UHJvcHMsXG59IGZyb20gJy4vc3JjL2NvbXBvbmVudHMvSGlnaGxpZ2h0T3ZlcmxheSc7XG5pbXBvcnQgeyBPdXRsaW5lIH0gZnJvbSAnLi9zcmMvY29tcG9uZW50cy9vdXRsaW5lL091dGxpbmUnO1xuaW1wb3J0IHsgT3V0bGluZUl0ZW0gfSBmcm9tICcuL3NyYy9jb21wb25lbnRzL291dGxpbmUvT3V0bGluZUl0ZW0nO1xuaW1wb3J0IHsgT3ZlcmxheSwgUHJvcHMgYXMgT3ZlcmxheVByb3BzIH0gZnJvbSAnLi9zcmMvY29tcG9uZW50cy9PdmVybGF5JztcbmltcG9ydCB7IFBhZ2VQcm9wcywgUGFnZVdyYXBwZXIsIFByb3BzIGFzIFBhZ2VXcmFwcGVyUHJvcHMgfSBmcm9tICcuL3NyYy9jb21wb25lbnRzL1BhZ2VXcmFwcGVyJztcbmltcG9ydCB7IE5vZGVEZXN0aW5hdGlvbiwgT3V0bGluZU5vZGUgfSBmcm9tICcuL3NyYy9jb21wb25lbnRzL3R5cGVzL091dGxpbmUnO1xuaW1wb3J0IHsgUGFnZVByb3BlcnRpZXMsIFBhZ2VSZWZlcmVuY2UgfSBmcm9tICcuL3NyYy9jb21wb25lbnRzL3R5cGVzL1BhZ2UnO1xuaW1wb3J0IHtcbiAgQm91bmRpbmdCb3ggYXMgQm91bmRpbmdCb3hUeXBlLFxuICBEaW1lbnNpb25zLFxuICBOdWxsYWJsZSxcbiAgT3JpZ2luLFxuICBTaXplLFxufSBmcm9tICcuL3NyYy9jb21wb25lbnRzL3R5cGVzL3R5cGVzJztcbmltcG9ydCB7IFpvb21JbkJ1dHRvbiB9IGZyb20gJy4vc3JjL2NvbXBvbmVudHMvWm9vbUluQnV0dG9uJztcbmltcG9ydCB7IFpvb21PdXRCdXR0b24gfSBmcm9tICcuL3NyYy9jb21wb25lbnRzL1pvb21PdXRCdXR0b24nO1xuaW1wb3J0IHsgQ29udGV4dFByb3ZpZGVyLCBQcm9wcyBhcyBDb250ZXh0UHJvdmlkZXJQcm9wcyB9IGZyb20gJy4vc3JjL2NvbnRleHQvQ29udGV4dFByb3ZpZGVyJztcbmltcG9ydCB7IERvY3VtZW50Q29udGV4dCwgSURvY3VtZW50Q29udGV4dCB9IGZyb20gJy4vc3JjL2NvbnRleHQvRG9jdW1lbnRDb250ZXh0JztcbmltcG9ydCB7IElUcmFuc2Zvcm1Db250ZXh0LCBUcmFuc2Zvcm1Db250ZXh0IH0gZnJvbSAnLi9zcmMvY29udGV4dC9UcmFuc2Zvcm1Db250ZXh0JztcbmltcG9ydCB7IElVaUNvbnRleHQsIFVpQ29udGV4dCB9IGZyb20gJy4vc3JjL2NvbnRleHQvVWlDb250ZXh0JztcbmltcG9ydCB7XG4gIGlzU2lkZXdheXMsXG4gIFBhZ2VSb3RhdGlvbixcbiAgcm90YXRlQ2xvY2t3aXNlLFxuICByb3RhdGVDb3VudGVyQ2xvY2t3aXNlLFxufSBmcm9tICcuL3NyYy91dGlscy9yb3RhdGUnO1xuaW1wb3J0IHsgZ2VuZXJhdGVQYWdlSWRGcm9tSW5kZXgsIHNjcm9sbFRvSWQsIHNjcm9sbFRvUGRmUGFnZUluZGV4IH0gZnJvbSAnLi9zcmMvdXRpbHMvc2Nyb2xsJztcbmltcG9ydCB7XG4gIGNvbXB1dGVCb3VuZGluZ0JveFN0eWxlLFxuICBjb21wdXRlUGFnZVN0eWxlLFxuICBnZXRQYWdlSGVpZ2h0LFxuICBnZXRQYWdlV2lkdGgsXG59IGZyb20gJy4vc3JjL3V0aWxzL3N0eWxlJztcblxuZXhwb3J0IHR5cGUge1xuICBCb3VuZGluZ0JveFByb3BzLFxuICBCb3VuZGluZ0JveFR5cGUsXG4gIENvbnRleHRQcm92aWRlclByb3BzLFxuICBEaW1lbnNpb25zLFxuICBEb2N1bWVudFdyYXBwZXJQcm9wcyxcbiAgRG93bmxvYWRCdXR0b25Qcm9wcyxcbiAgSGlnaGxpZ2h0T3ZlcmxheVByb3BzLFxuICBJRG9jdW1lbnRDb250ZXh0LFxuICBJVHJhbnNmb3JtQ29udGV4dCxcbiAgSVVpQ29udGV4dCxcbiAgTm9kZURlc3RpbmF0aW9uLFxuICBOdWxsYWJsZSxcbiAgT3JpZ2luLFxuICBPdXRsaW5lTm9kZSxcbiAgT3ZlcmxheVByb3BzLFxuICBQYWdlUHJvcGVydGllcyxcbiAgUGFnZVByb3BzLFxuICBQYWdlUmVmZXJlbmNlLFxuICBQYWdlUm90YXRpb24sXG4gIFBhZ2VXcmFwcGVyUHJvcHMsXG4gIFNpemUsXG59O1xuXG5leHBvcnQge1xuICBCb3VuZGluZ0JveCxcbiAgY29tcHV0ZUJvdW5kaW5nQm94U3R5bGUsXG4gIGNvbXB1dGVQYWdlU3R5bGUsXG4gIENvbnRleHRQcm92aWRlcixcbiAgRG9jdW1lbnRDb250ZXh0LFxuICBEb2N1bWVudFdyYXBwZXIsXG4gIERvd25sb2FkQnV0dG9uLFxuICBnZW5lcmF0ZVBhZ2VJZEZyb21JbmRleCxcbiAgZ2V0UGFnZUhlaWdodCxcbiAgZ2V0UGFnZVdpZHRoLFxuICBIaWdobGlnaHRPdmVybGF5LFxuICBpc1NpZGV3YXlzLFxuICBPdXRsaW5lLFxuICBPdXRsaW5lSXRlbSxcbiAgT3ZlcmxheSxcbiAgUGFnZVdyYXBwZXIsXG4gIHJvdGF0ZUNsb2Nrd2lzZSxcbiAgcm90YXRlQ291bnRlckNsb2Nrd2lzZSxcbiAgc2Nyb2xsVG9JZCxcbiAgc2Nyb2xsVG9QZGZQYWdlSW5kZXgsXG4gIFRyYW5zZm9ybUNvbnRleHQsXG4gIFVpQ29udGV4dCxcbiAgWm9vbUluQnV0dG9uLFxuICBab29tT3V0QnV0dG9uLFxufTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBCb3VuZGluZ0JveCxcbiAgY29tcHV0ZUJvdW5kaW5nQm94U3R5bGUsXG4gIGNvbXB1dGVQYWdlU3R5bGUsXG4gIENvbnRleHRQcm92aWRlcixcbiAgRG9jdW1lbnRDb250ZXh0LFxuICBEb2N1bWVudFdyYXBwZXIsXG4gIERvd25sb2FkQnV0dG9uLFxuICBnZW5lcmF0ZVBhZ2VJZEZyb21JbmRleCxcbiAgZ2V0UGFnZUhlaWdodCxcbiAgZ2V0UGFnZVdpZHRoLFxuICBIaWdobGlnaHRPdmVybGF5LFxuICBpc1NpZGV3YXlzLFxuICBPdXRsaW5lLFxuICBPdXRsaW5lSXRlbSxcbiAgT3ZlcmxheSxcbiAgUGFnZVJvdGF0aW9uLFxuICBQYWdlV3JhcHBlcixcbiAgcm90YXRlQ2xvY2t3aXNlLFxuICByb3RhdGVDb3VudGVyQ2xvY2t3aXNlLFxuICBzY3JvbGxUb0lkLFxuICBzY3JvbGxUb1BkZlBhZ2VJbmRleCxcbiAgVHJhbnNmb3JtQ29udGV4dCxcbiAgVWlDb250ZXh0LFxuICBab29tSW5CdXR0b24sXG4gIFpvb21PdXRCdXR0b24sXG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///14\n')},888:n=>{"use strict";n.exports=__WEBPACK_EXTERNAL_MODULE__888__},414:()=>{},172:()=>{},1:()=>{},779:()=>{},558:()=>{},258:()=>{}},__webpack_module_cache__={};function __webpack_require__(n){var g=__webpack_module_cache__[n];if(void 0!==g)return g.exports;var I=__webpack_module_cache__[n]={exports:{}};return __webpack_modules__[n].call(I.exports,I,I.exports,__webpack_require__),I.exports}__webpack_require__.n=n=>{var g=n&&n.__esModule?()=>n.default:()=>n;return __webpack_require__.d(g,{a:g}),g},__webpack_require__.d=(n,g)=>{for(var I in g)__webpack_require__.o(g,I)&&!__webpack_require__.o(n,I)&&Object.defineProperty(n,I,{enumerable:!0,get:g[I]})},__webpack_require__.o=(n,g)=>Object.prototype.hasOwnProperty.call(n,g);var __webpack_exports__=__webpack_require__(14);return __webpack_exports__=__webpack_exports__.default,__webpack_exports__})()}));